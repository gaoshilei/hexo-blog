{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0}],"Cache":[{"_id":"themes/jacman/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1509702573196},{"_id":"themes/jacman/README.md","hash":"ef11befd19805182a33f1119b06da59ae8295125","modified":1509702573197},{"_id":"themes/jacman/README_zh.md","hash":"d6014b16eaccc97dc54a7779c9e36003752410e1","modified":1509702573197},{"_id":"themes/jacman/LICENSE","hash":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1509702573197},{"_id":"themes/jacman/_config.yml","hash":"646420fae7dd0bf050bdd7e9164ed14d4981fdff","modified":1509967606445},{"_id":"source/404/index.md","hash":"16970acad408c78d123df0addbfa21603fc5fda7","modified":1509628197225},{"_id":"source/_posts/RunLoop的前世今生.md","hash":"9f20b335779c060d7a0742c970936a125e6ea992","modified":1509628197226},{"_id":"source/_posts/VPS搭建高速VPN服务器.md","hash":"1e1fa8b1abdbb9e626b9de207571753ddf3bec9a","modified":1509628197227},{"_id":"source/_posts/Weex从入门到超神（一）.md","hash":"d69364ee1deca26eedc80cea18a5f2697ac80e46","modified":1509969006628},{"_id":"source/_posts/Xcode编译报错Undefined symbols解决方案.md","hash":"8abe691ed770fa695df9a227b1aa302d6cbffb10","modified":1509628197229},{"_id":"source/_posts/Weex从入门到超神（二）.md","hash":"cc35c9eb8e654cbfc7630685b05f9161a337fafe","modified":1509969006629},{"_id":"source/_posts/dumpdecrypted给App砸壳.md","hash":"49382a57b01b7b8f19a05b7a34dea94097b96a84","modified":1509702085693},{"_id":"source/_posts/strong-weak-dance.md","hash":"6f47831e67c96bedb993b93cd08367f4d39c4dd9","modified":1509940252168},{"_id":"source/_posts/iOS静态库SDK制作（包含第三方静态库）.md","hash":"9c23d703b555633babf5b7ff7138ef4fbb625927","modified":1509628197230},{"_id":"source/_posts/iPhone查找序列号生成函数.md","hash":"93385e8c9acd78e299c3f624bf8f167edc87f49c","modified":1509628197230},{"_id":"source/_posts/搭建hexo博客.md","hash":"548a55ffb32c402c3a2266f8edc7955b2f354d5b","modified":1510226666032},{"_id":"source/_posts/手把手教你逆向微信之朋友圈小视频转发（上）.md","hash":"f9bdeb33c4c497db28328c43a4c8cf07215f2f12","modified":1509628197232},{"_id":"source/_posts/手把手教你逆向微信之朋友圈小视频转发（下）.md","hash":"b58e9392b951824edd294cd3713ff1978ae3696b","modified":1509628197232},{"_id":"source/tags/index.md","hash":"3a66f12e400860e076d1b20f6fb37c2659e531b2","modified":1509628197233},{"_id":"source/_posts/黑科技：把第三方 iOS 应用转成动态库.md","hash":"d13e99561d661594714ea07f2efc238661c060b4","modified":1509628197232},{"_id":"source/about/index.md","hash":"0bbec232e44b3505e593e8b27a1a8476e1a5f92d","modified":1509628197233},{"_id":"themes/jacman/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1509702565172},{"_id":"themes/jacman/.git/config","hash":"deddbba9a2947503f5c80fcaa0e2a963a4b99216","modified":1510218647793},{"_id":"themes/jacman/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1509702573187},{"_id":"themes/jacman/.git/index","hash":"30bdc95234b513afa816e0cc54d191b417306819","modified":1510220018969},{"_id":"themes/jacman/.git/packed-refs","hash":"1fd3c23c2b32c41896cbea128b3e4779e73e4aea","modified":1510218647787},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1509702573198},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1509702573198},{"_id":"themes/jacman/languages/default.yml","hash":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1509702573198},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1509702573206},{"_id":"themes/jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1509702573207},{"_id":"themes/jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1509702573207},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1509702573207},{"_id":"themes/jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1509702573209},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1509702573207},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1509702573208},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1509702573208},{"_id":"themes/jacman/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1509702565173},{"_id":"themes/jacman/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1509702565172},{"_id":"themes/jacman/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1509702565174},{"_id":"themes/jacman/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1509702565174},{"_id":"themes/jacman/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1509702565173},{"_id":"themes/jacman/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1509702565174},{"_id":"themes/jacman/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1509702565172},{"_id":"themes/jacman/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1509702565175},{"_id":"themes/jacman/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1509702565173},{"_id":"themes/jacman/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1509702565171},{"_id":"themes/jacman/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1509702565174},{"_id":"themes/jacman/.git/logs/HEAD","hash":"393515c07ff74d866299ecfe0482c3beb656a190","modified":1510220018973},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"9fefcd9c5b33a133f89312e6fcc1439b4ad47cb8","modified":1509702573198},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1509702573199},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1509702573198},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1509702573199},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1509702573199},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1509702573199},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"5f80bf6c6ddcf8c28c4599cd1540b14b25d54f18","modified":1509702573199},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1509702573200},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1509702573200},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1509702573200},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1509702573200},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1509702573203},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1509702573202},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","hash":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1509702573203},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1509702573203},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1509702573203},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1509702573204},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1509702573204},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1509702573204},{"_id":"themes/jacman/layout/_widget/github-card.ejs","hash":"d49a8d609c5fbafa9e7ad328163565af03306519","modified":1509702573205},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1509702573205},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1509702573205},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1509702573206},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1509702573205},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1509702573206},{"_id":"themes/jacman/source/css/style.styl","hash":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1509702573213},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1509702573213},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1509702573213},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1509702573215},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1509702573214},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1509702573214},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1509702573214},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1509702573216},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1509702573218},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1509702573217},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1509702573218},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1509702573219},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1509702573220},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1509702573221},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1509702573221},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1509702573224},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1509702573225},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1509702573226},{"_id":"themes/jacman/source/img/author.jpg","hash":"2a292e681b4c6c975eec9c8c356d99647a465542","modified":1509702573227},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1509702573226},{"_id":"themes/jacman/source/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1509702573230},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1509702573229},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1509702573229},{"_id":"themes/jacman/source/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1509702573231},{"_id":"themes/jacman/source/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1509702573230},{"_id":"themes/jacman/source/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1509702573230},{"_id":"themes/jacman/source/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1509702573230},{"_id":"themes/jacman/source/img/favicon.ico","hash":"e1f54c52ecd0ec44bb4f0e1960473df0a0e7eeb5","modified":1510219777139},{"_id":"themes/jacman/source/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1509702573232},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1509702573232},{"_id":"themes/jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1509702573232},{"_id":"themes/jacman/source/img/jacman.jpg","hash":"aa85baa72a38fdb643e0d1ba24a528598fa2a227","modified":1510219096556},{"_id":"themes/jacman/source/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1509702573235},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1509702573234},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1509702573234},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1509702573220},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1509702573224},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1509702573225},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1509702573233},{"_id":"themes/jacman/source/img/logo.png","hash":"613b54180d2a90652d9edb26ac75b182b94c6192","modified":1510218223041},{"_id":"themes/jacman/.git/refs/heads/master","hash":"ef896c035a1f4a6bf2779b22fc0ae47928ff79b2","modified":1510220018973},{"_id":"themes/jacman/.git/objects/pack/pack-4e121e09c611c00aa1f73565e8b634a32badb2f0.idx","hash":"895d287b71feddb2c5cd5244dc3c8332211ee310","modified":1509702573171},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1509702573201},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1509702573201},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1509702573201},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"b0dbec32bb3c3cd9ec4b41ce72d5112b32827464","modified":1509702573201},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1509702573201},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1509702573202},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1509702573202},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"d41c951006c35723f971315ca5c581e949d50dee","modified":1509960263864},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1509702573209},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"f016180726019927b9a835ed01e04d153f27a149","modified":1509702573210},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1509702573210},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1509702573211},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1509702573211},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1509702573211},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1509702573211},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1509702573212},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"1136600932b97534b88465bf05ef313630b2de3d","modified":1509702573212},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1509702573212},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1509702573212},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1509702573211},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1509702573215},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1509702573215},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1509702573216},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1509702573215},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1509702573216},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1509702573216},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1509702573223},{"_id":"themes/jacman/source/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1509702573229},{"_id":"themes/jacman/.git/logs/refs/heads/master","hash":"393515c07ff74d866299ecfe0482c3beb656a190","modified":1510220018974},{"_id":"themes/jacman/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1509702573186},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","hash":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1509702573210},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","hash":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1509702573210},{"_id":"themes/jacman/.git/logs/refs/remotes/origin/HEAD","hash":"1ed40d6a64d404291949b056905b5a5a7c417b01","modified":1510218647790},{"_id":"themes/jacman/.git/objects/pack/pack-4e121e09c611c00aa1f73565e8b634a32badb2f0.pack","hash":"c94f6a4a8b0f1b5602fd4e3c091073b3f02aba08","modified":1509702573171},{"_id":"public/baidusitemap.xml","hash":"414529881d4fe97c2bbcdc5cf182199e4e660d06","modified":1509969230056},{"_id":"public/sitemap.xml","hash":"35c6aef5b3aa33dc64290f39d290bfddff653b56","modified":1509969230056},{"_id":"public/404.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230067},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230067},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230068},{"_id":"public/categories/实用工具/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230071},{"_id":"public/categories/技术笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230071},{"_id":"public/categories/跳坑指南/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230071},{"_id":"public/categories/iOS逆向/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230071},{"_id":"public/categories/他山之石/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230072},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230070},{"_id":"public/archives/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230070},{"_id":"public/archives/2016/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230070},{"_id":"public/archives/2016/03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230070},{"_id":"public/archives/2016/05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230070},{"_id":"public/archives/2016/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230070},{"_id":"public/archives/2016/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230070},{"_id":"public/archives/2016/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230070},{"_id":"public/archives/2016/11/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230070},{"_id":"public/archives/2017/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230070},{"_id":"public/archives/2017/01/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230070},{"_id":"public/archives/2017/05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230071},{"_id":"public/archives/2017/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230071},{"_id":"public/archives/2017/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230071},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230072},{"_id":"public/tags/VPS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230072},{"_id":"public/tags/VPN/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230072},{"_id":"public/tags/Shadowsocks/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230072},{"_id":"public/tags/RunLoop/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230072},{"_id":"public/tags/NSTimer/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230072},{"_id":"public/tags/AutoreleasePool/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230072},{"_id":"public/tags/AFNetworking/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230072},{"_id":"public/tags/Weex/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230072},{"_id":"public/tags/Vue/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230072},{"_id":"public/tags/JS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230073},{"_id":"public/tags/前端/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230073},{"_id":"public/tags/Cocopods/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230073},{"_id":"public/tags/Xcode/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230073},{"_id":"public/tags/dumpdecrypted/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230073},{"_id":"public/tags/砸壳/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230073},{"_id":"public/tags/block/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230073},{"_id":"public/tags/retain-cycle/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230073},{"_id":"public/tags/静态库/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230073},{"_id":"public/tags/动态库/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230073},{"_id":"public/tags/framework/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230073},{"_id":"public/tags/SDK/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230073},{"_id":"public/tags/serial-Number/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230074},{"_id":"public/tags/UDID/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230074},{"_id":"public/tags/微信/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230075},{"_id":"public/tags/汇编语言/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230075},{"_id":"public/tags/IDA/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230075},{"_id":"public/tags/黑科技/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230075},{"_id":"public/tags/重签名/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230075},{"_id":"public/2017/09/26/weex-2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230068},{"_id":"public/2017/05/26/weex-1/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230068},{"_id":"public/2017/01/16/strong-weak_dance/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230068},{"_id":"public/2016/11/20/RunLoop/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230069},{"_id":"public/2016/11/18/Static Library/index.html","hash":"b4b99e43a6b33b34d6872a7e0bb177c4a0a42b13","modified":1509959253487},{"_id":"public/2016/11/11/手把手教你逆向微信之朋友圈小视频转发（下）/index.html","hash":"981ce9d992dd7c3f343c45d01c9805c40406d2bf","modified":1509959253487},{"_id":"public/2016/11/10/手把手教你逆向微信之朋友圈小视频转发（上）/index.html","hash":"62888812546083a75b75a979e6e7eb25f8401dee","modified":1509959253487},{"_id":"public/2016/10/16/iOSAppToLibrary/index.html","hash":"086918864d6d78661e64645d8a238c9646c7d311","modified":1509959253487},{"_id":"public/2016/09/08/iPhone查找序列号生成函数/index.html","hash":"5bb1caaebb7c6fea531884482749a3f24c30d3f0","modified":1509959253487},{"_id":"public/2016/08/09/dumpdecrypted给App砸壳/index.html","hash":"32979ae4ec7470ee1b8252386c3ae3eade496afe","modified":1509959253488},{"_id":"public/2016/05/20/VPS/index.html","hash":"0b4084c66ac1d3120569667b0159fa46ab690ce6","modified":1509959253488},{"_id":"public/2016/03/16/Xcode编译报错Undefined symbols解决方案/index.html","hash":"04db0872cff403ab8021e05c119331dfe0b00674","modified":1509959253488},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230072},{"_id":"public/categories/备忘录/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230072},{"_id":"public/tags/个人博客/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230074},{"_id":"public/2017/10/30/hexo-init/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230068},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1509941514203},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1509941514203},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1509941514203},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1509941514203},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1509941514203},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1509941514203},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1509941514203},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1509941514203},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1509941514203},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1509941514203},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1509941514203},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1509941514203},{"_id":"public/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1509941514203},{"_id":"public/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1509941514204},{"_id":"public/img/author.jpg","hash":"2a292e681b4c6c975eec9c8c356d99647a465542","modified":1509941514204},{"_id":"public/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1509941514205},{"_id":"public/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1509941514205},{"_id":"public/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1509941514205},{"_id":"public/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1509941514205},{"_id":"public/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1509941514205},{"_id":"public/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1509941514205},{"_id":"public/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1509941514205},{"_id":"public/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1509941514205},{"_id":"public/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1509941514205},{"_id":"public/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1509941514205},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1509941514205},{"_id":"public/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1509941514205},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1509941514205},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1509941515160},{"_id":"public/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1509941515162},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1509941515162},{"_id":"public/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1509941515162},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1509941515169},{"_id":"public/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1509941515169},{"_id":"public/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1509941515169},{"_id":"public/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1509941515169},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1509941515169},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1509941515169},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1509941515169},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1509941515169},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1509941515169},{"_id":"public/css/style.css","hash":"421e356dd5dc4c96e9c38aa2326a5575cbfbbc43","modified":1509941515169},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1509941515169},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1509941515169},{"_id":"public/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1509941515169},{"_id":"public/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1509941515169},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1509941515172},{"_id":"public/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1509941515172},{"_id":"public/2016/11/17/Static Library/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230069},{"_id":"public/2016/11/10/手把手教你逆向微信之朋友圈小视频转发（下）/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230069},{"_id":"public/2016/11/09/手把手教你逆向微信之朋友圈小视频转发（上）/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230069},{"_id":"public/2016/10/15/iOSAppToLibrary/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230069},{"_id":"public/2016/09/07/iPhone查找序列号生成函数/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230069},{"_id":"public/2016/08/08/dumpdecrypted给App砸壳/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230069},{"_id":"public/2016/05/19/VPS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230069},{"_id":"public/2016/03/15/Xcode编译报错Undefined symbols解决方案/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509969230069},{"_id":"source/robots.txt","hash":"c692ac0430b5667a2fba1dce3f8c1a0999fe7e67","modified":1510295669829},{"_id":"source/_posts/VPS+SSR+锐速（BBR魔改版）实现超级加速.md","hash":"6ce06cc544b4e993e1046f32c252b37cef47b54f","modified":1510905479591},{"_id":"source/_posts/VPS搭建高速SS服务器.md","hash":"0099ae64b11e70c78f6c1949b6f7d6f3195daf2c","modified":1510905668627},{"_id":"themes/jacman/.git/COMMIT_EDITMSG","hash":"6070278c2e3b31bc1e40c485f66da5336bd2cbb0","modified":1510220018971},{"_id":"themes/jacman/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1510219804268},{"_id":"themes/jacman/.git/objects/45/2496e77d3b6723710a491bda11085298da76c1","hash":"28dad5c6fcd2dfa5f49f130f0c15d4e945059157","modified":1510218787559},{"_id":"themes/jacman/.git/objects/41/52f772dc416318c5f6746e6d4fc61c321ca3c6","hash":"9d4f1f1c41d8b924e8f6fd746f0c756a870f4f15","modified":1510218777957},{"_id":"themes/jacman/.git/objects/23/e41b3d68c870c974d7924f70124acd3a0eb361","hash":"552b3b7f77466d3e31e6e6c70d3ea659eb7e0316","modified":1510220010937},{"_id":"themes/jacman/.git/objects/4b/8245f17e8dfd89501c582c52e3360225a22ebe","hash":"20b989e2ab911c7835d432571a3d0a3eb6cf2e04","modified":1510218787558},{"_id":"themes/jacman/.git/objects/95/f1fc22c9f200236e7f7bec1557fbcf41199ab6","hash":"46f4d98eca955e932afbe21e4378a20cb851f139","modified":1510220018967},{"_id":"themes/jacman/.git/objects/e8/5f9c90e64020fe0601787960e13b65fea9934f","hash":"5161d3e552b500af7875cc9ddbea395faaa843a4","modified":1510218787562},{"_id":"themes/jacman/.git/objects/2e/70ed367103c12d8e3597859e5351c70742790b","hash":"8a41ad94a4630e1897cf91896ecea35414f995f6","modified":1510220018972},{"_id":"themes/jacman/.git/objects/f2/d5f3bf3d9dc7498274454a4cbb9b0c3e8b92d4","hash":"bcbc00184eff5066f4fe972398e9295feff55b03","modified":1510220018968},{"_id":"themes/jacman/.git/objects/e9/f32a067822bedb19de3586ba27c4943f7ba343","hash":"9630c04df674eaec4bb489d55cb6ffdfd06651ad","modified":1510220010936},{"_id":"themes/jacman/.git/objects/16/09a5792980128619565f64990eb635a257db72","hash":"651eb657ea28e8ec3f398d9fa32746cc189579f4","modified":1510218787557},{"_id":"themes/jacman/.git/objects/pack/pack-14c2e0cae23ac4dbc9986fb32bcc122993e5d8b1.idx","hash":"54e447630c04436363c3f48e3d8b3ecee14f5072","modified":1510218647409},{"_id":"themes/jacman/.git/objects/f1/905389a937965f07ada16b6183be9933594ce5","hash":"8f7ab3253169506d4dd25e5fe50fe71d483f75c5","modified":1510220018968},{"_id":"themes/jacman/.git/refs/remotes/origin/master","hash":"ef896c035a1f4a6bf2779b22fc0ae47928ff79b2","modified":1510220036416},{"_id":"themes/jacman/.git/logs/refs/remotes/origin/master","hash":"bce9b4b35c3a9589324516bf9aa34a2d6c353819","modified":1510220036418},{"_id":"themes/jacman/.git/objects/pack/pack-14c2e0cae23ac4dbc9986fb32bcc122993e5d8b1.pack","hash":"2fc1aae7ffeedc9cd67196ddef875bb97f2ed825","modified":1510218787000},{"_id":"themes/jacman/.git/objects/04/3f146f2f12f9b36b097ebfaac2a02b29af7bc3","hash":"7dc6ae6021654aa4a7e646893151c089ab60b69b","modified":1511162159597},{"_id":"themes/jacman/.git/objects/a3/4b4bc9a48a1cd588fb914bee02559f98a0e045","hash":"60884d1b4102f4294e3f37c265bace5ac2b12a93","modified":1511162166404},{"_id":"themes/jacman/.git/objects/a7/f7f7c62962ce36dcf53069562662bbbabee1da","hash":"f9bb07678dc6181089c4d56628d00bf582126143","modified":1511162166407},{"_id":"themes/jacman/.git/objects/b2/64396d0d76b9257552600106b4592d6bbd7585","hash":"ef82e3f0b7a08b085be84182061df4e3e4ed571a","modified":1511171051630},{"_id":"themes/jacman/.git/objects/3c/0f977cbaaf833c913381733e3ed45a3e2c8ca4","hash":"19280383faeebac916d44cd4dedbd81ec3f60ea2","modified":1511171065966},{"_id":"themes/jacman/.git/objects/19/83948baf632d5e7188f3bfdd651762c654c454","hash":"354e82773c8dc64c73601c86f5920d2619655aff","modified":1511171065969},{"_id":"themes/jacman/.git/objects/c6/e97f537e530d4c4692fb162f10d57171cd742e","hash":"fde3a8d51eea410f974f7956be14dfd273777382","modified":1511172258965},{"_id":"themes/jacman/.git/objects/ff/0c3794200e9cd634b8923cff3a11c6abba97cf","hash":"edddd3c4de57c17627cf122a2e897f7aa26eeef3","modified":1511172274403},{"_id":"themes/jacman/.git/objects/8d/81ecb06f2074118f61138822fad9c407996912","hash":"aa01d618b9fad97d8eb8f6a31fbff63b37fc8570","modified":1511172274406},{"_id":"themes/jacman/.git/objects/07/a838a21309ea289142cf90d9e9e58075eb9249","hash":"a0d0f084ec07821088f9463be4e8d9339c3595e5","modified":1511172329685},{"_id":"themes/jacman/.git/objects/45/37f00f8a006279faa2df4f0aa42caec8cba93e","hash":"0600145766cd45c34acffdcbee14ff1593ceb1d4","modified":1511172329686},{"_id":"themes/jacman/.git/objects/d4/a949942723e5efaeb5fbd2aeec6a3564c8bed6","hash":"12d540cc239d1bb8320c5d0c0840cdae7cbaaefe","modified":1511172329686},{"_id":"themes/jacman/.git/objects/f3/4b635494688bdbe9bec6166de989c45cdf6bbb","hash":"7b435f61c34553a8eb76b198ea0581fd839428fe","modified":1511172330027},{"_id":"themes/jacman/.git/objects/74/e4e1a72d038948768d22089ce453968990a06c","hash":"44d8d401e1c63bda96b2decbab23eacb0b383bab","modified":1511172330030},{"_id":"themes/jacman/.git/objects/56/419329aad336e53f230901ebe2d443ed609a02","hash":"000b42996beb746cc3f864d6021250a6c8ae4f82","modified":1511172346145},{"_id":"themes/jacman/.git/objects/c6/2364db6be90a04f35ea7893488dd581fef95ec","hash":"44c4057885669daf40f586d58d010d2b05681ae5","modified":1511172658872},{"_id":"themes/jacman/.git/objects/d1/b0e79f6bd6cfbe3853a01541243794dab74ce6","hash":"374be8e6b42dd1a6669b699a589f1a95921d515b","modified":1511172661212},{"_id":"themes/jacman/.git/objects/15/ad2dc0258baf2691c373136d4e9eb42a545d28","hash":"c70d4e6c3741a99e9f35ddde009f1e96e814600c","modified":1511172661216}],"Category":[{"name":"实用工具","_id":"cj9no6vlz0003jaenw88zhzpq"},{"name":"技术笔记","_id":"cj9no6vm90008jaeni4pyiyb2"},{"name":"跳坑指南","_id":"cj9no6vms000ijaentisnxwan"},{"name":"iOS逆向","_id":"cj9no6vmv000pjaentvk5eg1e"},{"name":"备忘录","_id":"cj9no6vmx000xjaenue3sd7dw"},{"name":"他山之石","_id":"cj9no6vo5002jjaencgblcj5n"}],"Data":[],"Page":[{"title":"404 Not Found：该页无法显示","toc":false,"comments":0,"_content":"\n## 你所访问的页面已经更换地址或永久删除  \n![](http://oeat6c2zg.bkt.clouddn.com/hexo-404.jpg)  \n\n### [返回首页](http://gaoshilei.com)  \n\n### [关注我的微博](http://weibo.com/goslei1226)\n\n### [给我发邮件](mailto:goslei1315@gmail.com)\n","source":"404/index.md","raw":"---\ntitle: 404 Not Found：该页无法显示\ntoc: false\ncomments: false\npermalink: /404\n---\n\n## 你所访问的页面已经更换地址或永久删除  \n![](http://oeat6c2zg.bkt.clouddn.com/hexo-404.jpg)  \n\n### [返回首页](http://gaoshilei.com)  \n\n### [关注我的微博](http://weibo.com/goslei1226)\n\n### [给我发邮件](mailto:goslei1315@gmail.com)\n","date":"2017-11-02T13:09:57.225Z","updated":"2017-11-02T13:09:57.225Z","path":"/404.html","layout":"page","_id":"cj9no6vlo0000jaenbwh78ice","content":"<h2 id=\"你所访问的页面已经更换地址或永久删除\"><a href=\"#你所访问的页面已经更换地址或永久删除\" class=\"headerlink\" title=\"你所访问的页面已经更换地址或永久删除\"></a>你所访问的页面已经更换地址或永久删除</h2><p><img src=\"http://oeat6c2zg.bkt.clouddn.com/hexo-404.jpg\" alt=\"\">  </p>\n<h3 id=\"返回首页\"><a href=\"#返回首页\" class=\"headerlink\" title=\"返回首页\"></a><a href=\"http://gaoshilei.com\" target=\"_blank\" rel=\"external\">返回首页</a></h3><h3 id=\"关注我的微博\"><a href=\"#关注我的微博\" class=\"headerlink\" title=\"关注我的微博\"></a><a href=\"http://weibo.com/goslei1226\" target=\"_blank\" rel=\"external\">关注我的微博</a></h3><h3 id=\"给我发邮件\"><a href=\"#给我发邮件\" class=\"headerlink\" title=\"给我发邮件\"></a><a href=\"mailto:goslei1315@gmail.com\" target=\"_blank\" rel=\"external\">给我发邮件</a></h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"你所访问的页面已经更换地址或永久删除\"><a href=\"#你所访问的页面已经更换地址或永久删除\" class=\"headerlink\" title=\"你所访问的页面已经更换地址或永久删除\"></a>你所访问的页面已经更换地址或永久删除</h2><p><img src=\"http://oeat6c2zg.bkt.clouddn.com/hexo-404.jpg\" alt=\"\">  </p>\n<h3 id=\"返回首页\"><a href=\"#返回首页\" class=\"headerlink\" title=\"返回首页\"></a><a href=\"http://gaoshilei.com\" target=\"_blank\" rel=\"external\">返回首页</a></h3><h3 id=\"关注我的微博\"><a href=\"#关注我的微博\" class=\"headerlink\" title=\"关注我的微博\"></a><a href=\"http://weibo.com/goslei1226\" target=\"_blank\" rel=\"external\">关注我的微博</a></h3><h3 id=\"给我发邮件\"><a href=\"#给我发邮件\" class=\"headerlink\" title=\"给我发邮件\"></a><a href=\"mailto:goslei1315@gmail.com\" target=\"_blank\" rel=\"external\">给我发邮件</a></h3>"},{"title":"标签","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\n---\n","date":"2017-11-02T13:09:57.233Z","updated":"2017-11-02T13:09:57.233Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj9no6vnw002djaengsv4w4p1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我","_content":"\n> 此博客已布下结界，只有长的帅的人才可以找到   \n\n####  当你看到这个页面时，你已中了我下的蛊毒，关注我的微博即可解毒。   \n\n### [关注我的微博](http://weibo.com/goslei1226)\n### [给我发邮件](mailto:goslei1315@gmail.com)\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\n---\n\n> 此博客已布下结界，只有长的帅的人才可以找到   \n\n####  当你看到这个页面时，你已中了我下的蛊毒，关注我的微博即可解毒。   \n\n### [关注我的微博](http://weibo.com/goslei1226)\n### [给我发邮件](mailto:goslei1315@gmail.com)\n\n","date":"2017-11-20T07:20:32.468Z","updated":"2017-11-20T07:20:32.468Z","path":"about/index.html","_id":"cj9no6vo0002fjaenzfee4gz9","comments":1,"layout":"page","content":"<blockquote>\n<p>此博客已布下结界，只有长的帅的人才可以找到   </p>\n</blockquote>\n<h4 id=\"当你看到这个页面时，你已中了我下的蛊毒，关注我的微博即可解毒。\"><a href=\"#当你看到这个页面时，你已中了我下的蛊毒，关注我的微博即可解毒。\" class=\"headerlink\" title=\"当你看到这个页面时，你已中了我下的蛊毒，关注我的微博即可解毒。\"></a>当你看到这个页面时，你已中了我下的蛊毒，关注我的微博即可解毒。</h4><h3 id=\"关注我的微博\"><a href=\"#关注我的微博\" class=\"headerlink\" title=\"关注我的微博\"></a><a href=\"http://weibo.com/goslei1226\" target=\"_blank\" rel=\"external\">关注我的微博</a></h3><h3 id=\"给我发邮件\"><a href=\"#给我发邮件\" class=\"headerlink\" title=\"给我发邮件\"></a><a href=\"mailto:goslei1315@gmail.com\" target=\"_blank\" rel=\"external\">给我发邮件</a></h3>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>此博客已布下结界，只有长的帅的人才可以找到   </p>\n</blockquote>\n<h4 id=\"当你看到这个页面时，你已中了我下的蛊毒，关注我的微博即可解毒。\"><a href=\"#当你看到这个页面时，你已中了我下的蛊毒，关注我的微博即可解毒。\" class=\"headerlink\" title=\"当你看到这个页面时，你已中了我下的蛊毒，关注我的微博即可解毒。\"></a>当你看到这个页面时，你已中了我下的蛊毒，关注我的微博即可解毒。</h4><h3 id=\"关注我的微博\"><a href=\"#关注我的微博\" class=\"headerlink\" title=\"关注我的微博\"></a><a href=\"http://weibo.com/goslei1226\" target=\"_blank\" rel=\"external\">关注我的微博</a></h3><h3 id=\"给我发邮件\"><a href=\"#给我发邮件\" class=\"headerlink\" title=\"给我发邮件\"></a><a href=\"mailto:goslei1315@gmail.com\" target=\"_blank\" rel=\"external\">给我发邮件</a></h3>"}],"Post":[{"title":"RunLoop的前世今生","date":"2016-11-20T06:23:11.000Z","_content":"\n#\t一、\tRunLoop初识  \n\n日常的开发工作中，我们几乎很少注意RunLoop，因为我们基本上“用不到”RunLoop。包括我在内应该有很多人都不了解这个东西，只是听说过。最近有空查了不少资料终于把RunLoop运行原理搞清楚了。  \n本文会对RunLoop的原理进行深入探讨，但是不涉及底层的实现。  \n我们平时开发中的很多东西都和RunLoop相关，比如：  \n<!-- more -->\n\n-\tAutoreleasePool   \n-\tNSTimer  \n-\t消息通知\n-\tperform函数\n-\t网络请求\n-\tdispatch调用\n-\tblock回调\n-\tKVO\n-\t触摸事件以及各种硬件传感器 \n\nRunLoop机制贯穿整个App的生命周期的，这里提前剧透个彩蛋：  \n>\t我们都知道：如果主线程的RunLoop挂掉了，App也就挂掉了  \n\n**BUT：**  \n我们通过RunLoop机制可以让崩溃的App继续保持运行，非常英吹思婷！后面会有介绍。 \n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)   \n\n#\t二、\tRunLoop详解   \n\n计算机处理任务有进程和线程的概念，安卓中一个应用可以开启多个进程，而在iOS中一个App只能开启一个进程，但是线程可以开启多个。线程是用来处理事务的，多个线程处理事务是为了防止线程堵塞；一般来说一个线程一次只能执行一个任务，任务执行完成这个线程就会退出。  \n某些情况下我们需要这个线程一直运行着，不管有没有任务执行（*比方说App的主线程*），所以需要一种机制来维持线程的生命周期，iOS中叫做RunLoop，安卓里面的Looper机制和此类似。  \n为了让线程不退出随时候命处理事件而不退出，可以将逻辑简化为下面的代码  \n\n```ObjC\ndo{\n    var message = getNewmessages();//接收来自外部的消息\n    exec(message);//处理消息任务\n}while(0==isQuit)\n```\n\nRunLoop实际上也是一个对象，这个对象管理了线程内部需要处理的事件和消息，存在RunLoop的线程一直处于“消息接收->等待->处理”的循环中，直到这个循环结束（RunLoop被释放）。  \n\n##\t1.\t进程、线程、RunLoop之间的关系 \n**这里举一个比较通俗易懂的例子：** \n\n-\t进程：工厂  \n-\t线程：流水线  \n-\tRunLoop：生产线上面的主管  \n\n当工厂接到商家的订单时，会将订单生产的消息（外界的event消息）发送给对应流水线上的主管（RunLoop），主管接收到消息之后启动这个流水线（唤醒线程）进行生产（线程处理事务）。如果这个流水线没有主管，流水线将会被工厂销毁。  \n\n需要注意的是，线程与RunLoop是一一对应的关系（对应关系保存在一个全局的Dictionary里），线程创建之后是没有RunLoop的（主线程除外），RunLoop的创建是发生在第一次获取时。  \n>\t苹果不允许直接创建RunLoop，但是可以通过[NSRunLoop currentRunLoop]或者CFRunLoopGetCurrent()来获取（如果没有就会自动创建一个）。\n\n一般开发中使用的RunLoop就是NSRunLoop和CFRunLoopRef，CFRunLoopRef属于Core Foundation框架，提供的是C函数的API，**是线程安全的**，NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，**这些API不是线程安全的**。  \n\n由于NSRunLoop是基于CFRunLoop封装的，下文关于RunLoop的原理讨论都会基于CFRunLoop来进行。NSRunLoop和CFRunLoop所有类都是一一对应的关系。\n\n##\t2.\tRunLoop主要组成  \n>\tCFRunLoop对象可以检测某个task或者dispatch的输入事件，当检测到有输入源事件，CFRunLoop将会将其加入到线程中进行处理。比方说用户输入事件、网络连接事件、周期性或者延时事件、异步的回调等。  \n>\n>\tRunLoop可以检测的事件类型一共有3种，分别是CFRunLoopSource、CFRunLoopTimer、CFRunLoopObserver。可以通过CFRunLoopAddSource, CFRunLoopAddTimer或者CFRunLoopAddObserver添加相应的事件类型。  \n>\n>\t要让一个RunLoop跑起来还需要run loop modes，每一个source, timer和observer添加到RunLoop中时必须要与一个模式（CFRunLoopMode）相关联才可以运行。\n\n上面是对于CFRunLoop官方文档的解释，大致说明了RunLoop的工作原理。  \nRunLoop的主要组成部分如下：  \n\n-\tRun Loop （CFRunLoopRef）\n-\tRun Loop Source（CFRunLoopSourceRef）\n-\tRun Loop Timer（CFRunLoopTimerRef）\n-\tRun Loop Observer（CFRunLoopObserverRef）\n-\tRun Loop Modes（CFRunLoopModeRef）\n\nRunLoop共包含5个类，但公开的只有Source、Timer、Observer相关的三个类。\n这5个类之间的关系关系：  \n![](http://oeat6c2zg.bkt.clouddn.com/RunLoop.png)\n\n下面对这几个部分作详细的讲解。  \n\n###\t1.\tRunLoop Modes  \n>\tRun Loop Mode就是流水线上能够生产的产品类型，流水线在一个时刻只能在一种模式下运行，生产某一类型的产品。消息事件就是订单。  \n\nCFRunLoopMode 和 CFRunLoop的结构大致如下：\n\n```ObjC\nstruct __CFRunLoopMode {\n    CFStringRef _name;            // Mode Name, 例如 @\"kCFRunLoopDefaultMode\"\n    CFMutableSetRef _sources0;    // Set\n    CFMutableSetRef _sources1;    // Set\n    CFMutableArrayRef _observers; // Array\n    CFMutableArrayRef _timers;    // Array\n    ...\n};\n\nstruct __CFRunLoop {\n    CFMutableSetRef _commonModes;     // Set\n    CFMutableSetRef _commonModeItems; // Set<Source/Observer/Timer>\n    CFRunLoopModeRef _currentMode;    // Current Runloop Mode\n    CFMutableSetRef _modes;           // Set\n    ...\n};\n```\n\n一个RunLoop包含了多个Mode，每个Mode又包含了若干个Source/Timer/Observer。每次调用 RunLoop的主函数时，只能指定其中一个Mode，这个Mode被称作CurrentMode。如果需要切换 Mode，只能退出Loop，再重新指定一个Mode进入。这样做主要是为了分隔开不同Mode中的Source/Timer/Observer，让其互不影响。下面是5种Mode  \n\n-\t**kCFDefaultRunLoopMode**\tApp的默认Mode，通常主线程是在这个Mode下运行\n-\t**UITrackingRunLoopMode**\t界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响\n-\t**UIInitializationRunLoopMode** 在刚启动App时第进入的第一个Mode，启动完成后就不再使用\n-\t**GSEventReceiveRunLoopMode**\t接受系统事件的内部Mode，通常用不到\n-\t**kCFRunLoopCommonModes**\t这是一个占位用的Mode，不是一种真正的Mode\n\n其中kCFDefaultRunLoopMode、UITrackingRunLoopMode是苹果公开的，其余的mode都是无法添加的。既然没有CommonModes这个模式，那我们平时用的这行代码怎么解释呢？  \n\n\n```\n[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; \n```\n\n**什么是CommonModes？**   \n\n一个 Mode 可以将自己标记为\"Common\"属性（通过将其 ModeName 添加到 RunLoop 的 \"commonModes\" 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 \"Common\" 标记的所有Mode里\n主线程的 RunLoop 里有 kCFRunLoopDefaultMode 和 UITrackingRunLoopMode，这两个Mode都已经被标记为\"Common\"属性。当你创建一个Timer并加到DefaultMode时，Timer会得到重复回调，但此时滑动一个 scrollView 时，RunLoop 会将 mode 切换为TrackingRunLoopMode，这时Timer就不会被回调，并且也不会影响到滑动操作。    \n如果想让scrollView滑动时Timer可以正常调用，一种办法就是手动将这个 Timer 分别加入这两个 Mode。另一种方法就是将 Timer 加入到CommonMode 中。\n\n**怎么将事件加入到CommonMode？**  \n我们调用上面的代码将 Timer 加入到CommonMode 时，但实际并没有 CommonMode，其实系统将这个 Timer 加入到顶层的 RunLoop 的 commonModeItems 中。commonModeItems 会被 RunLoop 自动更新到所有具有\"Common\"属性的 Mode 里去。  \n这一步其实是系统帮我们将Timer加到了kCFRunLoopDefaultMode和UITrackingRunLoopMode中。  \n\n###\t2.\tRunLoop Source  \nCFRunLoopSourceRef是事件源（输入源），比如外部的触摸，点击事件和系统内部进程间的通信等。  \n按照官方文档，Source的分类：\n\n-\tPort-Based Sources\n-\tCustom Input Sources\n-\tCocoa Perform Selector Sources\n\nSource有两个版本：Source0 和 Source1（*这么风骚的名字不知道是谁想出来的*）。 \n**Source0：**\t非基于Port的，只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。  \n**Source1：**\t基于Port的，包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。后面讲到的AFNetwoeking创建常驻线程就是在线程中添加一个NSport来实现的。\n\n###\t3.\tRunLoop Timer  \nCFRunLoopTimerRef是基于时间的触发器，基本上说的就是NSTimer，它受RunLoop的Mode影响（GCD的定时器不受RunLoop的Mode影响），当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。如果线程阻塞或者不在这个Mode下，触发点将不会执行，一直等到下一个周期时间点触发。\n\n###\t4.\tRunLoop Observer \nCFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个\n\n```ObjC\nenum CFRunLoopActivity {\n    kCFRunLoopEntry                     = (1 << 0),    // 即将进入Loop   \n    kCFRunLoopBeforeTimers \t\t= (1 << 1),    // 即将处理 Timer    \t\n    kCFRunLoopBeforeSources\t\t= (1 << 2),    // 即将处理 Source  \n    kCFRunLoopBeforeWaiting\t\t= (1 << 5),    // 即将进入休眠     \n    kCFRunLoopAfterWaiting \t\t= (1 << 6),    // 刚从休眠中唤醒   \n    kCFRunLoopExit                      = (1 << 7),    // 即将退出Loop  \n    kCFRunLoopAllActivities\t\t= 0x0FFFFFFFU  // 包含上面所有状态  \n};\ntypedef enum CFRunLoopActivity CFRunLoopActivity;\n```\n\n##\t3.\tRunLoop 运行机制  \n这是我从别人博客上面摘录的一张图片，详细的描述了RunLoop运行机制  \n![](http://oeat6c2zg.bkt.clouddn.com/RunLoop_1.png)  \n\n每次线程运行RunLoop都会自动处理之前未处理的消息，并且将消息发送给观察者，让事件得到执行。RunLoop运行时首先根据modeName找到对应mode，如果mode里没有source/timer/observer，直接返回。   \n**流程如下：**  \n\n**Step1**  通知观察者 RunLoop 启动（之后调用内部函数，进入Loop，下面的流程都在Loop内部do-while函数中执行）   \n**Step2**  通知观察者: RunLoop 即将触发 Timer 回调。（kCFRunLoopBeforeTimers）   \n**Step3**  通知观察者: RunLoop 即将触发 Source0 回调。（kCFRunLoopBeforeSources）  \n**Step4**  RunLoop 触发 Source0 回调。\n**Step5** \t如果有 Source1 处于等待状态，直接处理这个 Source1 然后跳转到第9步处理消息。  \n**Step6**\t通知观察者：RunLoop 的线程即将进入休眠(sleep)。（kCFRunLoopBeforeWaiting）  \n**Step7**\t调用 `mach_msg` 等待接受 `mach_port` 的消息。线程将进入休眠, 直到被下面某一个事件唤醒  \n\n>   1.\t存在Source0被标记为待处理，系统调用CFRunLoopWakeUp唤醒线程处理事件  \n>   2.\t定时器时间到了   \n>   3.\tRunLoop自身的超时时间到了  \n>   4.\tRunLoop外部调用者唤醒      \n\n**Step8**\t通知观察者线程已经被唤醒 （kCFRunLoopAfterWaiting）  \n**Step9**   处理事件  \n\n>   1.\t如果一个 Timer 到时间了，触发这个Timer的回调    \n>   2.\t如果有dispatch到main_queue的block，执行block   \n>   3.\t如果一个 Source1 发出事件了，处理这个事件   \n\n**事件处理完成进行判断：**  \n\n>   1.  进入loop时传入参数指明处理完事件就返回（stopAfterHandle）  \n>   2.  超出传入参数标记的超时时间（timeout）  \n>   3.  被外部调用者强制停止`__CFRunLoopIsStopped(runloop)`   \n>   4.  source/timer/observer 全都空了`__CFRunLoopModeIsEmpty(runloop, currentMode)`  \n\n上面4个条件都不满足，即没超时、mode里没空、loop也没被停止，那继续loop。此时跳转到步骤2继续循环。  \n\n**Step10**\t系统通知观察者: RunLoop 即将退出。\n满足步骤9事件处理完成判断4条中的任何一条，跳出do-while函数的内部，通知观察者Loop结束。\n\n#\t三、\tRunLoop实际应用  \n\n##\t1. AutoreleasePool  \n\nApp启动之后，系统启动主线程并创建了RunLoop，在 main thread 中注册了两个 observer ，回调都是`_wrapRunLoopWithAutoreleasePoolHandler()`  \n\n###\t1.\t第一个observer  \n监听了一个事件：  \n####\t1.\t即将进入Loop（kCFRunLoopEntry）\n其回调会调用 `_objc_autoreleasePoolPush()` 创建一个栈自动释放池，这个优先级最高，保证创建释放池在其他操作之前。  \n###\t2.\t第二个observer\n监听了两个事件：\n####\t1.\t准备进入休眠（kCFRunLoopBeforeWaiting）\n此时调用 `_objc_autoreleasePoolPop()` 和 `_objc_autoreleasePoolPush()` 来释放旧的池并创建新的池。  \n####\t2. 即将退出Loop（kCFRunLoopExit）\n此时调用 `_objc_autoreleasePoolPop()`释放自动释放池。这个 observer 的优先级最低，确保池子释放在所有回调之后。  \n\n在主线程中执行代码一般都是写在事件回调或Timer回调中的，这些回调都被加入了main thread的自动释放池中，所以在ARC模式下我们不用关心对象什么时候释放，也不用去创建和管理pool。（如果事件不在主线程中要注意创建自动释放池，否则可能会出现内存泄漏）。  \n\n##\t2.\t\t事件响应  \n系统注册了一个 Source1 用来接收系统事件，其回调函数为 `__IOHIDEventSystemClientQueueCallback()`。当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收，\n\n>\tSpringBoard 只接收按键(锁屏/静音等)、触摸、加速，传感器等几种事件  \n\n随后用 mach port 转发给需要的App进程。随后系统注册的那个 Source1 就会触发回调，并调用 `_UIApplicationHandleEventQueue()`进行应用内部的分发。\n`_UIApplicationHandleEventQueue()` 会把 IOHIDEvent 事件处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。    \n\n\n##\t3.\t\t定时器  \n###\t1.\tNSTimer 的工作原理\n这里说的定时器就是NSTimer，我们使用频率最高的定时器，它的原型是CFRunLoopTimerRef。一个Timer注册 RunLoop 之后，RunLoop 会为这个Timer的重复时间点注册好事件。  \n需要注意：  \n>\t1.\t如果某个重复的时间点由于线程阻塞或者其他原因错过了，这个时间点会跳过去，直到下一个可以执行的时间点才会触发事件。举个栗子：假如公交车的发车间隔是10分钟，10:10的公交车我们没赶上，只能等10:20，如果由于我打电话没注意错过了10:20的车，只能等10:30的。  \n>\n>\t2.\t我们在哪个线程调用 NSTimer 就必须在哪个线程终止  \n\nNSTimer有一个 tolerance ，官方文档给它的解释是 Timer 的计时并不是准确的，有一定的误差，这个误差就是 tolerance 默认为0，我们可以手动设置这个误差。文档最后还强调了，为了防止时间点偏移，系统有权力给这个属性设置一个值无论你设置的值是多少，即使RunLoop 模式正确，当前线程并不阻塞，系统依然可能会在 NSTimer 上加上很小的的容差。    \n\n###\t2.\tNSTimer 优化使用  \n我们在平时开发中一个很常见的现象：\n\n>\t在界面上有一个UIscrollview控件（tableview，collectionview等），如果此时还有一个定时器在执行一个事件，你会发现当你滚动scrollview的时候，定时器会失效。\n\n这是因为，为了更好的用户体验，在主线程中UITrackingRunLoopMode的优先级最高。在用户拖动控件时，主线程的Run Loop是运行在UITrackingRunLoopMode下，而创建的Timer是默认关联为Default Mode，因此系统不会立即执行Default Mode下接收的事件。  \n\n解决方法1：  \n将当前 Timer 加入到 UITrackingRunLoopMode 或 kCFRunLoopCommonModes 中\n\n```ObjC\nNSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(TimerFire:) userInfo:nil repeats:YES];\n[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];  \n// 或 [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];\n[timer fire];\n```\n解决方法2：\n因为GCD创建的定时器不受RunLoop的影响，可以使用GCD创建的定时器 \n\n```ObjC\n\t//dispatch_source_t必须是全局或static变量，否则timer不会触发\n    static dispatch_source_t timer;\n    //创建新的调度源（这里传入的是DISPATCH_SOURCE_TYPE_TIMER，创建的是Timer调度\n    timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());\n    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);\n    dispatch_source_set_event_handler(timer, ^{\n        NSLog(@\"%@\",[NSThread currentThread]);\n    });\n    //启动或继续定时器\n    dispatch_resume(timer);\n```\n###\t3.\t基于mode的拓展应用  \n在 Timer 使用中我们可以通过将其加入到不同的mode来解决 Timer 的跳票问题。不过有些情况下，例如：  \n>\t用户滑动 scrollView 的过程中加载图片，由于UI的操作都是在主线程进行的，会造成滑动不流畅的问题，这个时候我们就需要在滑动的时候不加载图片，等滑动操作完成再进行加载图片的操作。  \n\n一般我们可以设置代理，当用户滑动结束的时候通知代理加载图片，这样比较麻烦太low，基于RunLoop的原理我们只要一行代码即可搞定  \n\n```ObjC\nUIImage *downloadImage = ...\n[self.imageView performSelector:@selector(setImage:) \n\t\t\t\t\t\twithObject: downloadImage \n\t\t\t\t\t\tafterDelay:3.0 \n\t\t\t\t\t\tinModes:@[NSDefaultRunLoopMode]];\n```\n通过将图片的设置 `setImage:` 添加到 DefaultMode 里面，确保在 UITrackingRunLoopMode 下该操作不会被执行，保证了滑动的流畅性。  \n\n##\t4.\t网络请求\n\n###\t1.\t网络请求接口\niOS中的网络请求接口自下而上有这么几层  \n![](http://oeat6c2zg.bkt.clouddn.com/runloop-nsnetwork.png)  \n\n**CFSocket** 是最底层的接口，只负责 socket 通信。  \n**CFNetwork** 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作在这层。  \n**NSURLConnection** 是基于 CFNetwork 更高层的封装，提供了面向对象的接口，AFNetworking 工作在这一层。  \n**NSURLSession** 看似是和 NSURLConnection 并列的，实际上它也用到了 NSURLConnection 的部分功能(比如 com.apple.NSURLConnectionLoader 线程)\n\n开始网络传输时，NSURLConnection 创建了两个新线程：`com.apple.NSURLConnectionLoader` 和 `com.apple.CFSocket.private`。   \n其中 CFSocket 线程是处理底层 socket 连接的，NSURLConnectionLoader 这个线程的RunLoop 创建了一个 Source1 事件源用来监听底层 socket 事件。当 CFSocket 处理好 socket 事件之后会通过 mach port 通知 NSURLConnectionLoader，然后 NSURLConnectionLoader 所在的线程再将消息通过 mach prot 转发给上层的 Delegate 所在的线程，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。  \n\n###\t2.\tAFNetworking 的工作原理  \n在AFNetworking2.6.3版本之前是有 AFURLConnectionOperation 这个类的，\nAFNetworking 3.0 版本开始已经移除了这个类，AFN没有自己创建线程，而是采用的下面的这种方式  \n\n```ObjC\n[inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n[outputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];  \n\nSCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);\n```\n\n由于本文讨论的是RunLoop，所以这里我们还是回到2.6.3版本AFN自己创建线程并添加RunLoop的这种方式讨论，在 AFURLConnectionOperation 类中可以找到下面的代码  \n\n```ObjC\n+ (void)networkRequestThreadEntryPoint:(id)__unused object {\n    @autoreleasepool {\n        [[NSThread currentThread] setName:@\"AFNetworking\"];\n        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n        [runLoop run];\n    }\n}\n\n+ (NSThread *)networkRequestThread {\n    static NSThread *_networkRequestThread = nil;\n    static dispatch_once_t oncePredicate;\n    dispatch_once(&oncePredicate, ^{\n        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n        [_networkRequestThread start];\n    });\n\n    return _networkRequestThread;\n}\n```\n从上面的代码可以看出，AFN创建了一个新的线程命名为 AFNetworking ，然后在这个线程中创建了一个 RunLoop ，在上面2.3章节 RunLoop 运行机制中提到了，一个RunLoop中如果source/timer/observer 都为空则会退出，并不进入循环。所以，AFN在这里为 RunLoop 添加了一个 NSMachPort ，这个port开启相当于添加了一个Source1事件源，但是这个事件源并没有真正的监听什么东西，只是为了不让 RunLoop 退出。 \n\n```ObjC\n//开始请求\n- (void)start {\n    [self.lock lock];\n    if ([self isCancelled]) {\n        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n    } else if ([self isReady]) {\n        self.state = AFOperationExecutingState;\n        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n    }\n    [self.lock unlock];\n}\n//暂停请求\n- (void)pause {\n    if ([self isPaused] || [self isFinished] || [self isCancelled]) {\n        return;\n    }\n    [self.lock lock];\n    if ([self isExecuting]) {\n        [self performSelector:@selector(operationDidPause) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n\n        dispatch_async(dispatch_get_main_queue(), ^{\n            NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];\n            [notificationCenter postNotificationName:AFNetworkingOperationDidFinishNotification object:self];\n        });\n    }\n    self.state = AFOperationPausedState;\n    [self.lock unlock];\n}\n//取消请求\n- (void)cancel {\n    [self.lock lock];\n    if (![self isFinished] && ![self isCancelled]) {\n        [super cancel];\n        if ([self isExecuting]) {\n            [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n        }\n    }\n    [self.lock unlock];\n}\n```\n\n可以看到，AFN每次进行的网络操作，开始、暂停、取消操作时都将相应的执行任务扔进了自己创建的线程的 RunLoop 中进行处理，从而避免造成主线程的阻塞。  \n\n##\t5.\t处理崩溃让程序继续运行  \n我们都知道，如果App运行遇到 Exception 就会直接崩溃并且退出，其实真正让应用退出的并不是产生的异常，而是当产生异常时，系统会结束掉当前主线程的 RunLoop ，RunLoop 退出主线程就退出了，所以应用才会退出。明白这个道理，去完成这个“不可能的任务”就很简单了。  \n\n接下来我们就去让应用在崩溃时依然可以正常运行，这个是非常有意义的。  \n\n###\t1.\t提升用户体验\t  \n应用遇到BUG崩溃时一般会给使用者造成非常不好的用户体验，如果当应用崩溃时我们让用户选择退出还是继续运行，那么用户会感觉我们的App跟别人的不一样，叼叼哒！\n\n###\t2.\t收集崩溃日志\n苹果提供了产生 Exception 的处理方法，我们可以在相应的方法中处理产生的异常，但是这个时间非常的短，之后应用就会退出，具体多长时间我们也不清楚，很被动。如果我们可以在应用崩溃时，有足够的时间收集并且上传到服务器，那么给我们的分析和解决BUG会带来相当大的便利。  \n\n下面直接上代码，非常简单：  \n\n```ObjC\n    CFRunLoopRef runLoop = CFRunLoopGetCurrent();\n    CFArrayRef allModes = CFRunLoopCopyAllModes(runLoop);\n    while (!isQuit){\n        for (NSString *mode in (__bridge NSArray *)allModes) {\n            CFRunLoopRunInMode((CFStringRef)mode, 0.001, false);\n        }\n    }\n    CFRelease(allModes);\n```\n\n把上面的代码添加到 Exception 的handle方法中，此时创建了一个 RunLoop ，让这个 RunLoop 在所有的 Mode 下面一直不停的跑，保证主线程不会退出，我们的应用也就存活下来了。\n\n参考：  \n[https://developer.apple.com/reference/corefoundation/cfrunloopref](https://developer.apple.com/reference/corefoundation/cfrunloopref)  \n[http://iphil.cc/?p=279](http://iphil.cc/?p=279)  \n[http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/](http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\n[http://www.itdadao.com/article/25145/](http://www.itdadao.com/article/25145/)  \n","source":"_posts/RunLoop的前世今生.md","raw":"---\ntitle: RunLoop的前世今生\ndate: 2016-11-20 14:23:11\ncategories:  \n- 技术笔记  \ntags:  \n- RunLoop  \n- NSTimer  \n- AutoreleasePool\n- AFNetworking  \npermalink: RunLoop  \n\n---\n\n#\t一、\tRunLoop初识  \n\n日常的开发工作中，我们几乎很少注意RunLoop，因为我们基本上“用不到”RunLoop。包括我在内应该有很多人都不了解这个东西，只是听说过。最近有空查了不少资料终于把RunLoop运行原理搞清楚了。  \n本文会对RunLoop的原理进行深入探讨，但是不涉及底层的实现。  \n我们平时开发中的很多东西都和RunLoop相关，比如：  \n<!-- more -->\n\n-\tAutoreleasePool   \n-\tNSTimer  \n-\t消息通知\n-\tperform函数\n-\t网络请求\n-\tdispatch调用\n-\tblock回调\n-\tKVO\n-\t触摸事件以及各种硬件传感器 \n\nRunLoop机制贯穿整个App的生命周期的，这里提前剧透个彩蛋：  \n>\t我们都知道：如果主线程的RunLoop挂掉了，App也就挂掉了  \n\n**BUT：**  \n我们通过RunLoop机制可以让崩溃的App继续保持运行，非常英吹思婷！后面会有介绍。 \n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)   \n\n#\t二、\tRunLoop详解   \n\n计算机处理任务有进程和线程的概念，安卓中一个应用可以开启多个进程，而在iOS中一个App只能开启一个进程，但是线程可以开启多个。线程是用来处理事务的，多个线程处理事务是为了防止线程堵塞；一般来说一个线程一次只能执行一个任务，任务执行完成这个线程就会退出。  \n某些情况下我们需要这个线程一直运行着，不管有没有任务执行（*比方说App的主线程*），所以需要一种机制来维持线程的生命周期，iOS中叫做RunLoop，安卓里面的Looper机制和此类似。  \n为了让线程不退出随时候命处理事件而不退出，可以将逻辑简化为下面的代码  \n\n```ObjC\ndo{\n    var message = getNewmessages();//接收来自外部的消息\n    exec(message);//处理消息任务\n}while(0==isQuit)\n```\n\nRunLoop实际上也是一个对象，这个对象管理了线程内部需要处理的事件和消息，存在RunLoop的线程一直处于“消息接收->等待->处理”的循环中，直到这个循环结束（RunLoop被释放）。  \n\n##\t1.\t进程、线程、RunLoop之间的关系 \n**这里举一个比较通俗易懂的例子：** \n\n-\t进程：工厂  \n-\t线程：流水线  \n-\tRunLoop：生产线上面的主管  \n\n当工厂接到商家的订单时，会将订单生产的消息（外界的event消息）发送给对应流水线上的主管（RunLoop），主管接收到消息之后启动这个流水线（唤醒线程）进行生产（线程处理事务）。如果这个流水线没有主管，流水线将会被工厂销毁。  \n\n需要注意的是，线程与RunLoop是一一对应的关系（对应关系保存在一个全局的Dictionary里），线程创建之后是没有RunLoop的（主线程除外），RunLoop的创建是发生在第一次获取时。  \n>\t苹果不允许直接创建RunLoop，但是可以通过[NSRunLoop currentRunLoop]或者CFRunLoopGetCurrent()来获取（如果没有就会自动创建一个）。\n\n一般开发中使用的RunLoop就是NSRunLoop和CFRunLoopRef，CFRunLoopRef属于Core Foundation框架，提供的是C函数的API，**是线程安全的**，NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，**这些API不是线程安全的**。  \n\n由于NSRunLoop是基于CFRunLoop封装的，下文关于RunLoop的原理讨论都会基于CFRunLoop来进行。NSRunLoop和CFRunLoop所有类都是一一对应的关系。\n\n##\t2.\tRunLoop主要组成  \n>\tCFRunLoop对象可以检测某个task或者dispatch的输入事件，当检测到有输入源事件，CFRunLoop将会将其加入到线程中进行处理。比方说用户输入事件、网络连接事件、周期性或者延时事件、异步的回调等。  \n>\n>\tRunLoop可以检测的事件类型一共有3种，分别是CFRunLoopSource、CFRunLoopTimer、CFRunLoopObserver。可以通过CFRunLoopAddSource, CFRunLoopAddTimer或者CFRunLoopAddObserver添加相应的事件类型。  \n>\n>\t要让一个RunLoop跑起来还需要run loop modes，每一个source, timer和observer添加到RunLoop中时必须要与一个模式（CFRunLoopMode）相关联才可以运行。\n\n上面是对于CFRunLoop官方文档的解释，大致说明了RunLoop的工作原理。  \nRunLoop的主要组成部分如下：  \n\n-\tRun Loop （CFRunLoopRef）\n-\tRun Loop Source（CFRunLoopSourceRef）\n-\tRun Loop Timer（CFRunLoopTimerRef）\n-\tRun Loop Observer（CFRunLoopObserverRef）\n-\tRun Loop Modes（CFRunLoopModeRef）\n\nRunLoop共包含5个类，但公开的只有Source、Timer、Observer相关的三个类。\n这5个类之间的关系关系：  \n![](http://oeat6c2zg.bkt.clouddn.com/RunLoop.png)\n\n下面对这几个部分作详细的讲解。  \n\n###\t1.\tRunLoop Modes  \n>\tRun Loop Mode就是流水线上能够生产的产品类型，流水线在一个时刻只能在一种模式下运行，生产某一类型的产品。消息事件就是订单。  \n\nCFRunLoopMode 和 CFRunLoop的结构大致如下：\n\n```ObjC\nstruct __CFRunLoopMode {\n    CFStringRef _name;            // Mode Name, 例如 @\"kCFRunLoopDefaultMode\"\n    CFMutableSetRef _sources0;    // Set\n    CFMutableSetRef _sources1;    // Set\n    CFMutableArrayRef _observers; // Array\n    CFMutableArrayRef _timers;    // Array\n    ...\n};\n\nstruct __CFRunLoop {\n    CFMutableSetRef _commonModes;     // Set\n    CFMutableSetRef _commonModeItems; // Set<Source/Observer/Timer>\n    CFRunLoopModeRef _currentMode;    // Current Runloop Mode\n    CFMutableSetRef _modes;           // Set\n    ...\n};\n```\n\n一个RunLoop包含了多个Mode，每个Mode又包含了若干个Source/Timer/Observer。每次调用 RunLoop的主函数时，只能指定其中一个Mode，这个Mode被称作CurrentMode。如果需要切换 Mode，只能退出Loop，再重新指定一个Mode进入。这样做主要是为了分隔开不同Mode中的Source/Timer/Observer，让其互不影响。下面是5种Mode  \n\n-\t**kCFDefaultRunLoopMode**\tApp的默认Mode，通常主线程是在这个Mode下运行\n-\t**UITrackingRunLoopMode**\t界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响\n-\t**UIInitializationRunLoopMode** 在刚启动App时第进入的第一个Mode，启动完成后就不再使用\n-\t**GSEventReceiveRunLoopMode**\t接受系统事件的内部Mode，通常用不到\n-\t**kCFRunLoopCommonModes**\t这是一个占位用的Mode，不是一种真正的Mode\n\n其中kCFDefaultRunLoopMode、UITrackingRunLoopMode是苹果公开的，其余的mode都是无法添加的。既然没有CommonModes这个模式，那我们平时用的这行代码怎么解释呢？  \n\n\n```\n[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; \n```\n\n**什么是CommonModes？**   \n\n一个 Mode 可以将自己标记为\"Common\"属性（通过将其 ModeName 添加到 RunLoop 的 \"commonModes\" 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 \"Common\" 标记的所有Mode里\n主线程的 RunLoop 里有 kCFRunLoopDefaultMode 和 UITrackingRunLoopMode，这两个Mode都已经被标记为\"Common\"属性。当你创建一个Timer并加到DefaultMode时，Timer会得到重复回调，但此时滑动一个 scrollView 时，RunLoop 会将 mode 切换为TrackingRunLoopMode，这时Timer就不会被回调，并且也不会影响到滑动操作。    \n如果想让scrollView滑动时Timer可以正常调用，一种办法就是手动将这个 Timer 分别加入这两个 Mode。另一种方法就是将 Timer 加入到CommonMode 中。\n\n**怎么将事件加入到CommonMode？**  \n我们调用上面的代码将 Timer 加入到CommonMode 时，但实际并没有 CommonMode，其实系统将这个 Timer 加入到顶层的 RunLoop 的 commonModeItems 中。commonModeItems 会被 RunLoop 自动更新到所有具有\"Common\"属性的 Mode 里去。  \n这一步其实是系统帮我们将Timer加到了kCFRunLoopDefaultMode和UITrackingRunLoopMode中。  \n\n###\t2.\tRunLoop Source  \nCFRunLoopSourceRef是事件源（输入源），比如外部的触摸，点击事件和系统内部进程间的通信等。  \n按照官方文档，Source的分类：\n\n-\tPort-Based Sources\n-\tCustom Input Sources\n-\tCocoa Perform Selector Sources\n\nSource有两个版本：Source0 和 Source1（*这么风骚的名字不知道是谁想出来的*）。 \n**Source0：**\t非基于Port的，只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。  \n**Source1：**\t基于Port的，包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。后面讲到的AFNetwoeking创建常驻线程就是在线程中添加一个NSport来实现的。\n\n###\t3.\tRunLoop Timer  \nCFRunLoopTimerRef是基于时间的触发器，基本上说的就是NSTimer，它受RunLoop的Mode影响（GCD的定时器不受RunLoop的Mode影响），当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。如果线程阻塞或者不在这个Mode下，触发点将不会执行，一直等到下一个周期时间点触发。\n\n###\t4.\tRunLoop Observer \nCFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个\n\n```ObjC\nenum CFRunLoopActivity {\n    kCFRunLoopEntry                     = (1 << 0),    // 即将进入Loop   \n    kCFRunLoopBeforeTimers \t\t= (1 << 1),    // 即将处理 Timer    \t\n    kCFRunLoopBeforeSources\t\t= (1 << 2),    // 即将处理 Source  \n    kCFRunLoopBeforeWaiting\t\t= (1 << 5),    // 即将进入休眠     \n    kCFRunLoopAfterWaiting \t\t= (1 << 6),    // 刚从休眠中唤醒   \n    kCFRunLoopExit                      = (1 << 7),    // 即将退出Loop  \n    kCFRunLoopAllActivities\t\t= 0x0FFFFFFFU  // 包含上面所有状态  \n};\ntypedef enum CFRunLoopActivity CFRunLoopActivity;\n```\n\n##\t3.\tRunLoop 运行机制  \n这是我从别人博客上面摘录的一张图片，详细的描述了RunLoop运行机制  \n![](http://oeat6c2zg.bkt.clouddn.com/RunLoop_1.png)  \n\n每次线程运行RunLoop都会自动处理之前未处理的消息，并且将消息发送给观察者，让事件得到执行。RunLoop运行时首先根据modeName找到对应mode，如果mode里没有source/timer/observer，直接返回。   \n**流程如下：**  \n\n**Step1**  通知观察者 RunLoop 启动（之后调用内部函数，进入Loop，下面的流程都在Loop内部do-while函数中执行）   \n**Step2**  通知观察者: RunLoop 即将触发 Timer 回调。（kCFRunLoopBeforeTimers）   \n**Step3**  通知观察者: RunLoop 即将触发 Source0 回调。（kCFRunLoopBeforeSources）  \n**Step4**  RunLoop 触发 Source0 回调。\n**Step5** \t如果有 Source1 处于等待状态，直接处理这个 Source1 然后跳转到第9步处理消息。  \n**Step6**\t通知观察者：RunLoop 的线程即将进入休眠(sleep)。（kCFRunLoopBeforeWaiting）  \n**Step7**\t调用 `mach_msg` 等待接受 `mach_port` 的消息。线程将进入休眠, 直到被下面某一个事件唤醒  \n\n>   1.\t存在Source0被标记为待处理，系统调用CFRunLoopWakeUp唤醒线程处理事件  \n>   2.\t定时器时间到了   \n>   3.\tRunLoop自身的超时时间到了  \n>   4.\tRunLoop外部调用者唤醒      \n\n**Step8**\t通知观察者线程已经被唤醒 （kCFRunLoopAfterWaiting）  \n**Step9**   处理事件  \n\n>   1.\t如果一个 Timer 到时间了，触发这个Timer的回调    \n>   2.\t如果有dispatch到main_queue的block，执行block   \n>   3.\t如果一个 Source1 发出事件了，处理这个事件   \n\n**事件处理完成进行判断：**  \n\n>   1.  进入loop时传入参数指明处理完事件就返回（stopAfterHandle）  \n>   2.  超出传入参数标记的超时时间（timeout）  \n>   3.  被外部调用者强制停止`__CFRunLoopIsStopped(runloop)`   \n>   4.  source/timer/observer 全都空了`__CFRunLoopModeIsEmpty(runloop, currentMode)`  \n\n上面4个条件都不满足，即没超时、mode里没空、loop也没被停止，那继续loop。此时跳转到步骤2继续循环。  \n\n**Step10**\t系统通知观察者: RunLoop 即将退出。\n满足步骤9事件处理完成判断4条中的任何一条，跳出do-while函数的内部，通知观察者Loop结束。\n\n#\t三、\tRunLoop实际应用  \n\n##\t1. AutoreleasePool  \n\nApp启动之后，系统启动主线程并创建了RunLoop，在 main thread 中注册了两个 observer ，回调都是`_wrapRunLoopWithAutoreleasePoolHandler()`  \n\n###\t1.\t第一个observer  \n监听了一个事件：  \n####\t1.\t即将进入Loop（kCFRunLoopEntry）\n其回调会调用 `_objc_autoreleasePoolPush()` 创建一个栈自动释放池，这个优先级最高，保证创建释放池在其他操作之前。  \n###\t2.\t第二个observer\n监听了两个事件：\n####\t1.\t准备进入休眠（kCFRunLoopBeforeWaiting）\n此时调用 `_objc_autoreleasePoolPop()` 和 `_objc_autoreleasePoolPush()` 来释放旧的池并创建新的池。  \n####\t2. 即将退出Loop（kCFRunLoopExit）\n此时调用 `_objc_autoreleasePoolPop()`释放自动释放池。这个 observer 的优先级最低，确保池子释放在所有回调之后。  \n\n在主线程中执行代码一般都是写在事件回调或Timer回调中的，这些回调都被加入了main thread的自动释放池中，所以在ARC模式下我们不用关心对象什么时候释放，也不用去创建和管理pool。（如果事件不在主线程中要注意创建自动释放池，否则可能会出现内存泄漏）。  \n\n##\t2.\t\t事件响应  \n系统注册了一个 Source1 用来接收系统事件，其回调函数为 `__IOHIDEventSystemClientQueueCallback()`。当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收，\n\n>\tSpringBoard 只接收按键(锁屏/静音等)、触摸、加速，传感器等几种事件  \n\n随后用 mach port 转发给需要的App进程。随后系统注册的那个 Source1 就会触发回调，并调用 `_UIApplicationHandleEventQueue()`进行应用内部的分发。\n`_UIApplicationHandleEventQueue()` 会把 IOHIDEvent 事件处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。    \n\n\n##\t3.\t\t定时器  \n###\t1.\tNSTimer 的工作原理\n这里说的定时器就是NSTimer，我们使用频率最高的定时器，它的原型是CFRunLoopTimerRef。一个Timer注册 RunLoop 之后，RunLoop 会为这个Timer的重复时间点注册好事件。  \n需要注意：  \n>\t1.\t如果某个重复的时间点由于线程阻塞或者其他原因错过了，这个时间点会跳过去，直到下一个可以执行的时间点才会触发事件。举个栗子：假如公交车的发车间隔是10分钟，10:10的公交车我们没赶上，只能等10:20，如果由于我打电话没注意错过了10:20的车，只能等10:30的。  \n>\n>\t2.\t我们在哪个线程调用 NSTimer 就必须在哪个线程终止  \n\nNSTimer有一个 tolerance ，官方文档给它的解释是 Timer 的计时并不是准确的，有一定的误差，这个误差就是 tolerance 默认为0，我们可以手动设置这个误差。文档最后还强调了，为了防止时间点偏移，系统有权力给这个属性设置一个值无论你设置的值是多少，即使RunLoop 模式正确，当前线程并不阻塞，系统依然可能会在 NSTimer 上加上很小的的容差。    \n\n###\t2.\tNSTimer 优化使用  \n我们在平时开发中一个很常见的现象：\n\n>\t在界面上有一个UIscrollview控件（tableview，collectionview等），如果此时还有一个定时器在执行一个事件，你会发现当你滚动scrollview的时候，定时器会失效。\n\n这是因为，为了更好的用户体验，在主线程中UITrackingRunLoopMode的优先级最高。在用户拖动控件时，主线程的Run Loop是运行在UITrackingRunLoopMode下，而创建的Timer是默认关联为Default Mode，因此系统不会立即执行Default Mode下接收的事件。  \n\n解决方法1：  \n将当前 Timer 加入到 UITrackingRunLoopMode 或 kCFRunLoopCommonModes 中\n\n```ObjC\nNSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(TimerFire:) userInfo:nil repeats:YES];\n[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];  \n// 或 [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];\n[timer fire];\n```\n解决方法2：\n因为GCD创建的定时器不受RunLoop的影响，可以使用GCD创建的定时器 \n\n```ObjC\n\t//dispatch_source_t必须是全局或static变量，否则timer不会触发\n    static dispatch_source_t timer;\n    //创建新的调度源（这里传入的是DISPATCH_SOURCE_TYPE_TIMER，创建的是Timer调度\n    timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());\n    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);\n    dispatch_source_set_event_handler(timer, ^{\n        NSLog(@\"%@\",[NSThread currentThread]);\n    });\n    //启动或继续定时器\n    dispatch_resume(timer);\n```\n###\t3.\t基于mode的拓展应用  \n在 Timer 使用中我们可以通过将其加入到不同的mode来解决 Timer 的跳票问题。不过有些情况下，例如：  \n>\t用户滑动 scrollView 的过程中加载图片，由于UI的操作都是在主线程进行的，会造成滑动不流畅的问题，这个时候我们就需要在滑动的时候不加载图片，等滑动操作完成再进行加载图片的操作。  \n\n一般我们可以设置代理，当用户滑动结束的时候通知代理加载图片，这样比较麻烦太low，基于RunLoop的原理我们只要一行代码即可搞定  \n\n```ObjC\nUIImage *downloadImage = ...\n[self.imageView performSelector:@selector(setImage:) \n\t\t\t\t\t\twithObject: downloadImage \n\t\t\t\t\t\tafterDelay:3.0 \n\t\t\t\t\t\tinModes:@[NSDefaultRunLoopMode]];\n```\n通过将图片的设置 `setImage:` 添加到 DefaultMode 里面，确保在 UITrackingRunLoopMode 下该操作不会被执行，保证了滑动的流畅性。  \n\n##\t4.\t网络请求\n\n###\t1.\t网络请求接口\niOS中的网络请求接口自下而上有这么几层  \n![](http://oeat6c2zg.bkt.clouddn.com/runloop-nsnetwork.png)  \n\n**CFSocket** 是最底层的接口，只负责 socket 通信。  \n**CFNetwork** 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作在这层。  \n**NSURLConnection** 是基于 CFNetwork 更高层的封装，提供了面向对象的接口，AFNetworking 工作在这一层。  \n**NSURLSession** 看似是和 NSURLConnection 并列的，实际上它也用到了 NSURLConnection 的部分功能(比如 com.apple.NSURLConnectionLoader 线程)\n\n开始网络传输时，NSURLConnection 创建了两个新线程：`com.apple.NSURLConnectionLoader` 和 `com.apple.CFSocket.private`。   \n其中 CFSocket 线程是处理底层 socket 连接的，NSURLConnectionLoader 这个线程的RunLoop 创建了一个 Source1 事件源用来监听底层 socket 事件。当 CFSocket 处理好 socket 事件之后会通过 mach port 通知 NSURLConnectionLoader，然后 NSURLConnectionLoader 所在的线程再将消息通过 mach prot 转发给上层的 Delegate 所在的线程，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。  \n\n###\t2.\tAFNetworking 的工作原理  \n在AFNetworking2.6.3版本之前是有 AFURLConnectionOperation 这个类的，\nAFNetworking 3.0 版本开始已经移除了这个类，AFN没有自己创建线程，而是采用的下面的这种方式  \n\n```ObjC\n[inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n[outputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];  \n\nSCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);\n```\n\n由于本文讨论的是RunLoop，所以这里我们还是回到2.6.3版本AFN自己创建线程并添加RunLoop的这种方式讨论，在 AFURLConnectionOperation 类中可以找到下面的代码  \n\n```ObjC\n+ (void)networkRequestThreadEntryPoint:(id)__unused object {\n    @autoreleasepool {\n        [[NSThread currentThread] setName:@\"AFNetworking\"];\n        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n        [runLoop run];\n    }\n}\n\n+ (NSThread *)networkRequestThread {\n    static NSThread *_networkRequestThread = nil;\n    static dispatch_once_t oncePredicate;\n    dispatch_once(&oncePredicate, ^{\n        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n        [_networkRequestThread start];\n    });\n\n    return _networkRequestThread;\n}\n```\n从上面的代码可以看出，AFN创建了一个新的线程命名为 AFNetworking ，然后在这个线程中创建了一个 RunLoop ，在上面2.3章节 RunLoop 运行机制中提到了，一个RunLoop中如果source/timer/observer 都为空则会退出，并不进入循环。所以，AFN在这里为 RunLoop 添加了一个 NSMachPort ，这个port开启相当于添加了一个Source1事件源，但是这个事件源并没有真正的监听什么东西，只是为了不让 RunLoop 退出。 \n\n```ObjC\n//开始请求\n- (void)start {\n    [self.lock lock];\n    if ([self isCancelled]) {\n        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n    } else if ([self isReady]) {\n        self.state = AFOperationExecutingState;\n        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n    }\n    [self.lock unlock];\n}\n//暂停请求\n- (void)pause {\n    if ([self isPaused] || [self isFinished] || [self isCancelled]) {\n        return;\n    }\n    [self.lock lock];\n    if ([self isExecuting]) {\n        [self performSelector:@selector(operationDidPause) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n\n        dispatch_async(dispatch_get_main_queue(), ^{\n            NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];\n            [notificationCenter postNotificationName:AFNetworkingOperationDidFinishNotification object:self];\n        });\n    }\n    self.state = AFOperationPausedState;\n    [self.lock unlock];\n}\n//取消请求\n- (void)cancel {\n    [self.lock lock];\n    if (![self isFinished] && ![self isCancelled]) {\n        [super cancel];\n        if ([self isExecuting]) {\n            [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n        }\n    }\n    [self.lock unlock];\n}\n```\n\n可以看到，AFN每次进行的网络操作，开始、暂停、取消操作时都将相应的执行任务扔进了自己创建的线程的 RunLoop 中进行处理，从而避免造成主线程的阻塞。  \n\n##\t5.\t处理崩溃让程序继续运行  \n我们都知道，如果App运行遇到 Exception 就会直接崩溃并且退出，其实真正让应用退出的并不是产生的异常，而是当产生异常时，系统会结束掉当前主线程的 RunLoop ，RunLoop 退出主线程就退出了，所以应用才会退出。明白这个道理，去完成这个“不可能的任务”就很简单了。  \n\n接下来我们就去让应用在崩溃时依然可以正常运行，这个是非常有意义的。  \n\n###\t1.\t提升用户体验\t  \n应用遇到BUG崩溃时一般会给使用者造成非常不好的用户体验，如果当应用崩溃时我们让用户选择退出还是继续运行，那么用户会感觉我们的App跟别人的不一样，叼叼哒！\n\n###\t2.\t收集崩溃日志\n苹果提供了产生 Exception 的处理方法，我们可以在相应的方法中处理产生的异常，但是这个时间非常的短，之后应用就会退出，具体多长时间我们也不清楚，很被动。如果我们可以在应用崩溃时，有足够的时间收集并且上传到服务器，那么给我们的分析和解决BUG会带来相当大的便利。  \n\n下面直接上代码，非常简单：  \n\n```ObjC\n    CFRunLoopRef runLoop = CFRunLoopGetCurrent();\n    CFArrayRef allModes = CFRunLoopCopyAllModes(runLoop);\n    while (!isQuit){\n        for (NSString *mode in (__bridge NSArray *)allModes) {\n            CFRunLoopRunInMode((CFStringRef)mode, 0.001, false);\n        }\n    }\n    CFRelease(allModes);\n```\n\n把上面的代码添加到 Exception 的handle方法中，此时创建了一个 RunLoop ，让这个 RunLoop 在所有的 Mode 下面一直不停的跑，保证主线程不会退出，我们的应用也就存活下来了。\n\n参考：  \n[https://developer.apple.com/reference/corefoundation/cfrunloopref](https://developer.apple.com/reference/corefoundation/cfrunloopref)  \n[http://iphil.cc/?p=279](http://iphil.cc/?p=279)  \n[http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/](http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\n[http://www.itdadao.com/article/25145/](http://www.itdadao.com/article/25145/)  \n","slug":"RunLoop","published":1,"updated":"2017-11-02T13:09:57.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9no6vlw0002jaen87mu7nu5","content":"<h1 id=\"一、-RunLoop初识\"><a href=\"#一、-RunLoop初识\" class=\"headerlink\" title=\"一、    RunLoop初识\"></a>一、    RunLoop初识</h1><p>日常的开发工作中，我们几乎很少注意RunLoop，因为我们基本上“用不到”RunLoop。包括我在内应该有很多人都不了解这个东西，只是听说过。最近有空查了不少资料终于把RunLoop运行原理搞清楚了。<br>本文会对RunLoop的原理进行深入探讨，但是不涉及底层的实现。<br>我们平时开发中的很多东西都和RunLoop相关，比如：<br><a id=\"more\"></a></p>\n<ul>\n<li>AutoreleasePool   </li>\n<li>NSTimer  </li>\n<li>消息通知</li>\n<li>perform函数</li>\n<li>网络请求</li>\n<li>dispatch调用</li>\n<li>block回调</li>\n<li>KVO</li>\n<li>触摸事件以及各种硬件传感器 </li>\n</ul>\n<p>RunLoop机制贯穿整个App的生命周期的，这里提前剧透个彩蛋：  </p>\n<blockquote>\n<p>   我们都知道：如果主线程的RunLoop挂掉了，App也就挂掉了  </p>\n</blockquote>\n<p><strong>BUT：</strong><br>我们通过RunLoop机制可以让崩溃的App继续保持运行，非常英吹思婷！后面会有介绍。 </p>\n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>   </p>\n<h1 id=\"二、-RunLoop详解\"><a href=\"#二、-RunLoop详解\" class=\"headerlink\" title=\"二、    RunLoop详解\"></a>二、    RunLoop详解</h1><p>计算机处理任务有进程和线程的概念，安卓中一个应用可以开启多个进程，而在iOS中一个App只能开启一个进程，但是线程可以开启多个。线程是用来处理事务的，多个线程处理事务是为了防止线程堵塞；一般来说一个线程一次只能执行一个任务，任务执行完成这个线程就会退出。<br>某些情况下我们需要这个线程一直运行着，不管有没有任务执行（<em>比方说App的主线程</em>），所以需要一种机制来维持线程的生命周期，iOS中叫做RunLoop，安卓里面的Looper机制和此类似。<br>为了让线程不退出随时候命处理事件而不退出，可以将逻辑简化为下面的代码  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">do</span>&#123;</div><div class=\"line\">    var message = getNewmessages();<span class=\"comment\">//接收来自外部的消息</span></div><div class=\"line\">    exec(message);<span class=\"comment\">//处理消息任务</span></div><div class=\"line\">&#125;<span class=\"keyword\">while</span>(<span class=\"number\">0</span>==isQuit)</div></pre></td></tr></table></figure>\n<p>RunLoop实际上也是一个对象，这个对象管理了线程内部需要处理的事件和消息，存在RunLoop的线程一直处于“消息接收-&gt;等待-&gt;处理”的循环中，直到这个循环结束（RunLoop被释放）。  </p>\n<h2 id=\"1-进程、线程、RunLoop之间的关系\"><a href=\"#1-进程、线程、RunLoop之间的关系\" class=\"headerlink\" title=\"1.    进程、线程、RunLoop之间的关系\"></a>1.    进程、线程、RunLoop之间的关系</h2><p><strong>这里举一个比较通俗易懂的例子：</strong> </p>\n<ul>\n<li>进程：工厂  </li>\n<li>线程：流水线  </li>\n<li>RunLoop：生产线上面的主管  </li>\n</ul>\n<p>当工厂接到商家的订单时，会将订单生产的消息（外界的event消息）发送给对应流水线上的主管（RunLoop），主管接收到消息之后启动这个流水线（唤醒线程）进行生产（线程处理事务）。如果这个流水线没有主管，流水线将会被工厂销毁。  </p>\n<p>需要注意的是，线程与RunLoop是一一对应的关系（对应关系保存在一个全局的Dictionary里），线程创建之后是没有RunLoop的（主线程除外），RunLoop的创建是发生在第一次获取时。  </p>\n<blockquote>\n<p>   苹果不允许直接创建RunLoop，但是可以通过[NSRunLoop currentRunLoop]或者CFRunLoopGetCurrent()来获取（如果没有就会自动创建一个）。</p>\n</blockquote>\n<p>一般开发中使用的RunLoop就是NSRunLoop和CFRunLoopRef，CFRunLoopRef属于Core Foundation框架，提供的是C函数的API，<strong>是线程安全的</strong>，NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，<strong>这些API不是线程安全的</strong>。  </p>\n<p>由于NSRunLoop是基于CFRunLoop封装的，下文关于RunLoop的原理讨论都会基于CFRunLoop来进行。NSRunLoop和CFRunLoop所有类都是一一对应的关系。</p>\n<h2 id=\"2-RunLoop主要组成\"><a href=\"#2-RunLoop主要组成\" class=\"headerlink\" title=\"2.    RunLoop主要组成\"></a>2.    RunLoop主要组成</h2><blockquote>\n<p>   CFRunLoop对象可以检测某个task或者dispatch的输入事件，当检测到有输入源事件，CFRunLoop将会将其加入到线程中进行处理。比方说用户输入事件、网络连接事件、周期性或者延时事件、异步的回调等。  </p>\n<p>   RunLoop可以检测的事件类型一共有3种，分别是CFRunLoopSource、CFRunLoopTimer、CFRunLoopObserver。可以通过CFRunLoopAddSource, CFRunLoopAddTimer或者CFRunLoopAddObserver添加相应的事件类型。  </p>\n<p>   要让一个RunLoop跑起来还需要run loop modes，每一个source, timer和observer添加到RunLoop中时必须要与一个模式（CFRunLoopMode）相关联才可以运行。</p>\n</blockquote>\n<p>上面是对于CFRunLoop官方文档的解释，大致说明了RunLoop的工作原理。<br>RunLoop的主要组成部分如下：  </p>\n<ul>\n<li>Run Loop （CFRunLoopRef）</li>\n<li>Run Loop Source（CFRunLoopSourceRef）</li>\n<li>Run Loop Timer（CFRunLoopTimerRef）</li>\n<li>Run Loop Observer（CFRunLoopObserverRef）</li>\n<li>Run Loop Modes（CFRunLoopModeRef）</li>\n</ul>\n<p>RunLoop共包含5个类，但公开的只有Source、Timer、Observer相关的三个类。<br>这5个类之间的关系关系：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/RunLoop.png\" alt=\"\"></p>\n<p>下面对这几个部分作详细的讲解。  </p>\n<h3 id=\"1-RunLoop-Modes\"><a href=\"#1-RunLoop-Modes\" class=\"headerlink\" title=\"1.    RunLoop Modes\"></a>1.    RunLoop Modes</h3><blockquote>\n<p>   Run Loop Mode就是流水线上能够生产的产品类型，流水线在一个时刻只能在一种模式下运行，生产某一类型的产品。消息事件就是订单。  </p>\n</blockquote>\n<p>CFRunLoopMode 和 CFRunLoop的结构大致如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoopMode &#123;</div><div class=\"line\">    <span class=\"built_in\">CFStringRef</span> _name;            <span class=\"comment\">// Mode Name, 例如 @\"kCFRunLoopDefaultMode\"</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources0;    <span class=\"comment\">// Set</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources1;    <span class=\"comment\">// Set</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _observers; <span class=\"comment\">// Array</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _timers;    <span class=\"comment\">// Array</span></div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes;     <span class=\"comment\">// Set</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems; <span class=\"comment\">// Set&lt;Source/Observer/Timer&gt;</span></div><div class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> _currentMode;    <span class=\"comment\">// Current Runloop Mode</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes;           <span class=\"comment\">// Set</span></div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>一个RunLoop包含了多个Mode，每个Mode又包含了若干个Source/Timer/Observer。每次调用 RunLoop的主函数时，只能指定其中一个Mode，这个Mode被称作CurrentMode。如果需要切换 Mode，只能退出Loop，再重新指定一个Mode进入。这样做主要是为了分隔开不同Mode中的Source/Timer/Observer，让其互不影响。下面是5种Mode  </p>\n<ul>\n<li><strong>kCFDefaultRunLoopMode</strong>    App的默认Mode，通常主线程是在这个Mode下运行</li>\n<li><strong>UITrackingRunLoopMode</strong>    界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li>\n<li><strong>UIInitializationRunLoopMode</strong> 在刚启动App时第进入的第一个Mode，启动完成后就不再使用</li>\n<li><strong>GSEventReceiveRunLoopMode</strong>    接受系统事件的内部Mode，通常用不到</li>\n<li><strong>kCFRunLoopCommonModes</strong>    这是一个占位用的Mode，不是一种真正的Mode</li>\n</ul>\n<p>其中kCFDefaultRunLoopMode、UITrackingRunLoopMode是苹果公开的，其余的mode都是无法添加的。既然没有CommonModes这个模式，那我们平时用的这行代码怎么解释呢？  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>\n<p><strong>什么是CommonModes？</strong>   </p>\n<p>一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里<br>主线程的 RunLoop 里有 kCFRunLoopDefaultMode 和 UITrackingRunLoopMode，这两个Mode都已经被标记为”Common”属性。当你创建一个Timer并加到DefaultMode时，Timer会得到重复回调，但此时滑动一个 scrollView 时，RunLoop 会将 mode 切换为TrackingRunLoopMode，这时Timer就不会被回调，并且也不会影响到滑动操作。<br>如果想让scrollView滑动时Timer可以正常调用，一种办法就是手动将这个 Timer 分别加入这两个 Mode。另一种方法就是将 Timer 加入到CommonMode 中。</p>\n<p><strong>怎么将事件加入到CommonMode？</strong><br>我们调用上面的代码将 Timer 加入到CommonMode 时，但实际并没有 CommonMode，其实系统将这个 Timer 加入到顶层的 RunLoop 的 commonModeItems 中。commonModeItems 会被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。<br>这一步其实是系统帮我们将Timer加到了kCFRunLoopDefaultMode和UITrackingRunLoopMode中。  </p>\n<h3 id=\"2-RunLoop-Source\"><a href=\"#2-RunLoop-Source\" class=\"headerlink\" title=\"2.    RunLoop Source\"></a>2.    RunLoop Source</h3><p>CFRunLoopSourceRef是事件源（输入源），比如外部的触摸，点击事件和系统内部进程间的通信等。<br>按照官方文档，Source的分类：</p>\n<ul>\n<li>Port-Based Sources</li>\n<li>Custom Input Sources</li>\n<li>Cocoa Perform Selector Sources</li>\n</ul>\n<p>Source有两个版本：Source0 和 Source1（<em>这么风骚的名字不知道是谁想出来的</em>）。<br><strong>Source0：</strong>    非基于Port的，只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。<br><strong>Source1：</strong>    基于Port的，包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。后面讲到的AFNetwoeking创建常驻线程就是在线程中添加一个NSport来实现的。</p>\n<h3 id=\"3-RunLoop-Timer\"><a href=\"#3-RunLoop-Timer\" class=\"headerlink\" title=\"3.    RunLoop Timer\"></a>3.    RunLoop Timer</h3><p>CFRunLoopTimerRef是基于时间的触发器，基本上说的就是NSTimer，它受RunLoop的Mode影响（GCD的定时器不受RunLoop的Mode影响），当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。如果线程阻塞或者不在这个Mode下，触发点将不会执行，一直等到下一个周期时间点触发。</p>\n<h3 id=\"4-RunLoop-Observer\"><a href=\"#4-RunLoop-Observer\" class=\"headerlink\" title=\"4.    RunLoop Observer\"></a>4.    RunLoop Observer</h3><p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">enum</span> <span class=\"built_in\">CFRunLoopActivity</span> &#123;</div><div class=\"line\">    kCFRunLoopEntry                     = (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>),    <span class=\"comment\">// 即将进入Loop   </span></div><div class=\"line\">    kCFRunLoopBeforeTimers \t\t= (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>),    <span class=\"comment\">// 即将处理 Timer    \t</span></div><div class=\"line\">    kCFRunLoopBeforeSources\t\t= (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>),    <span class=\"comment\">// 即将处理 Source  </span></div><div class=\"line\">    kCFRunLoopBeforeWaiting\t\t= (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">5</span>),    <span class=\"comment\">// 即将进入休眠     </span></div><div class=\"line\">    kCFRunLoopAfterWaiting \t\t= (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">6</span>),    <span class=\"comment\">// 刚从休眠中唤醒   </span></div><div class=\"line\">    kCFRunLoopExit                      = (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">7</span>),    <span class=\"comment\">// 即将退出Loop  </span></div><div class=\"line\">    kCFRunLoopAllActivities\t\t= <span class=\"number\">0x0FFFFFFF</span>U  <span class=\"comment\">// 包含上面所有状态  </span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> <span class=\"built_in\">CFRunLoopActivity</span> <span class=\"built_in\">CFRunLoopActivity</span>;</div></pre></td></tr></table></figure>\n<h2 id=\"3-RunLoop-运行机制\"><a href=\"#3-RunLoop-运行机制\" class=\"headerlink\" title=\"3.    RunLoop 运行机制\"></a>3.    RunLoop 运行机制</h2><p>这是我从别人博客上面摘录的一张图片，详细的描述了RunLoop运行机制<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/RunLoop_1.png\" alt=\"\">  </p>\n<p>每次线程运行RunLoop都会自动处理之前未处理的消息，并且将消息发送给观察者，让事件得到执行。RunLoop运行时首先根据modeName找到对应mode，如果mode里没有source/timer/observer，直接返回。<br><strong>流程如下：</strong>  </p>\n<p><strong>Step1</strong>  通知观察者 RunLoop 启动（之后调用内部函数，进入Loop，下面的流程都在Loop内部do-while函数中执行）<br><strong>Step2</strong>  通知观察者: RunLoop 即将触发 Timer 回调。（kCFRunLoopBeforeTimers）<br><strong>Step3</strong>  通知观察者: RunLoop 即将触发 Source0 回调。（kCFRunLoopBeforeSources）<br><strong>Step4</strong>  RunLoop 触发 Source0 回调。<br><strong>Step5</strong>     如果有 Source1 处于等待状态，直接处理这个 Source1 然后跳转到第9步处理消息。<br><strong>Step6</strong>    通知观察者：RunLoop 的线程即将进入休眠(sleep)。（kCFRunLoopBeforeWaiting）<br><strong>Step7</strong>    调用 <code>mach_msg</code> 等待接受 <code>mach_port</code> 的消息。线程将进入休眠, 直到被下面某一个事件唤醒  </p>\n<blockquote>\n<ol>\n<li>存在Source0被标记为待处理，系统调用CFRunLoopWakeUp唤醒线程处理事件  </li>\n<li>定时器时间到了   </li>\n<li>RunLoop自身的超时时间到了  </li>\n<li>RunLoop外部调用者唤醒      </li>\n</ol>\n</blockquote>\n<p><strong>Step8</strong>    通知观察者线程已经被唤醒 （kCFRunLoopAfterWaiting）<br><strong>Step9</strong>   处理事件  </p>\n<blockquote>\n<ol>\n<li>如果一个 Timer 到时间了，触发这个Timer的回调    </li>\n<li>如果有dispatch到main_queue的block，执行block   </li>\n<li>如果一个 Source1 发出事件了，处理这个事件   </li>\n</ol>\n</blockquote>\n<p><strong>事件处理完成进行判断：</strong>  </p>\n<blockquote>\n<ol>\n<li>进入loop时传入参数指明处理完事件就返回（stopAfterHandle）  </li>\n<li>超出传入参数标记的超时时间（timeout）  </li>\n<li>被外部调用者强制停止<code>__CFRunLoopIsStopped(runloop)</code>   </li>\n<li>source/timer/observer 全都空了<code>__CFRunLoopModeIsEmpty(runloop, currentMode)</code>  </li>\n</ol>\n</blockquote>\n<p>上面4个条件都不满足，即没超时、mode里没空、loop也没被停止，那继续loop。此时跳转到步骤2继续循环。  </p>\n<p><strong>Step10</strong>    系统通知观察者: RunLoop 即将退出。<br>满足步骤9事件处理完成判断4条中的任何一条，跳出do-while函数的内部，通知观察者Loop结束。</p>\n<h1 id=\"三、-RunLoop实际应用\"><a href=\"#三、-RunLoop实际应用\" class=\"headerlink\" title=\"三、    RunLoop实际应用\"></a>三、    RunLoop实际应用</h1><h2 id=\"1-AutoreleasePool\"><a href=\"#1-AutoreleasePool\" class=\"headerlink\" title=\"1. AutoreleasePool\"></a>1. AutoreleasePool</h2><p>App启动之后，系统启动主线程并创建了RunLoop，在 main thread 中注册了两个 observer ，回调都是<code>_wrapRunLoopWithAutoreleasePoolHandler()</code>  </p>\n<h3 id=\"1-第一个observer\"><a href=\"#1-第一个observer\" class=\"headerlink\" title=\"1.    第一个observer\"></a>1.    第一个observer</h3><p>监听了一个事件：  </p>\n<h4 id=\"1-即将进入Loop（kCFRunLoopEntry）\"><a href=\"#1-即将进入Loop（kCFRunLoopEntry）\" class=\"headerlink\" title=\"1.    即将进入Loop（kCFRunLoopEntry）\"></a>1.    即将进入Loop（kCFRunLoopEntry）</h4><p>其回调会调用 <code>_objc_autoreleasePoolPush()</code> 创建一个栈自动释放池，这个优先级最高，保证创建释放池在其他操作之前。  </p>\n<h3 id=\"2-第二个observer\"><a href=\"#2-第二个observer\" class=\"headerlink\" title=\"2.    第二个observer\"></a>2.    第二个observer</h3><p>监听了两个事件：</p>\n<h4 id=\"1-准备进入休眠（kCFRunLoopBeforeWaiting）\"><a href=\"#1-准备进入休眠（kCFRunLoopBeforeWaiting）\" class=\"headerlink\" title=\"1.    准备进入休眠（kCFRunLoopBeforeWaiting）\"></a>1.    准备进入休眠（kCFRunLoopBeforeWaiting）</h4><p>此时调用 <code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 来释放旧的池并创建新的池。  </p>\n<h4 id=\"2-即将退出Loop（kCFRunLoopExit）\"><a href=\"#2-即将退出Loop（kCFRunLoopExit）\" class=\"headerlink\" title=\"2. 即将退出Loop（kCFRunLoopExit）\"></a>2. 即将退出Loop（kCFRunLoopExit）</h4><p>此时调用 <code>_objc_autoreleasePoolPop()</code>释放自动释放池。这个 observer 的优先级最低，确保池子释放在所有回调之后。  </p>\n<p>在主线程中执行代码一般都是写在事件回调或Timer回调中的，这些回调都被加入了main thread的自动释放池中，所以在ARC模式下我们不用关心对象什么时候释放，也不用去创建和管理pool。（如果事件不在主线程中要注意创建自动释放池，否则可能会出现内存泄漏）。  </p>\n<h2 id=\"2-事件响应\"><a href=\"#2-事件响应\" class=\"headerlink\" title=\"2.        事件响应\"></a>2.        事件响应</h2><p>系统注册了一个 Source1 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收，</p>\n<blockquote>\n<p>   SpringBoard 只接收按键(锁屏/静音等)、触摸、加速，传感器等几种事件  </p>\n</blockquote>\n<p>随后用 mach port 转发给需要的App进程。随后系统注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code>进行应用内部的分发。<br><code>_UIApplicationHandleEventQueue()</code> 会把 IOHIDEvent 事件处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。    </p>\n<h2 id=\"3-定时器\"><a href=\"#3-定时器\" class=\"headerlink\" title=\"3.        定时器\"></a>3.        定时器</h2><h3 id=\"1-NSTimer-的工作原理\"><a href=\"#1-NSTimer-的工作原理\" class=\"headerlink\" title=\"1.    NSTimer 的工作原理\"></a>1.    NSTimer 的工作原理</h3><p>这里说的定时器就是NSTimer，我们使用频率最高的定时器，它的原型是CFRunLoopTimerRef。一个Timer注册 RunLoop 之后，RunLoop 会为这个Timer的重复时间点注册好事件。<br>需要注意：  </p>\n<blockquote>\n<ol>\n<li><p>如果某个重复的时间点由于线程阻塞或者其他原因错过了，这个时间点会跳过去，直到下一个可以执行的时间点才会触发事件。举个栗子：假如公交车的发车间隔是10分钟，10:10的公交车我们没赶上，只能等10:20，如果由于我打电话没注意错过了10:20的车，只能等10:30的。  </p>\n</li>\n<li><p>我们在哪个线程调用 NSTimer 就必须在哪个线程终止  </p>\n</li>\n</ol>\n</blockquote>\n<p>NSTimer有一个 tolerance ，官方文档给它的解释是 Timer 的计时并不是准确的，有一定的误差，这个误差就是 tolerance 默认为0，我们可以手动设置这个误差。文档最后还强调了，为了防止时间点偏移，系统有权力给这个属性设置一个值无论你设置的值是多少，即使RunLoop 模式正确，当前线程并不阻塞，系统依然可能会在 NSTimer 上加上很小的的容差。    </p>\n<h3 id=\"2-NSTimer-优化使用\"><a href=\"#2-NSTimer-优化使用\" class=\"headerlink\" title=\"2.    NSTimer 优化使用\"></a>2.    NSTimer 优化使用</h3><p>我们在平时开发中一个很常见的现象：</p>\n<blockquote>\n<p>   在界面上有一个UIscrollview控件（tableview，collectionview等），如果此时还有一个定时器在执行一个事件，你会发现当你滚动scrollview的时候，定时器会失效。</p>\n</blockquote>\n<p>这是因为，为了更好的用户体验，在主线程中UITrackingRunLoopMode的优先级最高。在用户拖动控件时，主线程的Run Loop是运行在UITrackingRunLoopMode下，而创建的Timer是默认关联为Default Mode，因此系统不会立即执行Default Mode下接收的事件。  </p>\n<p>解决方法1：<br>将当前 Timer 加入到 UITrackingRunLoopMode 或 kCFRunLoopCommonModes 中</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSTimer</span> * timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(TimerFire:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</div><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> mainRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];  </div><div class=\"line\"><span class=\"comment\">// 或 [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span></div><div class=\"line\">[timer fire];</div></pre></td></tr></table></figure>\n<p>解决方法2：<br>因为GCD创建的定时器不受RunLoop的影响，可以使用GCD创建的定时器 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//dispatch_source_t必须是全局或static变量，否则timer不会触发</span></div><div class=\"line\">   <span class=\"keyword\">static</span> dispatch_source_t timer;</div><div class=\"line\">   <span class=\"comment\">//创建新的调度源（这里传入的是DISPATCH_SOURCE_TYPE_TIMER，创建的是Timer调度</span></div><div class=\"line\">   timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class=\"number\">0</span>, <span class=\"number\">0</span>, dispatch_get_main_queue());</div><div class=\"line\">   dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class=\"number\">1</span> * <span class=\"built_in\">NSEC_PER_SEC</span>, <span class=\"number\">0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>);</div><div class=\"line\">   dispatch_source_set_event_handler(timer, ^&#123;</div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">   &#125;);</div><div class=\"line\">   <span class=\"comment\">//启动或继续定时器</span></div><div class=\"line\">   dispatch_resume(timer);</div></pre></td></tr></table></figure>\n<h3 id=\"3-基于mode的拓展应用\"><a href=\"#3-基于mode的拓展应用\" class=\"headerlink\" title=\"3.    基于mode的拓展应用\"></a>3.    基于mode的拓展应用</h3><p>在 Timer 使用中我们可以通过将其加入到不同的mode来解决 Timer 的跳票问题。不过有些情况下，例如：  </p>\n<blockquote>\n<p>   用户滑动 scrollView 的过程中加载图片，由于UI的操作都是在主线程进行的，会造成滑动不流畅的问题，这个时候我们就需要在滑动的时候不加载图片，等滑动操作完成再进行加载图片的操作。  </p>\n</blockquote>\n<p>一般我们可以设置代理，当用户滑动结束的时候通知代理加载图片，这样比较麻烦太low，基于RunLoop的原理我们只要一行代码即可搞定  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIImage</span> *downloadImage = ...</div><div class=\"line\">[<span class=\"keyword\">self</span>.imageView performSelector:<span class=\"keyword\">@selector</span>(setImage:) </div><div class=\"line\">\t\t\t\t\t\twithObject: downloadImage </div><div class=\"line\">\t\t\t\t\t\tafterDelay:<span class=\"number\">3.0</span> </div><div class=\"line\">\t\t\t\t\t\tinModes:@[<span class=\"built_in\">NSDefaultRunLoopMode</span>]];</div></pre></td></tr></table></figure>\n<p>通过将图片的设置 <code>setImage:</code> 添加到 DefaultMode 里面，确保在 UITrackingRunLoopMode 下该操作不会被执行，保证了滑动的流畅性。  </p>\n<h2 id=\"4-网络请求\"><a href=\"#4-网络请求\" class=\"headerlink\" title=\"4.    网络请求\"></a>4.    网络请求</h2><h3 id=\"1-网络请求接口\"><a href=\"#1-网络请求接口\" class=\"headerlink\" title=\"1.    网络请求接口\"></a>1.    网络请求接口</h3><p>iOS中的网络请求接口自下而上有这么几层<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/runloop-nsnetwork.png\" alt=\"\">  </p>\n<p><strong>CFSocket</strong> 是最底层的接口，只负责 socket 通信。<br><strong>CFNetwork</strong> 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作在这层。<br><strong>NSURLConnection</strong> 是基于 CFNetwork 更高层的封装，提供了面向对象的接口，AFNetworking 工作在这一层。<br><strong>NSURLSession</strong> 看似是和 NSURLConnection 并列的，实际上它也用到了 NSURLConnection 的部分功能(比如 com.apple.NSURLConnectionLoader 线程)</p>\n<p>开始网络传输时，NSURLConnection 创建了两个新线程：<code>com.apple.NSURLConnectionLoader</code> 和 <code>com.apple.CFSocket.private</code>。<br>其中 CFSocket 线程是处理底层 socket 连接的，NSURLConnectionLoader 这个线程的RunLoop 创建了一个 Source1 事件源用来监听底层 socket 事件。当 CFSocket 处理好 socket 事件之后会通过 mach port 通知 NSURLConnectionLoader，然后 NSURLConnectionLoader 所在的线程再将消息通过 mach prot 转发给上层的 Delegate 所在的线程，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。  </p>\n<h3 id=\"2-AFNetworking-的工作原理\"><a href=\"#2-AFNetworking-的工作原理\" class=\"headerlink\" title=\"2.    AFNetworking 的工作原理\"></a>2.    AFNetworking 的工作原理</h3><p>在AFNetworking2.6.3版本之前是有 AFURLConnectionOperation 这个类的，<br>AFNetworking 3.0 版本开始已经移除了这个类，AFN没有自己创建线程，而是采用的下面的这种方式  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[inputStream scheduleInRunLoop:[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</div><div class=\"line\">[outputStream scheduleInRunLoop:[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];  </div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">SCNetworkReachabilityUnscheduleFromRunLoop</span>(<span class=\"keyword\">self</span>.networkReachability, <span class=\"built_in\">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</div></pre></td></tr></table></figure>\n<p>由于本文讨论的是RunLoop，所以这里我们还是回到2.6.3版本AFN自己创建线程并添加RunLoop的这种方式讨论，在 AFURLConnectionOperation 类中可以找到下面的代码  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">void</span>)networkRequestThreadEntryPoint:(<span class=\"keyword\">id</span>)__unused object &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        [[<span class=\"built_in\">NSThread</span> currentThread] setName:<span class=\"string\">@\"AFNetworking\"</span>];</div><div class=\"line\">        <span class=\"built_in\">NSRunLoop</span> *runLoop = [<span class=\"built_in\">NSRunLoop</span> currentRunLoop];</div><div class=\"line\">        [runLoop addPort:[<span class=\"built_in\">NSMachPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</div><div class=\"line\">        [runLoop run];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (<span class=\"built_in\">NSThread</span> *)networkRequestThread &#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSThread</span> *_networkRequestThread = <span class=\"literal\">nil</span>;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> oncePredicate;</div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;oncePredicate, ^&#123;</div><div class=\"line\">        _networkRequestThread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(networkRequestThreadEntryPoint:) object:<span class=\"literal\">nil</span>];</div><div class=\"line\">        [_networkRequestThread start];</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> _networkRequestThread;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，AFN创建了一个新的线程命名为 AFNetworking ，然后在这个线程中创建了一个 RunLoop ，在上面2.3章节 RunLoop 运行机制中提到了，一个RunLoop中如果source/timer/observer 都为空则会退出，并不进入循环。所以，AFN在这里为 RunLoop 添加了一个 NSMachPort ，这个port开启相当于添加了一个Source1事件源，但是这个事件源并没有真正的监听什么东西，只是为了不让 RunLoop 退出。 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//开始请求</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock lock];</div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isCancelled]) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(cancelConnection) onThread:[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] networkRequestThread] withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span> modes:[<span class=\"keyword\">self</span>.runLoopModes allObjects]];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isReady]) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.state = AFOperationExecutingState;</div><div class=\"line\">        [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(operationDidStart) onThread:[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] networkRequestThread] withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span> modes:[<span class=\"keyword\">self</span>.runLoopModes allObjects]];</div><div class=\"line\">    &#125;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//暂停请求</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)pause &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isPaused] || [<span class=\"keyword\">self</span> isFinished] || [<span class=\"keyword\">self</span> isCancelled]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock lock];</div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isExecuting]) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(operationDidPause) onThread:[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] networkRequestThread] withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span> modes:[<span class=\"keyword\">self</span>.runLoopModes allObjects]];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            <span class=\"built_in\">NSNotificationCenter</span> *notificationCenter = [<span class=\"built_in\">NSNotificationCenter</span> defaultCenter];</div><div class=\"line\">            [notificationCenter postNotificationName:AFNetworkingOperationDidFinishNotification object:<span class=\"keyword\">self</span>];</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">self</span>.state = AFOperationPausedState;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//取消请求</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)cancel &#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock lock];</div><div class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> isFinished] &amp;&amp; ![<span class=\"keyword\">self</span> isCancelled]) &#123;</div><div class=\"line\">        [<span class=\"keyword\">super</span> cancel];</div><div class=\"line\">        <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isExecuting]) &#123;</div><div class=\"line\">            [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(cancelConnection) onThread:[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] networkRequestThread] withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span> modes:[<span class=\"keyword\">self</span>.runLoopModes allObjects]];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock unlock];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，AFN每次进行的网络操作，开始、暂停、取消操作时都将相应的执行任务扔进了自己创建的线程的 RunLoop 中进行处理，从而避免造成主线程的阻塞。  </p>\n<h2 id=\"5-处理崩溃让程序继续运行\"><a href=\"#5-处理崩溃让程序继续运行\" class=\"headerlink\" title=\"5.    处理崩溃让程序继续运行\"></a>5.    处理崩溃让程序继续运行</h2><p>我们都知道，如果App运行遇到 Exception 就会直接崩溃并且退出，其实真正让应用退出的并不是产生的异常，而是当产生异常时，系统会结束掉当前主线程的 RunLoop ，RunLoop 退出主线程就退出了，所以应用才会退出。明白这个道理，去完成这个“不可能的任务”就很简单了。  </p>\n<p>接下来我们就去让应用在崩溃时依然可以正常运行，这个是非常有意义的。  </p>\n<h3 id=\"1-提升用户体验\"><a href=\"#1-提升用户体验\" class=\"headerlink\" title=\"1.    提升用户体验\"></a>1.    提升用户体验</h3><p>应用遇到BUG崩溃时一般会给使用者造成非常不好的用户体验，如果当应用崩溃时我们让用户选择退出还是继续运行，那么用户会感觉我们的App跟别人的不一样，叼叼哒！</p>\n<h3 id=\"2-收集崩溃日志\"><a href=\"#2-收集崩溃日志\" class=\"headerlink\" title=\"2.    收集崩溃日志\"></a>2.    收集崩溃日志</h3><p>苹果提供了产生 Exception 的处理方法，我们可以在相应的方法中处理产生的异常，但是这个时间非常的短，之后应用就会退出，具体多长时间我们也不清楚，很被动。如果我们可以在应用崩溃时，有足够的时间收集并且上传到服务器，那么给我们的分析和解决BUG会带来相当大的便利。  </p>\n<p>下面直接上代码，非常简单：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> runLoop = <span class=\"built_in\">CFRunLoopGetCurrent</span>();</div><div class=\"line\"><span class=\"built_in\">CFArrayRef</span> allModes = <span class=\"built_in\">CFRunLoopCopyAllModes</span>(runLoop);</div><div class=\"line\"><span class=\"keyword\">while</span> (!isQuit)&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *mode <span class=\"keyword\">in</span> (__bridge <span class=\"built_in\">NSArray</span> *)allModes) &#123;</div><div class=\"line\">        <span class=\"built_in\">CFRunLoopRunInMode</span>((<span class=\"built_in\">CFStringRef</span>)mode, <span class=\"number\">0.001</span>, <span class=\"literal\">false</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">CFRelease</span>(allModes);</div></pre></td></tr></table></figure>\n<p>把上面的代码添加到 Exception 的handle方法中，此时创建了一个 RunLoop ，让这个 RunLoop 在所有的 Mode 下面一直不停的跑，保证主线程不会退出，我们的应用也就存活下来了。</p>\n<p>参考：<br><a href=\"https://developer.apple.com/reference/corefoundation/cfrunloopref\" target=\"_blank\" rel=\"external\">https://developer.apple.com/reference/corefoundation/cfrunloopref</a><br><a href=\"http://iphil.cc/?p=279\" target=\"_blank\" rel=\"external\">http://iphil.cc/?p=279</a><br><a href=\"http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"external\">http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a><br><a href=\"http://www.itdadao.com/article/25145/\" target=\"_blank\" rel=\"external\">http://www.itdadao.com/article/25145/</a>  </p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、-RunLoop初识\"><a href=\"#一、-RunLoop初识\" class=\"headerlink\" title=\"一、    RunLoop初识\"></a>一、    RunLoop初识</h1><p>日常的开发工作中，我们几乎很少注意RunLoop，因为我们基本上“用不到”RunLoop。包括我在内应该有很多人都不了解这个东西，只是听说过。最近有空查了不少资料终于把RunLoop运行原理搞清楚了。<br>本文会对RunLoop的原理进行深入探讨，但是不涉及底层的实现。<br>我们平时开发中的很多东西都和RunLoop相关，比如：<br>","more":"</p>\n<ul>\n<li>AutoreleasePool   </li>\n<li>NSTimer  </li>\n<li>消息通知</li>\n<li>perform函数</li>\n<li>网络请求</li>\n<li>dispatch调用</li>\n<li>block回调</li>\n<li>KVO</li>\n<li>触摸事件以及各种硬件传感器 </li>\n</ul>\n<p>RunLoop机制贯穿整个App的生命周期的，这里提前剧透个彩蛋：  </p>\n<blockquote>\n<p>   我们都知道：如果主线程的RunLoop挂掉了，App也就挂掉了  </p>\n</blockquote>\n<p><strong>BUT：</strong><br>我们通过RunLoop机制可以让崩溃的App继续保持运行，非常英吹思婷！后面会有介绍。 </p>\n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>   </p>\n<h1 id=\"二、-RunLoop详解\"><a href=\"#二、-RunLoop详解\" class=\"headerlink\" title=\"二、    RunLoop详解\"></a>二、    RunLoop详解</h1><p>计算机处理任务有进程和线程的概念，安卓中一个应用可以开启多个进程，而在iOS中一个App只能开启一个进程，但是线程可以开启多个。线程是用来处理事务的，多个线程处理事务是为了防止线程堵塞；一般来说一个线程一次只能执行一个任务，任务执行完成这个线程就会退出。<br>某些情况下我们需要这个线程一直运行着，不管有没有任务执行（<em>比方说App的主线程</em>），所以需要一种机制来维持线程的生命周期，iOS中叫做RunLoop，安卓里面的Looper机制和此类似。<br>为了让线程不退出随时候命处理事件而不退出，可以将逻辑简化为下面的代码  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">do</span>&#123;</div><div class=\"line\">    var message = getNewmessages();<span class=\"comment\">//接收来自外部的消息</span></div><div class=\"line\">    exec(message);<span class=\"comment\">//处理消息任务</span></div><div class=\"line\">&#125;<span class=\"keyword\">while</span>(<span class=\"number\">0</span>==isQuit)</div></pre></td></tr></table></figure>\n<p>RunLoop实际上也是一个对象，这个对象管理了线程内部需要处理的事件和消息，存在RunLoop的线程一直处于“消息接收-&gt;等待-&gt;处理”的循环中，直到这个循环结束（RunLoop被释放）。  </p>\n<h2 id=\"1-进程、线程、RunLoop之间的关系\"><a href=\"#1-进程、线程、RunLoop之间的关系\" class=\"headerlink\" title=\"1.    进程、线程、RunLoop之间的关系\"></a>1.    进程、线程、RunLoop之间的关系</h2><p><strong>这里举一个比较通俗易懂的例子：</strong> </p>\n<ul>\n<li>进程：工厂  </li>\n<li>线程：流水线  </li>\n<li>RunLoop：生产线上面的主管  </li>\n</ul>\n<p>当工厂接到商家的订单时，会将订单生产的消息（外界的event消息）发送给对应流水线上的主管（RunLoop），主管接收到消息之后启动这个流水线（唤醒线程）进行生产（线程处理事务）。如果这个流水线没有主管，流水线将会被工厂销毁。  </p>\n<p>需要注意的是，线程与RunLoop是一一对应的关系（对应关系保存在一个全局的Dictionary里），线程创建之后是没有RunLoop的（主线程除外），RunLoop的创建是发生在第一次获取时。  </p>\n<blockquote>\n<p>   苹果不允许直接创建RunLoop，但是可以通过[NSRunLoop currentRunLoop]或者CFRunLoopGetCurrent()来获取（如果没有就会自动创建一个）。</p>\n</blockquote>\n<p>一般开发中使用的RunLoop就是NSRunLoop和CFRunLoopRef，CFRunLoopRef属于Core Foundation框架，提供的是C函数的API，<strong>是线程安全的</strong>，NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，<strong>这些API不是线程安全的</strong>。  </p>\n<p>由于NSRunLoop是基于CFRunLoop封装的，下文关于RunLoop的原理讨论都会基于CFRunLoop来进行。NSRunLoop和CFRunLoop所有类都是一一对应的关系。</p>\n<h2 id=\"2-RunLoop主要组成\"><a href=\"#2-RunLoop主要组成\" class=\"headerlink\" title=\"2.    RunLoop主要组成\"></a>2.    RunLoop主要组成</h2><blockquote>\n<p>   CFRunLoop对象可以检测某个task或者dispatch的输入事件，当检测到有输入源事件，CFRunLoop将会将其加入到线程中进行处理。比方说用户输入事件、网络连接事件、周期性或者延时事件、异步的回调等。  </p>\n<p>   RunLoop可以检测的事件类型一共有3种，分别是CFRunLoopSource、CFRunLoopTimer、CFRunLoopObserver。可以通过CFRunLoopAddSource, CFRunLoopAddTimer或者CFRunLoopAddObserver添加相应的事件类型。  </p>\n<p>   要让一个RunLoop跑起来还需要run loop modes，每一个source, timer和observer添加到RunLoop中时必须要与一个模式（CFRunLoopMode）相关联才可以运行。</p>\n</blockquote>\n<p>上面是对于CFRunLoop官方文档的解释，大致说明了RunLoop的工作原理。<br>RunLoop的主要组成部分如下：  </p>\n<ul>\n<li>Run Loop （CFRunLoopRef）</li>\n<li>Run Loop Source（CFRunLoopSourceRef）</li>\n<li>Run Loop Timer（CFRunLoopTimerRef）</li>\n<li>Run Loop Observer（CFRunLoopObserverRef）</li>\n<li>Run Loop Modes（CFRunLoopModeRef）</li>\n</ul>\n<p>RunLoop共包含5个类，但公开的只有Source、Timer、Observer相关的三个类。<br>这5个类之间的关系关系：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/RunLoop.png\" alt=\"\"></p>\n<p>下面对这几个部分作详细的讲解。  </p>\n<h3 id=\"1-RunLoop-Modes\"><a href=\"#1-RunLoop-Modes\" class=\"headerlink\" title=\"1.    RunLoop Modes\"></a>1.    RunLoop Modes</h3><blockquote>\n<p>   Run Loop Mode就是流水线上能够生产的产品类型，流水线在一个时刻只能在一种模式下运行，生产某一类型的产品。消息事件就是订单。  </p>\n</blockquote>\n<p>CFRunLoopMode 和 CFRunLoop的结构大致如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoopMode &#123;</div><div class=\"line\">    <span class=\"built_in\">CFStringRef</span> _name;            <span class=\"comment\">// Mode Name, 例如 @\"kCFRunLoopDefaultMode\"</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources0;    <span class=\"comment\">// Set</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources1;    <span class=\"comment\">// Set</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _observers; <span class=\"comment\">// Array</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _timers;    <span class=\"comment\">// Array</span></div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes;     <span class=\"comment\">// Set</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems; <span class=\"comment\">// Set&lt;Source/Observer/Timer&gt;</span></div><div class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> _currentMode;    <span class=\"comment\">// Current Runloop Mode</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes;           <span class=\"comment\">// Set</span></div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>一个RunLoop包含了多个Mode，每个Mode又包含了若干个Source/Timer/Observer。每次调用 RunLoop的主函数时，只能指定其中一个Mode，这个Mode被称作CurrentMode。如果需要切换 Mode，只能退出Loop，再重新指定一个Mode进入。这样做主要是为了分隔开不同Mode中的Source/Timer/Observer，让其互不影响。下面是5种Mode  </p>\n<ul>\n<li><strong>kCFDefaultRunLoopMode</strong>    App的默认Mode，通常主线程是在这个Mode下运行</li>\n<li><strong>UITrackingRunLoopMode</strong>    界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li>\n<li><strong>UIInitializationRunLoopMode</strong> 在刚启动App时第进入的第一个Mode，启动完成后就不再使用</li>\n<li><strong>GSEventReceiveRunLoopMode</strong>    接受系统事件的内部Mode，通常用不到</li>\n<li><strong>kCFRunLoopCommonModes</strong>    这是一个占位用的Mode，不是一种真正的Mode</li>\n</ul>\n<p>其中kCFDefaultRunLoopMode、UITrackingRunLoopMode是苹果公开的，其余的mode都是无法添加的。既然没有CommonModes这个模式，那我们平时用的这行代码怎么解释呢？  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>\n<p><strong>什么是CommonModes？</strong>   </p>\n<p>一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里<br>主线程的 RunLoop 里有 kCFRunLoopDefaultMode 和 UITrackingRunLoopMode，这两个Mode都已经被标记为”Common”属性。当你创建一个Timer并加到DefaultMode时，Timer会得到重复回调，但此时滑动一个 scrollView 时，RunLoop 会将 mode 切换为TrackingRunLoopMode，这时Timer就不会被回调，并且也不会影响到滑动操作。<br>如果想让scrollView滑动时Timer可以正常调用，一种办法就是手动将这个 Timer 分别加入这两个 Mode。另一种方法就是将 Timer 加入到CommonMode 中。</p>\n<p><strong>怎么将事件加入到CommonMode？</strong><br>我们调用上面的代码将 Timer 加入到CommonMode 时，但实际并没有 CommonMode，其实系统将这个 Timer 加入到顶层的 RunLoop 的 commonModeItems 中。commonModeItems 会被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。<br>这一步其实是系统帮我们将Timer加到了kCFRunLoopDefaultMode和UITrackingRunLoopMode中。  </p>\n<h3 id=\"2-RunLoop-Source\"><a href=\"#2-RunLoop-Source\" class=\"headerlink\" title=\"2.    RunLoop Source\"></a>2.    RunLoop Source</h3><p>CFRunLoopSourceRef是事件源（输入源），比如外部的触摸，点击事件和系统内部进程间的通信等。<br>按照官方文档，Source的分类：</p>\n<ul>\n<li>Port-Based Sources</li>\n<li>Custom Input Sources</li>\n<li>Cocoa Perform Selector Sources</li>\n</ul>\n<p>Source有两个版本：Source0 和 Source1（<em>这么风骚的名字不知道是谁想出来的</em>）。<br><strong>Source0：</strong>    非基于Port的，只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。<br><strong>Source1：</strong>    基于Port的，包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。后面讲到的AFNetwoeking创建常驻线程就是在线程中添加一个NSport来实现的。</p>\n<h3 id=\"3-RunLoop-Timer\"><a href=\"#3-RunLoop-Timer\" class=\"headerlink\" title=\"3.    RunLoop Timer\"></a>3.    RunLoop Timer</h3><p>CFRunLoopTimerRef是基于时间的触发器，基本上说的就是NSTimer，它受RunLoop的Mode影响（GCD的定时器不受RunLoop的Mode影响），当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。如果线程阻塞或者不在这个Mode下，触发点将不会执行，一直等到下一个周期时间点触发。</p>\n<h3 id=\"4-RunLoop-Observer\"><a href=\"#4-RunLoop-Observer\" class=\"headerlink\" title=\"4.    RunLoop Observer\"></a>4.    RunLoop Observer</h3><p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">enum</span> <span class=\"built_in\">CFRunLoopActivity</span> &#123;</div><div class=\"line\">    kCFRunLoopEntry                     = (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>),    <span class=\"comment\">// 即将进入Loop   </span></div><div class=\"line\">    kCFRunLoopBeforeTimers \t\t= (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>),    <span class=\"comment\">// 即将处理 Timer    \t</span></div><div class=\"line\">    kCFRunLoopBeforeSources\t\t= (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>),    <span class=\"comment\">// 即将处理 Source  </span></div><div class=\"line\">    kCFRunLoopBeforeWaiting\t\t= (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">5</span>),    <span class=\"comment\">// 即将进入休眠     </span></div><div class=\"line\">    kCFRunLoopAfterWaiting \t\t= (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">6</span>),    <span class=\"comment\">// 刚从休眠中唤醒   </span></div><div class=\"line\">    kCFRunLoopExit                      = (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">7</span>),    <span class=\"comment\">// 即将退出Loop  </span></div><div class=\"line\">    kCFRunLoopAllActivities\t\t= <span class=\"number\">0x0FFFFFFF</span>U  <span class=\"comment\">// 包含上面所有状态  </span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> <span class=\"built_in\">CFRunLoopActivity</span> <span class=\"built_in\">CFRunLoopActivity</span>;</div></pre></td></tr></table></figure>\n<h2 id=\"3-RunLoop-运行机制\"><a href=\"#3-RunLoop-运行机制\" class=\"headerlink\" title=\"3.    RunLoop 运行机制\"></a>3.    RunLoop 运行机制</h2><p>这是我从别人博客上面摘录的一张图片，详细的描述了RunLoop运行机制<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/RunLoop_1.png\" alt=\"\">  </p>\n<p>每次线程运行RunLoop都会自动处理之前未处理的消息，并且将消息发送给观察者，让事件得到执行。RunLoop运行时首先根据modeName找到对应mode，如果mode里没有source/timer/observer，直接返回。<br><strong>流程如下：</strong>  </p>\n<p><strong>Step1</strong>  通知观察者 RunLoop 启动（之后调用内部函数，进入Loop，下面的流程都在Loop内部do-while函数中执行）<br><strong>Step2</strong>  通知观察者: RunLoop 即将触发 Timer 回调。（kCFRunLoopBeforeTimers）<br><strong>Step3</strong>  通知观察者: RunLoop 即将触发 Source0 回调。（kCFRunLoopBeforeSources）<br><strong>Step4</strong>  RunLoop 触发 Source0 回调。<br><strong>Step5</strong>     如果有 Source1 处于等待状态，直接处理这个 Source1 然后跳转到第9步处理消息。<br><strong>Step6</strong>    通知观察者：RunLoop 的线程即将进入休眠(sleep)。（kCFRunLoopBeforeWaiting）<br><strong>Step7</strong>    调用 <code>mach_msg</code> 等待接受 <code>mach_port</code> 的消息。线程将进入休眠, 直到被下面某一个事件唤醒  </p>\n<blockquote>\n<ol>\n<li>存在Source0被标记为待处理，系统调用CFRunLoopWakeUp唤醒线程处理事件  </li>\n<li>定时器时间到了   </li>\n<li>RunLoop自身的超时时间到了  </li>\n<li>RunLoop外部调用者唤醒      </li>\n</ol>\n</blockquote>\n<p><strong>Step8</strong>    通知观察者线程已经被唤醒 （kCFRunLoopAfterWaiting）<br><strong>Step9</strong>   处理事件  </p>\n<blockquote>\n<ol>\n<li>如果一个 Timer 到时间了，触发这个Timer的回调    </li>\n<li>如果有dispatch到main_queue的block，执行block   </li>\n<li>如果一个 Source1 发出事件了，处理这个事件   </li>\n</ol>\n</blockquote>\n<p><strong>事件处理完成进行判断：</strong>  </p>\n<blockquote>\n<ol>\n<li>进入loop时传入参数指明处理完事件就返回（stopAfterHandle）  </li>\n<li>超出传入参数标记的超时时间（timeout）  </li>\n<li>被外部调用者强制停止<code>__CFRunLoopIsStopped(runloop)</code>   </li>\n<li>source/timer/observer 全都空了<code>__CFRunLoopModeIsEmpty(runloop, currentMode)</code>  </li>\n</ol>\n</blockquote>\n<p>上面4个条件都不满足，即没超时、mode里没空、loop也没被停止，那继续loop。此时跳转到步骤2继续循环。  </p>\n<p><strong>Step10</strong>    系统通知观察者: RunLoop 即将退出。<br>满足步骤9事件处理完成判断4条中的任何一条，跳出do-while函数的内部，通知观察者Loop结束。</p>\n<h1 id=\"三、-RunLoop实际应用\"><a href=\"#三、-RunLoop实际应用\" class=\"headerlink\" title=\"三、    RunLoop实际应用\"></a>三、    RunLoop实际应用</h1><h2 id=\"1-AutoreleasePool\"><a href=\"#1-AutoreleasePool\" class=\"headerlink\" title=\"1. AutoreleasePool\"></a>1. AutoreleasePool</h2><p>App启动之后，系统启动主线程并创建了RunLoop，在 main thread 中注册了两个 observer ，回调都是<code>_wrapRunLoopWithAutoreleasePoolHandler()</code>  </p>\n<h3 id=\"1-第一个observer\"><a href=\"#1-第一个observer\" class=\"headerlink\" title=\"1.    第一个observer\"></a>1.    第一个observer</h3><p>监听了一个事件：  </p>\n<h4 id=\"1-即将进入Loop（kCFRunLoopEntry）\"><a href=\"#1-即将进入Loop（kCFRunLoopEntry）\" class=\"headerlink\" title=\"1.    即将进入Loop（kCFRunLoopEntry）\"></a>1.    即将进入Loop（kCFRunLoopEntry）</h4><p>其回调会调用 <code>_objc_autoreleasePoolPush()</code> 创建一个栈自动释放池，这个优先级最高，保证创建释放池在其他操作之前。  </p>\n<h3 id=\"2-第二个observer\"><a href=\"#2-第二个observer\" class=\"headerlink\" title=\"2.    第二个observer\"></a>2.    第二个observer</h3><p>监听了两个事件：</p>\n<h4 id=\"1-准备进入休眠（kCFRunLoopBeforeWaiting）\"><a href=\"#1-准备进入休眠（kCFRunLoopBeforeWaiting）\" class=\"headerlink\" title=\"1.    准备进入休眠（kCFRunLoopBeforeWaiting）\"></a>1.    准备进入休眠（kCFRunLoopBeforeWaiting）</h4><p>此时调用 <code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 来释放旧的池并创建新的池。  </p>\n<h4 id=\"2-即将退出Loop（kCFRunLoopExit）\"><a href=\"#2-即将退出Loop（kCFRunLoopExit）\" class=\"headerlink\" title=\"2. 即将退出Loop（kCFRunLoopExit）\"></a>2. 即将退出Loop（kCFRunLoopExit）</h4><p>此时调用 <code>_objc_autoreleasePoolPop()</code>释放自动释放池。这个 observer 的优先级最低，确保池子释放在所有回调之后。  </p>\n<p>在主线程中执行代码一般都是写在事件回调或Timer回调中的，这些回调都被加入了main thread的自动释放池中，所以在ARC模式下我们不用关心对象什么时候释放，也不用去创建和管理pool。（如果事件不在主线程中要注意创建自动释放池，否则可能会出现内存泄漏）。  </p>\n<h2 id=\"2-事件响应\"><a href=\"#2-事件响应\" class=\"headerlink\" title=\"2.        事件响应\"></a>2.        事件响应</h2><p>系统注册了一个 Source1 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收，</p>\n<blockquote>\n<p>   SpringBoard 只接收按键(锁屏/静音等)、触摸、加速，传感器等几种事件  </p>\n</blockquote>\n<p>随后用 mach port 转发给需要的App进程。随后系统注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code>进行应用内部的分发。<br><code>_UIApplicationHandleEventQueue()</code> 会把 IOHIDEvent 事件处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。    </p>\n<h2 id=\"3-定时器\"><a href=\"#3-定时器\" class=\"headerlink\" title=\"3.        定时器\"></a>3.        定时器</h2><h3 id=\"1-NSTimer-的工作原理\"><a href=\"#1-NSTimer-的工作原理\" class=\"headerlink\" title=\"1.    NSTimer 的工作原理\"></a>1.    NSTimer 的工作原理</h3><p>这里说的定时器就是NSTimer，我们使用频率最高的定时器，它的原型是CFRunLoopTimerRef。一个Timer注册 RunLoop 之后，RunLoop 会为这个Timer的重复时间点注册好事件。<br>需要注意：  </p>\n<blockquote>\n<ol>\n<li><p>如果某个重复的时间点由于线程阻塞或者其他原因错过了，这个时间点会跳过去，直到下一个可以执行的时间点才会触发事件。举个栗子：假如公交车的发车间隔是10分钟，10:10的公交车我们没赶上，只能等10:20，如果由于我打电话没注意错过了10:20的车，只能等10:30的。  </p>\n</li>\n<li><p>我们在哪个线程调用 NSTimer 就必须在哪个线程终止  </p>\n</li>\n</ol>\n</blockquote>\n<p>NSTimer有一个 tolerance ，官方文档给它的解释是 Timer 的计时并不是准确的，有一定的误差，这个误差就是 tolerance 默认为0，我们可以手动设置这个误差。文档最后还强调了，为了防止时间点偏移，系统有权力给这个属性设置一个值无论你设置的值是多少，即使RunLoop 模式正确，当前线程并不阻塞，系统依然可能会在 NSTimer 上加上很小的的容差。    </p>\n<h3 id=\"2-NSTimer-优化使用\"><a href=\"#2-NSTimer-优化使用\" class=\"headerlink\" title=\"2.    NSTimer 优化使用\"></a>2.    NSTimer 优化使用</h3><p>我们在平时开发中一个很常见的现象：</p>\n<blockquote>\n<p>   在界面上有一个UIscrollview控件（tableview，collectionview等），如果此时还有一个定时器在执行一个事件，你会发现当你滚动scrollview的时候，定时器会失效。</p>\n</blockquote>\n<p>这是因为，为了更好的用户体验，在主线程中UITrackingRunLoopMode的优先级最高。在用户拖动控件时，主线程的Run Loop是运行在UITrackingRunLoopMode下，而创建的Timer是默认关联为Default Mode，因此系统不会立即执行Default Mode下接收的事件。  </p>\n<p>解决方法1：<br>将当前 Timer 加入到 UITrackingRunLoopMode 或 kCFRunLoopCommonModes 中</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSTimer</span> * timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(TimerFire:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</div><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> mainRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];  </div><div class=\"line\"><span class=\"comment\">// 或 [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span></div><div class=\"line\">[timer fire];</div></pre></td></tr></table></figure>\n<p>解决方法2：<br>因为GCD创建的定时器不受RunLoop的影响，可以使用GCD创建的定时器 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//dispatch_source_t必须是全局或static变量，否则timer不会触发</span></div><div class=\"line\">   <span class=\"keyword\">static</span> dispatch_source_t timer;</div><div class=\"line\">   <span class=\"comment\">//创建新的调度源（这里传入的是DISPATCH_SOURCE_TYPE_TIMER，创建的是Timer调度</span></div><div class=\"line\">   timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class=\"number\">0</span>, <span class=\"number\">0</span>, dispatch_get_main_queue());</div><div class=\"line\">   dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class=\"number\">1</span> * <span class=\"built_in\">NSEC_PER_SEC</span>, <span class=\"number\">0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>);</div><div class=\"line\">   dispatch_source_set_event_handler(timer, ^&#123;</div><div class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">   &#125;);</div><div class=\"line\">   <span class=\"comment\">//启动或继续定时器</span></div><div class=\"line\">   dispatch_resume(timer);</div></pre></td></tr></table></figure>\n<h3 id=\"3-基于mode的拓展应用\"><a href=\"#3-基于mode的拓展应用\" class=\"headerlink\" title=\"3.    基于mode的拓展应用\"></a>3.    基于mode的拓展应用</h3><p>在 Timer 使用中我们可以通过将其加入到不同的mode来解决 Timer 的跳票问题。不过有些情况下，例如：  </p>\n<blockquote>\n<p>   用户滑动 scrollView 的过程中加载图片，由于UI的操作都是在主线程进行的，会造成滑动不流畅的问题，这个时候我们就需要在滑动的时候不加载图片，等滑动操作完成再进行加载图片的操作。  </p>\n</blockquote>\n<p>一般我们可以设置代理，当用户滑动结束的时候通知代理加载图片，这样比较麻烦太low，基于RunLoop的原理我们只要一行代码即可搞定  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIImage</span> *downloadImage = ...</div><div class=\"line\">[<span class=\"keyword\">self</span>.imageView performSelector:<span class=\"keyword\">@selector</span>(setImage:) </div><div class=\"line\">\t\t\t\t\t\twithObject: downloadImage </div><div class=\"line\">\t\t\t\t\t\tafterDelay:<span class=\"number\">3.0</span> </div><div class=\"line\">\t\t\t\t\t\tinModes:@[<span class=\"built_in\">NSDefaultRunLoopMode</span>]];</div></pre></td></tr></table></figure>\n<p>通过将图片的设置 <code>setImage:</code> 添加到 DefaultMode 里面，确保在 UITrackingRunLoopMode 下该操作不会被执行，保证了滑动的流畅性。  </p>\n<h2 id=\"4-网络请求\"><a href=\"#4-网络请求\" class=\"headerlink\" title=\"4.    网络请求\"></a>4.    网络请求</h2><h3 id=\"1-网络请求接口\"><a href=\"#1-网络请求接口\" class=\"headerlink\" title=\"1.    网络请求接口\"></a>1.    网络请求接口</h3><p>iOS中的网络请求接口自下而上有这么几层<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/runloop-nsnetwork.png\" alt=\"\">  </p>\n<p><strong>CFSocket</strong> 是最底层的接口，只负责 socket 通信。<br><strong>CFNetwork</strong> 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作在这层。<br><strong>NSURLConnection</strong> 是基于 CFNetwork 更高层的封装，提供了面向对象的接口，AFNetworking 工作在这一层。<br><strong>NSURLSession</strong> 看似是和 NSURLConnection 并列的，实际上它也用到了 NSURLConnection 的部分功能(比如 com.apple.NSURLConnectionLoader 线程)</p>\n<p>开始网络传输时，NSURLConnection 创建了两个新线程：<code>com.apple.NSURLConnectionLoader</code> 和 <code>com.apple.CFSocket.private</code>。<br>其中 CFSocket 线程是处理底层 socket 连接的，NSURLConnectionLoader 这个线程的RunLoop 创建了一个 Source1 事件源用来监听底层 socket 事件。当 CFSocket 处理好 socket 事件之后会通过 mach port 通知 NSURLConnectionLoader，然后 NSURLConnectionLoader 所在的线程再将消息通过 mach prot 转发给上层的 Delegate 所在的线程，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。  </p>\n<h3 id=\"2-AFNetworking-的工作原理\"><a href=\"#2-AFNetworking-的工作原理\" class=\"headerlink\" title=\"2.    AFNetworking 的工作原理\"></a>2.    AFNetworking 的工作原理</h3><p>在AFNetworking2.6.3版本之前是有 AFURLConnectionOperation 这个类的，<br>AFNetworking 3.0 版本开始已经移除了这个类，AFN没有自己创建线程，而是采用的下面的这种方式  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[inputStream scheduleInRunLoop:[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</div><div class=\"line\">[outputStream scheduleInRunLoop:[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];  </div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">SCNetworkReachabilityUnscheduleFromRunLoop</span>(<span class=\"keyword\">self</span>.networkReachability, <span class=\"built_in\">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</div></pre></td></tr></table></figure>\n<p>由于本文讨论的是RunLoop，所以这里我们还是回到2.6.3版本AFN自己创建线程并添加RunLoop的这种方式讨论，在 AFURLConnectionOperation 类中可以找到下面的代码  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">void</span>)networkRequestThreadEntryPoint:(<span class=\"keyword\">id</span>)__unused object &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        [[<span class=\"built_in\">NSThread</span> currentThread] setName:<span class=\"string\">@\"AFNetworking\"</span>];</div><div class=\"line\">        <span class=\"built_in\">NSRunLoop</span> *runLoop = [<span class=\"built_in\">NSRunLoop</span> currentRunLoop];</div><div class=\"line\">        [runLoop addPort:[<span class=\"built_in\">NSMachPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</div><div class=\"line\">        [runLoop run];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (<span class=\"built_in\">NSThread</span> *)networkRequestThread &#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSThread</span> *_networkRequestThread = <span class=\"literal\">nil</span>;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> oncePredicate;</div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;oncePredicate, ^&#123;</div><div class=\"line\">        _networkRequestThread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(networkRequestThreadEntryPoint:) object:<span class=\"literal\">nil</span>];</div><div class=\"line\">        [_networkRequestThread start];</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> _networkRequestThread;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，AFN创建了一个新的线程命名为 AFNetworking ，然后在这个线程中创建了一个 RunLoop ，在上面2.3章节 RunLoop 运行机制中提到了，一个RunLoop中如果source/timer/observer 都为空则会退出，并不进入循环。所以，AFN在这里为 RunLoop 添加了一个 NSMachPort ，这个port开启相当于添加了一个Source1事件源，但是这个事件源并没有真正的监听什么东西，只是为了不让 RunLoop 退出。 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//开始请求</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock lock];</div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isCancelled]) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(cancelConnection) onThread:[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] networkRequestThread] withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span> modes:[<span class=\"keyword\">self</span>.runLoopModes allObjects]];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isReady]) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.state = AFOperationExecutingState;</div><div class=\"line\">        [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(operationDidStart) onThread:[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] networkRequestThread] withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span> modes:[<span class=\"keyword\">self</span>.runLoopModes allObjects]];</div><div class=\"line\">    &#125;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//暂停请求</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)pause &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isPaused] || [<span class=\"keyword\">self</span> isFinished] || [<span class=\"keyword\">self</span> isCancelled]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock lock];</div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isExecuting]) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(operationDidPause) onThread:[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] networkRequestThread] withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span> modes:[<span class=\"keyword\">self</span>.runLoopModes allObjects]];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            <span class=\"built_in\">NSNotificationCenter</span> *notificationCenter = [<span class=\"built_in\">NSNotificationCenter</span> defaultCenter];</div><div class=\"line\">            [notificationCenter postNotificationName:AFNetworkingOperationDidFinishNotification object:<span class=\"keyword\">self</span>];</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">self</span>.state = AFOperationPausedState;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//取消请求</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)cancel &#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock lock];</div><div class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> isFinished] &amp;&amp; ![<span class=\"keyword\">self</span> isCancelled]) &#123;</div><div class=\"line\">        [<span class=\"keyword\">super</span> cancel];</div><div class=\"line\">        <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isExecuting]) &#123;</div><div class=\"line\">            [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(cancelConnection) onThread:[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] networkRequestThread] withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span> modes:[<span class=\"keyword\">self</span>.runLoopModes allObjects]];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock unlock];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，AFN每次进行的网络操作，开始、暂停、取消操作时都将相应的执行任务扔进了自己创建的线程的 RunLoop 中进行处理，从而避免造成主线程的阻塞。  </p>\n<h2 id=\"5-处理崩溃让程序继续运行\"><a href=\"#5-处理崩溃让程序继续运行\" class=\"headerlink\" title=\"5.    处理崩溃让程序继续运行\"></a>5.    处理崩溃让程序继续运行</h2><p>我们都知道，如果App运行遇到 Exception 就会直接崩溃并且退出，其实真正让应用退出的并不是产生的异常，而是当产生异常时，系统会结束掉当前主线程的 RunLoop ，RunLoop 退出主线程就退出了，所以应用才会退出。明白这个道理，去完成这个“不可能的任务”就很简单了。  </p>\n<p>接下来我们就去让应用在崩溃时依然可以正常运行，这个是非常有意义的。  </p>\n<h3 id=\"1-提升用户体验\"><a href=\"#1-提升用户体验\" class=\"headerlink\" title=\"1.    提升用户体验\"></a>1.    提升用户体验</h3><p>应用遇到BUG崩溃时一般会给使用者造成非常不好的用户体验，如果当应用崩溃时我们让用户选择退出还是继续运行，那么用户会感觉我们的App跟别人的不一样，叼叼哒！</p>\n<h3 id=\"2-收集崩溃日志\"><a href=\"#2-收集崩溃日志\" class=\"headerlink\" title=\"2.    收集崩溃日志\"></a>2.    收集崩溃日志</h3><p>苹果提供了产生 Exception 的处理方法，我们可以在相应的方法中处理产生的异常，但是这个时间非常的短，之后应用就会退出，具体多长时间我们也不清楚，很被动。如果我们可以在应用崩溃时，有足够的时间收集并且上传到服务器，那么给我们的分析和解决BUG会带来相当大的便利。  </p>\n<p>下面直接上代码，非常简单：  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> runLoop = <span class=\"built_in\">CFRunLoopGetCurrent</span>();</div><div class=\"line\"><span class=\"built_in\">CFArrayRef</span> allModes = <span class=\"built_in\">CFRunLoopCopyAllModes</span>(runLoop);</div><div class=\"line\"><span class=\"keyword\">while</span> (!isQuit)&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *mode <span class=\"keyword\">in</span> (__bridge <span class=\"built_in\">NSArray</span> *)allModes) &#123;</div><div class=\"line\">        <span class=\"built_in\">CFRunLoopRunInMode</span>((<span class=\"built_in\">CFStringRef</span>)mode, <span class=\"number\">0.001</span>, <span class=\"literal\">false</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">CFRelease</span>(allModes);</div></pre></td></tr></table></figure>\n<p>把上面的代码添加到 Exception 的handle方法中，此时创建了一个 RunLoop ，让这个 RunLoop 在所有的 Mode 下面一直不停的跑，保证主线程不会退出，我们的应用也就存活下来了。</p>\n<p>参考：<br><a href=\"https://developer.apple.com/reference/corefoundation/cfrunloopref\" target=\"_blank\" rel=\"external\">https://developer.apple.com/reference/corefoundation/cfrunloopref</a><br><a href=\"http://iphil.cc/?p=279\" target=\"_blank\" rel=\"external\">http://iphil.cc/?p=279</a><br><a href=\"http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"external\">http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a><br><a href=\"http://www.itdadao.com/article/25145/\" target=\"_blank\" rel=\"external\">http://www.itdadao.com/article/25145/</a>  </p>"},{"title":"Weex从入门到超神（一）","date":"2017-05-26T06:23:11.000Z","_content":"\n![](http://oeat6c2zg.bkt.clouddn.com/Weex_logo.png)\n\n随着移动端发展进入白热化阶段，很多中小型公司越来越注重于APP的更新迭代速度。加上去年微信小程序的问世，前端同学似乎迎来了“第二春”，越来越多的 Native 开发者感受到了前所未有的压力，人家已经打到家门口了，难道就这样两眼旁观吗？  \n  \n两年前 Facebook 团队发布了一个全新的移动端和前端无缝衔接的框架 React Native，很明显是用 React 开发的，支持在 Native 上运行的这么一个玩意，这相对于苹果漫长的审核机制的确是一个福音。可是 React 的学习曲线比较陡，网上大部分教程的性质都是 **“React Native 从入门到放弃”**，RN虽好，但是对于大多数移动开发者来说学习成本过高。   \n<!-- more -->\n\n去年阿里巴巴开源了一个类似 RN 的框架 **[Weex](http://weex.apache.org/cn/)** ，虽然面世才一年多，已经收获了广泛的关注，今年 Weex 已经被纳入 Apache 基金会的孵化项目。\n![](http://oeat6c2zg.bkt.clouddn.com/Weex_Apache.png)\n\n##\t\t为什么选择 Weex  \n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n\n作为 Native 开发者，我们很清楚 Native 走到今天所面临的困境，相较于前端比较呆板不够灵活，任何改动都需要重新打包提交审核然后发布版本，这个周期最短也要1~2天的时间，一直有人在说要用 H5 替代 Native ,这不是危言耸听，移动端市场正在遭受着冲击。  \n\n大部分中小型的互联网公司都是小步快走的模式进行版本迭代，版本发布的灵活性就显得尤为重要，可能产品早上想的功能点晚上就要上线，Native 肯定是办不到的，H5 这个时候就显示出它的优势了；但是 H5 有一个致命的缺点就是性能太差，用户体验远达不到 Native 带来的那种丝滑流畅般的享受。所以这两年，RN 和 Weex 悄然崛起就是为了解决这种矛盾。\n\n不管是 RN 还是 Weex 都能做到实时修改页面不需要 Native 发版，他们的原理都是一样的，通过 js 来渲染 Native 界面。  \nWeex 在很大程度上借鉴了 RN 的思想和方式，对比一下 RN 和 Weex 的差异和优缺点：  \n\n###\t优点\n-  由于 Weex 采用了 Vue 作为上层框架，相较于 React 更加轻量，Vue 的官网宣传就是非常轻量，体积小巧，语法简单。\n-  Vue 的学习成本相较于 React 更加小，大部分 Native 开发者更容易上手。\n-  Weex 吸收了 RN 的精华，可以说 Weex 是站在巨人的肩膀上问世。\n\n\n###\t缺点\n\n-\tWeex 相较于 RN 起步比较晚，社区没有 RN 活跃。\n- \t从问世的时间上来看，RN 具有更大的优势，Weex 的学习资料比较少。\n- \tWeex 现在存在的 BUG 相较于 RN 还比较多，对于使用来说会有一些影响。\n\n不管选择 RN 还是 Weex ，我们的目的都是一样：通过 js 语法渲染成  Native 的页面，至于该选择哪个，这就要结合自己公司的实际情况来选，没有绝对的好与坏。  \n由于我们公司的 H5 项目是用 Vue 开发的，所以我们也就毫不犹豫的选择了 Weex。  \n\n![](http://oeat6c2zg.bkt.clouddn.com/weex&vue.png)  \n\n可能大部分 Native 开发者看到这里就要说一句：*球都麻袋！Weex 都还搞明白怎么又提到 Vue ，这是什么鬼*；Vue 是国人开发的一个 JS 框架，大家可以去官网看看，文档都是中文比较方便，这里就不再赘述，有一点 H5 基础都可以很快上手。**[Vue官网](https://cn.vuejs.org)**\n\n##\t\tWeex 项目结构  \n想必大多数 Native 开发者对于前端的知识还是匮乏的，虽然 Weex 官网有教程会教你怎么安装怎么运行，大部分同学任然会卡在某一个步骤走不下去，所以基础工作还是要做好，后面的路才会顺畅。  \n  \n首先给大家介绍 Node.js 和 npm ，刚开始接触这个我也是懵逼的，这两者之间有什么关系？为什么要安装 Node.js ？ 搞懂这个关系后面对 weex 中结构理解会有很好的帮助，npm 是 Node.js 默认的包管理器，从 Node.js 0.6.3 开始，npm 集成到了 Node.js 的安装包里面，所以我们安装 Node.js 的目的是使用 npm 来管理 weex 所用到的一些依赖库。\n\n至于怎么安装，可以参考 Weex 的[官方教程](http://weex.apache.org/cn/guide/)\n\n>  前端同学用到的 npm 有点类似我们用的 Cocopods 来管理第三方依赖库，安装 Cocopods 之前你必须安装 ruby ，因为 Cocopods 依赖 ruby 才能运行， npm 也是一样的道理，npm 依赖 Node.js 才能运行。\n\nWeex 的文件格式有两种，分别是 `.we` 、`.vue`，可以很明显的发现用 Vue 可以直接写 Weex 页面。笔者开始接触 Weex 的时候也是直接学 Vue ,不仅可以用来写 Weex 还可以写写其他 H5 页面。 **所以我建议学 Weex 直接看 Vue 就可以了。**\n\n###\tWeex 的目录结构\n\n ```JavaScript\n\n├── src  \n├── node_modules \n├── dist\n├── build\n├── bin\n├── package.json\n├── webpack.config.js    \n└── config.js   \n        \n ```\n\n**src**  \n> 源码存放的位置，如`.we` `.vue`  \n\n**node_modules** \n> 依赖库的存放位置，类似于Xcode项目中的 Pods 文件夹。在 package.json 所在目录执行 npm install 就会自动安装好所有的依赖，有点像 pod install。\n  \n**dist**  \n> 存放编译好的js文件 \n \n**build**\n> 存放npm build 时的 js 文件，可在 package.json 文件中配置\n\n**bin**  \n> 存放一些 shell 脚本，一般用不到\n\n**package.json**  \n> 项目的配置和依赖库文件，有点类似 podfile 文件\n\n**webpack.config.js**\n> webpack 的配置文件\n\n**config.js**  \n> 项目的相关配置文件，你可以在这个文件中配置切换不同的环境\n\n提到 webpack ，这个比较复杂，我们只需要知道 Weex 用 webpack 进行打包编译就行了，当然也可以用其他工具来打包；感兴趣的同学可以看一下 webpack 的[官网](http://webpack.github.io)。  \n当你运行 `npm bulid` 时，对应的是运行 package.json 中配置的 `scripts: build` 命令，src 文件夹中的文件都会被编译好并存放到 dist 文件夹中，这个路径在 webpack.config.js 文件中可以进行配置。`npm run` 后面跟的命令都是在 package.json 的 `scripts` 配置的。  \n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)   \n\nWeex 前端的项目目录大概就是这样，Weex 前端的源码不在这次的讨论范围之类，如果大家感兴趣想看 Weex 前端的源码，在 node_modules 文件夹中就可以找到。**关于 Weex SDK源码在后续文章中会进行深度解析。**\n##\t\tWeex 运行原理 \n官方也给出了 Weex 的运行原理图，顺手牵羊拿了过来：\n\n![](http://oeat6c2zg.bkt.clouddn.com/Weex_theroy.png)  \n\n不难发现，Weex 其实就是将 `.vue` 、`.we` 文件编译成 js 文件，打包成所谓的 JS Bundle 放到 dist 文件夹中，然后将编译好的 JS Bundle 部署到服务器上，我们的 iOS、安卓、浏览器就可以访问对应的 JS 然后由 SDK 渲染成 Native 的页面，或者浏览器的内核渲染成 DOM 节点显示。**这里有个坑要提一下：虽然说是三端统一的，实际开发中还是要做兼容处理的。**  \n\n> 本篇文章浅显的介绍了 Weex 的应用背景和工作原理，下篇文章将深入分析 Weex 的实现原理。 \n","source":"_posts/Weex从入门到超神（一）.md","raw":"---\ntitle: Weex从入门到超神（一）\ndate: 2017-05-26 14:23:11\ncategories:  \n- 技术笔记  \ntags:  \n- Weex  \n- Vue  \n- JS\n- 前端  \npermalink: weex-1  \n\n---\n\n![](http://oeat6c2zg.bkt.clouddn.com/Weex_logo.png)\n\n随着移动端发展进入白热化阶段，很多中小型公司越来越注重于APP的更新迭代速度。加上去年微信小程序的问世，前端同学似乎迎来了“第二春”，越来越多的 Native 开发者感受到了前所未有的压力，人家已经打到家门口了，难道就这样两眼旁观吗？  \n  \n两年前 Facebook 团队发布了一个全新的移动端和前端无缝衔接的框架 React Native，很明显是用 React 开发的，支持在 Native 上运行的这么一个玩意，这相对于苹果漫长的审核机制的确是一个福音。可是 React 的学习曲线比较陡，网上大部分教程的性质都是 **“React Native 从入门到放弃”**，RN虽好，但是对于大多数移动开发者来说学习成本过高。   \n<!-- more -->\n\n去年阿里巴巴开源了一个类似 RN 的框架 **[Weex](http://weex.apache.org/cn/)** ，虽然面世才一年多，已经收获了广泛的关注，今年 Weex 已经被纳入 Apache 基金会的孵化项目。\n![](http://oeat6c2zg.bkt.clouddn.com/Weex_Apache.png)\n\n##\t\t为什么选择 Weex  \n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n\n作为 Native 开发者，我们很清楚 Native 走到今天所面临的困境，相较于前端比较呆板不够灵活，任何改动都需要重新打包提交审核然后发布版本，这个周期最短也要1~2天的时间，一直有人在说要用 H5 替代 Native ,这不是危言耸听，移动端市场正在遭受着冲击。  \n\n大部分中小型的互联网公司都是小步快走的模式进行版本迭代，版本发布的灵活性就显得尤为重要，可能产品早上想的功能点晚上就要上线，Native 肯定是办不到的，H5 这个时候就显示出它的优势了；但是 H5 有一个致命的缺点就是性能太差，用户体验远达不到 Native 带来的那种丝滑流畅般的享受。所以这两年，RN 和 Weex 悄然崛起就是为了解决这种矛盾。\n\n不管是 RN 还是 Weex 都能做到实时修改页面不需要 Native 发版，他们的原理都是一样的，通过 js 来渲染 Native 界面。  \nWeex 在很大程度上借鉴了 RN 的思想和方式，对比一下 RN 和 Weex 的差异和优缺点：  \n\n###\t优点\n-  由于 Weex 采用了 Vue 作为上层框架，相较于 React 更加轻量，Vue 的官网宣传就是非常轻量，体积小巧，语法简单。\n-  Vue 的学习成本相较于 React 更加小，大部分 Native 开发者更容易上手。\n-  Weex 吸收了 RN 的精华，可以说 Weex 是站在巨人的肩膀上问世。\n\n\n###\t缺点\n\n-\tWeex 相较于 RN 起步比较晚，社区没有 RN 活跃。\n- \t从问世的时间上来看，RN 具有更大的优势，Weex 的学习资料比较少。\n- \tWeex 现在存在的 BUG 相较于 RN 还比较多，对于使用来说会有一些影响。\n\n不管选择 RN 还是 Weex ，我们的目的都是一样：通过 js 语法渲染成  Native 的页面，至于该选择哪个，这就要结合自己公司的实际情况来选，没有绝对的好与坏。  \n由于我们公司的 H5 项目是用 Vue 开发的，所以我们也就毫不犹豫的选择了 Weex。  \n\n![](http://oeat6c2zg.bkt.clouddn.com/weex&vue.png)  \n\n可能大部分 Native 开发者看到这里就要说一句：*球都麻袋！Weex 都还搞明白怎么又提到 Vue ，这是什么鬼*；Vue 是国人开发的一个 JS 框架，大家可以去官网看看，文档都是中文比较方便，这里就不再赘述，有一点 H5 基础都可以很快上手。**[Vue官网](https://cn.vuejs.org)**\n\n##\t\tWeex 项目结构  \n想必大多数 Native 开发者对于前端的知识还是匮乏的，虽然 Weex 官网有教程会教你怎么安装怎么运行，大部分同学任然会卡在某一个步骤走不下去，所以基础工作还是要做好，后面的路才会顺畅。  \n  \n首先给大家介绍 Node.js 和 npm ，刚开始接触这个我也是懵逼的，这两者之间有什么关系？为什么要安装 Node.js ？ 搞懂这个关系后面对 weex 中结构理解会有很好的帮助，npm 是 Node.js 默认的包管理器，从 Node.js 0.6.3 开始，npm 集成到了 Node.js 的安装包里面，所以我们安装 Node.js 的目的是使用 npm 来管理 weex 所用到的一些依赖库。\n\n至于怎么安装，可以参考 Weex 的[官方教程](http://weex.apache.org/cn/guide/)\n\n>  前端同学用到的 npm 有点类似我们用的 Cocopods 来管理第三方依赖库，安装 Cocopods 之前你必须安装 ruby ，因为 Cocopods 依赖 ruby 才能运行， npm 也是一样的道理，npm 依赖 Node.js 才能运行。\n\nWeex 的文件格式有两种，分别是 `.we` 、`.vue`，可以很明显的发现用 Vue 可以直接写 Weex 页面。笔者开始接触 Weex 的时候也是直接学 Vue ,不仅可以用来写 Weex 还可以写写其他 H5 页面。 **所以我建议学 Weex 直接看 Vue 就可以了。**\n\n###\tWeex 的目录结构\n\n ```JavaScript\n\n├── src  \n├── node_modules \n├── dist\n├── build\n├── bin\n├── package.json\n├── webpack.config.js    \n└── config.js   \n        \n ```\n\n**src**  \n> 源码存放的位置，如`.we` `.vue`  \n\n**node_modules** \n> 依赖库的存放位置，类似于Xcode项目中的 Pods 文件夹。在 package.json 所在目录执行 npm install 就会自动安装好所有的依赖，有点像 pod install。\n  \n**dist**  \n> 存放编译好的js文件 \n \n**build**\n> 存放npm build 时的 js 文件，可在 package.json 文件中配置\n\n**bin**  \n> 存放一些 shell 脚本，一般用不到\n\n**package.json**  \n> 项目的配置和依赖库文件，有点类似 podfile 文件\n\n**webpack.config.js**\n> webpack 的配置文件\n\n**config.js**  \n> 项目的相关配置文件，你可以在这个文件中配置切换不同的环境\n\n提到 webpack ，这个比较复杂，我们只需要知道 Weex 用 webpack 进行打包编译就行了，当然也可以用其他工具来打包；感兴趣的同学可以看一下 webpack 的[官网](http://webpack.github.io)。  \n当你运行 `npm bulid` 时，对应的是运行 package.json 中配置的 `scripts: build` 命令，src 文件夹中的文件都会被编译好并存放到 dist 文件夹中，这个路径在 webpack.config.js 文件中可以进行配置。`npm run` 后面跟的命令都是在 package.json 的 `scripts` 配置的。  \n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)   \n\nWeex 前端的项目目录大概就是这样，Weex 前端的源码不在这次的讨论范围之类，如果大家感兴趣想看 Weex 前端的源码，在 node_modules 文件夹中就可以找到。**关于 Weex SDK源码在后续文章中会进行深度解析。**\n##\t\tWeex 运行原理 \n官方也给出了 Weex 的运行原理图，顺手牵羊拿了过来：\n\n![](http://oeat6c2zg.bkt.clouddn.com/Weex_theroy.png)  \n\n不难发现，Weex 其实就是将 `.vue` 、`.we` 文件编译成 js 文件，打包成所谓的 JS Bundle 放到 dist 文件夹中，然后将编译好的 JS Bundle 部署到服务器上，我们的 iOS、安卓、浏览器就可以访问对应的 JS 然后由 SDK 渲染成 Native 的页面，或者浏览器的内核渲染成 DOM 节点显示。**这里有个坑要提一下：虽然说是三端统一的，实际开发中还是要做兼容处理的。**  \n\n> 本篇文章浅显的介绍了 Weex 的应用背景和工作原理，下篇文章将深入分析 Weex 的实现原理。 \n","slug":"weex-1","published":1,"updated":"2017-11-06T11:50:06.628Z","_id":"cj9no6vm20005jaens0ytdj0c","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"http://oeat6c2zg.bkt.clouddn.com/Weex_logo.png\" alt=\"\"></p>\n<p>随着移动端发展进入白热化阶段，很多中小型公司越来越注重于APP的更新迭代速度。加上去年微信小程序的问世，前端同学似乎迎来了“第二春”，越来越多的 Native 开发者感受到了前所未有的压力，人家已经打到家门口了，难道就这样两眼旁观吗？  </p>\n<p>两年前 Facebook 团队发布了一个全新的移动端和前端无缝衔接的框架 React Native，很明显是用 React 开发的，支持在 Native 上运行的这么一个玩意，这相对于苹果漫长的审核机制的确是一个福音。可是 React 的学习曲线比较陡，网上大部分教程的性质都是 <strong>“React Native 从入门到放弃”</strong>，RN虽好，但是对于大多数移动开发者来说学习成本过高。<br><a id=\"more\"></a></p>\n<p>去年阿里巴巴开源了一个类似 RN 的框架 <strong><a href=\"http://weex.apache.org/cn/\" target=\"_blank\" rel=\"external\">Weex</a></strong> ，虽然面世才一年多，已经收获了广泛的关注，今年 Weex 已经被纳入 Apache 基金会的孵化项目。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/Weex_Apache.png\" alt=\"\"></p>\n<h2 id=\"为什么选择-Weex\"><a href=\"#为什么选择-Weex\" class=\"headerlink\" title=\"为什么选择 Weex\"></a>为什么选择 Weex</h2><p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<p>作为 Native 开发者，我们很清楚 Native 走到今天所面临的困境，相较于前端比较呆板不够灵活，任何改动都需要重新打包提交审核然后发布版本，这个周期最短也要1~2天的时间，一直有人在说要用 H5 替代 Native ,这不是危言耸听，移动端市场正在遭受着冲击。  </p>\n<p>大部分中小型的互联网公司都是小步快走的模式进行版本迭代，版本发布的灵活性就显得尤为重要，可能产品早上想的功能点晚上就要上线，Native 肯定是办不到的，H5 这个时候就显示出它的优势了；但是 H5 有一个致命的缺点就是性能太差，用户体验远达不到 Native 带来的那种丝滑流畅般的享受。所以这两年，RN 和 Weex 悄然崛起就是为了解决这种矛盾。</p>\n<p>不管是 RN 还是 Weex 都能做到实时修改页面不需要 Native 发版，他们的原理都是一样的，通过 js 来渲染 Native 界面。<br>Weex 在很大程度上借鉴了 RN 的思想和方式，对比一下 RN 和 Weex 的差异和优缺点：  </p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>由于 Weex 采用了 Vue 作为上层框架，相较于 React 更加轻量，Vue 的官网宣传就是非常轻量，体积小巧，语法简单。</li>\n<li>Vue 的学习成本相较于 React 更加小，大部分 Native 开发者更容易上手。</li>\n<li>Weex 吸收了 RN 的精华，可以说 Weex 是站在巨人的肩膀上问世。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>Weex 相较于 RN 起步比较晚，社区没有 RN 活跃。</li>\n<li>从问世的时间上来看，RN 具有更大的优势，Weex 的学习资料比较少。</li>\n<li>Weex 现在存在的 BUG 相较于 RN 还比较多，对于使用来说会有一些影响。</li>\n</ul>\n<p>不管选择 RN 还是 Weex ，我们的目的都是一样：通过 js 语法渲染成  Native 的页面，至于该选择哪个，这就要结合自己公司的实际情况来选，没有绝对的好与坏。<br>由于我们公司的 H5 项目是用 Vue 开发的，所以我们也就毫不犹豫的选择了 Weex。  </p>\n<p><img src=\"http://oeat6c2zg.bkt.clouddn.com/weex&amp;vue.png\" alt=\"\">  </p>\n<p>可能大部分 Native 开发者看到这里就要说一句：<em>球都麻袋！Weex 都还搞明白怎么又提到 Vue ，这是什么鬼</em>；Vue 是国人开发的一个 JS 框架，大家可以去官网看看，文档都是中文比较方便，这里就不再赘述，有一点 H5 基础都可以很快上手。<strong><a href=\"https://cn.vuejs.org\" target=\"_blank\" rel=\"external\">Vue官网</a></strong></p>\n<h2 id=\"Weex-项目结构\"><a href=\"#Weex-项目结构\" class=\"headerlink\" title=\"Weex 项目结构\"></a>Weex 项目结构</h2><p>想必大多数 Native 开发者对于前端的知识还是匮乏的，虽然 Weex 官网有教程会教你怎么安装怎么运行，大部分同学任然会卡在某一个步骤走不下去，所以基础工作还是要做好，后面的路才会顺畅。  </p>\n<p>首先给大家介绍 Node.js 和 npm ，刚开始接触这个我也是懵逼的，这两者之间有什么关系？为什么要安装 Node.js ？ 搞懂这个关系后面对 weex 中结构理解会有很好的帮助，npm 是 Node.js 默认的包管理器，从 Node.js 0.6.3 开始，npm 集成到了 Node.js 的安装包里面，所以我们安装 Node.js 的目的是使用 npm 来管理 weex 所用到的一些依赖库。</p>\n<p>至于怎么安装，可以参考 Weex 的<a href=\"http://weex.apache.org/cn/guide/\" target=\"_blank\" rel=\"external\">官方教程</a></p>\n<blockquote>\n<p> 前端同学用到的 npm 有点类似我们用的 Cocopods 来管理第三方依赖库，安装 Cocopods 之前你必须安装 ruby ，因为 Cocopods 依赖 ruby 才能运行， npm 也是一样的道理，npm 依赖 Node.js 才能运行。</p>\n</blockquote>\n<p>Weex 的文件格式有两种，分别是 <code>.we</code> 、<code>.vue</code>，可以很明显的发现用 Vue 可以直接写 Weex 页面。笔者开始接触 Weex 的时候也是直接学 Vue ,不仅可以用来写 Weex 还可以写写其他 H5 页面。 <strong>所以我建议学 Weex 直接看 Vue 就可以了。</strong></p>\n<h3 id=\"Weex-的目录结构\"><a href=\"#Weex-的目录结构\" class=\"headerlink\" title=\"Weex 的目录结构\"></a>Weex 的目录结构</h3> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">├── src  </div><div class=\"line\">├── node_modules </div><div class=\"line\">├── dist</div><div class=\"line\">├── build</div><div class=\"line\">├── bin</div><div class=\"line\">├── package.json</div><div class=\"line\">├── webpack.config.js    </div><div class=\"line\">└── config.js</div></pre></td></tr></table></figure>\n<p><strong>src</strong>  </p>\n<blockquote>\n<p>源码存放的位置，如<code>.we</code> <code>.vue</code>  </p>\n</blockquote>\n<p><strong>node_modules</strong> </p>\n<blockquote>\n<p>依赖库的存放位置，类似于Xcode项目中的 Pods 文件夹。在 package.json 所在目录执行 npm install 就会自动安装好所有的依赖，有点像 pod install。</p>\n</blockquote>\n<p><strong>dist</strong>  </p>\n<blockquote>\n<p>存放编译好的js文件 </p>\n</blockquote>\n<p><strong>build</strong></p>\n<blockquote>\n<p>存放npm build 时的 js 文件，可在 package.json 文件中配置</p>\n</blockquote>\n<p><strong>bin</strong>  </p>\n<blockquote>\n<p>存放一些 shell 脚本，一般用不到</p>\n</blockquote>\n<p><strong>package.json</strong>  </p>\n<blockquote>\n<p>项目的配置和依赖库文件，有点类似 podfile 文件</p>\n</blockquote>\n<p><strong>webpack.config.js</strong></p>\n<blockquote>\n<p>webpack 的配置文件</p>\n</blockquote>\n<p><strong>config.js</strong>  </p>\n<blockquote>\n<p>项目的相关配置文件，你可以在这个文件中配置切换不同的环境</p>\n</blockquote>\n<p>提到 webpack ，这个比较复杂，我们只需要知道 Weex 用 webpack 进行打包编译就行了，当然也可以用其他工具来打包；感兴趣的同学可以看一下 webpack 的<a href=\"http://webpack.github.io\" target=\"_blank\" rel=\"external\">官网</a>。<br>当你运行 <code>npm bulid</code> 时，对应的是运行 package.json 中配置的 <code>scripts: build</code> 命令，src 文件夹中的文件都会被编译好并存放到 dist 文件夹中，这个路径在 webpack.config.js 文件中可以进行配置。<code>npm run</code> 后面跟的命令都是在 package.json 的 <code>scripts</code> 配置的。  </p>\n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>   </p>\n<p>Weex 前端的项目目录大概就是这样，Weex 前端的源码不在这次的讨论范围之类，如果大家感兴趣想看 Weex 前端的源码，在 node_modules 文件夹中就可以找到。<strong>关于 Weex SDK源码在后续文章中会进行深度解析。</strong></p>\n<h2 id=\"Weex-运行原理\"><a href=\"#Weex-运行原理\" class=\"headerlink\" title=\"Weex 运行原理\"></a>Weex 运行原理</h2><p>官方也给出了 Weex 的运行原理图，顺手牵羊拿了过来：</p>\n<p><img src=\"http://oeat6c2zg.bkt.clouddn.com/Weex_theroy.png\" alt=\"\">  </p>\n<p>不难发现，Weex 其实就是将 <code>.vue</code> 、<code>.we</code> 文件编译成 js 文件，打包成所谓的 JS Bundle 放到 dist 文件夹中，然后将编译好的 JS Bundle 部署到服务器上，我们的 iOS、安卓、浏览器就可以访问对应的 JS 然后由 SDK 渲染成 Native 的页面，或者浏览器的内核渲染成 DOM 节点显示。<strong>这里有个坑要提一下：虽然说是三端统一的，实际开发中还是要做兼容处理的。</strong>  </p>\n<blockquote>\n<p>本篇文章浅显的介绍了 Weex 的应用背景和工作原理，下篇文章将深入分析 Weex 的实现原理。 </p>\n</blockquote>\n","excerpt":"<p><img src=\"http://oeat6c2zg.bkt.clouddn.com/Weex_logo.png\" alt=\"\"></p>\n<p>随着移动端发展进入白热化阶段，很多中小型公司越来越注重于APP的更新迭代速度。加上去年微信小程序的问世，前端同学似乎迎来了“第二春”，越来越多的 Native 开发者感受到了前所未有的压力，人家已经打到家门口了，难道就这样两眼旁观吗？  </p>\n<p>两年前 Facebook 团队发布了一个全新的移动端和前端无缝衔接的框架 React Native，很明显是用 React 开发的，支持在 Native 上运行的这么一个玩意，这相对于苹果漫长的审核机制的确是一个福音。可是 React 的学习曲线比较陡，网上大部分教程的性质都是 <strong>“React Native 从入门到放弃”</strong>，RN虽好，但是对于大多数移动开发者来说学习成本过高。<br>","more":"</p>\n<p>去年阿里巴巴开源了一个类似 RN 的框架 <strong><a href=\"http://weex.apache.org/cn/\">Weex</a></strong> ，虽然面世才一年多，已经收获了广泛的关注，今年 Weex 已经被纳入 Apache 基金会的孵化项目。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/Weex_Apache.png\" alt=\"\"></p>\n<h2 id=\"为什么选择-Weex\"><a href=\"#为什么选择-Weex\" class=\"headerlink\" title=\"为什么选择 Weex\"></a>为什么选择 Weex</h2><p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<p>作为 Native 开发者，我们很清楚 Native 走到今天所面临的困境，相较于前端比较呆板不够灵活，任何改动都需要重新打包提交审核然后发布版本，这个周期最短也要1~2天的时间，一直有人在说要用 H5 替代 Native ,这不是危言耸听，移动端市场正在遭受着冲击。  </p>\n<p>大部分中小型的互联网公司都是小步快走的模式进行版本迭代，版本发布的灵活性就显得尤为重要，可能产品早上想的功能点晚上就要上线，Native 肯定是办不到的，H5 这个时候就显示出它的优势了；但是 H5 有一个致命的缺点就是性能太差，用户体验远达不到 Native 带来的那种丝滑流畅般的享受。所以这两年，RN 和 Weex 悄然崛起就是为了解决这种矛盾。</p>\n<p>不管是 RN 还是 Weex 都能做到实时修改页面不需要 Native 发版，他们的原理都是一样的，通过 js 来渲染 Native 界面。<br>Weex 在很大程度上借鉴了 RN 的思想和方式，对比一下 RN 和 Weex 的差异和优缺点：  </p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>由于 Weex 采用了 Vue 作为上层框架，相较于 React 更加轻量，Vue 的官网宣传就是非常轻量，体积小巧，语法简单。</li>\n<li>Vue 的学习成本相较于 React 更加小，大部分 Native 开发者更容易上手。</li>\n<li>Weex 吸收了 RN 的精华，可以说 Weex 是站在巨人的肩膀上问世。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>Weex 相较于 RN 起步比较晚，社区没有 RN 活跃。</li>\n<li>从问世的时间上来看，RN 具有更大的优势，Weex 的学习资料比较少。</li>\n<li>Weex 现在存在的 BUG 相较于 RN 还比较多，对于使用来说会有一些影响。</li>\n</ul>\n<p>不管选择 RN 还是 Weex ，我们的目的都是一样：通过 js 语法渲染成  Native 的页面，至于该选择哪个，这就要结合自己公司的实际情况来选，没有绝对的好与坏。<br>由于我们公司的 H5 项目是用 Vue 开发的，所以我们也就毫不犹豫的选择了 Weex。  </p>\n<p><img src=\"http://oeat6c2zg.bkt.clouddn.com/weex&amp;vue.png\" alt=\"\">  </p>\n<p>可能大部分 Native 开发者看到这里就要说一句：<em>球都麻袋！Weex 都还搞明白怎么又提到 Vue ，这是什么鬼</em>；Vue 是国人开发的一个 JS 框架，大家可以去官网看看，文档都是中文比较方便，这里就不再赘述，有一点 H5 基础都可以很快上手。<strong><a href=\"https://cn.vuejs.org\">Vue官网</a></strong></p>\n<h2 id=\"Weex-项目结构\"><a href=\"#Weex-项目结构\" class=\"headerlink\" title=\"Weex 项目结构\"></a>Weex 项目结构</h2><p>想必大多数 Native 开发者对于前端的知识还是匮乏的，虽然 Weex 官网有教程会教你怎么安装怎么运行，大部分同学任然会卡在某一个步骤走不下去，所以基础工作还是要做好，后面的路才会顺畅。  </p>\n<p>首先给大家介绍 Node.js 和 npm ，刚开始接触这个我也是懵逼的，这两者之间有什么关系？为什么要安装 Node.js ？ 搞懂这个关系后面对 weex 中结构理解会有很好的帮助，npm 是 Node.js 默认的包管理器，从 Node.js 0.6.3 开始，npm 集成到了 Node.js 的安装包里面，所以我们安装 Node.js 的目的是使用 npm 来管理 weex 所用到的一些依赖库。</p>\n<p>至于怎么安装，可以参考 Weex 的<a href=\"http://weex.apache.org/cn/guide/\">官方教程</a></p>\n<blockquote>\n<p> 前端同学用到的 npm 有点类似我们用的 Cocopods 来管理第三方依赖库，安装 Cocopods 之前你必须安装 ruby ，因为 Cocopods 依赖 ruby 才能运行， npm 也是一样的道理，npm 依赖 Node.js 才能运行。</p>\n</blockquote>\n<p>Weex 的文件格式有两种，分别是 <code>.we</code> 、<code>.vue</code>，可以很明显的发现用 Vue 可以直接写 Weex 页面。笔者开始接触 Weex 的时候也是直接学 Vue ,不仅可以用来写 Weex 还可以写写其他 H5 页面。 <strong>所以我建议学 Weex 直接看 Vue 就可以了。</strong></p>\n<h3 id=\"Weex-的目录结构\"><a href=\"#Weex-的目录结构\" class=\"headerlink\" title=\"Weex 的目录结构\"></a>Weex 的目录结构</h3> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">├── src  </div><div class=\"line\">├── node_modules </div><div class=\"line\">├── dist</div><div class=\"line\">├── build</div><div class=\"line\">├── bin</div><div class=\"line\">├── package.json</div><div class=\"line\">├── webpack.config.js    </div><div class=\"line\">└── config.js</div></pre></td></tr></table></figure>\n<p><strong>src</strong>  </p>\n<blockquote>\n<p>源码存放的位置，如<code>.we</code> <code>.vue</code>  </p>\n</blockquote>\n<p><strong>node_modules</strong> </p>\n<blockquote>\n<p>依赖库的存放位置，类似于Xcode项目中的 Pods 文件夹。在 package.json 所在目录执行 npm install 就会自动安装好所有的依赖，有点像 pod install。</p>\n</blockquote>\n<p><strong>dist</strong>  </p>\n<blockquote>\n<p>存放编译好的js文件 </p>\n</blockquote>\n<p><strong>build</strong></p>\n<blockquote>\n<p>存放npm build 时的 js 文件，可在 package.json 文件中配置</p>\n</blockquote>\n<p><strong>bin</strong>  </p>\n<blockquote>\n<p>存放一些 shell 脚本，一般用不到</p>\n</blockquote>\n<p><strong>package.json</strong>  </p>\n<blockquote>\n<p>项目的配置和依赖库文件，有点类似 podfile 文件</p>\n</blockquote>\n<p><strong>webpack.config.js</strong></p>\n<blockquote>\n<p>webpack 的配置文件</p>\n</blockquote>\n<p><strong>config.js</strong>  </p>\n<blockquote>\n<p>项目的相关配置文件，你可以在这个文件中配置切换不同的环境</p>\n</blockquote>\n<p>提到 webpack ，这个比较复杂，我们只需要知道 Weex 用 webpack 进行打包编译就行了，当然也可以用其他工具来打包；感兴趣的同学可以看一下 webpack 的<a href=\"http://webpack.github.io\">官网</a>。<br>当你运行 <code>npm bulid</code> 时，对应的是运行 package.json 中配置的 <code>scripts: build</code> 命令，src 文件夹中的文件都会被编译好并存放到 dist 文件夹中，这个路径在 webpack.config.js 文件中可以进行配置。<code>npm run</code> 后面跟的命令都是在 package.json 的 <code>scripts</code> 配置的。  </p>\n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>   </p>\n<p>Weex 前端的项目目录大概就是这样，Weex 前端的源码不在这次的讨论范围之类，如果大家感兴趣想看 Weex 前端的源码，在 node_modules 文件夹中就可以找到。<strong>关于 Weex SDK源码在后续文章中会进行深度解析。</strong></p>\n<h2 id=\"Weex-运行原理\"><a href=\"#Weex-运行原理\" class=\"headerlink\" title=\"Weex 运行原理\"></a>Weex 运行原理</h2><p>官方也给出了 Weex 的运行原理图，顺手牵羊拿了过来：</p>\n<p><img src=\"http://oeat6c2zg.bkt.clouddn.com/Weex_theroy.png\" alt=\"\">  </p>\n<p>不难发现，Weex 其实就是将 <code>.vue</code> 、<code>.we</code> 文件编译成 js 文件，打包成所谓的 JS Bundle 放到 dist 文件夹中，然后将编译好的 JS Bundle 部署到服务器上，我们的 iOS、安卓、浏览器就可以访问对应的 JS 然后由 SDK 渲染成 Native 的页面，或者浏览器的内核渲染成 DOM 节点显示。<strong>这里有个坑要提一下：虽然说是三端统一的，实际开发中还是要做兼容处理的。</strong>  </p>\n<blockquote>\n<p>本篇文章浅显的介绍了 Weex 的应用背景和工作原理，下篇文章将深入分析 Weex 的实现原理。 </p>\n</blockquote>"},{"title":"Xcode编译报错Undefined symbols解决方案","date":"2016-03-15T16:00:00.000Z","_content":"####  当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：\n\n```\n`Undefined symbols for architecture x86_64:\n  \"_OBJC_CLASS_$_AFHTTPRequestOperation\", referenced from:\n      objc-class-ref in ZRAPIClient.o\n  \"_OBJC_CLASS_$_AFHTTPRequestSerializer\", referenced from:\n      objc-class-ref in ZRAPIClient.o\n  \"_OBJC_CLASS_$_AFJSONResponseSerializer\", referenced from:\n      objc-class-ref in ZRAPIClient.o\n  \"_OBJC_CLASS_$_BITHockeyManager\", referenced from:\n      objc-class-ref in ZRAppDelegate.o`\n```\n\n<!-- more -->\n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)\n网上各种说法都有，不过每个人遇到的情况可能不一样，个人总结了3个方案供参考：\n#####  所连接的静态库不支持 x86_64，解决方案：\n\n1. 打开Pods的`Build Setting` ，添加`X86_64`architecture\n2. 设置`Build Active Architectures Only`为`NO`\n3. Clean Pods\n4. Build 项目  \n\n\n#####  OtherLink Flags问题，解决方案：\n\n打开项目的`TARGETS` > `Build Settings` >`OTHER_LDFLAGS `\n添加` $(inherited)`\n\n##### 编译文件出错，解决方案：\n1. 找到\n`/Users/***YourName***/Library/Developer/Xcode/DerivedData/***YourProject***/Build/Products/Debug-iphoneos`\n2. 这里可以使用terminal命令行打开，打开终端输入 `open \"上面的路径\"`可以直接打开目录\n3. 删除当前报错项目的编译文件，回到项目里面重新Build就不会报错了\n","source":"_posts/Xcode编译报错Undefined symbols解决方案.md","raw":"title: Xcode编译报错Undefined symbols解决方案\ndate: 2016-03-16\ncategories:\n- 跳坑指南\ntags:\n- Xcode\n- Cocopods\npermalink: Xcode编译报错Undefined symbols解决方案\n\n---\n####  当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：\n\n```\n`Undefined symbols for architecture x86_64:\n  \"_OBJC_CLASS_$_AFHTTPRequestOperation\", referenced from:\n      objc-class-ref in ZRAPIClient.o\n  \"_OBJC_CLASS_$_AFHTTPRequestSerializer\", referenced from:\n      objc-class-ref in ZRAPIClient.o\n  \"_OBJC_CLASS_$_AFJSONResponseSerializer\", referenced from:\n      objc-class-ref in ZRAPIClient.o\n  \"_OBJC_CLASS_$_BITHockeyManager\", referenced from:\n      objc-class-ref in ZRAppDelegate.o`\n```\n\n<!-- more -->\n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)\n网上各种说法都有，不过每个人遇到的情况可能不一样，个人总结了3个方案供参考：\n#####  所连接的静态库不支持 x86_64，解决方案：\n\n1. 打开Pods的`Build Setting` ，添加`X86_64`architecture\n2. 设置`Build Active Architectures Only`为`NO`\n3. Clean Pods\n4. Build 项目  \n\n\n#####  OtherLink Flags问题，解决方案：\n\n打开项目的`TARGETS` > `Build Settings` >`OTHER_LDFLAGS `\n添加` $(inherited)`\n\n##### 编译文件出错，解决方案：\n1. 找到\n`/Users/***YourName***/Library/Developer/Xcode/DerivedData/***YourProject***/Build/Products/Debug-iphoneos`\n2. 这里可以使用terminal命令行打开，打开终端输入 `open \"上面的路径\"`可以直接打开目录\n3. 删除当前报错项目的编译文件，回到项目里面重新Build就不会报错了\n","slug":"Xcode编译报错Undefined symbols解决方案","published":1,"updated":"2017-11-02T13:09:57.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9no6vm50006jaengg25tbbj","content":"<h4 id=\"当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：\"><a href=\"#当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：\" class=\"headerlink\" title=\"当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：\"></a>当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">`Undefined symbols for architecture x86_64:</div><div class=\"line\">  &quot;_OBJC_CLASS_$_AFHTTPRequestOperation&quot;, referenced from:</div><div class=\"line\">      objc-class-ref in ZRAPIClient.o</div><div class=\"line\">  &quot;_OBJC_CLASS_$_AFHTTPRequestSerializer&quot;, referenced from:</div><div class=\"line\">      objc-class-ref in ZRAPIClient.o</div><div class=\"line\">  &quot;_OBJC_CLASS_$_AFJSONResponseSerializer&quot;, referenced from:</div><div class=\"line\">      objc-class-ref in ZRAPIClient.o</div><div class=\"line\">  &quot;_OBJC_CLASS_$_BITHockeyManager&quot;, referenced from:</div><div class=\"line\">      objc-class-ref in ZRAppDelegate.o`</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a><br>网上各种说法都有，不过每个人遇到的情况可能不一样，个人总结了3个方案供参考：</p>\n<h5 id=\"所连接的静态库不支持-x86-64，解决方案：\"><a href=\"#所连接的静态库不支持-x86-64，解决方案：\" class=\"headerlink\" title=\"所连接的静态库不支持 x86_64，解决方案：\"></a>所连接的静态库不支持 x86_64，解决方案：</h5><ol>\n<li>打开Pods的<code>Build Setting</code> ，添加<code>X86_64</code>architecture</li>\n<li>设置<code>Build Active Architectures Only</code>为<code>NO</code></li>\n<li>Clean Pods</li>\n<li>Build 项目  </li>\n</ol>\n<h5 id=\"OtherLink-Flags问题，解决方案：\"><a href=\"#OtherLink-Flags问题，解决方案：\" class=\"headerlink\" title=\"OtherLink Flags问题，解决方案：\"></a>OtherLink Flags问题，解决方案：</h5><p>打开项目的<code>TARGETS</code> &gt; <code>Build Settings</code> &gt;<code>OTHER_LDFLAGS</code><br>添加<code>$(inherited)</code></p>\n<h5 id=\"编译文件出错，解决方案：\"><a href=\"#编译文件出错，解决方案：\" class=\"headerlink\" title=\"编译文件出错，解决方案：\"></a>编译文件出错，解决方案：</h5><ol>\n<li>找到<br><code>/Users/***YourName***/Library/Developer/Xcode/DerivedData/***YourProject***/Build/Products/Debug-iphoneos</code></li>\n<li>这里可以使用terminal命令行打开，打开终端输入 <code>open &quot;上面的路径&quot;</code>可以直接打开目录</li>\n<li>删除当前报错项目的编译文件，回到项目里面重新Build就不会报错了</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：\"><a href=\"#当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：\" class=\"headerlink\" title=\"当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：\"></a>当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">`Undefined symbols for architecture x86_64:</div><div class=\"line\">  &quot;_OBJC_CLASS_$_AFHTTPRequestOperation&quot;, referenced from:</div><div class=\"line\">      objc-class-ref in ZRAPIClient.o</div><div class=\"line\">  &quot;_OBJC_CLASS_$_AFHTTPRequestSerializer&quot;, referenced from:</div><div class=\"line\">      objc-class-ref in ZRAPIClient.o</div><div class=\"line\">  &quot;_OBJC_CLASS_$_AFJSONResponseSerializer&quot;, referenced from:</div><div class=\"line\">      objc-class-ref in ZRAPIClient.o</div><div class=\"line\">  &quot;_OBJC_CLASS_$_BITHockeyManager&quot;, referenced from:</div><div class=\"line\">      objc-class-ref in ZRAppDelegate.o`</div></pre></td></tr></table></figure>","more":"<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a><br>网上各种说法都有，不过每个人遇到的情况可能不一样，个人总结了3个方案供参考：</p>\n<h5 id=\"所连接的静态库不支持-x86-64，解决方案：\"><a href=\"#所连接的静态库不支持-x86-64，解决方案：\" class=\"headerlink\" title=\"所连接的静态库不支持 x86_64，解决方案：\"></a>所连接的静态库不支持 x86_64，解决方案：</h5><ol>\n<li>打开Pods的<code>Build Setting</code> ，添加<code>X86_64</code>architecture</li>\n<li>设置<code>Build Active Architectures Only</code>为<code>NO</code></li>\n<li>Clean Pods</li>\n<li>Build 项目  </li>\n</ol>\n<h5 id=\"OtherLink-Flags问题，解决方案：\"><a href=\"#OtherLink-Flags问题，解决方案：\" class=\"headerlink\" title=\"OtherLink Flags问题，解决方案：\"></a>OtherLink Flags问题，解决方案：</h5><p>打开项目的<code>TARGETS</code> &gt; <code>Build Settings</code> &gt;<code>OTHER_LDFLAGS</code><br>添加<code>$(inherited)</code></p>\n<h5 id=\"编译文件出错，解决方案：\"><a href=\"#编译文件出错，解决方案：\" class=\"headerlink\" title=\"编译文件出错，解决方案：\"></a>编译文件出错，解决方案：</h5><ol>\n<li>找到<br><code>/Users/***YourName***/Library/Developer/Xcode/DerivedData/***YourProject***/Build/Products/Debug-iphoneos</code></li>\n<li>这里可以使用terminal命令行打开，打开终端输入 <code>open &quot;上面的路径&quot;</code>可以直接打开目录</li>\n<li>删除当前报错项目的编译文件，回到项目里面重新Build就不会报错了</li>\n</ol>"},{"title":"dumpdecrypted给App砸壳","date":"2016-08-08T16:00:00.000Z","_content":"#### 1.前言\n> 我们都知道从AppStore下载的应用二进制文件被苹果进行了加密处理，也就是我们俗称的*壳*，我们要想对目标App进行逆向分析，必须解密目标二进制文件，俗称*砸壳*。  \n> long long ago有一种傻瓜式的砸壳方式，利用iPhoneCake源的AppCrackr进行一键砸壳，这种方式简单粗暴，省时省力，但正是因为它过于方便，导致几乎所有用户都可轻松上手，随便亵玩，所以不少用户都拿它来破解程序，这也导致了iOS越狱开发社区普遍认为这个软件助长了盗版的气焰，对iPhoneCake源进行了强烈谴责。迫于压力，iPhoneCake将AppCrackr下架。从此利用纯UI方式砸壳的行为已经走入绝路，只能利用更加geek更加niubility的方式来砸壳，这也是这篇文章介绍的主角**dumpdecrypted**  \n\n<!-- more --> \n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n#### 2.准备工作\n1. 一部已经越狱的手机 `我这里用的是iPhone 5S; iOS 9.1`\n2. 已经安装了OpenSSH\n3. 已经安装了[Cycript](http://www.cycript.org)\n4. [dumpdecrypted源码](https://github.com/stefanesser/dumpdecrypted/archive/master.zip)  \n\n#### 3.编译dumpdecrypted\n下载好之后将文件放到你自己的文件夹中，下面开始编译：  \n \n```  \nLeonLei-MBP:~ gaoshilei$ cd /Users/gaoshilei/Desktop/reverse/dumpdecrypted  \nLeonLei-MBP:dumpdecrypted gaoshilei$ make\n`xcrun --sdk iphoneos --find gcc` -Os  -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -dynamiclib -o dumpdecrypted.dylib dumpdecrypted.o\n```\n进入dumpdecrypted目录下之后，执行make命令，此时目录下会生成一个`dumpdecrypted.dylib`，这个文件生成一次即可，下次砸壳可以直接使用。\n\n#### 4.开始砸壳  \n##### 定位目标App可执行文件的位置  \n\n```  \nLeonLei-MBP:~ gaoshilei$ ssh root@192.168.0.115\niPhone-5S:~ root# ps -e\n  PID TTY           TIME CMD\n    1 ??         5:23.51 /sbin/launchd\n   23 ??         0:00.81 /usr/libexec/amfid\n   34 ??         1:28.92 /usr/sbin/mediaserverd\n   36 ??         4:23.49 /usr/libexec/fseventsd\n   38 ??         1:21.05 /System/Library/PrivateFrameworks/AssistantServices.framework/assistantd\n   40 ??         0:01.13 /System/Library/PrivateFrameworks/FileProvider.framework/Support/fileproviderd\n   42 ??         1:56.46 /usr/libexec/routined\n   46 ??         0:03.34 /System/Library/PrivateFrameworks/MediaRemote.framework/Support/mediaremoted\n   48 ??         0:00.86 /usr/libexec/misd\n   50 ??         0:18.48 /System/Library/Frameworks/HealthKit.framework/healthd\n   52 ??        19:18.39 /usr/libexec/configd\n   54 ??         3:30.26 /System/Library/CoreServices/powerd.bundle/powerd\n   58 ??         0:50.73 /usr/libexec/atc\n   60 ??        13:47.50 /usr/sbin/wifid\n   ···              ···\n 5673 ??         0:04.41 /var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat\n 5732 ??         0:00.32 /usr/libexec/ptpd -t usb\n 5735 ??         0:00.07 /usr/libexec/webinspectord\n 5741 ??         0:00.18 sshd: root@ttys000 \n 5770 ??         0:00.16 /System/Library/PrivateFrameworks/SyncedDefaults.framework/Support/syncdefaultsd\n 5785 ??         0:00.05 /System/Library/CoreServices/CFNetworkAgent\n```\n可以看到目前手机运行的进程中有微信的影子`/var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat` 我们已经找到微信可执行文件的位置\n##### 目标锁定，定位到目标App的Documents位置  \n \n```  \niPhone-5S:~ root# cycript -p WeChat  \ncy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]\n#file:///var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents/  \n```\n\n执行到这里我们已经找到了微信的Documents位置，正式开始砸壳！\n> 这里有两种方式，一种是scp命令行拷贝  \n> 另一种是iFunBox工具操作  \n\n我这里采用的是第一种scp命令行  \n \n```      \nLeonLei-MBP:~ gaoshilei$ scp /Users/gaoshilei/Desktop/reverse/dumpdecrypted/dumpdecrypted.dylib   root@192.168.0.115:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents  \ndumpdecrypted.dylib                                                              100%  193KB 192.9KB/s   00:00   \n```  \n\n我们已经将dumpdecrypted.dylib拷贝到了微信沙盒的Document目录中，可以砸壳了：  \n\n```  \niPhone-5S:~ root# cd /var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents/\niPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat\nmach-o decryption dumper\nDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.\n[+] detected 64bit ARM binary in memory.\n[+] offset to cryptid found: @0x100024ca8(from 0x100024000) = ca8\n[+] Found encrypted data at address 00004000 of length 45678592 bytes - type 1.\n[+] Opening /private/var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat for reading.\n[+] Reading header\n[+] Detecting header type\n[+] Executable is a plain MACH-O image\n[+] Opening WeChat.decrypted for writing.\n[+] Copying the not encrypted start of the file\n[+] Dumping the decrypted data into the file\n[+] Copying the not encrypted remainder of the file\n[+] Setting the LC_ENCRYPTION_INFO->cryptid to 0 at offset ca8\n[+] Closing original file\n[+] Closing dump file\niPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root#  \n```  \n\n等待命令执行完，此时已经完成砸壳，我们看一下当前目录都有啥：  \n  \n```  \niPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root# ls -o\ntotal 55272\ndrwxr-xr-x  6 mobile      272 Aug 26 13:48 00000000000000000000000000000000\ndrwxr-xr-x 20 mobile     1122 Oct 10 15:28 6f696a1b596ce2499419d844f90418aa\ndrwxr-xr-x  3 mobile      136 Oct  9 10:56 CrashReport\n-rw-r--r--  1 mobile      310 Aug 26 13:49 Ksid\n-rw-r--r--  1 mobile     1036 Oct 10 13:40 LocalInfo.lst\ndrwxr-xr-x  5 mobile      272 Aug 26 13:49 MMResourceMgr\ndrwxr-xr-x  2 mobile      748 Aug 26 13:51 MMappedKV\n-rw-r--r--  1 mobile       15 Oct 10 13:40 SafeMode.dat\n-rw-r--r--  1 root   56380816 Oct 10 15:37 WeChat.decrypted\n-rwxr-xr-x  1 root     197528 Oct 10 15:34 dumpdecrypted.dylib\n-rw-r--r--  1 mobile      448 Aug 26 13:49 mmupdateinfo.archive\n```  \n砸好壳的微信可执行文件`WeChat.decrypted`已经生成，现在就可以把文件拷到Mac上利用IDA或者Hopper的分析了。\n\n\n","source":"_posts/dumpdecrypted给App砸壳.md","raw":"---\ntitle: dumpdecrypted给App砸壳\ndate: 2016-08-09\ncategories:\n- iOS逆向\ntags:\n- dumpdecrypted\n- 砸壳\npermalink: dumpdecrypted给App砸壳\n---\n#### 1.前言\n> 我们都知道从AppStore下载的应用二进制文件被苹果进行了加密处理，也就是我们俗称的*壳*，我们要想对目标App进行逆向分析，必须解密目标二进制文件，俗称*砸壳*。  \n> long long ago有一种傻瓜式的砸壳方式，利用iPhoneCake源的AppCrackr进行一键砸壳，这种方式简单粗暴，省时省力，但正是因为它过于方便，导致几乎所有用户都可轻松上手，随便亵玩，所以不少用户都拿它来破解程序，这也导致了iOS越狱开发社区普遍认为这个软件助长了盗版的气焰，对iPhoneCake源进行了强烈谴责。迫于压力，iPhoneCake将AppCrackr下架。从此利用纯UI方式砸壳的行为已经走入绝路，只能利用更加geek更加niubility的方式来砸壳，这也是这篇文章介绍的主角**dumpdecrypted**  \n\n<!-- more --> \n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n#### 2.准备工作\n1. 一部已经越狱的手机 `我这里用的是iPhone 5S; iOS 9.1`\n2. 已经安装了OpenSSH\n3. 已经安装了[Cycript](http://www.cycript.org)\n4. [dumpdecrypted源码](https://github.com/stefanesser/dumpdecrypted/archive/master.zip)  \n\n#### 3.编译dumpdecrypted\n下载好之后将文件放到你自己的文件夹中，下面开始编译：  \n \n```  \nLeonLei-MBP:~ gaoshilei$ cd /Users/gaoshilei/Desktop/reverse/dumpdecrypted  \nLeonLei-MBP:dumpdecrypted gaoshilei$ make\n`xcrun --sdk iphoneos --find gcc` -Os  -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -dynamiclib -o dumpdecrypted.dylib dumpdecrypted.o\n```\n进入dumpdecrypted目录下之后，执行make命令，此时目录下会生成一个`dumpdecrypted.dylib`，这个文件生成一次即可，下次砸壳可以直接使用。\n\n#### 4.开始砸壳  \n##### 定位目标App可执行文件的位置  \n\n```  \nLeonLei-MBP:~ gaoshilei$ ssh root@192.168.0.115\niPhone-5S:~ root# ps -e\n  PID TTY           TIME CMD\n    1 ??         5:23.51 /sbin/launchd\n   23 ??         0:00.81 /usr/libexec/amfid\n   34 ??         1:28.92 /usr/sbin/mediaserverd\n   36 ??         4:23.49 /usr/libexec/fseventsd\n   38 ??         1:21.05 /System/Library/PrivateFrameworks/AssistantServices.framework/assistantd\n   40 ??         0:01.13 /System/Library/PrivateFrameworks/FileProvider.framework/Support/fileproviderd\n   42 ??         1:56.46 /usr/libexec/routined\n   46 ??         0:03.34 /System/Library/PrivateFrameworks/MediaRemote.framework/Support/mediaremoted\n   48 ??         0:00.86 /usr/libexec/misd\n   50 ??         0:18.48 /System/Library/Frameworks/HealthKit.framework/healthd\n   52 ??        19:18.39 /usr/libexec/configd\n   54 ??         3:30.26 /System/Library/CoreServices/powerd.bundle/powerd\n   58 ??         0:50.73 /usr/libexec/atc\n   60 ??        13:47.50 /usr/sbin/wifid\n   ···              ···\n 5673 ??         0:04.41 /var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat\n 5732 ??         0:00.32 /usr/libexec/ptpd -t usb\n 5735 ??         0:00.07 /usr/libexec/webinspectord\n 5741 ??         0:00.18 sshd: root@ttys000 \n 5770 ??         0:00.16 /System/Library/PrivateFrameworks/SyncedDefaults.framework/Support/syncdefaultsd\n 5785 ??         0:00.05 /System/Library/CoreServices/CFNetworkAgent\n```\n可以看到目前手机运行的进程中有微信的影子`/var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat` 我们已经找到微信可执行文件的位置\n##### 目标锁定，定位到目标App的Documents位置  \n \n```  \niPhone-5S:~ root# cycript -p WeChat  \ncy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]\n#file:///var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents/  \n```\n\n执行到这里我们已经找到了微信的Documents位置，正式开始砸壳！\n> 这里有两种方式，一种是scp命令行拷贝  \n> 另一种是iFunBox工具操作  \n\n我这里采用的是第一种scp命令行  \n \n```      \nLeonLei-MBP:~ gaoshilei$ scp /Users/gaoshilei/Desktop/reverse/dumpdecrypted/dumpdecrypted.dylib   root@192.168.0.115:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents  \ndumpdecrypted.dylib                                                              100%  193KB 192.9KB/s   00:00   \n```  \n\n我们已经将dumpdecrypted.dylib拷贝到了微信沙盒的Document目录中，可以砸壳了：  \n\n```  \niPhone-5S:~ root# cd /var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents/\niPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat\nmach-o decryption dumper\nDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.\n[+] detected 64bit ARM binary in memory.\n[+] offset to cryptid found: @0x100024ca8(from 0x100024000) = ca8\n[+] Found encrypted data at address 00004000 of length 45678592 bytes - type 1.\n[+] Opening /private/var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat for reading.\n[+] Reading header\n[+] Detecting header type\n[+] Executable is a plain MACH-O image\n[+] Opening WeChat.decrypted for writing.\n[+] Copying the not encrypted start of the file\n[+] Dumping the decrypted data into the file\n[+] Copying the not encrypted remainder of the file\n[+] Setting the LC_ENCRYPTION_INFO->cryptid to 0 at offset ca8\n[+] Closing original file\n[+] Closing dump file\niPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root#  \n```  \n\n等待命令执行完，此时已经完成砸壳，我们看一下当前目录都有啥：  \n  \n```  \niPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root# ls -o\ntotal 55272\ndrwxr-xr-x  6 mobile      272 Aug 26 13:48 00000000000000000000000000000000\ndrwxr-xr-x 20 mobile     1122 Oct 10 15:28 6f696a1b596ce2499419d844f90418aa\ndrwxr-xr-x  3 mobile      136 Oct  9 10:56 CrashReport\n-rw-r--r--  1 mobile      310 Aug 26 13:49 Ksid\n-rw-r--r--  1 mobile     1036 Oct 10 13:40 LocalInfo.lst\ndrwxr-xr-x  5 mobile      272 Aug 26 13:49 MMResourceMgr\ndrwxr-xr-x  2 mobile      748 Aug 26 13:51 MMappedKV\n-rw-r--r--  1 mobile       15 Oct 10 13:40 SafeMode.dat\n-rw-r--r--  1 root   56380816 Oct 10 15:37 WeChat.decrypted\n-rwxr-xr-x  1 root     197528 Oct 10 15:34 dumpdecrypted.dylib\n-rw-r--r--  1 mobile      448 Aug 26 13:49 mmupdateinfo.archive\n```  \n砸好壳的微信可执行文件`WeChat.decrypted`已经生成，现在就可以把文件拷到Mac上利用IDA或者Hopper的分析了。\n\n\n","slug":"dumpdecrypted给App砸壳","published":1,"updated":"2017-11-03T09:41:25.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9no6vm80007jaen6ahy2418","content":"<h4 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h4><blockquote>\n<p>我们都知道从AppStore下载的应用二进制文件被苹果进行了加密处理，也就是我们俗称的<em>壳</em>，我们要想对目标App进行逆向分析，必须解密目标二进制文件，俗称<em>砸壳</em>。<br>long long ago有一种傻瓜式的砸壳方式，利用iPhoneCake源的AppCrackr进行一键砸壳，这种方式简单粗暴，省时省力，但正是因为它过于方便，导致几乎所有用户都可轻松上手，随便亵玩，所以不少用户都拿它来破解程序，这也导致了iOS越狱开发社区普遍认为这个软件助长了盗版的气焰，对iPhoneCake源进行了强烈谴责。迫于压力，iPhoneCake将AppCrackr下架。从此利用纯UI方式砸壳的行为已经走入绝路，只能利用更加geek更加niubility的方式来砸壳，这也是这篇文章介绍的主角<strong>dumpdecrypted</strong>  </p>\n</blockquote>\n<a id=\"more\"></a> \n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<h4 id=\"2-准备工作\"><a href=\"#2-准备工作\" class=\"headerlink\" title=\"2.准备工作\"></a>2.准备工作</h4><ol>\n<li>一部已经越狱的手机 <code>我这里用的是iPhone 5S; iOS 9.1</code></li>\n<li>已经安装了OpenSSH</li>\n<li>已经安装了<a href=\"http://www.cycript.org\" target=\"_blank\" rel=\"external\">Cycript</a></li>\n<li><a href=\"https://github.com/stefanesser/dumpdecrypted/archive/master.zip\" target=\"_blank\" rel=\"external\">dumpdecrypted源码</a>  </li>\n</ol>\n<h4 id=\"3-编译dumpdecrypted\"><a href=\"#3-编译dumpdecrypted\" class=\"headerlink\" title=\"3.编译dumpdecrypted\"></a>3.编译dumpdecrypted</h4><p>下载好之后将文件放到你自己的文件夹中，下面开始编译：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ cd /Users/gaoshilei/Desktop/reverse/dumpdecrypted  </div><div class=\"line\">LeonLei-MBP:dumpdecrypted gaoshilei$ make</div><div class=\"line\">`xcrun --sdk iphoneos --find gcc` -Os  -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -dynamiclib -o dumpdecrypted.dylib dumpdecrypted.o</div></pre></td></tr></table></figure>\n<p>进入dumpdecrypted目录下之后，执行make命令，此时目录下会生成一个<code>dumpdecrypted.dylib</code>，这个文件生成一次即可，下次砸壳可以直接使用。</p>\n<h4 id=\"4-开始砸壳\"><a href=\"#4-开始砸壳\" class=\"headerlink\" title=\"4.开始砸壳\"></a>4.开始砸壳</h4><h5 id=\"定位目标App可执行文件的位置\"><a href=\"#定位目标App可执行文件的位置\" class=\"headerlink\" title=\"定位目标App可执行文件的位置\"></a>定位目标App可执行文件的位置</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ ssh root@192.168.0.115</div><div class=\"line\">iPhone-5S:~ root# ps -e</div><div class=\"line\">  PID TTY           TIME CMD</div><div class=\"line\">    1 ??         5:23.51 /sbin/launchd</div><div class=\"line\">   23 ??         0:00.81 /usr/libexec/amfid</div><div class=\"line\">   34 ??         1:28.92 /usr/sbin/mediaserverd</div><div class=\"line\">   36 ??         4:23.49 /usr/libexec/fseventsd</div><div class=\"line\">   38 ??         1:21.05 /System/Library/PrivateFrameworks/AssistantServices.framework/assistantd</div><div class=\"line\">   40 ??         0:01.13 /System/Library/PrivateFrameworks/FileProvider.framework/Support/fileproviderd</div><div class=\"line\">   42 ??         1:56.46 /usr/libexec/routined</div><div class=\"line\">   46 ??         0:03.34 /System/Library/PrivateFrameworks/MediaRemote.framework/Support/mediaremoted</div><div class=\"line\">   48 ??         0:00.86 /usr/libexec/misd</div><div class=\"line\">   50 ??         0:18.48 /System/Library/Frameworks/HealthKit.framework/healthd</div><div class=\"line\">   52 ??        19:18.39 /usr/libexec/configd</div><div class=\"line\">   54 ??         3:30.26 /System/Library/CoreServices/powerd.bundle/powerd</div><div class=\"line\">   58 ??         0:50.73 /usr/libexec/atc</div><div class=\"line\">   60 ??        13:47.50 /usr/sbin/wifid</div><div class=\"line\">   ···              ···</div><div class=\"line\"> 5673 ??         0:04.41 /var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat</div><div class=\"line\"> 5732 ??         0:00.32 /usr/libexec/ptpd -t usb</div><div class=\"line\"> 5735 ??         0:00.07 /usr/libexec/webinspectord</div><div class=\"line\"> 5741 ??         0:00.18 sshd: root@ttys000 </div><div class=\"line\"> 5770 ??         0:00.16 /System/Library/PrivateFrameworks/SyncedDefaults.framework/Support/syncdefaultsd</div><div class=\"line\"> 5785 ??         0:00.05 /System/Library/CoreServices/CFNetworkAgent</div></pre></td></tr></table></figure>\n<p>可以看到目前手机运行的进程中有微信的影子<code>/var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat</code> 我们已经找到微信可执行文件的位置</p>\n<h5 id=\"目标锁定，定位到目标App的Documents位置\"><a href=\"#目标锁定，定位到目标App的Documents位置\" class=\"headerlink\" title=\"目标锁定，定位到目标App的Documents位置\"></a>目标锁定，定位到目标App的Documents位置</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">iPhone-5S:~ root# cycript -p WeChat  </div><div class=\"line\">cy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]</div><div class=\"line\">#file:///var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents/</div></pre></td></tr></table></figure>\n<p>执行到这里我们已经找到了微信的Documents位置，正式开始砸壳！</p>\n<blockquote>\n<p>这里有两种方式，一种是scp命令行拷贝<br>另一种是iFunBox工具操作  </p>\n</blockquote>\n<p>我这里采用的是第一种scp命令行  </p>\n<pre><code>LeonLei-MBP:~ gaoshilei$ scp /Users/gaoshilei/Desktop/reverse/dumpdecrypted/dumpdecrypted.dylib   root@192.168.0.115:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents  \ndumpdecrypted.dylib                                                              100%  193KB 192.9KB/s   00:00\n</code></pre><p>我们已经将dumpdecrypted.dylib拷贝到了微信沙盒的Document目录中，可以砸壳了：  </p>\n<pre><code>iPhone-5S:~ root# cd /var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents/\niPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat\nmach-o decryption dumper\nDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.\n[+] detected 64bit ARM binary in memory.\n[+] offset to cryptid found: @0x100024ca8(from 0x100024000) = ca8\n[+] Found encrypted data at address 00004000 of length 45678592 bytes - type 1.\n[+] Opening /private/var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat for reading.\n[+] Reading header\n[+] Detecting header type\n[+] Executable is a plain MACH-O image\n[+] Opening WeChat.decrypted for writing.\n[+] Copying the not encrypted start of the file\n[+] Dumping the decrypted data into the file\n[+] Copying the not encrypted remainder of the file\n[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset ca8\n[+] Closing original file\n[+] Closing dump file\niPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root#\n</code></pre><p>等待命令执行完，此时已经完成砸壳，我们看一下当前目录都有啥：  </p>\n<pre><code>iPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root# ls -o\ntotal 55272\ndrwxr-xr-x  6 mobile      272 Aug 26 13:48 00000000000000000000000000000000\ndrwxr-xr-x 20 mobile     1122 Oct 10 15:28 6f696a1b596ce2499419d844f90418aa\ndrwxr-xr-x  3 mobile      136 Oct  9 10:56 CrashReport\n-rw-r--r--  1 mobile      310 Aug 26 13:49 Ksid\n-rw-r--r--  1 mobile     1036 Oct 10 13:40 LocalInfo.lst\ndrwxr-xr-x  5 mobile      272 Aug 26 13:49 MMResourceMgr\ndrwxr-xr-x  2 mobile      748 Aug 26 13:51 MMappedKV\n-rw-r--r--  1 mobile       15 Oct 10 13:40 SafeMode.dat\n-rw-r--r--  1 root   56380816 Oct 10 15:37 WeChat.decrypted\n-rwxr-xr-x  1 root     197528 Oct 10 15:34 dumpdecrypted.dylib\n-rw-r--r--  1 mobile      448 Aug 26 13:49 mmupdateinfo.archive\n</code></pre><p>砸好壳的微信可执行文件<code>WeChat.decrypted</code>已经生成，现在就可以把文件拷到Mac上利用IDA或者Hopper的分析了。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h4><blockquote>\n<p>我们都知道从AppStore下载的应用二进制文件被苹果进行了加密处理，也就是我们俗称的<em>壳</em>，我们要想对目标App进行逆向分析，必须解密目标二进制文件，俗称<em>砸壳</em>。<br>long long ago有一种傻瓜式的砸壳方式，利用iPhoneCake源的AppCrackr进行一键砸壳，这种方式简单粗暴，省时省力，但正是因为它过于方便，导致几乎所有用户都可轻松上手，随便亵玩，所以不少用户都拿它来破解程序，这也导致了iOS越狱开发社区普遍认为这个软件助长了盗版的气焰，对iPhoneCake源进行了强烈谴责。迫于压力，iPhoneCake将AppCrackr下架。从此利用纯UI方式砸壳的行为已经走入绝路，只能利用更加geek更加niubility的方式来砸壳，这也是这篇文章介绍的主角<strong>dumpdecrypted</strong>  </p>\n</blockquote>","more":"<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<h4 id=\"2-准备工作\"><a href=\"#2-准备工作\" class=\"headerlink\" title=\"2.准备工作\"></a>2.准备工作</h4><ol>\n<li>一部已经越狱的手机 <code>我这里用的是iPhone 5S; iOS 9.1</code></li>\n<li>已经安装了OpenSSH</li>\n<li>已经安装了<a href=\"http://www.cycript.org\" target=\"_blank\" rel=\"external\">Cycript</a></li>\n<li><a href=\"https://github.com/stefanesser/dumpdecrypted/archive/master.zip\" target=\"_blank\" rel=\"external\">dumpdecrypted源码</a>  </li>\n</ol>\n<h4 id=\"3-编译dumpdecrypted\"><a href=\"#3-编译dumpdecrypted\" class=\"headerlink\" title=\"3.编译dumpdecrypted\"></a>3.编译dumpdecrypted</h4><p>下载好之后将文件放到你自己的文件夹中，下面开始编译：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ cd /Users/gaoshilei/Desktop/reverse/dumpdecrypted  </div><div class=\"line\">LeonLei-MBP:dumpdecrypted gaoshilei$ make</div><div class=\"line\">`xcrun --sdk iphoneos --find gcc` -Os  -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -dynamiclib -o dumpdecrypted.dylib dumpdecrypted.o</div></pre></td></tr></table></figure>\n<p>进入dumpdecrypted目录下之后，执行make命令，此时目录下会生成一个<code>dumpdecrypted.dylib</code>，这个文件生成一次即可，下次砸壳可以直接使用。</p>\n<h4 id=\"4-开始砸壳\"><a href=\"#4-开始砸壳\" class=\"headerlink\" title=\"4.开始砸壳\"></a>4.开始砸壳</h4><h5 id=\"定位目标App可执行文件的位置\"><a href=\"#定位目标App可执行文件的位置\" class=\"headerlink\" title=\"定位目标App可执行文件的位置\"></a>定位目标App可执行文件的位置</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ ssh root@192.168.0.115</div><div class=\"line\">iPhone-5S:~ root# ps -e</div><div class=\"line\">  PID TTY           TIME CMD</div><div class=\"line\">    1 ??         5:23.51 /sbin/launchd</div><div class=\"line\">   23 ??         0:00.81 /usr/libexec/amfid</div><div class=\"line\">   34 ??         1:28.92 /usr/sbin/mediaserverd</div><div class=\"line\">   36 ??         4:23.49 /usr/libexec/fseventsd</div><div class=\"line\">   38 ??         1:21.05 /System/Library/PrivateFrameworks/AssistantServices.framework/assistantd</div><div class=\"line\">   40 ??         0:01.13 /System/Library/PrivateFrameworks/FileProvider.framework/Support/fileproviderd</div><div class=\"line\">   42 ??         1:56.46 /usr/libexec/routined</div><div class=\"line\">   46 ??         0:03.34 /System/Library/PrivateFrameworks/MediaRemote.framework/Support/mediaremoted</div><div class=\"line\">   48 ??         0:00.86 /usr/libexec/misd</div><div class=\"line\">   50 ??         0:18.48 /System/Library/Frameworks/HealthKit.framework/healthd</div><div class=\"line\">   52 ??        19:18.39 /usr/libexec/configd</div><div class=\"line\">   54 ??         3:30.26 /System/Library/CoreServices/powerd.bundle/powerd</div><div class=\"line\">   58 ??         0:50.73 /usr/libexec/atc</div><div class=\"line\">   60 ??        13:47.50 /usr/sbin/wifid</div><div class=\"line\">   ···              ···</div><div class=\"line\"> 5673 ??         0:04.41 /var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat</div><div class=\"line\"> 5732 ??         0:00.32 /usr/libexec/ptpd -t usb</div><div class=\"line\"> 5735 ??         0:00.07 /usr/libexec/webinspectord</div><div class=\"line\"> 5741 ??         0:00.18 sshd: root@ttys000 </div><div class=\"line\"> 5770 ??         0:00.16 /System/Library/PrivateFrameworks/SyncedDefaults.framework/Support/syncdefaultsd</div><div class=\"line\"> 5785 ??         0:00.05 /System/Library/CoreServices/CFNetworkAgent</div></pre></td></tr></table></figure>\n<p>可以看到目前手机运行的进程中有微信的影子<code>/var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat</code> 我们已经找到微信可执行文件的位置</p>\n<h5 id=\"目标锁定，定位到目标App的Documents位置\"><a href=\"#目标锁定，定位到目标App的Documents位置\" class=\"headerlink\" title=\"目标锁定，定位到目标App的Documents位置\"></a>目标锁定，定位到目标App的Documents位置</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">iPhone-5S:~ root# cycript -p WeChat  </div><div class=\"line\">cy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]</div><div class=\"line\">#file:///var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents/</div></pre></td></tr></table></figure>\n<p>执行到这里我们已经找到了微信的Documents位置，正式开始砸壳！</p>\n<blockquote>\n<p>这里有两种方式，一种是scp命令行拷贝<br>另一种是iFunBox工具操作  </p>\n</blockquote>\n<p>我这里采用的是第一种scp命令行  </p>\n<pre><code>LeonLei-MBP:~ gaoshilei$ scp /Users/gaoshilei/Desktop/reverse/dumpdecrypted/dumpdecrypted.dylib   root@192.168.0.115:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents  \ndumpdecrypted.dylib                                                              100%  193KB 192.9KB/s   00:00\n</code></pre><p>我们已经将dumpdecrypted.dylib拷贝到了微信沙盒的Document目录中，可以砸壳了：  </p>\n<pre><code>iPhone-5S:~ root# cd /var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents/\niPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat\nmach-o decryption dumper\nDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.\n[+] detected 64bit ARM binary in memory.\n[+] offset to cryptid found: @0x100024ca8(from 0x100024000) = ca8\n[+] Found encrypted data at address 00004000 of length 45678592 bytes - type 1.\n[+] Opening /private/var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat for reading.\n[+] Reading header\n[+] Detecting header type\n[+] Executable is a plain MACH-O image\n[+] Opening WeChat.decrypted for writing.\n[+] Copying the not encrypted start of the file\n[+] Dumping the decrypted data into the file\n[+] Copying the not encrypted remainder of the file\n[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset ca8\n[+] Closing original file\n[+] Closing dump file\niPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root#\n</code></pre><p>等待命令执行完，此时已经完成砸壳，我们看一下当前目录都有啥：  </p>\n<pre><code>iPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root# ls -o\ntotal 55272\ndrwxr-xr-x  6 mobile      272 Aug 26 13:48 00000000000000000000000000000000\ndrwxr-xr-x 20 mobile     1122 Oct 10 15:28 6f696a1b596ce2499419d844f90418aa\ndrwxr-xr-x  3 mobile      136 Oct  9 10:56 CrashReport\n-rw-r--r--  1 mobile      310 Aug 26 13:49 Ksid\n-rw-r--r--  1 mobile     1036 Oct 10 13:40 LocalInfo.lst\ndrwxr-xr-x  5 mobile      272 Aug 26 13:49 MMResourceMgr\ndrwxr-xr-x  2 mobile      748 Aug 26 13:51 MMappedKV\n-rw-r--r--  1 mobile       15 Oct 10 13:40 SafeMode.dat\n-rw-r--r--  1 root   56380816 Oct 10 15:37 WeChat.decrypted\n-rwxr-xr-x  1 root     197528 Oct 10 15:34 dumpdecrypted.dylib\n-rw-r--r--  1 mobile      448 Aug 26 13:49 mmupdateinfo.archive\n</code></pre><p>砸好壳的微信可执行文件<code>WeChat.decrypted</code>已经生成，现在就可以把文件拷到Mac上利用IDA或者Hopper的分析了。</p>"},{"title":"Weex从入门到超神（二）","date":"2017-09-26T10:10:21.000Z","_content":"\n距离我写的上一篇文章 [Weex从入门到超神（一）](https://gaoshilei.com/2017/05/26/weex-1/) 已经过了挺久了（惭愧而不失礼貌的微笑），起初写那篇文章的初衷是因为项目中使用到了 Weex ,所以准备对 Weex 做一个心得式的笔记，后来无意间发现[简书“霜神”](http://www.jianshu.com/u/12201cdd5d7a)已经对 Weex 写过几篇剖析比较深刻的文章，还有其他一些原因（懒），所以就没有继续写下去。  \n最近由于Facebook的 [BSD license](https://github.com/facebook/react/blob/master/LICENSE)，React 被前端社区的同学们推到了风口浪尖，React&RN、Vue&Weex 又成为了大家码前码后讨论的话题。Apache 社区还因为 Facebook 的 BSD license，全面封杀使用了 BSD license 的开源项目，貌似一切都很精彩，迫于前端同(da)学(lao)的淫威还有社区的强烈谴责，上周 Facebook 终于认怂了，承诺这周将 React 以及 gayhub 上面的其他几个项目的开源协议从 BSD 改成 MIT，下图是我脑补的场景：  \n![](http://oeat6c2zg.bkt.clouddn.com/FA269E01D9C3794449AA6748EA6280C6.png)  \n鉴于对于项目中使用 Weex 的一些经验和心得，还是希望写出来和大家一起分享。  \n<!-- more -->\n## 应用层核心组件\nWeex 运行时会先注入一段位于 `pre-build` 下的 `native-bundle-main.js` 代码。不过在注入这段代码之前会先注册一些默认的 `Component`、`Module`和`Handler`，**这就是 Weex 与 Native 应用层交互最核心的部分**，可以理解为“组件”。其中 Component 是为了映射 Html 的一些标签，Module 中是提供一些 Native 的一些方法供 Weex 调用，Handler 是一些协议的实现。  \n\n![](http://oeat6c2zg.bkt.clouddn.com/weex-component.png)  \n\n注册完 Weex 默认的“组件” 之后，注入刚才那段 JS，这个时候 Vue 的标签和动作才能被 Weex 所识别和转换。  \n**为了便于下文的描述和理解，我把 Native 这边的 SDK 称作 Weex，前端的 Vue 和 Weex 库以及 Vue 编译后的 js 统称为 Vue**\n\n### 1. 组件：Component\n目前 Weex 一共提供了26种 Component，比较常见的有 `div`、`image`、`scroller`... ，有些跟 html 标签重名，有些是 Weex 自定义的。Weex 注册的 Component 有两种类型，一类是有\n`{@\"append\":@\"tree\"}`属性的标签，另一类是没有`{@\"append\":@\"tree\"}`属性的标签。要搞清楚这两类标签有什么不同，我们就要看一下 Component 的注册的源码实现。\n\n```ObjC  \n    [WXComponentFactory registerComponent:name withClass:clazz withPros:properties];\n    NSMutableDictionary *dict = [WXComponentFactory componentMethodMapsWithName:name];\n    dict[@\"type\"] = name;\n    if (properties) {\n        NSMutableDictionary *props = [properties mutableCopy];\n        if ([dict[@\"methods\"] count]) {\n            [props addEntriesFromDictionary:dict];\n        }\n        [[WXSDKManager bridgeMgr] registerComponents:@[props]];\n    } else {\n        [[WXSDKManager bridgeMgr] registerComponents:@[dict]];\n    }\n```\n\n首先通过一个工厂类`WXComponentFactory`注册 Component，  \n\n>  这个工厂类（单例）中管理了所有的 Component ，注册的每一个 Component 都会用一个对应的 `WXComponentConfig`来保存标签name、对应的class和属性，最后由`WXComponentFactory`来统一管理这些`WXComponentConfig `   \n\n这一步同时注册了 Component 中的 methods，关于 method 也有两类，一类是包含`wx_export_method_sync_`前缀的同步方法，另一类是包含`wx_export_method_`前缀的异步方法（*这两种方法有什么不同，后面会有介绍*）。在`WXComponentConfig`的父类`WXInvocationConfig`储存了 Component 的方法map:\n\n```ObjC  \n@property (nonatomic, strong) NSMutableDictionary *asyncMethods;\n@property (nonatomic, strong) NSMutableDictionary *syncMethods;\n```\n\n然后再从`WXComponentFactory`拿到对应 Component 的方法列表字典，需要注意的是这里拿到的方法列表只是**异步方法**，得到的是这样的字典：\n\n```ObjC   \n{\n    methods =     (\n        resetLoadmore\n    );\n    type = scroller;\n} \n```\n\n不过大部分 Component 并没有`wx_export`前缀的 method，所以很多这里拿到的方法都为空。  \n最后也是最关键的一步，要将 Component 注册到`WXBridgeContext`中。\n\n```ObjC   \n    if (self.frameworkLoadFinished) {\n        [self.jsBridge callJSMethod:method args:args];\n    } else {\n        [_methodQueue addObject:@{@\"method\":method, @\"args\":args}];\n    }  \n```\n\n最后将 Component 注册到了`JSContext`中，\n\n>  还记得文章开头介绍的`native-bundle-main.js`吗？这里的注册调用了js中的`registerComponents`方法，这个 Component 与 Vue 就联系起来了，在 Vue 就可以使用这个 Component。\n \n并且从上面的这段代码可以看出来，Component 的注册操作是在 JSFramework 加载完成才会进行，如果`native-bundle-main.js`没有加载完成，所有的 Component 的方法注册操作都会被加到队列中等待。其中的第二个参数`args`就是上面我们拿到的字典。不过有属性的 和没属性的有点区别，有属性的会将属性添加到之前拿到的字典中作为`args`再去注册。  \n要搞清楚这个属性干嘛的，我们先看一下`WXComponentManager`中的相关源码：\n\n```ObjC    \n- (void)_recursivelyAddComponent:(NSDictionary *)componentData toSupercomponent:(WXComponent *)supercomponent atIndex:(NSInteger)index appendingInTree:(BOOL)appendingInTree {\n\t\t...    \n    BOOL appendTree = !appendingInTree && [component.attributes[@\"append\"] isEqualToString:@\"tree\"];\n    // if ancestor is appending tree, child should not be laid out again even it is appending tree.\n    for(NSDictionary *subcomponentData in subcomponentsData){\n        [self _recursivelyAddComponent:subcomponentData toSupercomponent:component atIndex:-1 appendingInTree:appendTree || appendingInTree];\n    }\n    if (appendTree) {\n        // If appending tree，force layout in case of too much tasks piling up in syncQueue\n        [self _layoutAndSyncUI];\n    }\n}\n```\n\n这个方法是 Vue 页面渲染时所调用的方法，这个方法会递归添加 Component，同时会向视图中添加与 Component 相对应的 UIView。从代码的后半部分可以看到，如果当前 Component 有`{@\"append\":@\"tree\"}`属性并且它的父 Component 没有这个属性将会强制对页面进行重新布局。可以看到这样做是为了防止UI绘制任务太多堆积在一起影响同步队列任务的执行。    \n\n搞清楚了 Component 的注册机制，下面重点扒一下 Component 的运行原理：Vue 标签是如何加载以及渲染到视图上的。  \n从刚才的注册过程中发现，最后一步是通过`_jsBridge`调用`callJSMethod`这个方法来注册的，而且从`WXBridgeContext`中可以看到，这个`_jsBridge`就是`WXJSCoreBridge`的实例。`WXJSCoreBridge`可以认为是 Weex 与 Vue 进行通信的最底层的部分。在调用`callJSMethod`方法之前，`_jsBridge`向 JavaScriptCore 中注册了很多全局 function，因为`jsBridge`是懒加载的，所以这些操作只会执行一次，具体请看精简后的源码：\n\n```ObjC  \n    [_jsBridge registerCallNative:^NSInteger(NSString *instance, NSArray *tasks, NSString *callback) {\t\n\t\t...    \n\t }];\n    [_jsBridge registerCallAddElement:^NSInteger(NSString *instanceId, NSString *parentRef, NSDictionary *elementData, NSInteger index) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallCreateBody:^NSInteger(NSString *instanceId, NSDictionary *bodyData) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallRemoveElement:^NSInteger(NSString *instanceId, NSString *ref) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallMoveElement:^NSInteger(NSString *instanceId,NSString *ref,NSString *parentRef,NSInteger index) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallUpdateAttrs:^NSInteger(NSString *instanceId,NSString *ref,NSDictionary *attrsData) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallUpdateStyle:^NSInteger(NSString *instanceId,NSString *ref,NSDictionary *stylesData) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallAddEvent:^NSInteger(NSString *instanceId,NSString *ref,NSString *event) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallRemoveEvent:^NSInteger(NSString *instanceId,NSString *ref,NSString *event) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallCreateFinish:^NSInteger(NSString *instanceId) {\n    \t...\n    }];\n    \n    [_jsBridge registerCallNativeModule:^NSInvocation*(NSString *instanceId, NSString *moduleName, NSString *methodName, NSArray *arguments, NSDictionary *options) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallNativeComponent:^void(NSString *instanceId, NSString *componentRef, NSString *methodName, NSArray *args, NSDictionary *options) {\n\t\t...\n    }];\n```\n\n从这些方法名看，大多数都是一些与 Dom 更新相关的方法，我们在`WXJSCoreBridge`中更细致的看一下是怎么实现的：\n\n```ObjC  \n- (void)registerCallAddElement:(WXJSCallAddElement)callAddElement\n{\n    id callAddElementBlock = ^(JSValue *instanceId, JSValue *ref, JSValue *element, JSValue *index, JSValue *ifCallback) {\n        \n        NSString *instanceIdString = [instanceId toString];\n        NSDictionary *componentData = [element toDictionary];\n        NSString *parentRef = [ref toString];\n        NSInteger insertIndex = [[index toNumber] integerValue];\n        [WXTracingManager startTracingWithInstanceId:instanceIdString ref:componentData[@\"ref\"] className:nil name:WXTJSCall phase:WXTracingBegin functionName:@\"addElement\" options:nil];\n         WXLogDebug(@\"callAddElement...%@, %@, %@, %ld\", instanceIdString, parentRef, componentData, (long)insertIndex);\n        \n        return [JSValue valueWithInt32:(int32_t)callAddElement(instanceIdString, parentRef, componentData, insertIndex) inContext:[JSContext currentContext]];\n    };\n\n    _jsContext[@\"callAddElement\"] = callAddElementBlock;\n}\n```\n\n这是一个更新 Dom 添加 UIView 的方法，这里需要把 Native 的方法暴露给 JS 调用。但是有一个问题：  \n>  OC 的方法参数格式和 JS 的不一样，不能直接提供给 JS 调用。  \n\n所以这里用了两个 Block 嵌套的方式，在 JS 中调用方法时会先 invoke 里层的 callAddElementBlock，这层 Block 将 JS 传进来的参数转换成 OC 的参数格式，再执行 callAddElement 并返回一个 JSValue 给 JS，callAddElement Block中是在`WXComponentManager`中完成的关于 Component 的一些操作，这在上面介绍 Component 包含 `tree`属性问题时已经介绍过了。  \n至此，简单来说就是：Weex 的页面渲染是通过先向 JSCore 注入方法，Vue 加载完成就可以调用这些方法并传入相应的参数完成 Component 的渲染和视图的更新。  \n要注意，每一个 `WXSDKInstance` 对应一个 Vue 页面，Vue 加载之前就会创建对应的 WXSDKInstance，所有的 Component 都继承自`WXComponent`，他们的初始化方法都是\n\n```ObjC  \n-(instancetype)initWithRef:(NSString *)ref\n                      type:(NSString *)type\n                    styles:(NSDictionary *)styles\n                attributes:(NSDictionary *)attributes\n                    events:(NSArray *)events\n              weexInstance:(WXSDKInstance *)weexInstance\n```\n\n这个方法会在 JS 调用`callCreateBody`时被 invoke。 \n\n### 2. 组件：Module  \nModule 注册流程和 Component 基本一致，首先通过`WXModuleFactory`注册 Module\n\n```ObjC  \n- (NSString *)_registerModule:(NSString *)name withClass:(Class)clazz\n{\n    WXAssert(name && clazz, @\"Fail to register the module, please check if the parameters are correct ！\");\n    \n    [_moduleLock lock];\n    //allow to register module with the same name;\n    WXModuleConfig *config = [[WXModuleConfig alloc] init];\n    config.name = name;\n    config.clazz = NSStringFromClass(clazz);\n    [config registerMethods];\n    [_moduleMap setValue:config forKey:name];\n    [_moduleLock unlock];\n    \n    return name;\n}\n```\n\n注册 Moudle 的`registerMethods`方法与注册 Component 是一样的，都是将方法注册到`WXInvocationConfig`中，`wx_export_method_sync_`前缀的同步方法注册到 syncMethods 中，`wx_export_method_`前缀的异步方法注册到 asyncMethods 中。再将 Moudle 的同步和异步方法取出来调用`registerComponents`注入到`JSContext`中\n\n```ObjC  \n{\n    dom =     (\n        addEventListener,\n        removeAllEventListeners,\n        addEvent,\n        removeElement,\n        getComponentRect,\n        updateFinish,\n        scrollToElement,\n        addRule,\n        updateAttrs,\n        addElement,\n        createFinish,\n        createBody,\n        updateStyle,\n        removeEvent,\n        refreshFinish,\n        moveElement\n    );\n}\n```\n\n这是`WXDomModule`中所有的方法，*Moudle 中的方法注册比 Component 更有意义，因为 Moudle 中基本上都是暴露给 Vue 调用的 Native 方法。*   \n**接下来我们来看一下 Moudle 的方法如何被调用以及 syncMethods 和 asyncMethods 有什么不同。**  \n在前面的`jsBridge`懒加载中，有一个注册方法是跟 Moudle 中方法有关的，Moudle 中的方法会在这个注册方法的回调中被 invoke，换言之，Vue 调用 Moudle 中的方法会在这个回调中被唤起  \n\n```ObjC  \n    [_jsBridge registerCallNativeModule:^NSInvocation*(NSString *instanceId, NSString *moduleName, NSString *methodName, NSArray *arguments, NSDictionary *options) {\n        \n        WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];\n        \n        if (!instance) {\n            WXLogInfo(@\"instance not found for callNativeModule:%@.%@, maybe already destroyed\", moduleName, methodName);\n            return nil;\n        }\n        \n        WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance];\n        if(![moduleName isEqualToString:@\"dom\"] && instance.needPrerender){\n            [WXPrerenderManager storePrerenderModuleTasks:method forUrl:instance.scriptURL.absoluteString];\n            return nil;\n        }\n        return [method invoke];\n    }];\n```\n\n在`WXModuleMethod`中可以看到`-(NSInvocation *)invoke`这个方法，Moudle 中的方法将会通过这个方法被 invoke\n\n```ObjC  \n\t\t...\n    \n    Class moduleClass =  [WXModuleFactory classWithModuleName:_moduleName];\n    if (!moduleClass) {\n        NSString *errorMessage = [NSString stringWithFormat:@\"Module：%@ doesn't exist, maybe it has not been registered\", _moduleName];\n        WX_MONITOR_FAIL(WXMTJSBridge, WX_ERR_INVOKE_NATIVE, errorMessage);\n        return nil;\n    }\n    \n    id<WXModuleProtocol> moduleInstance = [self.instance moduleForClass:moduleClass];\n    WXAssert(moduleInstance, @\"No instance found for module name:%@, class:%@\", _moduleName, moduleClass);\n    BOOL isSync = NO;\n    SEL selector = [WXModuleFactory selectorWithModuleName:self.moduleName methodName:self.methodName isSync:&isSync];\n   \n    if (![moduleInstance respondsToSelector:selector]) {\n        // if not implement the selector, then dispatch default module method\n        if ([self.methodName isEqualToString:@\"addEventListener\"]) {\n            [self.instance _addModuleEventObserversWithModuleMethod:self];\n        } else if ([self.methodName isEqualToString:@\"removeAllEventListeners\"]) {\n            [self.instance _removeModuleEventObserverWithModuleMethod:self];\n        } else {\n            NSString *errorMessage = [NSString stringWithFormat:@\"method：%@ for module:%@ doesn't exist, maybe it has not been registered\", self.methodName, _moduleName];\n            WX_MONITOR_FAIL(WXMTJSBridge, WX_ERR_INVOKE_NATIVE, errorMessage);\n        }\n        return nil;\n    }\n\t\n    [self commitModuleInvoke];\n    NSInvocation *invocation = [self invocationWithTarget:moduleInstance selector:selector];\n    \n    if (isSync) {\n        [invocation invoke];\n        return invocation;\n    } else {\n        [self _dispatchInvocation:invocation moduleInstance:moduleInstance];\n        return nil;\n    }\n```\n\n先通过 `WXModuleFactory` 拿到对应的方法 Selector，然后再拿到这个方法对应的 NSInvocation ，最后 invoke 这个 NSInvocation。对于 syncMethods 和 asyncMethods 有两种 invoke 方式。如果是 syncMethod 会直接 invoke ，如果是 asyncMethod，会将它派发到某个指定的线程中进行 invoke，这样做的好处是不会阻塞当前线程。到这里 Moudle 的大概的运行原理都清除了，不过还有一个问题，Moudle 的方法是怎么暴露给 Vue 的呢？  \n在 Moudle 中我们通过 Weex 提供的宏可以将方法暴露出来：\n\n```ObjC  \n#define WX_EXPORT_METHOD(method) WX_EXPORT_METHOD_INTERNAL(method,wx_export_method_)\n#define WX_EXPORT_METHOD_SYNC(method) WX_EXPORT_METHOD_INTERNAL(method,wx_export_method_sync_)\n```\n\n分别提供了 syncMethod 和 asyncMethod 的宏，展开其实是这样的\n\n```ObjC  \n#define WX_EXPORT_METHOD_INTERNAL(method, token) \\\n+ (NSString *)WX_CONCAT_WRAPPER(token, __LINE__) { \\\n    return NSStringFromSelector(method); \\\n}\n```  \n这里会自动将方法名和当前的行数拼成一个新的方法名，这样做的好处是可以保证方法的唯一性，例如 `WXDomModule` 中的 `createBody:` 方法利用宏暴露出来，最终展开形式是这样的  \n\n```ObjC  \n+ (NSString *)wx_export_method_40 { \\\n    return NSStringFromSelector(createBody:); \\\n}\n```  \n\n在`WXInvocationConfig`中调用`- (void)registerMethods`注册方法的时候，首先拿到当前 class 中所有的类方法**（宏包装成的方法，并不是实际要注册的方法）**，然后通过判断有无`wx_export_method_sync_`前缀和`wx_export_method_`前缀来判断是否为暴露的方法，然后再调用该类方法，获得最终的实例方法字符串\n\n```ObjC  \nmethod = ((NSString* (*)(id, SEL))[currentClass methodForSelector:selector])(currentClass, selector);\n```\n\n拿到需要注册的实例方法字符串，再将方法字符串注册到`WXInvocationConfig`的对应方法 map 中。  \n\n\n### 3. 组件：Handlers  \n\nHandlers 的注册和使用非常简单，直接将对应的 class 注册到 `WXHandlerFactory` map中\n\n```ObjC  \n[[WXHandlerFactory sharedInstance].handlers setObject:handler forKey:NSStringFromProtocol(protocol)];\n\n```\n\n需要使用的时候也非常简单粗暴，通过`WXHandlerFactory`的方法和相应的 protocol\n\n```ObjC  \n+ (id)handlerForProtocol:(Protocol *)\n{\n    id handler = [[WXHandlerFactory sharedInstance].handlers objectForKey:NSStringFromProtocol(protocol)];\n    return handler;\n}\n```\n\n直接拿出即可。\n \n\n\n\n\n","source":"_posts/Weex从入门到超神（二）.md","raw":"---\ntitle: Weex从入门到超神（二）  \ndate: 2017-09-26 18:10:21  \ncategories:  \n- 技术笔记  \ntags:  \n- Weex  \n- Vue  \n- JS  \n- 前端  \npermalink: weex-2  \n\n---\n\n距离我写的上一篇文章 [Weex从入门到超神（一）](https://gaoshilei.com/2017/05/26/weex-1/) 已经过了挺久了（惭愧而不失礼貌的微笑），起初写那篇文章的初衷是因为项目中使用到了 Weex ,所以准备对 Weex 做一个心得式的笔记，后来无意间发现[简书“霜神”](http://www.jianshu.com/u/12201cdd5d7a)已经对 Weex 写过几篇剖析比较深刻的文章，还有其他一些原因（懒），所以就没有继续写下去。  \n最近由于Facebook的 [BSD license](https://github.com/facebook/react/blob/master/LICENSE)，React 被前端社区的同学们推到了风口浪尖，React&RN、Vue&Weex 又成为了大家码前码后讨论的话题。Apache 社区还因为 Facebook 的 BSD license，全面封杀使用了 BSD license 的开源项目，貌似一切都很精彩，迫于前端同(da)学(lao)的淫威还有社区的强烈谴责，上周 Facebook 终于认怂了，承诺这周将 React 以及 gayhub 上面的其他几个项目的开源协议从 BSD 改成 MIT，下图是我脑补的场景：  \n![](http://oeat6c2zg.bkt.clouddn.com/FA269E01D9C3794449AA6748EA6280C6.png)  \n鉴于对于项目中使用 Weex 的一些经验和心得，还是希望写出来和大家一起分享。  \n<!-- more -->\n## 应用层核心组件\nWeex 运行时会先注入一段位于 `pre-build` 下的 `native-bundle-main.js` 代码。不过在注入这段代码之前会先注册一些默认的 `Component`、`Module`和`Handler`，**这就是 Weex 与 Native 应用层交互最核心的部分**，可以理解为“组件”。其中 Component 是为了映射 Html 的一些标签，Module 中是提供一些 Native 的一些方法供 Weex 调用，Handler 是一些协议的实现。  \n\n![](http://oeat6c2zg.bkt.clouddn.com/weex-component.png)  \n\n注册完 Weex 默认的“组件” 之后，注入刚才那段 JS，这个时候 Vue 的标签和动作才能被 Weex 所识别和转换。  \n**为了便于下文的描述和理解，我把 Native 这边的 SDK 称作 Weex，前端的 Vue 和 Weex 库以及 Vue 编译后的 js 统称为 Vue**\n\n### 1. 组件：Component\n目前 Weex 一共提供了26种 Component，比较常见的有 `div`、`image`、`scroller`... ，有些跟 html 标签重名，有些是 Weex 自定义的。Weex 注册的 Component 有两种类型，一类是有\n`{@\"append\":@\"tree\"}`属性的标签，另一类是没有`{@\"append\":@\"tree\"}`属性的标签。要搞清楚这两类标签有什么不同，我们就要看一下 Component 的注册的源码实现。\n\n```ObjC  \n    [WXComponentFactory registerComponent:name withClass:clazz withPros:properties];\n    NSMutableDictionary *dict = [WXComponentFactory componentMethodMapsWithName:name];\n    dict[@\"type\"] = name;\n    if (properties) {\n        NSMutableDictionary *props = [properties mutableCopy];\n        if ([dict[@\"methods\"] count]) {\n            [props addEntriesFromDictionary:dict];\n        }\n        [[WXSDKManager bridgeMgr] registerComponents:@[props]];\n    } else {\n        [[WXSDKManager bridgeMgr] registerComponents:@[dict]];\n    }\n```\n\n首先通过一个工厂类`WXComponentFactory`注册 Component，  \n\n>  这个工厂类（单例）中管理了所有的 Component ，注册的每一个 Component 都会用一个对应的 `WXComponentConfig`来保存标签name、对应的class和属性，最后由`WXComponentFactory`来统一管理这些`WXComponentConfig `   \n\n这一步同时注册了 Component 中的 methods，关于 method 也有两类，一类是包含`wx_export_method_sync_`前缀的同步方法，另一类是包含`wx_export_method_`前缀的异步方法（*这两种方法有什么不同，后面会有介绍*）。在`WXComponentConfig`的父类`WXInvocationConfig`储存了 Component 的方法map:\n\n```ObjC  \n@property (nonatomic, strong) NSMutableDictionary *asyncMethods;\n@property (nonatomic, strong) NSMutableDictionary *syncMethods;\n```\n\n然后再从`WXComponentFactory`拿到对应 Component 的方法列表字典，需要注意的是这里拿到的方法列表只是**异步方法**，得到的是这样的字典：\n\n```ObjC   \n{\n    methods =     (\n        resetLoadmore\n    );\n    type = scroller;\n} \n```\n\n不过大部分 Component 并没有`wx_export`前缀的 method，所以很多这里拿到的方法都为空。  \n最后也是最关键的一步，要将 Component 注册到`WXBridgeContext`中。\n\n```ObjC   \n    if (self.frameworkLoadFinished) {\n        [self.jsBridge callJSMethod:method args:args];\n    } else {\n        [_methodQueue addObject:@{@\"method\":method, @\"args\":args}];\n    }  \n```\n\n最后将 Component 注册到了`JSContext`中，\n\n>  还记得文章开头介绍的`native-bundle-main.js`吗？这里的注册调用了js中的`registerComponents`方法，这个 Component 与 Vue 就联系起来了，在 Vue 就可以使用这个 Component。\n \n并且从上面的这段代码可以看出来，Component 的注册操作是在 JSFramework 加载完成才会进行，如果`native-bundle-main.js`没有加载完成，所有的 Component 的方法注册操作都会被加到队列中等待。其中的第二个参数`args`就是上面我们拿到的字典。不过有属性的 和没属性的有点区别，有属性的会将属性添加到之前拿到的字典中作为`args`再去注册。  \n要搞清楚这个属性干嘛的，我们先看一下`WXComponentManager`中的相关源码：\n\n```ObjC    \n- (void)_recursivelyAddComponent:(NSDictionary *)componentData toSupercomponent:(WXComponent *)supercomponent atIndex:(NSInteger)index appendingInTree:(BOOL)appendingInTree {\n\t\t...    \n    BOOL appendTree = !appendingInTree && [component.attributes[@\"append\"] isEqualToString:@\"tree\"];\n    // if ancestor is appending tree, child should not be laid out again even it is appending tree.\n    for(NSDictionary *subcomponentData in subcomponentsData){\n        [self _recursivelyAddComponent:subcomponentData toSupercomponent:component atIndex:-1 appendingInTree:appendTree || appendingInTree];\n    }\n    if (appendTree) {\n        // If appending tree，force layout in case of too much tasks piling up in syncQueue\n        [self _layoutAndSyncUI];\n    }\n}\n```\n\n这个方法是 Vue 页面渲染时所调用的方法，这个方法会递归添加 Component，同时会向视图中添加与 Component 相对应的 UIView。从代码的后半部分可以看到，如果当前 Component 有`{@\"append\":@\"tree\"}`属性并且它的父 Component 没有这个属性将会强制对页面进行重新布局。可以看到这样做是为了防止UI绘制任务太多堆积在一起影响同步队列任务的执行。    \n\n搞清楚了 Component 的注册机制，下面重点扒一下 Component 的运行原理：Vue 标签是如何加载以及渲染到视图上的。  \n从刚才的注册过程中发现，最后一步是通过`_jsBridge`调用`callJSMethod`这个方法来注册的，而且从`WXBridgeContext`中可以看到，这个`_jsBridge`就是`WXJSCoreBridge`的实例。`WXJSCoreBridge`可以认为是 Weex 与 Vue 进行通信的最底层的部分。在调用`callJSMethod`方法之前，`_jsBridge`向 JavaScriptCore 中注册了很多全局 function，因为`jsBridge`是懒加载的，所以这些操作只会执行一次，具体请看精简后的源码：\n\n```ObjC  \n    [_jsBridge registerCallNative:^NSInteger(NSString *instance, NSArray *tasks, NSString *callback) {\t\n\t\t...    \n\t }];\n    [_jsBridge registerCallAddElement:^NSInteger(NSString *instanceId, NSString *parentRef, NSDictionary *elementData, NSInteger index) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallCreateBody:^NSInteger(NSString *instanceId, NSDictionary *bodyData) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallRemoveElement:^NSInteger(NSString *instanceId, NSString *ref) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallMoveElement:^NSInteger(NSString *instanceId,NSString *ref,NSString *parentRef,NSInteger index) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallUpdateAttrs:^NSInteger(NSString *instanceId,NSString *ref,NSDictionary *attrsData) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallUpdateStyle:^NSInteger(NSString *instanceId,NSString *ref,NSDictionary *stylesData) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallAddEvent:^NSInteger(NSString *instanceId,NSString *ref,NSString *event) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallRemoveEvent:^NSInteger(NSString *instanceId,NSString *ref,NSString *event) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallCreateFinish:^NSInteger(NSString *instanceId) {\n    \t...\n    }];\n    \n    [_jsBridge registerCallNativeModule:^NSInvocation*(NSString *instanceId, NSString *moduleName, NSString *methodName, NSArray *arguments, NSDictionary *options) {\n\t\t...\n    }];\n    \n    [_jsBridge registerCallNativeComponent:^void(NSString *instanceId, NSString *componentRef, NSString *methodName, NSArray *args, NSDictionary *options) {\n\t\t...\n    }];\n```\n\n从这些方法名看，大多数都是一些与 Dom 更新相关的方法，我们在`WXJSCoreBridge`中更细致的看一下是怎么实现的：\n\n```ObjC  \n- (void)registerCallAddElement:(WXJSCallAddElement)callAddElement\n{\n    id callAddElementBlock = ^(JSValue *instanceId, JSValue *ref, JSValue *element, JSValue *index, JSValue *ifCallback) {\n        \n        NSString *instanceIdString = [instanceId toString];\n        NSDictionary *componentData = [element toDictionary];\n        NSString *parentRef = [ref toString];\n        NSInteger insertIndex = [[index toNumber] integerValue];\n        [WXTracingManager startTracingWithInstanceId:instanceIdString ref:componentData[@\"ref\"] className:nil name:WXTJSCall phase:WXTracingBegin functionName:@\"addElement\" options:nil];\n         WXLogDebug(@\"callAddElement...%@, %@, %@, %ld\", instanceIdString, parentRef, componentData, (long)insertIndex);\n        \n        return [JSValue valueWithInt32:(int32_t)callAddElement(instanceIdString, parentRef, componentData, insertIndex) inContext:[JSContext currentContext]];\n    };\n\n    _jsContext[@\"callAddElement\"] = callAddElementBlock;\n}\n```\n\n这是一个更新 Dom 添加 UIView 的方法，这里需要把 Native 的方法暴露给 JS 调用。但是有一个问题：  \n>  OC 的方法参数格式和 JS 的不一样，不能直接提供给 JS 调用。  \n\n所以这里用了两个 Block 嵌套的方式，在 JS 中调用方法时会先 invoke 里层的 callAddElementBlock，这层 Block 将 JS 传进来的参数转换成 OC 的参数格式，再执行 callAddElement 并返回一个 JSValue 给 JS，callAddElement Block中是在`WXComponentManager`中完成的关于 Component 的一些操作，这在上面介绍 Component 包含 `tree`属性问题时已经介绍过了。  \n至此，简单来说就是：Weex 的页面渲染是通过先向 JSCore 注入方法，Vue 加载完成就可以调用这些方法并传入相应的参数完成 Component 的渲染和视图的更新。  \n要注意，每一个 `WXSDKInstance` 对应一个 Vue 页面，Vue 加载之前就会创建对应的 WXSDKInstance，所有的 Component 都继承自`WXComponent`，他们的初始化方法都是\n\n```ObjC  \n-(instancetype)initWithRef:(NSString *)ref\n                      type:(NSString *)type\n                    styles:(NSDictionary *)styles\n                attributes:(NSDictionary *)attributes\n                    events:(NSArray *)events\n              weexInstance:(WXSDKInstance *)weexInstance\n```\n\n这个方法会在 JS 调用`callCreateBody`时被 invoke。 \n\n### 2. 组件：Module  \nModule 注册流程和 Component 基本一致，首先通过`WXModuleFactory`注册 Module\n\n```ObjC  \n- (NSString *)_registerModule:(NSString *)name withClass:(Class)clazz\n{\n    WXAssert(name && clazz, @\"Fail to register the module, please check if the parameters are correct ！\");\n    \n    [_moduleLock lock];\n    //allow to register module with the same name;\n    WXModuleConfig *config = [[WXModuleConfig alloc] init];\n    config.name = name;\n    config.clazz = NSStringFromClass(clazz);\n    [config registerMethods];\n    [_moduleMap setValue:config forKey:name];\n    [_moduleLock unlock];\n    \n    return name;\n}\n```\n\n注册 Moudle 的`registerMethods`方法与注册 Component 是一样的，都是将方法注册到`WXInvocationConfig`中，`wx_export_method_sync_`前缀的同步方法注册到 syncMethods 中，`wx_export_method_`前缀的异步方法注册到 asyncMethods 中。再将 Moudle 的同步和异步方法取出来调用`registerComponents`注入到`JSContext`中\n\n```ObjC  \n{\n    dom =     (\n        addEventListener,\n        removeAllEventListeners,\n        addEvent,\n        removeElement,\n        getComponentRect,\n        updateFinish,\n        scrollToElement,\n        addRule,\n        updateAttrs,\n        addElement,\n        createFinish,\n        createBody,\n        updateStyle,\n        removeEvent,\n        refreshFinish,\n        moveElement\n    );\n}\n```\n\n这是`WXDomModule`中所有的方法，*Moudle 中的方法注册比 Component 更有意义，因为 Moudle 中基本上都是暴露给 Vue 调用的 Native 方法。*   \n**接下来我们来看一下 Moudle 的方法如何被调用以及 syncMethods 和 asyncMethods 有什么不同。**  \n在前面的`jsBridge`懒加载中，有一个注册方法是跟 Moudle 中方法有关的，Moudle 中的方法会在这个注册方法的回调中被 invoke，换言之，Vue 调用 Moudle 中的方法会在这个回调中被唤起  \n\n```ObjC  \n    [_jsBridge registerCallNativeModule:^NSInvocation*(NSString *instanceId, NSString *moduleName, NSString *methodName, NSArray *arguments, NSDictionary *options) {\n        \n        WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];\n        \n        if (!instance) {\n            WXLogInfo(@\"instance not found for callNativeModule:%@.%@, maybe already destroyed\", moduleName, methodName);\n            return nil;\n        }\n        \n        WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance];\n        if(![moduleName isEqualToString:@\"dom\"] && instance.needPrerender){\n            [WXPrerenderManager storePrerenderModuleTasks:method forUrl:instance.scriptURL.absoluteString];\n            return nil;\n        }\n        return [method invoke];\n    }];\n```\n\n在`WXModuleMethod`中可以看到`-(NSInvocation *)invoke`这个方法，Moudle 中的方法将会通过这个方法被 invoke\n\n```ObjC  \n\t\t...\n    \n    Class moduleClass =  [WXModuleFactory classWithModuleName:_moduleName];\n    if (!moduleClass) {\n        NSString *errorMessage = [NSString stringWithFormat:@\"Module：%@ doesn't exist, maybe it has not been registered\", _moduleName];\n        WX_MONITOR_FAIL(WXMTJSBridge, WX_ERR_INVOKE_NATIVE, errorMessage);\n        return nil;\n    }\n    \n    id<WXModuleProtocol> moduleInstance = [self.instance moduleForClass:moduleClass];\n    WXAssert(moduleInstance, @\"No instance found for module name:%@, class:%@\", _moduleName, moduleClass);\n    BOOL isSync = NO;\n    SEL selector = [WXModuleFactory selectorWithModuleName:self.moduleName methodName:self.methodName isSync:&isSync];\n   \n    if (![moduleInstance respondsToSelector:selector]) {\n        // if not implement the selector, then dispatch default module method\n        if ([self.methodName isEqualToString:@\"addEventListener\"]) {\n            [self.instance _addModuleEventObserversWithModuleMethod:self];\n        } else if ([self.methodName isEqualToString:@\"removeAllEventListeners\"]) {\n            [self.instance _removeModuleEventObserverWithModuleMethod:self];\n        } else {\n            NSString *errorMessage = [NSString stringWithFormat:@\"method：%@ for module:%@ doesn't exist, maybe it has not been registered\", self.methodName, _moduleName];\n            WX_MONITOR_FAIL(WXMTJSBridge, WX_ERR_INVOKE_NATIVE, errorMessage);\n        }\n        return nil;\n    }\n\t\n    [self commitModuleInvoke];\n    NSInvocation *invocation = [self invocationWithTarget:moduleInstance selector:selector];\n    \n    if (isSync) {\n        [invocation invoke];\n        return invocation;\n    } else {\n        [self _dispatchInvocation:invocation moduleInstance:moduleInstance];\n        return nil;\n    }\n```\n\n先通过 `WXModuleFactory` 拿到对应的方法 Selector，然后再拿到这个方法对应的 NSInvocation ，最后 invoke 这个 NSInvocation。对于 syncMethods 和 asyncMethods 有两种 invoke 方式。如果是 syncMethod 会直接 invoke ，如果是 asyncMethod，会将它派发到某个指定的线程中进行 invoke，这样做的好处是不会阻塞当前线程。到这里 Moudle 的大概的运行原理都清除了，不过还有一个问题，Moudle 的方法是怎么暴露给 Vue 的呢？  \n在 Moudle 中我们通过 Weex 提供的宏可以将方法暴露出来：\n\n```ObjC  \n#define WX_EXPORT_METHOD(method) WX_EXPORT_METHOD_INTERNAL(method,wx_export_method_)\n#define WX_EXPORT_METHOD_SYNC(method) WX_EXPORT_METHOD_INTERNAL(method,wx_export_method_sync_)\n```\n\n分别提供了 syncMethod 和 asyncMethod 的宏，展开其实是这样的\n\n```ObjC  \n#define WX_EXPORT_METHOD_INTERNAL(method, token) \\\n+ (NSString *)WX_CONCAT_WRAPPER(token, __LINE__) { \\\n    return NSStringFromSelector(method); \\\n}\n```  \n这里会自动将方法名和当前的行数拼成一个新的方法名，这样做的好处是可以保证方法的唯一性，例如 `WXDomModule` 中的 `createBody:` 方法利用宏暴露出来，最终展开形式是这样的  \n\n```ObjC  \n+ (NSString *)wx_export_method_40 { \\\n    return NSStringFromSelector(createBody:); \\\n}\n```  \n\n在`WXInvocationConfig`中调用`- (void)registerMethods`注册方法的时候，首先拿到当前 class 中所有的类方法**（宏包装成的方法，并不是实际要注册的方法）**，然后通过判断有无`wx_export_method_sync_`前缀和`wx_export_method_`前缀来判断是否为暴露的方法，然后再调用该类方法，获得最终的实例方法字符串\n\n```ObjC  \nmethod = ((NSString* (*)(id, SEL))[currentClass methodForSelector:selector])(currentClass, selector);\n```\n\n拿到需要注册的实例方法字符串，再将方法字符串注册到`WXInvocationConfig`的对应方法 map 中。  \n\n\n### 3. 组件：Handlers  \n\nHandlers 的注册和使用非常简单，直接将对应的 class 注册到 `WXHandlerFactory` map中\n\n```ObjC  \n[[WXHandlerFactory sharedInstance].handlers setObject:handler forKey:NSStringFromProtocol(protocol)];\n\n```\n\n需要使用的时候也非常简单粗暴，通过`WXHandlerFactory`的方法和相应的 protocol\n\n```ObjC  \n+ (id)handlerForProtocol:(Protocol *)\n{\n    id handler = [[WXHandlerFactory sharedInstance].handlers objectForKey:NSStringFromProtocol(protocol)];\n    return handler;\n}\n```\n\n直接拿出即可。\n \n\n\n\n\n","slug":"weex-2","published":1,"updated":"2017-11-06T11:50:06.629Z","_id":"cj9no6vma000ajaenaapqem8p","comments":1,"layout":"post","photos":[],"link":"","content":"<p>距离我写的上一篇文章 <a href=\"https://gaoshilei.com/2017/05/26/weex-1/\" target=\"_blank\" rel=\"external\">Weex从入门到超神（一）</a> 已经过了挺久了（惭愧而不失礼貌的微笑），起初写那篇文章的初衷是因为项目中使用到了 Weex ,所以准备对 Weex 做一个心得式的笔记，后来无意间发现<a href=\"http://www.jianshu.com/u/12201cdd5d7a\" target=\"_blank\" rel=\"external\">简书“霜神”</a>已经对 Weex 写过几篇剖析比较深刻的文章，还有其他一些原因（懒），所以就没有继续写下去。<br>最近由于Facebook的 <a href=\"https://github.com/facebook/react/blob/master/LICENSE\" target=\"_blank\" rel=\"external\">BSD license</a>，React 被前端社区的同学们推到了风口浪尖，React&amp;RN、Vue&amp;Weex 又成为了大家码前码后讨论的话题。Apache 社区还因为 Facebook 的 BSD license，全面封杀使用了 BSD license 的开源项目，貌似一切都很精彩，迫于前端同(da)学(lao)的淫威还有社区的强烈谴责，上周 Facebook 终于认怂了，承诺这周将 React 以及 gayhub 上面的其他几个项目的开源协议从 BSD 改成 MIT，下图是我脑补的场景：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/FA269E01D9C3794449AA6748EA6280C6.png\" alt=\"\"><br>鉴于对于项目中使用 Weex 的一些经验和心得，还是希望写出来和大家一起分享。<br><a id=\"more\"></a></p>\n<h2 id=\"应用层核心组件\"><a href=\"#应用层核心组件\" class=\"headerlink\" title=\"应用层核心组件\"></a>应用层核心组件</h2><p>Weex 运行时会先注入一段位于 <code>pre-build</code> 下的 <code>native-bundle-main.js</code> 代码。不过在注入这段代码之前会先注册一些默认的 <code>Component</code>、<code>Module</code>和<code>Handler</code>，<strong>这就是 Weex 与 Native 应用层交互最核心的部分</strong>，可以理解为“组件”。其中 Component 是为了映射 Html 的一些标签，Module 中是提供一些 Native 的一些方法供 Weex 调用，Handler 是一些协议的实现。  </p>\n<p><img src=\"http://oeat6c2zg.bkt.clouddn.com/weex-component.png\" alt=\"\">  </p>\n<p>注册完 Weex 默认的“组件” 之后，注入刚才那段 JS，这个时候 Vue 的标签和动作才能被 Weex 所识别和转换。<br><strong>为了便于下文的描述和理解，我把 Native 这边的 SDK 称作 Weex，前端的 Vue 和 Weex 库以及 Vue 编译后的 js 统称为 Vue</strong></p>\n<h3 id=\"1-组件：Component\"><a href=\"#1-组件：Component\" class=\"headerlink\" title=\"1. 组件：Component\"></a>1. 组件：Component</h3><p>目前 Weex 一共提供了26种 Component，比较常见的有 <code>div</code>、<code>image</code>、<code>scroller</code>… ，有些跟 html 标签重名，有些是 Weex 自定义的。Weex 注册的 Component 有两种类型，一类是有<br><code>{@&quot;append&quot;:@&quot;tree&quot;}</code>属性的标签，另一类是没有<code>{@&quot;append&quot;:@&quot;tree&quot;}</code>属性的标签。要搞清楚这两类标签有什么不同，我们就要看一下 Component 的注册的源码实现。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[WXComponentFactory registerComponent:name withClass:clazz withPros:properties];</div><div class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *dict = [WXComponentFactory componentMethodMapsWithName:name];</div><div class=\"line\">dict[<span class=\"string\">@\"type\"</span>] = name;</div><div class=\"line\"><span class=\"keyword\">if</span> (properties) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSMutableDictionary</span> *props = [properties mutableCopy];</div><div class=\"line\">    <span class=\"keyword\">if</span> ([dict[<span class=\"string\">@\"methods\"</span>] count]) &#123;</div><div class=\"line\">        [props addEntriesFromDictionary:dict];</div><div class=\"line\">    &#125;</div><div class=\"line\">    [[WXSDKManager bridgeMgr] registerComponents:@[props]];</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    [[WXSDKManager bridgeMgr] registerComponents:@[dict]];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先通过一个工厂类<code>WXComponentFactory</code>注册 Component，  </p>\n<blockquote>\n<p> 这个工厂类（单例）中管理了所有的 Component ，注册的每一个 Component 都会用一个对应的 <code>WXComponentConfig</code>来保存标签name、对应的class和属性，最后由<code>WXComponentFactory</code>来统一管理这些<code>WXComponentConfig</code>   </p>\n</blockquote>\n<p>这一步同时注册了 Component 中的 methods，关于 method 也有两类，一类是包含<code>wx_export_method_sync_</code>前缀的同步方法，另一类是包含<code>wx_export_method_</code>前缀的异步方法（<em>这两种方法有什么不同，后面会有介绍</em>）。在<code>WXComponentConfig</code>的父类<code>WXInvocationConfig</code>储存了 Component 的方法map:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *asyncMethods;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *syncMethods;</div></pre></td></tr></table></figure>\n<p>然后再从<code>WXComponentFactory</code>拿到对应 Component 的方法列表字典，需要注意的是这里拿到的方法列表只是<strong>异步方法</strong>，得到的是这样的字典：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    methods =     (</div><div class=\"line\">        resetLoadmore</div><div class=\"line\">    );</div><div class=\"line\">    type = scroller;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不过大部分 Component 并没有<code>wx_export</code>前缀的 method，所以很多这里拿到的方法都为空。<br>最后也是最关键的一步，要将 Component 注册到<code>WXBridgeContext</code>中。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.frameworkLoadFinished) &#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.jsBridge callJSMethod:method args:args];</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    [_methodQueue addObject:@&#123;<span class=\"string\">@\"method\"</span>:method, <span class=\"string\">@\"args\"</span>:args&#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后将 Component 注册到了<code>JSContext</code>中，</p>\n<blockquote>\n<p> 还记得文章开头介绍的<code>native-bundle-main.js</code>吗？这里的注册调用了js中的<code>registerComponents</code>方法，这个 Component 与 Vue 就联系起来了，在 Vue 就可以使用这个 Component。</p>\n</blockquote>\n<p>并且从上面的这段代码可以看出来，Component 的注册操作是在 JSFramework 加载完成才会进行，如果<code>native-bundle-main.js</code>没有加载完成，所有的 Component 的方法注册操作都会被加到队列中等待。其中的第二个参数<code>args</code>就是上面我们拿到的字典。不过有属性的 和没属性的有点区别，有属性的会将属性添加到之前拿到的字典中作为<code>args</code>再去注册。<br>要搞清楚这个属性干嘛的，我们先看一下<code>WXComponentManager</code>中的相关源码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)_recursivelyAddComponent:(<span class=\"built_in\">NSDictionary</span> *)componentData toSupercomponent:(WXComponent *)supercomponent atIndex:(<span class=\"built_in\">NSInteger</span>)index appendingInTree:(<span class=\"built_in\">BOOL</span>)appendingInTree &#123;</div><div class=\"line\">\t\t...    </div><div class=\"line\">    <span class=\"built_in\">BOOL</span> appendTree = !appendingInTree &amp;&amp; [component.attributes[<span class=\"string\">@\"append\"</span>] isEqualToString:<span class=\"string\">@\"tree\"</span>];</div><div class=\"line\">    <span class=\"comment\">// if ancestor is appending tree, child should not be laid out again even it is appending tree.</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"built_in\">NSDictionary</span> *subcomponentData <span class=\"keyword\">in</span> subcomponentsData)&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> _recursivelyAddComponent:subcomponentData toSupercomponent:component atIndex:<span class=\"number\">-1</span> appendingInTree:appendTree || appendingInTree];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (appendTree) &#123;</div><div class=\"line\">        <span class=\"comment\">// If appending tree，force layout in case of too much tasks piling up in syncQueue</span></div><div class=\"line\">        [<span class=\"keyword\">self</span> _layoutAndSyncUI];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法是 Vue 页面渲染时所调用的方法，这个方法会递归添加 Component，同时会向视图中添加与 Component 相对应的 UIView。从代码的后半部分可以看到，如果当前 Component 有<code>{@&quot;append&quot;:@&quot;tree&quot;}</code>属性并且它的父 Component 没有这个属性将会强制对页面进行重新布局。可以看到这样做是为了防止UI绘制任务太多堆积在一起影响同步队列任务的执行。    </p>\n<p>搞清楚了 Component 的注册机制，下面重点扒一下 Component 的运行原理：Vue 标签是如何加载以及渲染到视图上的。<br>从刚才的注册过程中发现，最后一步是通过<code>_jsBridge</code>调用<code>callJSMethod</code>这个方法来注册的，而且从<code>WXBridgeContext</code>中可以看到，这个<code>_jsBridge</code>就是<code>WXJSCoreBridge</code>的实例。<code>WXJSCoreBridge</code>可以认为是 Weex 与 Vue 进行通信的最底层的部分。在调用<code>callJSMethod</code>方法之前，<code>_jsBridge</code>向 JavaScriptCore 中注册了很多全局 function，因为<code>jsBridge</code>是懒加载的，所以这些操作只会执行一次，具体请看精简后的源码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">  [_jsBridge registerCallNative:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instance, <span class=\"built_in\">NSArray</span> *tasks, <span class=\"built_in\">NSString</span> *callback) &#123;\t</div><div class=\"line\">...    </div><div class=\"line\">&#125;];</div><div class=\"line\">  [_jsBridge registerCallAddElement:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId, <span class=\"built_in\">NSString</span> *parentRef, <span class=\"built_in\">NSDictionary</span> *elementData, <span class=\"built_in\">NSInteger</span> index) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallCreateBody:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId, <span class=\"built_in\">NSDictionary</span> *bodyData) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallRemoveElement:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId, <span class=\"built_in\">NSString</span> *ref) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallMoveElement:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId,<span class=\"built_in\">NSString</span> *ref,<span class=\"built_in\">NSString</span> *parentRef,<span class=\"built_in\">NSInteger</span> index) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallUpdateAttrs:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId,<span class=\"built_in\">NSString</span> *ref,<span class=\"built_in\">NSDictionary</span> *attrsData) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallUpdateStyle:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId,<span class=\"built_in\">NSString</span> *ref,<span class=\"built_in\">NSDictionary</span> *stylesData) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallAddEvent:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId,<span class=\"built_in\">NSString</span> *ref,<span class=\"built_in\">NSString</span> *event) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallRemoveEvent:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId,<span class=\"built_in\">NSString</span> *ref,<span class=\"built_in\">NSString</span> *event) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallCreateFinish:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId) &#123;</div><div class=\"line\">  \t...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallNativeModule:^<span class=\"built_in\">NSInvocation</span>*(<span class=\"built_in\">NSString</span> *instanceId, <span class=\"built_in\">NSString</span> *moduleName, <span class=\"built_in\">NSString</span> *methodName, <span class=\"built_in\">NSArray</span> *arguments, <span class=\"built_in\">NSDictionary</span> *options) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallNativeComponent:^<span class=\"keyword\">void</span>(<span class=\"built_in\">NSString</span> *instanceId, <span class=\"built_in\">NSString</span> *componentRef, <span class=\"built_in\">NSString</span> *methodName, <span class=\"built_in\">NSArray</span> *args, <span class=\"built_in\">NSDictionary</span> *options) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div></pre></td></tr></table></figure>\n<p>从这些方法名看，大多数都是一些与 Dom 更新相关的方法，我们在<code>WXJSCoreBridge</code>中更细致的看一下是怎么实现的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)registerCallAddElement:(WXJSCallAddElement)callAddElement</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> callAddElementBlock = ^(JSValue *instanceId, JSValue *ref, JSValue *element, JSValue *index, JSValue *ifCallback) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">NSString</span> *instanceIdString = [instanceId toString];</div><div class=\"line\">        <span class=\"built_in\">NSDictionary</span> *componentData = [element toDictionary];</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *parentRef = [ref toString];</div><div class=\"line\">        <span class=\"built_in\">NSInteger</span> insertIndex = [[index toNumber] integerValue];</div><div class=\"line\">        [WXTracingManager startTracingWithInstanceId:instanceIdString ref:componentData[<span class=\"string\">@\"ref\"</span>] className:<span class=\"literal\">nil</span> name:WXTJSCall phase:WXTracingBegin functionName:<span class=\"string\">@\"addElement\"</span> options:<span class=\"literal\">nil</span>];</div><div class=\"line\">         WXLogDebug(<span class=\"string\">@\"callAddElement...%@, %@, %@, %ld\"</span>, instanceIdString, parentRef, componentData, (<span class=\"keyword\">long</span>)insertIndex);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> [JSValue valueWithInt32:(int32_t)callAddElement(instanceIdString, parentRef, componentData, insertIndex) inContext:[JSContext currentContext]];</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    _jsContext[<span class=\"string\">@\"callAddElement\"</span>] = callAddElementBlock;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是一个更新 Dom 添加 UIView 的方法，这里需要把 Native 的方法暴露给 JS 调用。但是有一个问题：  </p>\n<blockquote>\n<p> OC 的方法参数格式和 JS 的不一样，不能直接提供给 JS 调用。  </p>\n</blockquote>\n<p>所以这里用了两个 Block 嵌套的方式，在 JS 中调用方法时会先 invoke 里层的 callAddElementBlock，这层 Block 将 JS 传进来的参数转换成 OC 的参数格式，再执行 callAddElement 并返回一个 JSValue 给 JS，callAddElement Block中是在<code>WXComponentManager</code>中完成的关于 Component 的一些操作，这在上面介绍 Component 包含 <code>tree</code>属性问题时已经介绍过了。<br>至此，简单来说就是：Weex 的页面渲染是通过先向 JSCore 注入方法，Vue 加载完成就可以调用这些方法并传入相应的参数完成 Component 的渲染和视图的更新。<br>要注意，每一个 <code>WXSDKInstance</code> 对应一个 Vue 页面，Vue 加载之前就会创建对应的 WXSDKInstance，所有的 Component 都继承自<code>WXComponent</code>，他们的初始化方法都是</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">instancetype</span>)initWithRef:(<span class=\"built_in\">NSString</span> *)ref</div><div class=\"line\">                      type:(<span class=\"built_in\">NSString</span> *)type</div><div class=\"line\">                    styles:(<span class=\"built_in\">NSDictionary</span> *)styles</div><div class=\"line\">                attributes:(<span class=\"built_in\">NSDictionary</span> *)attributes</div><div class=\"line\">                    events:(<span class=\"built_in\">NSArray</span> *)events</div><div class=\"line\">              weexInstance:(WXSDKInstance *)weexInstance</div></pre></td></tr></table></figure>\n<p>这个方法会在 JS 调用<code>callCreateBody</code>时被 invoke。 </p>\n<h3 id=\"2-组件：Module\"><a href=\"#2-组件：Module\" class=\"headerlink\" title=\"2. 组件：Module\"></a>2. 组件：Module</h3><p>Module 注册流程和 Component 基本一致，首先通过<code>WXModuleFactory</code>注册 Module</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)_registerModule:(<span class=\"built_in\">NSString</span> *)name withClass:(Class)clazz</div><div class=\"line\">&#123;</div><div class=\"line\">    WXAssert(name &amp;&amp; clazz, <span class=\"string\">@\"Fail to register the module, please check if the parameters are correct ！\"</span>);</div><div class=\"line\">    </div><div class=\"line\">    [_moduleLock lock];</div><div class=\"line\">    <span class=\"comment\">//allow to register module with the same name;</span></div><div class=\"line\">    WXModuleConfig *config = [[WXModuleConfig alloc] init];</div><div class=\"line\">    config.name = name;</div><div class=\"line\">    config.clazz = <span class=\"built_in\">NSStringFromClass</span>(clazz);</div><div class=\"line\">    [config registerMethods];</div><div class=\"line\">    [_moduleMap setValue:config forKey:name];</div><div class=\"line\">    [_moduleLock unlock];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注册 Moudle 的<code>registerMethods</code>方法与注册 Component 是一样的，都是将方法注册到<code>WXInvocationConfig</code>中，<code>wx_export_method_sync_</code>前缀的同步方法注册到 syncMethods 中，<code>wx_export_method_</code>前缀的异步方法注册到 asyncMethods 中。再将 Moudle 的同步和异步方法取出来调用<code>registerComponents</code>注入到<code>JSContext</code>中</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    dom =     (</div><div class=\"line\">        addEventListener,</div><div class=\"line\">        removeAllEventListeners,</div><div class=\"line\">        addEvent,</div><div class=\"line\">        removeElement,</div><div class=\"line\">        getComponentRect,</div><div class=\"line\">        updateFinish,</div><div class=\"line\">        scrollToElement,</div><div class=\"line\">        addRule,</div><div class=\"line\">        updateAttrs,</div><div class=\"line\">        addElement,</div><div class=\"line\">        createFinish,</div><div class=\"line\">        createBody,</div><div class=\"line\">        updateStyle,</div><div class=\"line\">        removeEvent,</div><div class=\"line\">        refreshFinish,</div><div class=\"line\">        moveElement</div><div class=\"line\">    );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是<code>WXDomModule</code>中所有的方法，<em>Moudle 中的方法注册比 Component 更有意义，因为 Moudle 中基本上都是暴露给 Vue 调用的 Native 方法。</em><br><strong>接下来我们来看一下 Moudle 的方法如何被调用以及 syncMethods 和 asyncMethods 有什么不同。</strong><br>在前面的<code>jsBridge</code>懒加载中，有一个注册方法是跟 Moudle 中方法有关的，Moudle 中的方法会在这个注册方法的回调中被 invoke，换言之，Vue 调用 Moudle 中的方法会在这个回调中被唤起  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">[_jsBridge registerCallNativeModule:^<span class=\"built_in\">NSInvocation</span>*(<span class=\"built_in\">NSString</span> *instanceId, <span class=\"built_in\">NSString</span> *moduleName, <span class=\"built_in\">NSString</span> *methodName, <span class=\"built_in\">NSArray</span> *arguments, <span class=\"built_in\">NSDictionary</span> *options) &#123;</div><div class=\"line\">    </div><div class=\"line\">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (!instance) &#123;</div><div class=\"line\">        WXLogInfo(<span class=\"string\">@\"instance not found for callNativeModule:%@.%@, maybe already destroyed\"</span>, moduleName, methodName);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance];</div><div class=\"line\">    <span class=\"keyword\">if</span>(![moduleName isEqualToString:<span class=\"string\">@\"dom\"</span>] &amp;&amp; instance.needPrerender)&#123;</div><div class=\"line\">        [WXPrerenderManager storePrerenderModuleTasks:method forUrl:instance.scriptURL.absoluteString];</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> [method invoke];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>在<code>WXModuleMethod</code>中可以看到<code>-(NSInvocation *)invoke</code>这个方法，Moudle 中的方法将会通过这个方法被 invoke</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">  </div><div class=\"line\">  Class moduleClass =  [WXModuleFactory classWithModuleName:_moduleName];</div><div class=\"line\">  <span class=\"keyword\">if</span> (!moduleClass) &#123;</div><div class=\"line\">      <span class=\"built_in\">NSString</span> *errorMessage = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Module：%@ doesn't exist, maybe it has not been registered\"</span>, _moduleName];</div><div class=\"line\">      WX_MONITOR_FAIL(WXMTJSBridge, WX_ERR_INVOKE_NATIVE, errorMessage);</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">id</span>&lt;WXModuleProtocol&gt; moduleInstance = [<span class=\"keyword\">self</span>.instance moduleForClass:moduleClass];</div><div class=\"line\">  WXAssert(moduleInstance, <span class=\"string\">@\"No instance found for module name:%@, class:%@\"</span>, _moduleName, moduleClass);</div><div class=\"line\">  <span class=\"built_in\">BOOL</span> isSync = <span class=\"literal\">NO</span>;</div><div class=\"line\">  SEL selector = [WXModuleFactory selectorWithModuleName:<span class=\"keyword\">self</span>.moduleName methodName:<span class=\"keyword\">self</span>.methodName isSync:&amp;isSync];</div><div class=\"line\"> </div><div class=\"line\">  <span class=\"keyword\">if</span> (![moduleInstance respondsToSelector:selector]) &#123;</div><div class=\"line\">      <span class=\"comment\">// if not implement the selector, then dispatch default module method</span></div><div class=\"line\">      <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.methodName isEqualToString:<span class=\"string\">@\"addEventListener\"</span>]) &#123;</div><div class=\"line\">          [<span class=\"keyword\">self</span>.instance _addModuleEventObserversWithModuleMethod:<span class=\"keyword\">self</span>];</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.methodName isEqualToString:<span class=\"string\">@\"removeAllEventListeners\"</span>]) &#123;</div><div class=\"line\">          [<span class=\"keyword\">self</span>.instance _removeModuleEventObserverWithModuleMethod:<span class=\"keyword\">self</span>];</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"built_in\">NSString</span> *errorMessage = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"method：%@ for module:%@ doesn't exist, maybe it has not been registered\"</span>, <span class=\"keyword\">self</span>.methodName, _moduleName];</div><div class=\"line\">          WX_MONITOR_FAIL(WXMTJSBridge, WX_ERR_INVOKE_NATIVE, errorMessage);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">\t</div><div class=\"line\">  [<span class=\"keyword\">self</span> commitModuleInvoke];</div><div class=\"line\">  <span class=\"built_in\">NSInvocation</span> *invocation = [<span class=\"keyword\">self</span> invocationWithTarget:moduleInstance selector:selector];</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">if</span> (isSync) &#123;</div><div class=\"line\">      [invocation invoke];</div><div class=\"line\">      <span class=\"keyword\">return</span> invocation;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      [<span class=\"keyword\">self</span> _dispatchInvocation:invocation moduleInstance:moduleInstance];</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>先通过 <code>WXModuleFactory</code> 拿到对应的方法 Selector，然后再拿到这个方法对应的 NSInvocation ，最后 invoke 这个 NSInvocation。对于 syncMethods 和 asyncMethods 有两种 invoke 方式。如果是 syncMethod 会直接 invoke ，如果是 asyncMethod，会将它派发到某个指定的线程中进行 invoke，这样做的好处是不会阻塞当前线程。到这里 Moudle 的大概的运行原理都清除了，不过还有一个问题，Moudle 的方法是怎么暴露给 Vue 的呢？<br>在 Moudle 中我们通过 Weex 提供的宏可以将方法暴露出来：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#define WX_EXPORT_METHOD(method) WX_EXPORT_METHOD_INTERNAL(method,wx_export_method_)</span></div><div class=\"line\"><span class=\"meta\">#define WX_EXPORT_METHOD_SYNC(method) WX_EXPORT_METHOD_INTERNAL(method,wx_export_method_sync_)</span></div></pre></td></tr></table></figure>\n<p>分别提供了 syncMethod 和 asyncMethod 的宏，展开其实是这样的</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#define WX_EXPORT_METHOD_INTERNAL(method, token) \\</span></div><div class=\"line\">+ (<span class=\"built_in\">NSString</span> *)WX_CONCAT_WRAPPER(token, __LINE__) &#123; \\</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">NSStringFromSelector</span>(method); \\</div><div class=\"line\">&#125;</div><div class=\"line\">```  </div><div class=\"line\">这里会自动将方法名和当前的行数拼成一个新的方法名，这样做的好处是可以保证方法的唯一性，例如 `WXDomModule` 中的 `createBody:` 方法利用宏暴露出来，最终展开形式是这样的  </div><div class=\"line\"></div><div class=\"line\">```ObjC  </div><div class=\"line\">+ (<span class=\"built_in\">NSString</span> *)wx_export_method_40 &#123; \\</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">NSStringFromSelector</span>(createBody:); \\</div><div class=\"line\">&#125;</div><div class=\"line\">```  </div><div class=\"line\"></div><div class=\"line\">在`WXInvocationConfig`中调用`- (<span class=\"keyword\">void</span>)registerMethods`注册方法的时候，首先拿到当前 <span class=\"keyword\">class</span> 中所有的类方法**（宏包装成的方法，并不是实际要注册的方法）**，然后通过判断有无`wx_export_method_sync_`前缀和`wx_export_method_`前缀来判断是否为暴露的方法，然后再调用该类方法，获得最终的实例方法字符串</div><div class=\"line\"></div><div class=\"line\">```ObjC  </div><div class=\"line\">method = ((<span class=\"built_in\">NSString</span>* (*)(<span class=\"keyword\">id</span>, SEL))[currentClass methodForSelector:selector])(currentClass, selector);</div></pre></td></tr></table></figure>\n<p>拿到需要注册的实例方法字符串，再将方法字符串注册到<code>WXInvocationConfig</code>的对应方法 map 中。  </p>\n<h3 id=\"3-组件：Handlers\"><a href=\"#3-组件：Handlers\" class=\"headerlink\" title=\"3. 组件：Handlers\"></a>3. 组件：Handlers</h3><p>Handlers 的注册和使用非常简单，直接将对应的 class 注册到 <code>WXHandlerFactory</code> map中</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[WXHandlerFactory sharedInstance].handlers setObject:handler forKey:<span class=\"built_in\">NSStringFromProtocol</span>(protocol)];</div></pre></td></tr></table></figure>\n<p>需要使用的时候也非常简单粗暴，通过<code>WXHandlerFactory</code>的方法和相应的 protocol</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">id</span>)handlerForProtocol:(Protocol *)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> handler = [[WXHandlerFactory sharedInstance].handlers objectForKey:<span class=\"built_in\">NSStringFromProtocol</span>(protocol)];</div><div class=\"line\">    <span class=\"keyword\">return</span> handler;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>直接拿出即可。</p>\n","excerpt":"<p>距离我写的上一篇文章 <a href=\"https://gaoshilei.com/2017/05/26/weex-1/\">Weex从入门到超神（一）</a> 已经过了挺久了（惭愧而不失礼貌的微笑），起初写那篇文章的初衷是因为项目中使用到了 Weex ,所以准备对 Weex 做一个心得式的笔记，后来无意间发现<a href=\"http://www.jianshu.com/u/12201cdd5d7a\">简书“霜神”</a>已经对 Weex 写过几篇剖析比较深刻的文章，还有其他一些原因（懒），所以就没有继续写下去。<br>最近由于Facebook的 <a href=\"https://github.com/facebook/react/blob/master/LICENSE\">BSD license</a>，React 被前端社区的同学们推到了风口浪尖，React&amp;RN、Vue&amp;Weex 又成为了大家码前码后讨论的话题。Apache 社区还因为 Facebook 的 BSD license，全面封杀使用了 BSD license 的开源项目，貌似一切都很精彩，迫于前端同(da)学(lao)的淫威还有社区的强烈谴责，上周 Facebook 终于认怂了，承诺这周将 React 以及 gayhub 上面的其他几个项目的开源协议从 BSD 改成 MIT，下图是我脑补的场景：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/FA269E01D9C3794449AA6748EA6280C6.png\" alt=\"\"><br>鉴于对于项目中使用 Weex 的一些经验和心得，还是希望写出来和大家一起分享。<br>","more":"</p>\n<h2 id=\"应用层核心组件\"><a href=\"#应用层核心组件\" class=\"headerlink\" title=\"应用层核心组件\"></a>应用层核心组件</h2><p>Weex 运行时会先注入一段位于 <code>pre-build</code> 下的 <code>native-bundle-main.js</code> 代码。不过在注入这段代码之前会先注册一些默认的 <code>Component</code>、<code>Module</code>和<code>Handler</code>，<strong>这就是 Weex 与 Native 应用层交互最核心的部分</strong>，可以理解为“组件”。其中 Component 是为了映射 Html 的一些标签，Module 中是提供一些 Native 的一些方法供 Weex 调用，Handler 是一些协议的实现。  </p>\n<p><img src=\"http://oeat6c2zg.bkt.clouddn.com/weex-component.png\" alt=\"\">  </p>\n<p>注册完 Weex 默认的“组件” 之后，注入刚才那段 JS，这个时候 Vue 的标签和动作才能被 Weex 所识别和转换。<br><strong>为了便于下文的描述和理解，我把 Native 这边的 SDK 称作 Weex，前端的 Vue 和 Weex 库以及 Vue 编译后的 js 统称为 Vue</strong></p>\n<h3 id=\"1-组件：Component\"><a href=\"#1-组件：Component\" class=\"headerlink\" title=\"1. 组件：Component\"></a>1. 组件：Component</h3><p>目前 Weex 一共提供了26种 Component，比较常见的有 <code>div</code>、<code>image</code>、<code>scroller</code>… ，有些跟 html 标签重名，有些是 Weex 自定义的。Weex 注册的 Component 有两种类型，一类是有<br><code>{@&quot;append&quot;:@&quot;tree&quot;}</code>属性的标签，另一类是没有<code>{@&quot;append&quot;:@&quot;tree&quot;}</code>属性的标签。要搞清楚这两类标签有什么不同，我们就要看一下 Component 的注册的源码实现。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[WXComponentFactory registerComponent:name withClass:clazz withPros:properties];</div><div class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *dict = [WXComponentFactory componentMethodMapsWithName:name];</div><div class=\"line\">dict[<span class=\"string\">@\"type\"</span>] = name;</div><div class=\"line\"><span class=\"keyword\">if</span> (properties) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSMutableDictionary</span> *props = [properties mutableCopy];</div><div class=\"line\">    <span class=\"keyword\">if</span> ([dict[<span class=\"string\">@\"methods\"</span>] count]) &#123;</div><div class=\"line\">        [props addEntriesFromDictionary:dict];</div><div class=\"line\">    &#125;</div><div class=\"line\">    [[WXSDKManager bridgeMgr] registerComponents:@[props]];</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    [[WXSDKManager bridgeMgr] registerComponents:@[dict]];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先通过一个工厂类<code>WXComponentFactory</code>注册 Component，  </p>\n<blockquote>\n<p> 这个工厂类（单例）中管理了所有的 Component ，注册的每一个 Component 都会用一个对应的 <code>WXComponentConfig</code>来保存标签name、对应的class和属性，最后由<code>WXComponentFactory</code>来统一管理这些<code>WXComponentConfig</code>   </p>\n</blockquote>\n<p>这一步同时注册了 Component 中的 methods，关于 method 也有两类，一类是包含<code>wx_export_method_sync_</code>前缀的同步方法，另一类是包含<code>wx_export_method_</code>前缀的异步方法（<em>这两种方法有什么不同，后面会有介绍</em>）。在<code>WXComponentConfig</code>的父类<code>WXInvocationConfig</code>储存了 Component 的方法map:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *asyncMethods;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *syncMethods;</div></pre></td></tr></table></figure>\n<p>然后再从<code>WXComponentFactory</code>拿到对应 Component 的方法列表字典，需要注意的是这里拿到的方法列表只是<strong>异步方法</strong>，得到的是这样的字典：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    methods =     (</div><div class=\"line\">        resetLoadmore</div><div class=\"line\">    );</div><div class=\"line\">    type = scroller;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不过大部分 Component 并没有<code>wx_export</code>前缀的 method，所以很多这里拿到的方法都为空。<br>最后也是最关键的一步，要将 Component 注册到<code>WXBridgeContext</code>中。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.frameworkLoadFinished) &#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.jsBridge callJSMethod:method args:args];</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    [_methodQueue addObject:@&#123;<span class=\"string\">@\"method\"</span>:method, <span class=\"string\">@\"args\"</span>:args&#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后将 Component 注册到了<code>JSContext</code>中，</p>\n<blockquote>\n<p> 还记得文章开头介绍的<code>native-bundle-main.js</code>吗？这里的注册调用了js中的<code>registerComponents</code>方法，这个 Component 与 Vue 就联系起来了，在 Vue 就可以使用这个 Component。</p>\n</blockquote>\n<p>并且从上面的这段代码可以看出来，Component 的注册操作是在 JSFramework 加载完成才会进行，如果<code>native-bundle-main.js</code>没有加载完成，所有的 Component 的方法注册操作都会被加到队列中等待。其中的第二个参数<code>args</code>就是上面我们拿到的字典。不过有属性的 和没属性的有点区别，有属性的会将属性添加到之前拿到的字典中作为<code>args</code>再去注册。<br>要搞清楚这个属性干嘛的，我们先看一下<code>WXComponentManager</code>中的相关源码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)_recursivelyAddComponent:(<span class=\"built_in\">NSDictionary</span> *)componentData toSupercomponent:(WXComponent *)supercomponent atIndex:(<span class=\"built_in\">NSInteger</span>)index appendingInTree:(<span class=\"built_in\">BOOL</span>)appendingInTree &#123;</div><div class=\"line\">\t\t...    </div><div class=\"line\">    <span class=\"built_in\">BOOL</span> appendTree = !appendingInTree &amp;&amp; [component.attributes[<span class=\"string\">@\"append\"</span>] isEqualToString:<span class=\"string\">@\"tree\"</span>];</div><div class=\"line\">    <span class=\"comment\">// if ancestor is appending tree, child should not be laid out again even it is appending tree.</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"built_in\">NSDictionary</span> *subcomponentData <span class=\"keyword\">in</span> subcomponentsData)&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> _recursivelyAddComponent:subcomponentData toSupercomponent:component atIndex:<span class=\"number\">-1</span> appendingInTree:appendTree || appendingInTree];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (appendTree) &#123;</div><div class=\"line\">        <span class=\"comment\">// If appending tree，force layout in case of too much tasks piling up in syncQueue</span></div><div class=\"line\">        [<span class=\"keyword\">self</span> _layoutAndSyncUI];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法是 Vue 页面渲染时所调用的方法，这个方法会递归添加 Component，同时会向视图中添加与 Component 相对应的 UIView。从代码的后半部分可以看到，如果当前 Component 有<code>{@&quot;append&quot;:@&quot;tree&quot;}</code>属性并且它的父 Component 没有这个属性将会强制对页面进行重新布局。可以看到这样做是为了防止UI绘制任务太多堆积在一起影响同步队列任务的执行。    </p>\n<p>搞清楚了 Component 的注册机制，下面重点扒一下 Component 的运行原理：Vue 标签是如何加载以及渲染到视图上的。<br>从刚才的注册过程中发现，最后一步是通过<code>_jsBridge</code>调用<code>callJSMethod</code>这个方法来注册的，而且从<code>WXBridgeContext</code>中可以看到，这个<code>_jsBridge</code>就是<code>WXJSCoreBridge</code>的实例。<code>WXJSCoreBridge</code>可以认为是 Weex 与 Vue 进行通信的最底层的部分。在调用<code>callJSMethod</code>方法之前，<code>_jsBridge</code>向 JavaScriptCore 中注册了很多全局 function，因为<code>jsBridge</code>是懒加载的，所以这些操作只会执行一次，具体请看精简后的源码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">  [_jsBridge registerCallNative:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instance, <span class=\"built_in\">NSArray</span> *tasks, <span class=\"built_in\">NSString</span> *callback) &#123;\t</div><div class=\"line\">...    </div><div class=\"line\">&#125;];</div><div class=\"line\">  [_jsBridge registerCallAddElement:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId, <span class=\"built_in\">NSString</span> *parentRef, <span class=\"built_in\">NSDictionary</span> *elementData, <span class=\"built_in\">NSInteger</span> index) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallCreateBody:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId, <span class=\"built_in\">NSDictionary</span> *bodyData) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallRemoveElement:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId, <span class=\"built_in\">NSString</span> *ref) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallMoveElement:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId,<span class=\"built_in\">NSString</span> *ref,<span class=\"built_in\">NSString</span> *parentRef,<span class=\"built_in\">NSInteger</span> index) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallUpdateAttrs:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId,<span class=\"built_in\">NSString</span> *ref,<span class=\"built_in\">NSDictionary</span> *attrsData) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallUpdateStyle:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId,<span class=\"built_in\">NSString</span> *ref,<span class=\"built_in\">NSDictionary</span> *stylesData) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallAddEvent:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId,<span class=\"built_in\">NSString</span> *ref,<span class=\"built_in\">NSString</span> *event) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallRemoveEvent:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId,<span class=\"built_in\">NSString</span> *ref,<span class=\"built_in\">NSString</span> *event) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallCreateFinish:^<span class=\"built_in\">NSInteger</span>(<span class=\"built_in\">NSString</span> *instanceId) &#123;</div><div class=\"line\">  \t...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallNativeModule:^<span class=\"built_in\">NSInvocation</span>*(<span class=\"built_in\">NSString</span> *instanceId, <span class=\"built_in\">NSString</span> *moduleName, <span class=\"built_in\">NSString</span> *methodName, <span class=\"built_in\">NSArray</span> *arguments, <span class=\"built_in\">NSDictionary</span> *options) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div><div class=\"line\">  </div><div class=\"line\">  [_jsBridge registerCallNativeComponent:^<span class=\"keyword\">void</span>(<span class=\"built_in\">NSString</span> *instanceId, <span class=\"built_in\">NSString</span> *componentRef, <span class=\"built_in\">NSString</span> *methodName, <span class=\"built_in\">NSArray</span> *args, <span class=\"built_in\">NSDictionary</span> *options) &#123;</div><div class=\"line\">...</div><div class=\"line\">  &#125;];</div></pre></td></tr></table></figure>\n<p>从这些方法名看，大多数都是一些与 Dom 更新相关的方法，我们在<code>WXJSCoreBridge</code>中更细致的看一下是怎么实现的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)registerCallAddElement:(WXJSCallAddElement)callAddElement</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> callAddElementBlock = ^(JSValue *instanceId, JSValue *ref, JSValue *element, JSValue *index, JSValue *ifCallback) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">NSString</span> *instanceIdString = [instanceId toString];</div><div class=\"line\">        <span class=\"built_in\">NSDictionary</span> *componentData = [element toDictionary];</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *parentRef = [ref toString];</div><div class=\"line\">        <span class=\"built_in\">NSInteger</span> insertIndex = [[index toNumber] integerValue];</div><div class=\"line\">        [WXTracingManager startTracingWithInstanceId:instanceIdString ref:componentData[<span class=\"string\">@\"ref\"</span>] className:<span class=\"literal\">nil</span> name:WXTJSCall phase:WXTracingBegin functionName:<span class=\"string\">@\"addElement\"</span> options:<span class=\"literal\">nil</span>];</div><div class=\"line\">         WXLogDebug(<span class=\"string\">@\"callAddElement...%@, %@, %@, %ld\"</span>, instanceIdString, parentRef, componentData, (<span class=\"keyword\">long</span>)insertIndex);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> [JSValue valueWithInt32:(int32_t)callAddElement(instanceIdString, parentRef, componentData, insertIndex) inContext:[JSContext currentContext]];</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    _jsContext[<span class=\"string\">@\"callAddElement\"</span>] = callAddElementBlock;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是一个更新 Dom 添加 UIView 的方法，这里需要把 Native 的方法暴露给 JS 调用。但是有一个问题：  </p>\n<blockquote>\n<p> OC 的方法参数格式和 JS 的不一样，不能直接提供给 JS 调用。  </p>\n</blockquote>\n<p>所以这里用了两个 Block 嵌套的方式，在 JS 中调用方法时会先 invoke 里层的 callAddElementBlock，这层 Block 将 JS 传进来的参数转换成 OC 的参数格式，再执行 callAddElement 并返回一个 JSValue 给 JS，callAddElement Block中是在<code>WXComponentManager</code>中完成的关于 Component 的一些操作，这在上面介绍 Component 包含 <code>tree</code>属性问题时已经介绍过了。<br>至此，简单来说就是：Weex 的页面渲染是通过先向 JSCore 注入方法，Vue 加载完成就可以调用这些方法并传入相应的参数完成 Component 的渲染和视图的更新。<br>要注意，每一个 <code>WXSDKInstance</code> 对应一个 Vue 页面，Vue 加载之前就会创建对应的 WXSDKInstance，所有的 Component 都继承自<code>WXComponent</code>，他们的初始化方法都是</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">instancetype</span>)initWithRef:(<span class=\"built_in\">NSString</span> *)ref</div><div class=\"line\">                      type:(<span class=\"built_in\">NSString</span> *)type</div><div class=\"line\">                    styles:(<span class=\"built_in\">NSDictionary</span> *)styles</div><div class=\"line\">                attributes:(<span class=\"built_in\">NSDictionary</span> *)attributes</div><div class=\"line\">                    events:(<span class=\"built_in\">NSArray</span> *)events</div><div class=\"line\">              weexInstance:(WXSDKInstance *)weexInstance</div></pre></td></tr></table></figure>\n<p>这个方法会在 JS 调用<code>callCreateBody</code>时被 invoke。 </p>\n<h3 id=\"2-组件：Module\"><a href=\"#2-组件：Module\" class=\"headerlink\" title=\"2. 组件：Module\"></a>2. 组件：Module</h3><p>Module 注册流程和 Component 基本一致，首先通过<code>WXModuleFactory</code>注册 Module</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)_registerModule:(<span class=\"built_in\">NSString</span> *)name withClass:(Class)clazz</div><div class=\"line\">&#123;</div><div class=\"line\">    WXAssert(name &amp;&amp; clazz, <span class=\"string\">@\"Fail to register the module, please check if the parameters are correct ！\"</span>);</div><div class=\"line\">    </div><div class=\"line\">    [_moduleLock lock];</div><div class=\"line\">    <span class=\"comment\">//allow to register module with the same name;</span></div><div class=\"line\">    WXModuleConfig *config = [[WXModuleConfig alloc] init];</div><div class=\"line\">    config.name = name;</div><div class=\"line\">    config.clazz = <span class=\"built_in\">NSStringFromClass</span>(clazz);</div><div class=\"line\">    [config registerMethods];</div><div class=\"line\">    [_moduleMap setValue:config forKey:name];</div><div class=\"line\">    [_moduleLock unlock];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注册 Moudle 的<code>registerMethods</code>方法与注册 Component 是一样的，都是将方法注册到<code>WXInvocationConfig</code>中，<code>wx_export_method_sync_</code>前缀的同步方法注册到 syncMethods 中，<code>wx_export_method_</code>前缀的异步方法注册到 asyncMethods 中。再将 Moudle 的同步和异步方法取出来调用<code>registerComponents</code>注入到<code>JSContext</code>中</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    dom =     (</div><div class=\"line\">        addEventListener,</div><div class=\"line\">        removeAllEventListeners,</div><div class=\"line\">        addEvent,</div><div class=\"line\">        removeElement,</div><div class=\"line\">        getComponentRect,</div><div class=\"line\">        updateFinish,</div><div class=\"line\">        scrollToElement,</div><div class=\"line\">        addRule,</div><div class=\"line\">        updateAttrs,</div><div class=\"line\">        addElement,</div><div class=\"line\">        createFinish,</div><div class=\"line\">        createBody,</div><div class=\"line\">        updateStyle,</div><div class=\"line\">        removeEvent,</div><div class=\"line\">        refreshFinish,</div><div class=\"line\">        moveElement</div><div class=\"line\">    );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是<code>WXDomModule</code>中所有的方法，<em>Moudle 中的方法注册比 Component 更有意义，因为 Moudle 中基本上都是暴露给 Vue 调用的 Native 方法。</em><br><strong>接下来我们来看一下 Moudle 的方法如何被调用以及 syncMethods 和 asyncMethods 有什么不同。</strong><br>在前面的<code>jsBridge</code>懒加载中，有一个注册方法是跟 Moudle 中方法有关的，Moudle 中的方法会在这个注册方法的回调中被 invoke，换言之，Vue 调用 Moudle 中的方法会在这个回调中被唤起  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">[_jsBridge registerCallNativeModule:^<span class=\"built_in\">NSInvocation</span>*(<span class=\"built_in\">NSString</span> *instanceId, <span class=\"built_in\">NSString</span> *moduleName, <span class=\"built_in\">NSString</span> *methodName, <span class=\"built_in\">NSArray</span> *arguments, <span class=\"built_in\">NSDictionary</span> *options) &#123;</div><div class=\"line\">    </div><div class=\"line\">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (!instance) &#123;</div><div class=\"line\">        WXLogInfo(<span class=\"string\">@\"instance not found for callNativeModule:%@.%@, maybe already destroyed\"</span>, moduleName, methodName);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance];</div><div class=\"line\">    <span class=\"keyword\">if</span>(![moduleName isEqualToString:<span class=\"string\">@\"dom\"</span>] &amp;&amp; instance.needPrerender)&#123;</div><div class=\"line\">        [WXPrerenderManager storePrerenderModuleTasks:method forUrl:instance.scriptURL.absoluteString];</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> [method invoke];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>在<code>WXModuleMethod</code>中可以看到<code>-(NSInvocation *)invoke</code>这个方法，Moudle 中的方法将会通过这个方法被 invoke</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">  </div><div class=\"line\">  Class moduleClass =  [WXModuleFactory classWithModuleName:_moduleName];</div><div class=\"line\">  <span class=\"keyword\">if</span> (!moduleClass) &#123;</div><div class=\"line\">      <span class=\"built_in\">NSString</span> *errorMessage = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Module：%@ doesn't exist, maybe it has not been registered\"</span>, _moduleName];</div><div class=\"line\">      WX_MONITOR_FAIL(WXMTJSBridge, WX_ERR_INVOKE_NATIVE, errorMessage);</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">id</span>&lt;WXModuleProtocol&gt; moduleInstance = [<span class=\"keyword\">self</span>.instance moduleForClass:moduleClass];</div><div class=\"line\">  WXAssert(moduleInstance, <span class=\"string\">@\"No instance found for module name:%@, class:%@\"</span>, _moduleName, moduleClass);</div><div class=\"line\">  <span class=\"built_in\">BOOL</span> isSync = <span class=\"literal\">NO</span>;</div><div class=\"line\">  SEL selector = [WXModuleFactory selectorWithModuleName:<span class=\"keyword\">self</span>.moduleName methodName:<span class=\"keyword\">self</span>.methodName isSync:&amp;isSync];</div><div class=\"line\"> </div><div class=\"line\">  <span class=\"keyword\">if</span> (![moduleInstance respondsToSelector:selector]) &#123;</div><div class=\"line\">      <span class=\"comment\">// if not implement the selector, then dispatch default module method</span></div><div class=\"line\">      <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.methodName isEqualToString:<span class=\"string\">@\"addEventListener\"</span>]) &#123;</div><div class=\"line\">          [<span class=\"keyword\">self</span>.instance _addModuleEventObserversWithModuleMethod:<span class=\"keyword\">self</span>];</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.methodName isEqualToString:<span class=\"string\">@\"removeAllEventListeners\"</span>]) &#123;</div><div class=\"line\">          [<span class=\"keyword\">self</span>.instance _removeModuleEventObserverWithModuleMethod:<span class=\"keyword\">self</span>];</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"built_in\">NSString</span> *errorMessage = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"method：%@ for module:%@ doesn't exist, maybe it has not been registered\"</span>, <span class=\"keyword\">self</span>.methodName, _moduleName];</div><div class=\"line\">          WX_MONITOR_FAIL(WXMTJSBridge, WX_ERR_INVOKE_NATIVE, errorMessage);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">\t</div><div class=\"line\">  [<span class=\"keyword\">self</span> commitModuleInvoke];</div><div class=\"line\">  <span class=\"built_in\">NSInvocation</span> *invocation = [<span class=\"keyword\">self</span> invocationWithTarget:moduleInstance selector:selector];</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">if</span> (isSync) &#123;</div><div class=\"line\">      [invocation invoke];</div><div class=\"line\">      <span class=\"keyword\">return</span> invocation;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      [<span class=\"keyword\">self</span> _dispatchInvocation:invocation moduleInstance:moduleInstance];</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>先通过 <code>WXModuleFactory</code> 拿到对应的方法 Selector，然后再拿到这个方法对应的 NSInvocation ，最后 invoke 这个 NSInvocation。对于 syncMethods 和 asyncMethods 有两种 invoke 方式。如果是 syncMethod 会直接 invoke ，如果是 asyncMethod，会将它派发到某个指定的线程中进行 invoke，这样做的好处是不会阻塞当前线程。到这里 Moudle 的大概的运行原理都清除了，不过还有一个问题，Moudle 的方法是怎么暴露给 Vue 的呢？<br>在 Moudle 中我们通过 Weex 提供的宏可以将方法暴露出来：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#define WX_EXPORT_METHOD(method) WX_EXPORT_METHOD_INTERNAL(method,wx_export_method_)</span></div><div class=\"line\"><span class=\"meta\">#define WX_EXPORT_METHOD_SYNC(method) WX_EXPORT_METHOD_INTERNAL(method,wx_export_method_sync_)</span></div></pre></td></tr></table></figure>\n<p>分别提供了 syncMethod 和 asyncMethod 的宏，展开其实是这样的</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#define WX_EXPORT_METHOD_INTERNAL(method, token) \\</span></div><div class=\"line\">+ (<span class=\"built_in\">NSString</span> *)WX_CONCAT_WRAPPER(token, __LINE__) &#123; \\</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">NSStringFromSelector</span>(method); \\</div><div class=\"line\">&#125;</div><div class=\"line\">```  </div><div class=\"line\">这里会自动将方法名和当前的行数拼成一个新的方法名，这样做的好处是可以保证方法的唯一性，例如 `WXDomModule` 中的 `createBody:` 方法利用宏暴露出来，最终展开形式是这样的  </div><div class=\"line\"></div><div class=\"line\">```ObjC  </div><div class=\"line\">+ (<span class=\"built_in\">NSString</span> *)wx_export_method_40 &#123; \\</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">NSStringFromSelector</span>(createBody:); \\</div><div class=\"line\">&#125;</div><div class=\"line\">```  </div><div class=\"line\"></div><div class=\"line\">在`WXInvocationConfig`中调用`- (<span class=\"keyword\">void</span>)registerMethods`注册方法的时候，首先拿到当前 <span class=\"keyword\">class</span> 中所有的类方法**（宏包装成的方法，并不是实际要注册的方法）**，然后通过判断有无`wx_export_method_sync_`前缀和`wx_export_method_`前缀来判断是否为暴露的方法，然后再调用该类方法，获得最终的实例方法字符串</div><div class=\"line\"></div><div class=\"line\">```ObjC  </div><div class=\"line\">method = ((<span class=\"built_in\">NSString</span>* (*)(<span class=\"keyword\">id</span>, SEL))[currentClass methodForSelector:selector])(currentClass, selector);</div></pre></td></tr></table></figure>\n<p>拿到需要注册的实例方法字符串，再将方法字符串注册到<code>WXInvocationConfig</code>的对应方法 map 中。  </p>\n<h3 id=\"3-组件：Handlers\"><a href=\"#3-组件：Handlers\" class=\"headerlink\" title=\"3. 组件：Handlers\"></a>3. 组件：Handlers</h3><p>Handlers 的注册和使用非常简单，直接将对应的 class 注册到 <code>WXHandlerFactory</code> map中</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[WXHandlerFactory sharedInstance].handlers setObject:handler forKey:<span class=\"built_in\">NSStringFromProtocol</span>(protocol)];</div></pre></td></tr></table></figure>\n<p>需要使用的时候也非常简单粗暴，通过<code>WXHandlerFactory</code>的方法和相应的 protocol</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">id</span>)handlerForProtocol:(Protocol *)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> handler = [[WXHandlerFactory sharedInstance].handlers objectForKey:<span class=\"built_in\">NSStringFromProtocol</span>(protocol)];</div><div class=\"line\">    <span class=\"keyword\">return</span> handler;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>直接拿出即可。</p>"},{"title":"你真的会用strong-weak dance吗？","date":"2017-01-16T07:34:45.000Z","_content":"\n\n>\t下文的讨论基于ARC  \n\n\n平时开发中我们遇到block里面引用self的情况，大部分都是这样处理的  \n\n```ObjC  \n    __weak typeof(self) weakSelf = self;\n    self.myBlock =  ^{\n    __strong typeof(self) strongSelf = weakSelf;\n        [strongSelf doSomething]; \n        [strongSelf doSomethingElse]; \n    };  \n```\n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)   \n\n我们习惯了这样用，**貌似这样用了之后可以解决循环引用的问题，而且可以保证block执行之前self不会被释放掉？真相总是残酷的，然而事实并非如此！**下面将会对block中引用self的三种方式进行讨论，并给出原因和另外一种解决方案。\n\n<!-- more -->\n\n##\t1.  block中直接引用self  \n\n这种情况使用是block被没有被self强引用，因此这样不会导致retain cycle。  \n\n```ObjC\n    dispatch_block_t completionHandler = ^{\n        NSLog(@\"%@\", self);\n    }  \n```\n\n##\t2.在block外部创建weakself变量，在block中引用weakself  \n\n当block被self强引用，此时如果在block内强引用self将会导致retain cycle。所以我们就想到了在block外部创建一个weakself，然后block在创建的时候捕获到的是weakself，这样就不会导致retain cycle。  \n\n```ObjC  \n__weak typeof(self) weakSelf = self;\ndispatch_block_t block =  ^{\n    [weakSelf doSomething]; \n    [weakSelf doSomethingElse]; \n};  \n```\n\n但是要注意的是block捕获的是weakself变量，如果在执行doSomething的过程中self被释放掉，由于是弱引用，weakself也将置空，下面的doSomethingElse是无法得到执行的，看一个例子：\n\n下面的例子展示的是，在block调用之后的1秒后释放self，在block中调用doSomething，2秒之后再调用doAnotherThing，意味着调用doAnotherThing之前self已经被释放了  \n\n\n```ObjC  \n\n//viewController.m\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.sself = [strongweakself new];\n    [self.sself test];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"self.block被释放!\");\n        self.sself = nil;\n    });\n}\n//strongweakself.m\n-(void)test\n{\n    self.myobject = [TestObject new];\n    __weak typeof(self) __weakself = self;\n    [self.myobject setWeakblock:^{\n        NSLog(@\"调用block!\");\n        [__weakself doSomething];\n            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n                [__weakself doAnotherThing];\n            });\n    }];\n    self.myobject.weakblock();\n}\n-(void)doSomething\n{\n    NSLog(@\"%s\",__func__);\n}\n-(void)doAnotherThing\n{\n    NSLog(@\"%s\",__func__);\n}\n-(void)dealloc{\n    NSLog(@\"%s\",__func__);\n}\n```\n\n\n从打印日志可以看出，block执行大约1秒之后self被dealloc，doAnotherThing并没有得到调用\n\n```ObjC \n2017-01-16 14:31:13.834 strong-weak dance[11366:4727954] 调用block!\n2017-01-16 14:31:13.836 strong-weak dance[11366:4727954] -[strongweakself doSomething]\n2017-01-16 14:31:14.893 strong-weak dance[11366:4727954] self.block被释放!\n2017-01-16 14:31:14.893 strong-weak dance[11366:4727954] -[strongweakself dealloc]\n```\n\n所以只使用weakself，在self被释放之后，weakself由于self的释放已经为空，后面的self都将失效，所以在block中这样引用self是非常危险的，下面就要谈谈我们最熟悉的strong-weak dance了。\n\n##\t3.strong-weak dance  \n\n对比第二种方案我们看一下doAnotherThing是否可以得到调用，稍微改一下代码，还是在block执行1秒后释放self，我们看看后面的self引用是否有效\n\n```ObjC \n-(void)test\n{\n    self.myobject = [TestObject new];\n    __weak typeof(self) __weakself = self;\n    [self.myobject setWeakblock:^{\n        NSLog(@\"调用block!\");\n        __strong typeof(self) __strongself= __weakself;\n        [__strongself doSomething];\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            [__strongself doAnotherThing];\n        });\n    }];\n    self.myobject.weakblock();\n}\n```\n\n此时看打印日志：\n\n```ObjC\n2017-01-16 14:36:39.039 strong-weak dance[11374:4728878] 调用block!\n2017-01-16 14:36:39.039 strong-weak dance[11374:4728878] -[strongweakself doSomething]\n2017-01-16 14:36:40.110 strong-weak dance[11374:4728878] self.block被释放!\n2017-01-16 14:36:41.213 strong-weak dance[11374:4728878] -[strongweakself doAnotherThing]\n2017-01-16 14:36:41.213 strong-weak dance[11374:4728878] -[strongweakself dealloc]\n```\n\n\n虽然self被释放掉了，但是并没有dealloc，因为block内部的strongself对他进行了一次retain，当doAnotherThing执行完毕，strongself对他的引用计数减一，self被dealloc彻底销毁。\n\n**那么问题来了！strong-weak dance能不能解决block执行前，self被释放的问题？**下面继续验证  \n我们改一下代码，在1秒之后释放self，在2秒之后执行block（*注意延时block中对于self的处理是weakself，防止延时block对self进行retain影响验证结果*）\n\n```ObjC\n//viewController.m\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.sself = [strongweakself new];\n    [self.sself test];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"self.block被释放!\");\n        self.sself = nil;\n    });\n}\n\n//strongweakself.m\n-(void)test\n{\n    self.myobject = [TestObject new];\n    __weak typeof(self) __weakself = self;\n    [self.myobject setWeakblock:^{\n    NSLog(@\"调用block!\");\n    __strong typeof(self) __strongself= __weakself;\n    [__strongself doSomething];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        [__strongself doAnotherThing];\n    });\n    }];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"%@\",__weakself);\n        __weakself.myobject.weakblock();\n});\n}\n\n```\n\n看一下日志：\n\n```ObjC\n2017-01-16 14:44:26.314 strong-weak dance[11395:4730727] self.block被释放!\n2017-01-16 14:44:26.314 strong-weak dance[11395:4730727] -[strongweakself dealloc]\n2017-01-16 14:44:27.372 strong-weak dance[11395:4730727] (null)\n```\n\n当开始调用block的时候报错了，self这时已经被dealloc掉。strong-weak dance并没有解决这种问题。看到这心是不是凉了半截？真相就是如此，我们平时一直使用的strong-weak dance也只能解决block得到调用之后self不被释放的问题。  \n\n这是我们最常用的是一种方案，因为block创建时捕获的是weakself，所以block执行之前不能够控制self的生命周期，所以这样不会导致整个block对self进行强引用。之后在block内部创建一个对self进行retain的变量strongself，**strongself 作为局部变量强引用了 self 并且会在block执行完毕的时候被自动销毁，这样既可以保证在block执行期间 self 不会被外界干掉，同时也解决了retain cycle的问题。**\n\n##\t总结  \n\n通过上面几个小栗子可以看出来：strong-weak dance确实是比较好的解决方案，但是也不是万能的，他不能解决block调用之前self被释放的问题，下面将block中引用self分为4中场景：\n\n####\t1.\t使用self  \n当self不持有、不间接持有block时，可以在block内部直接引用self。\n\n####\t2.使用weakself\n当self持有或间接持有block，可以通过在外部创建self的弱引用weakself然后捕获到block内部进行使用，但是这样使用存在一定风险，一般也不推荐使用。\n\n####\t3.使用strong-weak dance\n当self持有或间接持有block，此时要使用strong-weak dance。\n这种方法也不是万能的，在block被执行前，block对self依然只是弱引用，进入block里面才会retain一次，保证在block执行期间self都不会被释放掉。\n\n\n####\t4.\tblock中强引用self并且打破retain cycle\n**不管是weakself还是strong-weak dance，目的都是避免retain cycle，strong-weak dance的本质也是在block中搞了一个局部变量来打破这种循环引用的；**    \n如果我们在block中直接使用self，并且在适当的时机打破这种循环（比如说在block执行完成将这个block销毁）也可以避免retain cycle，并且这种在block创建时就强引用的方式，在block被调用前 self 不会被释放掉，可以弥补strong-weak dance的不足。\n\n关于本文的内容可能存在不足的地方，欢迎大家指正！\n\n\n\n##\t参考资料\n1.\t[http://albertodebortoli.com/blog/2013/08/03/objective-c-blocks-caveat](http://albertodebortoli.com/blog/2013/08/03/objective-c-blocks-caveat)\n","source":"_posts/strong-weak-dance.md","raw":"---\ntitle: 你真的会用strong-weak dance吗？\ndate: 2017-01-16 15:34:45\ncategories:  \n- 技术笔记\ntags: \n- block  \n- retain cycle   \npermalink: strong-weak_dance\n\n---\n\n\n>\t下文的讨论基于ARC  \n\n\n平时开发中我们遇到block里面引用self的情况，大部分都是这样处理的  \n\n```ObjC  \n    __weak typeof(self) weakSelf = self;\n    self.myBlock =  ^{\n    __strong typeof(self) strongSelf = weakSelf;\n        [strongSelf doSomething]; \n        [strongSelf doSomethingElse]; \n    };  \n```\n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)   \n\n我们习惯了这样用，**貌似这样用了之后可以解决循环引用的问题，而且可以保证block执行之前self不会被释放掉？真相总是残酷的，然而事实并非如此！**下面将会对block中引用self的三种方式进行讨论，并给出原因和另外一种解决方案。\n\n<!-- more -->\n\n##\t1.  block中直接引用self  \n\n这种情况使用是block被没有被self强引用，因此这样不会导致retain cycle。  \n\n```ObjC\n    dispatch_block_t completionHandler = ^{\n        NSLog(@\"%@\", self);\n    }  \n```\n\n##\t2.在block外部创建weakself变量，在block中引用weakself  \n\n当block被self强引用，此时如果在block内强引用self将会导致retain cycle。所以我们就想到了在block外部创建一个weakself，然后block在创建的时候捕获到的是weakself，这样就不会导致retain cycle。  \n\n```ObjC  \n__weak typeof(self) weakSelf = self;\ndispatch_block_t block =  ^{\n    [weakSelf doSomething]; \n    [weakSelf doSomethingElse]; \n};  \n```\n\n但是要注意的是block捕获的是weakself变量，如果在执行doSomething的过程中self被释放掉，由于是弱引用，weakself也将置空，下面的doSomethingElse是无法得到执行的，看一个例子：\n\n下面的例子展示的是，在block调用之后的1秒后释放self，在block中调用doSomething，2秒之后再调用doAnotherThing，意味着调用doAnotherThing之前self已经被释放了  \n\n\n```ObjC  \n\n//viewController.m\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.sself = [strongweakself new];\n    [self.sself test];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"self.block被释放!\");\n        self.sself = nil;\n    });\n}\n//strongweakself.m\n-(void)test\n{\n    self.myobject = [TestObject new];\n    __weak typeof(self) __weakself = self;\n    [self.myobject setWeakblock:^{\n        NSLog(@\"调用block!\");\n        [__weakself doSomething];\n            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n                [__weakself doAnotherThing];\n            });\n    }];\n    self.myobject.weakblock();\n}\n-(void)doSomething\n{\n    NSLog(@\"%s\",__func__);\n}\n-(void)doAnotherThing\n{\n    NSLog(@\"%s\",__func__);\n}\n-(void)dealloc{\n    NSLog(@\"%s\",__func__);\n}\n```\n\n\n从打印日志可以看出，block执行大约1秒之后self被dealloc，doAnotherThing并没有得到调用\n\n```ObjC \n2017-01-16 14:31:13.834 strong-weak dance[11366:4727954] 调用block!\n2017-01-16 14:31:13.836 strong-weak dance[11366:4727954] -[strongweakself doSomething]\n2017-01-16 14:31:14.893 strong-weak dance[11366:4727954] self.block被释放!\n2017-01-16 14:31:14.893 strong-weak dance[11366:4727954] -[strongweakself dealloc]\n```\n\n所以只使用weakself，在self被释放之后，weakself由于self的释放已经为空，后面的self都将失效，所以在block中这样引用self是非常危险的，下面就要谈谈我们最熟悉的strong-weak dance了。\n\n##\t3.strong-weak dance  \n\n对比第二种方案我们看一下doAnotherThing是否可以得到调用，稍微改一下代码，还是在block执行1秒后释放self，我们看看后面的self引用是否有效\n\n```ObjC \n-(void)test\n{\n    self.myobject = [TestObject new];\n    __weak typeof(self) __weakself = self;\n    [self.myobject setWeakblock:^{\n        NSLog(@\"调用block!\");\n        __strong typeof(self) __strongself= __weakself;\n        [__strongself doSomething];\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            [__strongself doAnotherThing];\n        });\n    }];\n    self.myobject.weakblock();\n}\n```\n\n此时看打印日志：\n\n```ObjC\n2017-01-16 14:36:39.039 strong-weak dance[11374:4728878] 调用block!\n2017-01-16 14:36:39.039 strong-weak dance[11374:4728878] -[strongweakself doSomething]\n2017-01-16 14:36:40.110 strong-weak dance[11374:4728878] self.block被释放!\n2017-01-16 14:36:41.213 strong-weak dance[11374:4728878] -[strongweakself doAnotherThing]\n2017-01-16 14:36:41.213 strong-weak dance[11374:4728878] -[strongweakself dealloc]\n```\n\n\n虽然self被释放掉了，但是并没有dealloc，因为block内部的strongself对他进行了一次retain，当doAnotherThing执行完毕，strongself对他的引用计数减一，self被dealloc彻底销毁。\n\n**那么问题来了！strong-weak dance能不能解决block执行前，self被释放的问题？**下面继续验证  \n我们改一下代码，在1秒之后释放self，在2秒之后执行block（*注意延时block中对于self的处理是weakself，防止延时block对self进行retain影响验证结果*）\n\n```ObjC\n//viewController.m\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.sself = [strongweakself new];\n    [self.sself test];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"self.block被释放!\");\n        self.sself = nil;\n    });\n}\n\n//strongweakself.m\n-(void)test\n{\n    self.myobject = [TestObject new];\n    __weak typeof(self) __weakself = self;\n    [self.myobject setWeakblock:^{\n    NSLog(@\"调用block!\");\n    __strong typeof(self) __strongself= __weakself;\n    [__strongself doSomething];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        [__strongself doAnotherThing];\n    });\n    }];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"%@\",__weakself);\n        __weakself.myobject.weakblock();\n});\n}\n\n```\n\n看一下日志：\n\n```ObjC\n2017-01-16 14:44:26.314 strong-weak dance[11395:4730727] self.block被释放!\n2017-01-16 14:44:26.314 strong-weak dance[11395:4730727] -[strongweakself dealloc]\n2017-01-16 14:44:27.372 strong-weak dance[11395:4730727] (null)\n```\n\n当开始调用block的时候报错了，self这时已经被dealloc掉。strong-weak dance并没有解决这种问题。看到这心是不是凉了半截？真相就是如此，我们平时一直使用的strong-weak dance也只能解决block得到调用之后self不被释放的问题。  \n\n这是我们最常用的是一种方案，因为block创建时捕获的是weakself，所以block执行之前不能够控制self的生命周期，所以这样不会导致整个block对self进行强引用。之后在block内部创建一个对self进行retain的变量strongself，**strongself 作为局部变量强引用了 self 并且会在block执行完毕的时候被自动销毁，这样既可以保证在block执行期间 self 不会被外界干掉，同时也解决了retain cycle的问题。**\n\n##\t总结  \n\n通过上面几个小栗子可以看出来：strong-weak dance确实是比较好的解决方案，但是也不是万能的，他不能解决block调用之前self被释放的问题，下面将block中引用self分为4中场景：\n\n####\t1.\t使用self  \n当self不持有、不间接持有block时，可以在block内部直接引用self。\n\n####\t2.使用weakself\n当self持有或间接持有block，可以通过在外部创建self的弱引用weakself然后捕获到block内部进行使用，但是这样使用存在一定风险，一般也不推荐使用。\n\n####\t3.使用strong-weak dance\n当self持有或间接持有block，此时要使用strong-weak dance。\n这种方法也不是万能的，在block被执行前，block对self依然只是弱引用，进入block里面才会retain一次，保证在block执行期间self都不会被释放掉。\n\n\n####\t4.\tblock中强引用self并且打破retain cycle\n**不管是weakself还是strong-weak dance，目的都是避免retain cycle，strong-weak dance的本质也是在block中搞了一个局部变量来打破这种循环引用的；**    \n如果我们在block中直接使用self，并且在适当的时机打破这种循环（比如说在block执行完成将这个block销毁）也可以避免retain cycle，并且这种在block创建时就强引用的方式，在block被调用前 self 不会被释放掉，可以弥补strong-weak dance的不足。\n\n关于本文的内容可能存在不足的地方，欢迎大家指正！\n\n\n\n##\t参考资料\n1.\t[http://albertodebortoli.com/blog/2013/08/03/objective-c-blocks-caveat](http://albertodebortoli.com/blog/2013/08/03/objective-c-blocks-caveat)\n","slug":"strong-weak_dance","published":1,"updated":"2017-11-06T03:50:52.168Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9no6vmf000bjaen5ive6f1k","content":"<blockquote>\n<p>   下文的讨论基于ARC  </p>\n</blockquote>\n<p>平时开发中我们遇到block里面引用self的情况，大部分都是这样处理的  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\"><span class=\"keyword\">self</span>.myBlock =  ^&#123;</div><div class=\"line\">__<span class=\"keyword\">strong</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) strongSelf = weakSelf;</div><div class=\"line\">    [strongSelf doSomething]; </div><div class=\"line\">    [strongSelf doSomethingElse]; </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>   </p>\n<p>我们习惯了这样用，<strong>貌似这样用了之后可以解决循环引用的问题，而且可以保证block执行之前self不会被释放掉？真相总是残酷的，然而事实并非如此！</strong>下面将会对block中引用self的三种方式进行讨论，并给出原因和另外一种解决方案。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-block中直接引用self\"><a href=\"#1-block中直接引用self\" class=\"headerlink\" title=\"1.  block中直接引用self\"></a>1.  block中直接引用self</h2><p>这种情况使用是block被没有被self强引用，因此这样不会导致retain cycle。  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_block_t completionHandler = ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"keyword\">self</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-在block外部创建weakself变量，在block中引用weakself\"><a href=\"#2-在block外部创建weakself变量，在block中引用weakself\" class=\"headerlink\" title=\"2.在block外部创建weakself变量，在block中引用weakself\"></a>2.在block外部创建weakself变量，在block中引用weakself</h2><p>当block被self强引用，此时如果在block内强引用self将会导致retain cycle。所以我们就想到了在block外部创建一个weakself，然后block在创建的时候捕获到的是weakself，这样就不会导致retain cycle。  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\">dispatch_block_t block =  ^&#123;</div><div class=\"line\">    [weakSelf doSomething]; </div><div class=\"line\">    [weakSelf doSomethingElse]; </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>但是要注意的是block捕获的是weakself变量，如果在执行doSomething的过程中self被释放掉，由于是弱引用，weakself也将置空，下面的doSomethingElse是无法得到执行的，看一个例子：</p>\n<p>下面的例子展示的是，在block调用之后的1秒后释放self，在block中调用doSomething，2秒之后再调用doAnotherThing，意味着调用doAnotherThing之前self已经被释放了  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//viewController.m</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"keyword\">self</span>.sself = [strongweakself new];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.sself test];</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">1</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"self.block被释放!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">self</span>.sself = <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//strongweakself.m</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)test</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.myobject = [TestObject new];</div><div class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) __weakself = <span class=\"keyword\">self</span>;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.myobject setWeakblock:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用block!\"</span>);</div><div class=\"line\">        [__weakself doSomething];</div><div class=\"line\">            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">                [__weakself doAnotherThing];</div><div class=\"line\">            &#125;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    <span class=\"keyword\">self</span>.myobject.weakblock();</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)doSomething</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)doAnotherThing</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)dealloc&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>,__func__);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从打印日志可以看出，block执行大约1秒之后self被dealloc，doAnotherThing并没有得到调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">31</span>:<span class=\"number\">13.834</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11366</span>:<span class=\"number\">4727954</span>] 调用block!</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">31</span>:<span class=\"number\">13.836</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11366</span>:<span class=\"number\">4727954</span>] -[strongweakself doSomething]</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">31</span>:<span class=\"number\">14.893</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11366</span>:<span class=\"number\">4727954</span>] <span class=\"keyword\">self</span>.block被释放!</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">31</span>:<span class=\"number\">14.893</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11366</span>:<span class=\"number\">4727954</span>] -[strongweakself dealloc]</div></pre></td></tr></table></figure>\n<p>所以只使用weakself，在self被释放之后，weakself由于self的释放已经为空，后面的self都将失效，所以在block中这样引用self是非常危险的，下面就要谈谈我们最熟悉的strong-weak dance了。</p>\n<h2 id=\"3-strong-weak-dance\"><a href=\"#3-strong-weak-dance\" class=\"headerlink\" title=\"3.strong-weak dance\"></a>3.strong-weak dance</h2><p>对比第二种方案我们看一下doAnotherThing是否可以得到调用，稍微改一下代码，还是在block执行1秒后释放self，我们看看后面的self引用是否有效</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)test</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.myobject = [TestObject new];</div><div class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) __weakself = <span class=\"keyword\">self</span>;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.myobject setWeakblock:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用block!\"</span>);</div><div class=\"line\">        __<span class=\"keyword\">strong</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) __strongself= __weakself;</div><div class=\"line\">        [__strongself doSomething];</div><div class=\"line\">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [__strongself doAnotherThing];</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    <span class=\"keyword\">self</span>.myobject.weakblock();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>此时看打印日志：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">36</span>:<span class=\"number\">39.039</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11374</span>:<span class=\"number\">4728878</span>] 调用block!</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">36</span>:<span class=\"number\">39.039</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11374</span>:<span class=\"number\">4728878</span>] -[strongweakself doSomething]</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">36</span>:<span class=\"number\">40.110</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11374</span>:<span class=\"number\">4728878</span>] <span class=\"keyword\">self</span>.block被释放!</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">36</span>:<span class=\"number\">41.213</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11374</span>:<span class=\"number\">4728878</span>] -[strongweakself doAnotherThing]</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">36</span>:<span class=\"number\">41.213</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11374</span>:<span class=\"number\">4728878</span>] -[strongweakself dealloc]</div></pre></td></tr></table></figure>\n<p>虽然self被释放掉了，但是并没有dealloc，因为block内部的strongself对他进行了一次retain，当doAnotherThing执行完毕，strongself对他的引用计数减一，self被dealloc彻底销毁。</p>\n<p><strong>那么问题来了！strong-weak dance能不能解决block执行前，self被释放的问题？</strong>下面继续验证<br>我们改一下代码，在1秒之后释放self，在2秒之后执行block（<em>注意延时block中对于self的处理是weakself，防止延时block对self进行retain影响验证结果</em>）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//viewController.m</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"keyword\">self</span>.sself = [strongweakself new];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.sself test];</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">1</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"self.block被释放!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">self</span>.sself = <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//strongweakself.m</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)test</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.myobject = [TestObject new];</div><div class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) __weakself = <span class=\"keyword\">self</span>;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.myobject setWeakblock:^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用block!\"</span>);</div><div class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) __strongself= __weakself;</div><div class=\"line\">    [__strongself doSomething];</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        [__strongself doAnotherThing];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,__weakself);</div><div class=\"line\">        __weakself.myobject.weakblock();</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一下日志：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">44</span>:<span class=\"number\">26.314</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11395</span>:<span class=\"number\">4730727</span>] <span class=\"keyword\">self</span>.block被释放!</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">44</span>:<span class=\"number\">26.314</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11395</span>:<span class=\"number\">4730727</span>] -[strongweakself dealloc]</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">44</span>:<span class=\"number\">27.372</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11395</span>:<span class=\"number\">4730727</span>] (null)</div></pre></td></tr></table></figure>\n<p>当开始调用block的时候报错了，self这时已经被dealloc掉。strong-weak dance并没有解决这种问题。看到这心是不是凉了半截？真相就是如此，我们平时一直使用的strong-weak dance也只能解决block得到调用之后self不被释放的问题。  </p>\n<p>这是我们最常用的是一种方案，因为block创建时捕获的是weakself，所以block执行之前不能够控制self的生命周期，所以这样不会导致整个block对self进行强引用。之后在block内部创建一个对self进行retain的变量strongself，<strong>strongself 作为局部变量强引用了 self 并且会在block执行完毕的时候被自动销毁，这样既可以保证在block执行期间 self 不会被外界干掉，同时也解决了retain cycle的问题。</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面几个小栗子可以看出来：strong-weak dance确实是比较好的解决方案，但是也不是万能的，他不能解决block调用之前self被释放的问题，下面将block中引用self分为4中场景：</p>\n<h4 id=\"1-使用self\"><a href=\"#1-使用self\" class=\"headerlink\" title=\"1.    使用self\"></a>1.    使用self</h4><p>当self不持有、不间接持有block时，可以在block内部直接引用self。</p>\n<h4 id=\"2-使用weakself\"><a href=\"#2-使用weakself\" class=\"headerlink\" title=\"2.使用weakself\"></a>2.使用weakself</h4><p>当self持有或间接持有block，可以通过在外部创建self的弱引用weakself然后捕获到block内部进行使用，但是这样使用存在一定风险，一般也不推荐使用。</p>\n<h4 id=\"3-使用strong-weak-dance\"><a href=\"#3-使用strong-weak-dance\" class=\"headerlink\" title=\"3.使用strong-weak dance\"></a>3.使用strong-weak dance</h4><p>当self持有或间接持有block，此时要使用strong-weak dance。<br>这种方法也不是万能的，在block被执行前，block对self依然只是弱引用，进入block里面才会retain一次，保证在block执行期间self都不会被释放掉。</p>\n<h4 id=\"4-block中强引用self并且打破retain-cycle\"><a href=\"#4-block中强引用self并且打破retain-cycle\" class=\"headerlink\" title=\"4.    block中强引用self并且打破retain cycle\"></a>4.    block中强引用self并且打破retain cycle</h4><p><strong>不管是weakself还是strong-weak dance，目的都是避免retain cycle，strong-weak dance的本质也是在block中搞了一个局部变量来打破这种循环引用的；</strong><br>如果我们在block中直接使用self，并且在适当的时机打破这种循环（比如说在block执行完成将这个block销毁）也可以避免retain cycle，并且这种在block创建时就强引用的方式，在block被调用前 self 不会被释放掉，可以弥补strong-weak dance的不足。</p>\n<p>关于本文的内容可能存在不足的地方，欢迎大家指正！</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://albertodebortoli.com/blog/2013/08/03/objective-c-blocks-caveat\" target=\"_blank\" rel=\"external\">http://albertodebortoli.com/blog/2013/08/03/objective-c-blocks-caveat</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>   下文的讨论基于ARC  </p>\n</blockquote>\n<p>平时开发中我们遇到block里面引用self的情况，大部分都是这样处理的  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\"><span class=\"keyword\">self</span>.myBlock =  ^&#123;</div><div class=\"line\">__<span class=\"keyword\">strong</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) strongSelf = weakSelf;</div><div class=\"line\">    [strongSelf doSomething]; </div><div class=\"line\">    [strongSelf doSomethingElse]; </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>   </p>\n<p>我们习惯了这样用，<strong>貌似这样用了之后可以解决循环引用的问题，而且可以保证block执行之前self不会被释放掉？真相总是残酷的，然而事实并非如此！</strong>下面将会对block中引用self的三种方式进行讨论，并给出原因和另外一种解决方案。</p>","more":"<h2 id=\"1-block中直接引用self\"><a href=\"#1-block中直接引用self\" class=\"headerlink\" title=\"1.  block中直接引用self\"></a>1.  block中直接引用self</h2><p>这种情况使用是block被没有被self强引用，因此这样不会导致retain cycle。  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_block_t completionHandler = ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"keyword\">self</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-在block外部创建weakself变量，在block中引用weakself\"><a href=\"#2-在block外部创建weakself变量，在block中引用weakself\" class=\"headerlink\" title=\"2.在block外部创建weakself变量，在block中引用weakself\"></a>2.在block外部创建weakself变量，在block中引用weakself</h2><p>当block被self强引用，此时如果在block内强引用self将会导致retain cycle。所以我们就想到了在block外部创建一个weakself，然后block在创建的时候捕获到的是weakself，这样就不会导致retain cycle。  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\">dispatch_block_t block =  ^&#123;</div><div class=\"line\">    [weakSelf doSomething]; </div><div class=\"line\">    [weakSelf doSomethingElse]; </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>但是要注意的是block捕获的是weakself变量，如果在执行doSomething的过程中self被释放掉，由于是弱引用，weakself也将置空，下面的doSomethingElse是无法得到执行的，看一个例子：</p>\n<p>下面的例子展示的是，在block调用之后的1秒后释放self，在block中调用doSomething，2秒之后再调用doAnotherThing，意味着调用doAnotherThing之前self已经被释放了  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//viewController.m</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"keyword\">self</span>.sself = [strongweakself new];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.sself test];</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">1</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"self.block被释放!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">self</span>.sself = <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//strongweakself.m</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)test</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.myobject = [TestObject new];</div><div class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) __weakself = <span class=\"keyword\">self</span>;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.myobject setWeakblock:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用block!\"</span>);</div><div class=\"line\">        [__weakself doSomething];</div><div class=\"line\">            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">                [__weakself doAnotherThing];</div><div class=\"line\">            &#125;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    <span class=\"keyword\">self</span>.myobject.weakblock();</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)doSomething</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)doAnotherThing</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)dealloc&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>,__func__);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从打印日志可以看出，block执行大约1秒之后self被dealloc，doAnotherThing并没有得到调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">31</span>:<span class=\"number\">13.834</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11366</span>:<span class=\"number\">4727954</span>] 调用block!</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">31</span>:<span class=\"number\">13.836</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11366</span>:<span class=\"number\">4727954</span>] -[strongweakself doSomething]</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">31</span>:<span class=\"number\">14.893</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11366</span>:<span class=\"number\">4727954</span>] <span class=\"keyword\">self</span>.block被释放!</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">31</span>:<span class=\"number\">14.893</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11366</span>:<span class=\"number\">4727954</span>] -[strongweakself dealloc]</div></pre></td></tr></table></figure>\n<p>所以只使用weakself，在self被释放之后，weakself由于self的释放已经为空，后面的self都将失效，所以在block中这样引用self是非常危险的，下面就要谈谈我们最熟悉的strong-weak dance了。</p>\n<h2 id=\"3-strong-weak-dance\"><a href=\"#3-strong-weak-dance\" class=\"headerlink\" title=\"3.strong-weak dance\"></a>3.strong-weak dance</h2><p>对比第二种方案我们看一下doAnotherThing是否可以得到调用，稍微改一下代码，还是在block执行1秒后释放self，我们看看后面的self引用是否有效</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)test</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.myobject = [TestObject new];</div><div class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) __weakself = <span class=\"keyword\">self</span>;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.myobject setWeakblock:^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用block!\"</span>);</div><div class=\"line\">        __<span class=\"keyword\">strong</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) __strongself= __weakself;</div><div class=\"line\">        [__strongself doSomething];</div><div class=\"line\">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [__strongself doAnotherThing];</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    <span class=\"keyword\">self</span>.myobject.weakblock();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>此时看打印日志：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">36</span>:<span class=\"number\">39.039</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11374</span>:<span class=\"number\">4728878</span>] 调用block!</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">36</span>:<span class=\"number\">39.039</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11374</span>:<span class=\"number\">4728878</span>] -[strongweakself doSomething]</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">36</span>:<span class=\"number\">40.110</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11374</span>:<span class=\"number\">4728878</span>] <span class=\"keyword\">self</span>.block被释放!</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">36</span>:<span class=\"number\">41.213</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11374</span>:<span class=\"number\">4728878</span>] -[strongweakself doAnotherThing]</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">36</span>:<span class=\"number\">41.213</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11374</span>:<span class=\"number\">4728878</span>] -[strongweakself dealloc]</div></pre></td></tr></table></figure>\n<p>虽然self被释放掉了，但是并没有dealloc，因为block内部的strongself对他进行了一次retain，当doAnotherThing执行完毕，strongself对他的引用计数减一，self被dealloc彻底销毁。</p>\n<p><strong>那么问题来了！strong-weak dance能不能解决block执行前，self被释放的问题？</strong>下面继续验证<br>我们改一下代码，在1秒之后释放self，在2秒之后执行block（<em>注意延时block中对于self的处理是weakself，防止延时block对self进行retain影响验证结果</em>）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//viewController.m</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"keyword\">self</span>.sself = [strongweakself new];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.sself test];</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">1</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"self.block被释放!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">self</span>.sself = <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//strongweakself.m</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)test</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.myobject = [TestObject new];</div><div class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) __weakself = <span class=\"keyword\">self</span>;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.myobject setWeakblock:^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用block!\"</span>);</div><div class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) __strongself= __weakself;</div><div class=\"line\">    [__strongself doSomething];</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        [__strongself doAnotherThing];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,__weakself);</div><div class=\"line\">        __weakself.myobject.weakblock();</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一下日志：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">44</span>:<span class=\"number\">26.314</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11395</span>:<span class=\"number\">4730727</span>] <span class=\"keyword\">self</span>.block被释放!</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">44</span>:<span class=\"number\">26.314</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11395</span>:<span class=\"number\">4730727</span>] -[strongweakself dealloc]</div><div class=\"line\"><span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-16</span> <span class=\"number\">14</span>:<span class=\"number\">44</span>:<span class=\"number\">27.372</span> <span class=\"keyword\">strong</span>-<span class=\"keyword\">weak</span> dance[<span class=\"number\">11395</span>:<span class=\"number\">4730727</span>] (null)</div></pre></td></tr></table></figure>\n<p>当开始调用block的时候报错了，self这时已经被dealloc掉。strong-weak dance并没有解决这种问题。看到这心是不是凉了半截？真相就是如此，我们平时一直使用的strong-weak dance也只能解决block得到调用之后self不被释放的问题。  </p>\n<p>这是我们最常用的是一种方案，因为block创建时捕获的是weakself，所以block执行之前不能够控制self的生命周期，所以这样不会导致整个block对self进行强引用。之后在block内部创建一个对self进行retain的变量strongself，<strong>strongself 作为局部变量强引用了 self 并且会在block执行完毕的时候被自动销毁，这样既可以保证在block执行期间 self 不会被外界干掉，同时也解决了retain cycle的问题。</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面几个小栗子可以看出来：strong-weak dance确实是比较好的解决方案，但是也不是万能的，他不能解决block调用之前self被释放的问题，下面将block中引用self分为4中场景：</p>\n<h4 id=\"1-使用self\"><a href=\"#1-使用self\" class=\"headerlink\" title=\"1.    使用self\"></a>1.    使用self</h4><p>当self不持有、不间接持有block时，可以在block内部直接引用self。</p>\n<h4 id=\"2-使用weakself\"><a href=\"#2-使用weakself\" class=\"headerlink\" title=\"2.使用weakself\"></a>2.使用weakself</h4><p>当self持有或间接持有block，可以通过在外部创建self的弱引用weakself然后捕获到block内部进行使用，但是这样使用存在一定风险，一般也不推荐使用。</p>\n<h4 id=\"3-使用strong-weak-dance\"><a href=\"#3-使用strong-weak-dance\" class=\"headerlink\" title=\"3.使用strong-weak dance\"></a>3.使用strong-weak dance</h4><p>当self持有或间接持有block，此时要使用strong-weak dance。<br>这种方法也不是万能的，在block被执行前，block对self依然只是弱引用，进入block里面才会retain一次，保证在block执行期间self都不会被释放掉。</p>\n<h4 id=\"4-block中强引用self并且打破retain-cycle\"><a href=\"#4-block中强引用self并且打破retain-cycle\" class=\"headerlink\" title=\"4.    block中强引用self并且打破retain cycle\"></a>4.    block中强引用self并且打破retain cycle</h4><p><strong>不管是weakself还是strong-weak dance，目的都是避免retain cycle，strong-weak dance的本质也是在block中搞了一个局部变量来打破这种循环引用的；</strong><br>如果我们在block中直接使用self，并且在适当的时机打破这种循环（比如说在block执行完成将这个block销毁）也可以避免retain cycle，并且这种在block创建时就强引用的方式，在block被调用前 self 不会被释放掉，可以弥补strong-weak dance的不足。</p>\n<p>关于本文的内容可能存在不足的地方，欢迎大家指正！</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://albertodebortoli.com/blog/2013/08/03/objective-c-blocks-caveat\" target=\"_blank\" rel=\"external\">http://albertodebortoli.com/blog/2013/08/03/objective-c-blocks-caveat</a></li>\n</ol>"},{"title":"iOS静态库SDK制作（包含第三方静态库）","date":"2016-11-17T16:00:00.000Z","_content":"\n##\t\t前言  \n>\t以下所涉及的框架和库只针对iOS而言，不确保在其他平台也适用。\n\n最近由于公司业务需要，要求封装一个支付SDK，需要用到微信支付和支付宝，之前做过的Framework没有依赖其他第三方的库所以比较好做，这次有所不同；一开始我想把支付宝和微信支付的SDK全部融合进来，折腾一天才发现我之前的想法有很多误区，这样是根本行不通的，不过最后还是封装成功了，下面把我的经验分享出来，供有需要的同学少走弯路。 制作之前最好把功课做足，看看静态库和动态库到底是什么东西。  \n\n<!-- more -->\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n##\t\t一.\t静态库和动态库的详细介绍  \n我们平时的工程中或多或少都要引入第三方的SDK，就算你没有引入第三方的，至少引用过系统的Framework吧？其实这些SDK和Framework都属于库，库又分为静态库和动态库，我们平时导入的第三方SDK有的是Framework，有的是.a，到底哪些是动态库，哪些是静态库呢？下面分别介绍静态库、动态库，Framework和.a以及.dylib/.tbd区别  \t\n###\t一.\t静态库与动态库\n首先要解释一下什么是库，库(Library)其实就是一段编译好的二进制代码，加上头文件就可以供别人使用，一般会有两种情况要用到库：  \n\n- 某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件。  \n- 对于某些不会进行大的改动的代码，比方说很多大公司常用且很少变动的模块都会编译成库，这样做的好处一是可以节省编译时间，二来对于代码的管理也非常方便。  \n\n因为库是已经编译好的二进制文件了，编译的时候只需要link一下，**既然提到了link那就有不同的形式了，静态和动态，与之相对应的就是静态库和动态库**。   \n\n####\t1. 静态库\n平时我们用的第三方SDK基本上都是静态库，静态库的几个特点：  \n\n-\t在App项目编译的时候会被拷贝一份编译到目标程序中，相当于将静态库嵌入了，所以得到的App二进制文件会变大。\n- 在使用的时候，需要手动导入静态库所依赖的其他类库。*（比如说某个SDK中使用到了CoreMotion.framework，在使用的时候需要手动导入。有的SDK需要link十几个系统库，这个时候非常恶心，只能一个一个手动加，这是静态库一个很大的不便之处。）* \n- 导入静态库的应用可以减少对外界的依赖，如果导入的是第三方动态库，动态库找不到的话应用就会崩掉，例如Linux上经常出现的lib not found。\n- 静态库很大的一个优点是减少耦合性，因为静态库中是不可以包含其他静态库的，使用的时候要另外导入它的依赖库，最大限度的保证了每一个静态库都是独立的，不会重复引用。\n\n####\t2.\t动态库  \n这个是我们最常用的一类库，使用频率最高的UIKit.framework和Fundation.framework都属于动态库，所有.dylib和.tbd结尾的都属于动态库。动态库的几个特点：  \n\n-\t平时使用的系统库都放在iOS系统中，在你打包应用程序的时候这些库不会拷贝到你的程序中，当需要使用的时候会动态从iOS系统中加载它们，因为这个原因，动态库也被称作共享库。编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。\n- \t这些库是所有应用公用的，换一种说法就是节省了应用安装包的体积，这是区别静态库很重要的一个特点，因为静态库使用一次就要拷贝一次，非常浪费资源。  \n-  动态库在制作的时候可以直接包含静态库，也能自动link所需要的依赖库。\n-  使用动态库的时候不需要再次link依赖库，即导即用，这个就厉害了。**唯一需要注意的是在导入自己制作的动态库时，需要在Embedded Binaries中导入，不然会报错：image not found。此时这个动态库会跟静态库一样被拷贝到目标程序中进行编译，苹果又把这种Framework叫做[Embedded Framework](https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html)**  \n\n**关于动态库要搞清楚一点，我们自己制作的动态库与系统动态库的区别，我们自己制作的动态库引入App项目的时候需要embed进项目，也就是要拷贝到目标程序中，这就有点不像动态库的特性了，苹果这么做也是考虑安全问题吧！**  \n至于能不能正常上架，我也不清楚，查了大量资料都是抄来抄去没说清楚，我猜测是不能上架的，因为一般的第三方SDK也都是静态库的形式，我猜测一个重要原因是iOS的应用本来就是运行在沙盒里面的，不同应用之间不能共享代码，同时动态下载代码苹果肯定也是明令禁止的，所以动态库也就失去意义了。当然可能还有其他因素，欢迎交流学习！\n\n###\t二.\tFramework、.a、.dylib/.tbd\n####\t1.\tFramework  \nFramework的英文释意是框架，主要由Headers、binary文件、.bundle这三部分构成，除此之外还有Info.plist和Modules，后两者主要记录Framework的版本之类的信息，一般都会删掉，不做讨论  \n\n-\t**Headers**  \n包含我们在制作Framework的时候暴露的头文件，所有被暴露的.h都放在这里。\n-\t**binary文件**  \n整个Framework的核心，所有代码都被编译成了这样一坨二进制文件，这里要注意的是添加的依赖库不会被编译进来，用的时候还需要重新link其他依赖库。  \n-\t**.bundle**   \n资源文件都打包放在这里。在制作Framework的时候不可以把图片直接放在项目中，否则制作好之后图片是一张一张的出现在项目中非常乱，需要新建一个bundle将图片放进去，这里的bundle提供整个SDK的图片资源。  \n**注意：**图片放进bundle之后不可以用`[UIImage ImageWithName:]`读取图片。要先找到bundle包再拿图片。  \n\n这里要纠正一个误区\n>\t很多人认为系统的Framework就是动态库，我们自己制作的Framework就是静态库。  \n\n其实Framework既可以是静态库也可以是动态库，这取决于编译成的Mach-O（就是那个二进制文件）是动态库还是静态库，Framework本质上并不是一个库，它是苹果为了方便开发者提供了一种库的打包方式，Framework会将Mach-O文件、头文件和资源包全都包含进来，不需要你再手动整理，我们也可以通过Xcode来制作framework动态库使用。\n**所以总结： Framework是库的打包形式，既可以是动态库也是静态库。**\n\n####\t2.\t.a静态库\n这类静态库与Framework基本类似，不同的是在打包成.a文件的同时，还需要提供头文件，使用时相较于Framework比较麻烦，（例如[微信支付SDK](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419319164&token=&lang=zh_CN)使用的是.a，不同的是[支付宝SDK](https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.Ijm3sG&treeId=193&articleId=104509&docType=1)是以framework的形式打包的）。.a这样打包不够方便，而Framework编译完成暴露的头文件都已经放好了。 \n\n####\t3.\t.dylib/.tbd 动态库 \n这类动态库我们也经常用，基本上都是系统提供的，一般不能自己制作，就算你通过其他方式制作使用，也肯定不能上架的，这里没什么好讲的。 \n\n##\t\t二.\tFramework的制作\n动态库与静态库的制作流程基本一样，包括头文件的暴露等，唯一不同的是Mach-O文件的编译形式。本节将介绍Xcode制作Framework的过程，本次制作的Framework静态库依赖其他第三方静态库（Framework和.a）。\n\n1>\t新建工程\n![新建Framework工程](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B.png)  \n这里要选Framework，如果选择右边的Static Library制作出来的是.a静态库。\n\n2>\t导入所有要打包的文件和其他第三方静态库  \n正常导入要打包的文件就可以了，在导入第三方静态库的时候要注意，不要选择添加到target中，如果添加进去要去target里面把第三方静态库删掉（只需导入，不要添加进target）\n![导入第三方静态库](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9D%99%E6%80%81%E5%BA%93.png)  \n导入第三方静态库之后再link依赖的系统库，像这样  \n![link依赖库](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96%E5%BA%93.png)  \n注意上面的运行目标，因为我用的是Xcode8，最低支持到iOS8。  \n要打包的文件和第三方静态库全部导入完成    \n![所有文件导入情况](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E6%83%85%E5%86%B5.png)   \n\n3>\t项目性质修改  \n把项目的membership需改为public，否则头文件暴露将会不正常  \n![修改项目的membership](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%B7%A5%E7%A8%8B%E6%80%A7%E8%B4%A8.png)  \n\n4>\t暴露头文件  \n将头文件暴露出去，供外界使用，所有的编译文件都在Project中，需要右击添加到public里面  \n![暴露头文件](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%9A%B4%E9%9C%B2%E5%A4%B4%E6%96%87%E4%BB%B6.png)  \n\n**5>\t选择Mach-O的编译方式**  \n这是最重要的一步，这一步决定我们制作出来的是静态库还是动态库，默认选择的是Dynamic Library，要手动选择Static Library\n![Mach-O 形式](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E9%80%89%E6%8B%A9%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F.png)\n\n6>\t编译  \n如果你的依赖库里面有lib开头的dylib动态库，此时应该会报错  \n![动态库链接报错](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E7%B3%BB%E7%BB%9F%E5%8A%A8%E6%80%81%E5%BA%93%E6%8A%A5%E9%94%99.png)  \n什么意思呢？大概就是没找到对应的库文件，因为tbd是苹果提供的新的动态库格式，之前都是dylib，不知道这里又抽什么风，下面解决问题。  \n\n7>\ttbd动态库报错修改  \n先把原来的.tbd删掉，然后再次添加，这个时候选择add other，在弹出的窗口中按快捷键shift + command + G 调出finder的前往窗口，输入/usr/lib，然后添加相应的dylib动态库 \n![修改的动态库](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%9B%BF%E6%8D%A2%E4%BE%9D%E8%B5%96%E5%BA%93.png)  \n替换完成之后重新编译项目，生成Framework(可在Product文件中右击在finder中显示找到)  \n\n8>\t使用  \n新建一个文件夹，将制作好的静态库拷贝出来放进去，再将第三方静态库拷贝到相同的文件夹中，此时只要将这个文件夹提供给外界使用就可以了，这是我写的测试demo验证打包好的SDK是否可以正常使用 \n![制作完成使用](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E4%BD%BF%E7%94%A8.png)  \n至此我们已经完成了Framework中包含其他第三方静态库的制作。  \n**如果需要制作动态库，只需要在第5步中将Mach-O的形式改为Dynamic Library就可以了，其他步骤一样**   \n \n如果有问题请在留言区留言，或者邮件给我，互相交流学习！  \n","source":"_posts/iOS静态库SDK制作（包含第三方静态库）.md","raw":"---\ntitle: iOS静态库SDK制作（包含第三方静态库）\ndate: 2016-11-18\ncategories:\n- 技术笔记\ntags:\n- 静态库\n- 动态库\n- framework\n- SDK\npermalink: Static Library \n\n---\n\n##\t\t前言  \n>\t以下所涉及的框架和库只针对iOS而言，不确保在其他平台也适用。\n\n最近由于公司业务需要，要求封装一个支付SDK，需要用到微信支付和支付宝，之前做过的Framework没有依赖其他第三方的库所以比较好做，这次有所不同；一开始我想把支付宝和微信支付的SDK全部融合进来，折腾一天才发现我之前的想法有很多误区，这样是根本行不通的，不过最后还是封装成功了，下面把我的经验分享出来，供有需要的同学少走弯路。 制作之前最好把功课做足，看看静态库和动态库到底是什么东西。  \n\n<!-- more -->\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n##\t\t一.\t静态库和动态库的详细介绍  \n我们平时的工程中或多或少都要引入第三方的SDK，就算你没有引入第三方的，至少引用过系统的Framework吧？其实这些SDK和Framework都属于库，库又分为静态库和动态库，我们平时导入的第三方SDK有的是Framework，有的是.a，到底哪些是动态库，哪些是静态库呢？下面分别介绍静态库、动态库，Framework和.a以及.dylib/.tbd区别  \t\n###\t一.\t静态库与动态库\n首先要解释一下什么是库，库(Library)其实就是一段编译好的二进制代码，加上头文件就可以供别人使用，一般会有两种情况要用到库：  \n\n- 某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件。  \n- 对于某些不会进行大的改动的代码，比方说很多大公司常用且很少变动的模块都会编译成库，这样做的好处一是可以节省编译时间，二来对于代码的管理也非常方便。  \n\n因为库是已经编译好的二进制文件了，编译的时候只需要link一下，**既然提到了link那就有不同的形式了，静态和动态，与之相对应的就是静态库和动态库**。   \n\n####\t1. 静态库\n平时我们用的第三方SDK基本上都是静态库，静态库的几个特点：  \n\n-\t在App项目编译的时候会被拷贝一份编译到目标程序中，相当于将静态库嵌入了，所以得到的App二进制文件会变大。\n- 在使用的时候，需要手动导入静态库所依赖的其他类库。*（比如说某个SDK中使用到了CoreMotion.framework，在使用的时候需要手动导入。有的SDK需要link十几个系统库，这个时候非常恶心，只能一个一个手动加，这是静态库一个很大的不便之处。）* \n- 导入静态库的应用可以减少对外界的依赖，如果导入的是第三方动态库，动态库找不到的话应用就会崩掉，例如Linux上经常出现的lib not found。\n- 静态库很大的一个优点是减少耦合性，因为静态库中是不可以包含其他静态库的，使用的时候要另外导入它的依赖库，最大限度的保证了每一个静态库都是独立的，不会重复引用。\n\n####\t2.\t动态库  \n这个是我们最常用的一类库，使用频率最高的UIKit.framework和Fundation.framework都属于动态库，所有.dylib和.tbd结尾的都属于动态库。动态库的几个特点：  \n\n-\t平时使用的系统库都放在iOS系统中，在你打包应用程序的时候这些库不会拷贝到你的程序中，当需要使用的时候会动态从iOS系统中加载它们，因为这个原因，动态库也被称作共享库。编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。\n- \t这些库是所有应用公用的，换一种说法就是节省了应用安装包的体积，这是区别静态库很重要的一个特点，因为静态库使用一次就要拷贝一次，非常浪费资源。  \n-  动态库在制作的时候可以直接包含静态库，也能自动link所需要的依赖库。\n-  使用动态库的时候不需要再次link依赖库，即导即用，这个就厉害了。**唯一需要注意的是在导入自己制作的动态库时，需要在Embedded Binaries中导入，不然会报错：image not found。此时这个动态库会跟静态库一样被拷贝到目标程序中进行编译，苹果又把这种Framework叫做[Embedded Framework](https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html)**  \n\n**关于动态库要搞清楚一点，我们自己制作的动态库与系统动态库的区别，我们自己制作的动态库引入App项目的时候需要embed进项目，也就是要拷贝到目标程序中，这就有点不像动态库的特性了，苹果这么做也是考虑安全问题吧！**  \n至于能不能正常上架，我也不清楚，查了大量资料都是抄来抄去没说清楚，我猜测是不能上架的，因为一般的第三方SDK也都是静态库的形式，我猜测一个重要原因是iOS的应用本来就是运行在沙盒里面的，不同应用之间不能共享代码，同时动态下载代码苹果肯定也是明令禁止的，所以动态库也就失去意义了。当然可能还有其他因素，欢迎交流学习！\n\n###\t二.\tFramework、.a、.dylib/.tbd\n####\t1.\tFramework  \nFramework的英文释意是框架，主要由Headers、binary文件、.bundle这三部分构成，除此之外还有Info.plist和Modules，后两者主要记录Framework的版本之类的信息，一般都会删掉，不做讨论  \n\n-\t**Headers**  \n包含我们在制作Framework的时候暴露的头文件，所有被暴露的.h都放在这里。\n-\t**binary文件**  \n整个Framework的核心，所有代码都被编译成了这样一坨二进制文件，这里要注意的是添加的依赖库不会被编译进来，用的时候还需要重新link其他依赖库。  \n-\t**.bundle**   \n资源文件都打包放在这里。在制作Framework的时候不可以把图片直接放在项目中，否则制作好之后图片是一张一张的出现在项目中非常乱，需要新建一个bundle将图片放进去，这里的bundle提供整个SDK的图片资源。  \n**注意：**图片放进bundle之后不可以用`[UIImage ImageWithName:]`读取图片。要先找到bundle包再拿图片。  \n\n这里要纠正一个误区\n>\t很多人认为系统的Framework就是动态库，我们自己制作的Framework就是静态库。  \n\n其实Framework既可以是静态库也可以是动态库，这取决于编译成的Mach-O（就是那个二进制文件）是动态库还是静态库，Framework本质上并不是一个库，它是苹果为了方便开发者提供了一种库的打包方式，Framework会将Mach-O文件、头文件和资源包全都包含进来，不需要你再手动整理，我们也可以通过Xcode来制作framework动态库使用。\n**所以总结： Framework是库的打包形式，既可以是动态库也是静态库。**\n\n####\t2.\t.a静态库\n这类静态库与Framework基本类似，不同的是在打包成.a文件的同时，还需要提供头文件，使用时相较于Framework比较麻烦，（例如[微信支付SDK](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419319164&token=&lang=zh_CN)使用的是.a，不同的是[支付宝SDK](https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.Ijm3sG&treeId=193&articleId=104509&docType=1)是以framework的形式打包的）。.a这样打包不够方便，而Framework编译完成暴露的头文件都已经放好了。 \n\n####\t3.\t.dylib/.tbd 动态库 \n这类动态库我们也经常用，基本上都是系统提供的，一般不能自己制作，就算你通过其他方式制作使用，也肯定不能上架的，这里没什么好讲的。 \n\n##\t\t二.\tFramework的制作\n动态库与静态库的制作流程基本一样，包括头文件的暴露等，唯一不同的是Mach-O文件的编译形式。本节将介绍Xcode制作Framework的过程，本次制作的Framework静态库依赖其他第三方静态库（Framework和.a）。\n\n1>\t新建工程\n![新建Framework工程](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B.png)  \n这里要选Framework，如果选择右边的Static Library制作出来的是.a静态库。\n\n2>\t导入所有要打包的文件和其他第三方静态库  \n正常导入要打包的文件就可以了，在导入第三方静态库的时候要注意，不要选择添加到target中，如果添加进去要去target里面把第三方静态库删掉（只需导入，不要添加进target）\n![导入第三方静态库](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9D%99%E6%80%81%E5%BA%93.png)  \n导入第三方静态库之后再link依赖的系统库，像这样  \n![link依赖库](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96%E5%BA%93.png)  \n注意上面的运行目标，因为我用的是Xcode8，最低支持到iOS8。  \n要打包的文件和第三方静态库全部导入完成    \n![所有文件导入情况](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E6%83%85%E5%86%B5.png)   \n\n3>\t项目性质修改  \n把项目的membership需改为public，否则头文件暴露将会不正常  \n![修改项目的membership](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%B7%A5%E7%A8%8B%E6%80%A7%E8%B4%A8.png)  \n\n4>\t暴露头文件  \n将头文件暴露出去，供外界使用，所有的编译文件都在Project中，需要右击添加到public里面  \n![暴露头文件](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%9A%B4%E9%9C%B2%E5%A4%B4%E6%96%87%E4%BB%B6.png)  \n\n**5>\t选择Mach-O的编译方式**  \n这是最重要的一步，这一步决定我们制作出来的是静态库还是动态库，默认选择的是Dynamic Library，要手动选择Static Library\n![Mach-O 形式](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E9%80%89%E6%8B%A9%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F.png)\n\n6>\t编译  \n如果你的依赖库里面有lib开头的dylib动态库，此时应该会报错  \n![动态库链接报错](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E7%B3%BB%E7%BB%9F%E5%8A%A8%E6%80%81%E5%BA%93%E6%8A%A5%E9%94%99.png)  \n什么意思呢？大概就是没找到对应的库文件，因为tbd是苹果提供的新的动态库格式，之前都是dylib，不知道这里又抽什么风，下面解决问题。  \n\n7>\ttbd动态库报错修改  \n先把原来的.tbd删掉，然后再次添加，这个时候选择add other，在弹出的窗口中按快捷键shift + command + G 调出finder的前往窗口，输入/usr/lib，然后添加相应的dylib动态库 \n![修改的动态库](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%9B%BF%E6%8D%A2%E4%BE%9D%E8%B5%96%E5%BA%93.png)  \n替换完成之后重新编译项目，生成Framework(可在Product文件中右击在finder中显示找到)  \n\n8>\t使用  \n新建一个文件夹，将制作好的静态库拷贝出来放进去，再将第三方静态库拷贝到相同的文件夹中，此时只要将这个文件夹提供给外界使用就可以了，这是我写的测试demo验证打包好的SDK是否可以正常使用 \n![制作完成使用](http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E4%BD%BF%E7%94%A8.png)  \n至此我们已经完成了Framework中包含其他第三方静态库的制作。  \n**如果需要制作动态库，只需要在第5步中将Mach-O的形式改为Dynamic Library就可以了，其他步骤一样**   \n \n如果有问题请在留言区留言，或者邮件给我，互相交流学习！  \n","slug":"Static Library","published":1,"updated":"2017-11-02T13:09:57.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9no6vmn000fjaen5cn518s8","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>   以下所涉及的框架和库只针对iOS而言，不确保在其他平台也适用。</p>\n</blockquote>\n<p>最近由于公司业务需要，要求封装一个支付SDK，需要用到微信支付和支付宝，之前做过的Framework没有依赖其他第三方的库所以比较好做，这次有所不同；一开始我想把支付宝和微信支付的SDK全部融合进来，折腾一天才发现我之前的想法有很多误区，这样是根本行不通的，不过最后还是封装成功了，下面把我的经验分享出来，供有需要的同学少走弯路。 制作之前最好把功课做足，看看静态库和动态库到底是什么东西。  </p>\n<a id=\"more\"></a>\n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<h2 id=\"一-静态库和动态库的详细介绍\"><a href=\"#一-静态库和动态库的详细介绍\" class=\"headerlink\" title=\"一.    静态库和动态库的详细介绍\"></a>一.    静态库和动态库的详细介绍</h2><p>我们平时的工程中或多或少都要引入第三方的SDK，就算你没有引入第三方的，至少引用过系统的Framework吧？其实这些SDK和Framework都属于库，库又分为静态库和动态库，我们平时导入的第三方SDK有的是Framework，有的是.a，到底哪些是动态库，哪些是静态库呢？下面分别介绍静态库、动态库，Framework和.a以及.dylib/.tbd区别      </p>\n<h3 id=\"一-静态库与动态库\"><a href=\"#一-静态库与动态库\" class=\"headerlink\" title=\"一.    静态库与动态库\"></a>一.    静态库与动态库</h3><p>首先要解释一下什么是库，库(Library)其实就是一段编译好的二进制代码，加上头文件就可以供别人使用，一般会有两种情况要用到库：  </p>\n<ul>\n<li>某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件。  </li>\n<li>对于某些不会进行大的改动的代码，比方说很多大公司常用且很少变动的模块都会编译成库，这样做的好处一是可以节省编译时间，二来对于代码的管理也非常方便。  </li>\n</ul>\n<p>因为库是已经编译好的二进制文件了，编译的时候只需要link一下，<strong>既然提到了link那就有不同的形式了，静态和动态，与之相对应的就是静态库和动态库</strong>。   </p>\n<h4 id=\"1-静态库\"><a href=\"#1-静态库\" class=\"headerlink\" title=\"1. 静态库\"></a>1. 静态库</h4><p>平时我们用的第三方SDK基本上都是静态库，静态库的几个特点：  </p>\n<ul>\n<li>在App项目编译的时候会被拷贝一份编译到目标程序中，相当于将静态库嵌入了，所以得到的App二进制文件会变大。</li>\n<li>在使用的时候，需要手动导入静态库所依赖的其他类库。<em>（比如说某个SDK中使用到了CoreMotion.framework，在使用的时候需要手动导入。有的SDK需要link十几个系统库，这个时候非常恶心，只能一个一个手动加，这是静态库一个很大的不便之处。）</em> </li>\n<li>导入静态库的应用可以减少对外界的依赖，如果导入的是第三方动态库，动态库找不到的话应用就会崩掉，例如Linux上经常出现的lib not found。</li>\n<li>静态库很大的一个优点是减少耦合性，因为静态库中是不可以包含其他静态库的，使用的时候要另外导入它的依赖库，最大限度的保证了每一个静态库都是独立的，不会重复引用。</li>\n</ul>\n<h4 id=\"2-动态库\"><a href=\"#2-动态库\" class=\"headerlink\" title=\"2.    动态库\"></a>2.    动态库</h4><p>这个是我们最常用的一类库，使用频率最高的UIKit.framework和Fundation.framework都属于动态库，所有.dylib和.tbd结尾的都属于动态库。动态库的几个特点：  </p>\n<ul>\n<li>平时使用的系统库都放在iOS系统中，在你打包应用程序的时候这些库不会拷贝到你的程序中，当需要使用的时候会动态从iOS系统中加载它们，因为这个原因，动态库也被称作共享库。编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。</li>\n<li>这些库是所有应用公用的，换一种说法就是节省了应用安装包的体积，这是区别静态库很重要的一个特点，因为静态库使用一次就要拷贝一次，非常浪费资源。  </li>\n<li>动态库在制作的时候可以直接包含静态库，也能自动link所需要的依赖库。</li>\n<li>使用动态库的时候不需要再次link依赖库，即导即用，这个就厉害了。<strong>唯一需要注意的是在导入自己制作的动态库时，需要在Embedded Binaries中导入，不然会报错：image not found。此时这个动态库会跟静态库一样被拷贝到目标程序中进行编译，苹果又把这种Framework叫做<a href=\"https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html\" target=\"_blank\" rel=\"external\">Embedded Framework</a></strong>  </li>\n</ul>\n<p><strong>关于动态库要搞清楚一点，我们自己制作的动态库与系统动态库的区别，我们自己制作的动态库引入App项目的时候需要embed进项目，也就是要拷贝到目标程序中，这就有点不像动态库的特性了，苹果这么做也是考虑安全问题吧！</strong><br>至于能不能正常上架，我也不清楚，查了大量资料都是抄来抄去没说清楚，我猜测是不能上架的，因为一般的第三方SDK也都是静态库的形式，我猜测一个重要原因是iOS的应用本来就是运行在沙盒里面的，不同应用之间不能共享代码，同时动态下载代码苹果肯定也是明令禁止的，所以动态库也就失去意义了。当然可能还有其他因素，欢迎交流学习！</p>\n<h3 id=\"二-Framework、-a、-dylib-tbd\"><a href=\"#二-Framework、-a、-dylib-tbd\" class=\"headerlink\" title=\"二.    Framework、.a、.dylib/.tbd\"></a>二.    Framework、.a、.dylib/.tbd</h3><h4 id=\"1-Framework\"><a href=\"#1-Framework\" class=\"headerlink\" title=\"1.    Framework\"></a>1.    Framework</h4><p>Framework的英文释意是框架，主要由Headers、binary文件、.bundle这三部分构成，除此之外还有Info.plist和Modules，后两者主要记录Framework的版本之类的信息，一般都会删掉，不做讨论  </p>\n<ul>\n<li><strong>Headers</strong><br>包含我们在制作Framework的时候暴露的头文件，所有被暴露的.h都放在这里。</li>\n<li><strong>binary文件</strong><br>整个Framework的核心，所有代码都被编译成了这样一坨二进制文件，这里要注意的是添加的依赖库不会被编译进来，用的时候还需要重新link其他依赖库。  </li>\n<li><strong>.bundle</strong><br>资源文件都打包放在这里。在制作Framework的时候不可以把图片直接放在项目中，否则制作好之后图片是一张一张的出现在项目中非常乱，需要新建一个bundle将图片放进去，这里的bundle提供整个SDK的图片资源。<br><strong>注意：</strong>图片放进bundle之后不可以用<code>[UIImage ImageWithName:]</code>读取图片。要先找到bundle包再拿图片。  </li>\n</ul>\n<p>这里要纠正一个误区</p>\n<blockquote>\n<p>   很多人认为系统的Framework就是动态库，我们自己制作的Framework就是静态库。  </p>\n</blockquote>\n<p>其实Framework既可以是静态库也可以是动态库，这取决于编译成的Mach-O（就是那个二进制文件）是动态库还是静态库，Framework本质上并不是一个库，它是苹果为了方便开发者提供了一种库的打包方式，Framework会将Mach-O文件、头文件和资源包全都包含进来，不需要你再手动整理，我们也可以通过Xcode来制作framework动态库使用。<br><strong>所以总结： Framework是库的打包形式，既可以是动态库也是静态库。</strong></p>\n<h4 id=\"2-a静态库\"><a href=\"#2-a静态库\" class=\"headerlink\" title=\"2.    .a静态库\"></a>2.    .a静态库</h4><p>这类静态库与Framework基本类似，不同的是在打包成.a文件的同时，还需要提供头文件，使用时相较于Framework比较麻烦，（例如<a href=\"https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419319164&amp;token=&amp;lang=zh_CN\" target=\"_blank\" rel=\"external\">微信支付SDK</a>使用的是.a，不同的是<a href=\"https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.Ijm3sG&amp;treeId=193&amp;articleId=104509&amp;docType=1\" target=\"_blank\" rel=\"external\">支付宝SDK</a>是以framework的形式打包的）。.a这样打包不够方便，而Framework编译完成暴露的头文件都已经放好了。 </p>\n<h4 id=\"3-dylib-tbd-动态库\"><a href=\"#3-dylib-tbd-动态库\" class=\"headerlink\" title=\"3.    .dylib/.tbd 动态库\"></a>3.    .dylib/.tbd 动态库</h4><p>这类动态库我们也经常用，基本上都是系统提供的，一般不能自己制作，就算你通过其他方式制作使用，也肯定不能上架的，这里没什么好讲的。 </p>\n<h2 id=\"二-Framework的制作\"><a href=\"#二-Framework的制作\" class=\"headerlink\" title=\"二.    Framework的制作\"></a>二.    Framework的制作</h2><p>动态库与静态库的制作流程基本一样，包括头文件的暴露等，唯一不同的是Mach-O文件的编译形式。本节将介绍Xcode制作Framework的过程，本次制作的Framework静态库依赖其他第三方静态库（Framework和.a）。</p>\n<p>1&gt;    新建工程<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B.png\" alt=\"新建Framework工程\"><br>这里要选Framework，如果选择右边的Static Library制作出来的是.a静态库。</p>\n<p>2&gt;    导入所有要打包的文件和其他第三方静态库<br>正常导入要打包的文件就可以了，在导入第三方静态库的时候要注意，不要选择添加到target中，如果添加进去要去target里面把第三方静态库删掉（只需导入，不要添加进target）<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9D%99%E6%80%81%E5%BA%93.png\" alt=\"导入第三方静态库\"><br>导入第三方静态库之后再link依赖的系统库，像这样<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96%E5%BA%93.png\" alt=\"link依赖库\"><br>注意上面的运行目标，因为我用的是Xcode8，最低支持到iOS8。<br>要打包的文件和第三方静态库全部导入完成<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E6%83%85%E5%86%B5.png\" alt=\"所有文件导入情况\">   </p>\n<p>3&gt;    项目性质修改<br>把项目的membership需改为public，否则头文件暴露将会不正常<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%B7%A5%E7%A8%8B%E6%80%A7%E8%B4%A8.png\" alt=\"修改项目的membership\">  </p>\n<p>4&gt;    暴露头文件<br>将头文件暴露出去，供外界使用，所有的编译文件都在Project中，需要右击添加到public里面<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%9A%B4%E9%9C%B2%E5%A4%B4%E6%96%87%E4%BB%B6.png\" alt=\"暴露头文件\">  </p>\n<p><strong>5&gt;    选择Mach-O的编译方式</strong><br>这是最重要的一步，这一步决定我们制作出来的是静态库还是动态库，默认选择的是Dynamic Library，要手动选择Static Library<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E9%80%89%E6%8B%A9%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F.png\" alt=\"Mach-O 形式\"></p>\n<p>6&gt;    编译<br>如果你的依赖库里面有lib开头的dylib动态库，此时应该会报错<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E7%B3%BB%E7%BB%9F%E5%8A%A8%E6%80%81%E5%BA%93%E6%8A%A5%E9%94%99.png\" alt=\"动态库链接报错\"><br>什么意思呢？大概就是没找到对应的库文件，因为tbd是苹果提供的新的动态库格式，之前都是dylib，不知道这里又抽什么风，下面解决问题。  </p>\n<p>7&gt;    tbd动态库报错修改<br>先把原来的.tbd删掉，然后再次添加，这个时候选择add other，在弹出的窗口中按快捷键shift + command + G 调出finder的前往窗口，输入/usr/lib，然后添加相应的dylib动态库<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%9B%BF%E6%8D%A2%E4%BE%9D%E8%B5%96%E5%BA%93.png\" alt=\"修改的动态库\"><br>替换完成之后重新编译项目，生成Framework(可在Product文件中右击在finder中显示找到)  </p>\n<p>8&gt;    使用<br>新建一个文件夹，将制作好的静态库拷贝出来放进去，再将第三方静态库拷贝到相同的文件夹中，此时只要将这个文件夹提供给外界使用就可以了，这是我写的测试demo验证打包好的SDK是否可以正常使用<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E4%BD%BF%E7%94%A8.png\" alt=\"制作完成使用\"><br>至此我们已经完成了Framework中包含其他第三方静态库的制作。<br><strong>如果需要制作动态库，只需要在第5步中将Mach-O的形式改为Dynamic Library就可以了，其他步骤一样</strong>   </p>\n<p>如果有问题请在留言区留言，或者邮件给我，互相交流学习！  </p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>   以下所涉及的框架和库只针对iOS而言，不确保在其他平台也适用。</p>\n</blockquote>\n<p>最近由于公司业务需要，要求封装一个支付SDK，需要用到微信支付和支付宝，之前做过的Framework没有依赖其他第三方的库所以比较好做，这次有所不同；一开始我想把支付宝和微信支付的SDK全部融合进来，折腾一天才发现我之前的想法有很多误区，这样是根本行不通的，不过最后还是封装成功了，下面把我的经验分享出来，供有需要的同学少走弯路。 制作之前最好把功课做足，看看静态库和动态库到底是什么东西。  </p>","more":"<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<h2 id=\"一-静态库和动态库的详细介绍\"><a href=\"#一-静态库和动态库的详细介绍\" class=\"headerlink\" title=\"一.    静态库和动态库的详细介绍\"></a>一.    静态库和动态库的详细介绍</h2><p>我们平时的工程中或多或少都要引入第三方的SDK，就算你没有引入第三方的，至少引用过系统的Framework吧？其实这些SDK和Framework都属于库，库又分为静态库和动态库，我们平时导入的第三方SDK有的是Framework，有的是.a，到底哪些是动态库，哪些是静态库呢？下面分别介绍静态库、动态库，Framework和.a以及.dylib/.tbd区别      </p>\n<h3 id=\"一-静态库与动态库\"><a href=\"#一-静态库与动态库\" class=\"headerlink\" title=\"一.    静态库与动态库\"></a>一.    静态库与动态库</h3><p>首先要解释一下什么是库，库(Library)其实就是一段编译好的二进制代码，加上头文件就可以供别人使用，一般会有两种情况要用到库：  </p>\n<ul>\n<li>某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件。  </li>\n<li>对于某些不会进行大的改动的代码，比方说很多大公司常用且很少变动的模块都会编译成库，这样做的好处一是可以节省编译时间，二来对于代码的管理也非常方便。  </li>\n</ul>\n<p>因为库是已经编译好的二进制文件了，编译的时候只需要link一下，<strong>既然提到了link那就有不同的形式了，静态和动态，与之相对应的就是静态库和动态库</strong>。   </p>\n<h4 id=\"1-静态库\"><a href=\"#1-静态库\" class=\"headerlink\" title=\"1. 静态库\"></a>1. 静态库</h4><p>平时我们用的第三方SDK基本上都是静态库，静态库的几个特点：  </p>\n<ul>\n<li>在App项目编译的时候会被拷贝一份编译到目标程序中，相当于将静态库嵌入了，所以得到的App二进制文件会变大。</li>\n<li>在使用的时候，需要手动导入静态库所依赖的其他类库。<em>（比如说某个SDK中使用到了CoreMotion.framework，在使用的时候需要手动导入。有的SDK需要link十几个系统库，这个时候非常恶心，只能一个一个手动加，这是静态库一个很大的不便之处。）</em> </li>\n<li>导入静态库的应用可以减少对外界的依赖，如果导入的是第三方动态库，动态库找不到的话应用就会崩掉，例如Linux上经常出现的lib not found。</li>\n<li>静态库很大的一个优点是减少耦合性，因为静态库中是不可以包含其他静态库的，使用的时候要另外导入它的依赖库，最大限度的保证了每一个静态库都是独立的，不会重复引用。</li>\n</ul>\n<h4 id=\"2-动态库\"><a href=\"#2-动态库\" class=\"headerlink\" title=\"2.    动态库\"></a>2.    动态库</h4><p>这个是我们最常用的一类库，使用频率最高的UIKit.framework和Fundation.framework都属于动态库，所有.dylib和.tbd结尾的都属于动态库。动态库的几个特点：  </p>\n<ul>\n<li>平时使用的系统库都放在iOS系统中，在你打包应用程序的时候这些库不会拷贝到你的程序中，当需要使用的时候会动态从iOS系统中加载它们，因为这个原因，动态库也被称作共享库。编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。</li>\n<li>这些库是所有应用公用的，换一种说法就是节省了应用安装包的体积，这是区别静态库很重要的一个特点，因为静态库使用一次就要拷贝一次，非常浪费资源。  </li>\n<li>动态库在制作的时候可以直接包含静态库，也能自动link所需要的依赖库。</li>\n<li>使用动态库的时候不需要再次link依赖库，即导即用，这个就厉害了。<strong>唯一需要注意的是在导入自己制作的动态库时，需要在Embedded Binaries中导入，不然会报错：image not found。此时这个动态库会跟静态库一样被拷贝到目标程序中进行编译，苹果又把这种Framework叫做<a href=\"https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html\" target=\"_blank\" rel=\"external\">Embedded Framework</a></strong>  </li>\n</ul>\n<p><strong>关于动态库要搞清楚一点，我们自己制作的动态库与系统动态库的区别，我们自己制作的动态库引入App项目的时候需要embed进项目，也就是要拷贝到目标程序中，这就有点不像动态库的特性了，苹果这么做也是考虑安全问题吧！</strong><br>至于能不能正常上架，我也不清楚，查了大量资料都是抄来抄去没说清楚，我猜测是不能上架的，因为一般的第三方SDK也都是静态库的形式，我猜测一个重要原因是iOS的应用本来就是运行在沙盒里面的，不同应用之间不能共享代码，同时动态下载代码苹果肯定也是明令禁止的，所以动态库也就失去意义了。当然可能还有其他因素，欢迎交流学习！</p>\n<h3 id=\"二-Framework、-a、-dylib-tbd\"><a href=\"#二-Framework、-a、-dylib-tbd\" class=\"headerlink\" title=\"二.    Framework、.a、.dylib/.tbd\"></a>二.    Framework、.a、.dylib/.tbd</h3><h4 id=\"1-Framework\"><a href=\"#1-Framework\" class=\"headerlink\" title=\"1.    Framework\"></a>1.    Framework</h4><p>Framework的英文释意是框架，主要由Headers、binary文件、.bundle这三部分构成，除此之外还有Info.plist和Modules，后两者主要记录Framework的版本之类的信息，一般都会删掉，不做讨论  </p>\n<ul>\n<li><strong>Headers</strong><br>包含我们在制作Framework的时候暴露的头文件，所有被暴露的.h都放在这里。</li>\n<li><strong>binary文件</strong><br>整个Framework的核心，所有代码都被编译成了这样一坨二进制文件，这里要注意的是添加的依赖库不会被编译进来，用的时候还需要重新link其他依赖库。  </li>\n<li><strong>.bundle</strong><br>资源文件都打包放在这里。在制作Framework的时候不可以把图片直接放在项目中，否则制作好之后图片是一张一张的出现在项目中非常乱，需要新建一个bundle将图片放进去，这里的bundle提供整个SDK的图片资源。<br><strong>注意：</strong>图片放进bundle之后不可以用<code>[UIImage ImageWithName:]</code>读取图片。要先找到bundle包再拿图片。  </li>\n</ul>\n<p>这里要纠正一个误区</p>\n<blockquote>\n<p>   很多人认为系统的Framework就是动态库，我们自己制作的Framework就是静态库。  </p>\n</blockquote>\n<p>其实Framework既可以是静态库也可以是动态库，这取决于编译成的Mach-O（就是那个二进制文件）是动态库还是静态库，Framework本质上并不是一个库，它是苹果为了方便开发者提供了一种库的打包方式，Framework会将Mach-O文件、头文件和资源包全都包含进来，不需要你再手动整理，我们也可以通过Xcode来制作framework动态库使用。<br><strong>所以总结： Framework是库的打包形式，既可以是动态库也是静态库。</strong></p>\n<h4 id=\"2-a静态库\"><a href=\"#2-a静态库\" class=\"headerlink\" title=\"2.    .a静态库\"></a>2.    .a静态库</h4><p>这类静态库与Framework基本类似，不同的是在打包成.a文件的同时，还需要提供头文件，使用时相较于Framework比较麻烦，（例如<a href=\"https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419319164&amp;token=&amp;lang=zh_CN\" target=\"_blank\" rel=\"external\">微信支付SDK</a>使用的是.a，不同的是<a href=\"https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.Ijm3sG&amp;treeId=193&amp;articleId=104509&amp;docType=1\" target=\"_blank\" rel=\"external\">支付宝SDK</a>是以framework的形式打包的）。.a这样打包不够方便，而Framework编译完成暴露的头文件都已经放好了。 </p>\n<h4 id=\"3-dylib-tbd-动态库\"><a href=\"#3-dylib-tbd-动态库\" class=\"headerlink\" title=\"3.    .dylib/.tbd 动态库\"></a>3.    .dylib/.tbd 动态库</h4><p>这类动态库我们也经常用，基本上都是系统提供的，一般不能自己制作，就算你通过其他方式制作使用，也肯定不能上架的，这里没什么好讲的。 </p>\n<h2 id=\"二-Framework的制作\"><a href=\"#二-Framework的制作\" class=\"headerlink\" title=\"二.    Framework的制作\"></a>二.    Framework的制作</h2><p>动态库与静态库的制作流程基本一样，包括头文件的暴露等，唯一不同的是Mach-O文件的编译形式。本节将介绍Xcode制作Framework的过程，本次制作的Framework静态库依赖其他第三方静态库（Framework和.a）。</p>\n<p>1&gt;    新建工程<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B.png\" alt=\"新建Framework工程\"><br>这里要选Framework，如果选择右边的Static Library制作出来的是.a静态库。</p>\n<p>2&gt;    导入所有要打包的文件和其他第三方静态库<br>正常导入要打包的文件就可以了，在导入第三方静态库的时候要注意，不要选择添加到target中，如果添加进去要去target里面把第三方静态库删掉（只需导入，不要添加进target）<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9D%99%E6%80%81%E5%BA%93.png\" alt=\"导入第三方静态库\"><br>导入第三方静态库之后再link依赖的系统库，像这样<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96%E5%BA%93.png\" alt=\"link依赖库\"><br>注意上面的运行目标，因为我用的是Xcode8，最低支持到iOS8。<br>要打包的文件和第三方静态库全部导入完成<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E6%83%85%E5%86%B5.png\" alt=\"所有文件导入情况\">   </p>\n<p>3&gt;    项目性质修改<br>把项目的membership需改为public，否则头文件暴露将会不正常<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%B7%A5%E7%A8%8B%E6%80%A7%E8%B4%A8.png\" alt=\"修改项目的membership\">  </p>\n<p>4&gt;    暴露头文件<br>将头文件暴露出去，供外界使用，所有的编译文件都在Project中，需要右击添加到public里面<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%9A%B4%E9%9C%B2%E5%A4%B4%E6%96%87%E4%BB%B6.png\" alt=\"暴露头文件\">  </p>\n<p><strong>5&gt;    选择Mach-O的编译方式</strong><br>这是最重要的一步，这一步决定我们制作出来的是静态库还是动态库，默认选择的是Dynamic Library，要手动选择Static Library<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E9%80%89%E6%8B%A9%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F.png\" alt=\"Mach-O 形式\"></p>\n<p>6&gt;    编译<br>如果你的依赖库里面有lib开头的dylib动态库，此时应该会报错<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E7%B3%BB%E7%BB%9F%E5%8A%A8%E6%80%81%E5%BA%93%E6%8A%A5%E9%94%99.png\" alt=\"动态库链接报错\"><br>什么意思呢？大概就是没找到对应的库文件，因为tbd是苹果提供的新的动态库格式，之前都是dylib，不知道这里又抽什么风，下面解决问题。  </p>\n<p>7&gt;    tbd动态库报错修改<br>先把原来的.tbd删掉，然后再次添加，这个时候选择add other，在弹出的窗口中按快捷键shift + command + G 调出finder的前往窗口，输入/usr/lib，然后添加相应的dylib动态库<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%9B%BF%E6%8D%A2%E4%BE%9D%E8%B5%96%E5%BA%93.png\" alt=\"修改的动态库\"><br>替换完成之后重新编译项目，生成Framework(可在Product文件中右击在finder中显示找到)  </p>\n<p>8&gt;    使用<br>新建一个文件夹，将制作好的静态库拷贝出来放进去，再将第三方静态库拷贝到相同的文件夹中，此时只要将这个文件夹提供给外界使用就可以了，这是我写的测试demo验证打包好的SDK是否可以正常使用<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E4%BD%BF%E7%94%A8.png\" alt=\"制作完成使用\"><br>至此我们已经完成了Framework中包含其他第三方静态库的制作。<br><strong>如果需要制作动态库，只需要在第5步中将Mach-O的形式改为Dynamic Library就可以了，其他步骤一样</strong>   </p>\n<p>如果有问题请在留言区留言，或者邮件给我，互相交流学习！  </p>"},{"title":"iPhone查找序列号生成函数","date":"2016-09-07T16:00:00.000Z","_content":"\n##  前言  \n在iOS7之前我们可以通过`- (NSString *)uniqueIdentifier`这个方法获取iPhone的唯一标识符，也叫作UDID。不过自从iOS7苹果就把这个方法给禁了，此时我们想要获取iPhone的唯一标识符就很困难。  \n不过苹果提供一个叫做IDFA的标识符，这个IDFA是广告标识符用来追踪广告投放的，不过用户可以在设置中手动重置IDFA，可靠性很低，目前常见的两种标记iPhone的方式为  \n*  openUDID  \n*  IDFA或UUID+keychain  \n\n这两种模式都有个弊端，用户重置手机或者刷机唯一标识符会发生变化，不过对于大多数情况是够用了。看来苹果是把路给封死了，有没有办法拿到之前的UDID呢？我们注意到iPhone的设置通用关于里面有手机的硬件信息，其中有一个serialNumber，这个serialnumber就是我们查询手机是否过保的依据，那么它肯定是唯一的，所以下文是围绕这个进行的探索。最终是可以拿到这个serialNumber的， 不过由于苹果的沙盒限制，所以只能在越狱机中拿到，如果想在非越狱机中拿到必须添加entitlements文件来获取权限，可想而知这个应用是无法上架的。**下文仅作为逆向工程的一种思路和探索** \n<!-- more -->\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n##  正文\n###\t一、SSH连接手机（USB模式）\n####\t1.映射端口\n```shell\nLeonLei-MBP:~ gaoshilei$ /Users/gaoshilei/Desktop/reverse/USBSSH/tcprelay.py -t 22:6666\nForwarding local port 6666 to remote port 22\n```\n####\t2.连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试\n```OC\nLeonLei-MBP:~ gaoshilei$ ssh root@localhost -p 6666\niPhone-5S:~ root# ps -e | grep Pre\n  270 ??         0:00.29 /System/Library/PrivateFrameworks/MobileSoftwareUpdate.framework/XPCServices/com.apple.MobileSoftwareUpdate.CleanupPreparePathService.xpc/com.apple.MobileSoftwareUpdate.CleanupPreparePathService\n 1192 ??         0:14.26 /var/db/stash/_.fP74Fg/Applications/Preferences.app/Preferences\n 1289 ttys000    0:00.01 grep Pre\niPhone-5S:~ root# debugserver *:1234 -a \"Preferences\"\ndebugserver-@(#)PROGRAM:debugserver  PROJECT:debugserver-340.3.51.1\n for arm64.\nAttaching to process Preferences...\nListening to port 1234 for a connection from *...\n```\n####\t3.完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样\n```Object-C\nLeonLei-MBP:~ gaoshilei$ /Users/gaoshilei/Desktop/reverse/USBSSH/tcprelay.py -t 1234:1234\nForwarding local port 1234 to remote port 1234\n```\n###\t二、通过LLDB、IDA寻找线索\nlldb的调试端口已经打开，此时我们可以进入调试\n\n```\nLeonLei-MBP:~ gaoshilei$ lldb\n(lldb) process connect connect://localhost:1234\nProcess 1192 stopped  \n* thread #1: tid = 0x523a6, 0x000000019a3c8a40 libsystem_kernel.dylib`mach_msg_trap + 8, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP  \n    frame #0: 0x000000019a3c8a40 libsystem_kernel.dylib`mach_msg_trap + 8\nlibsystem_kernel.dylib`mach_msg_trap:\n->  0x19a3c8a40 <+8>: ret    \nlibsystem_kernel.dylib`mach_msg_overwrite_trap:\n    0x19a3c8a44 <+0>: movn   x16, #0x1f\n    0x19a3c8a48 <+4>: svc    #0x80\n    0x19a3c8a4c <+8>: ret    \n```\n此时我们已经成功进入Preferences的调试阶段，先c一下，让程序继续运行\n  \n```\n(lldb) c\nProcess 1192 resuming\n```\n这么做的原因是我们待会要打印image的基地址偏移，有可能在我们打印的image list中没有我们想要的image。\n此时我们已经找到到Preference.framework的基地址偏移，见下图\n\n```\n(lldb) im li -o -f\n[  0] 0x00000000000dc000 /var/db/stash/_.fP74Fg/Applications/Preferences.app/Preferences(0x00000001000dc000)\n[  1] 0x0000000100100000 /Library/MobileSubstrate/MobileSubstrate.dylib(0x0000000100100000)\n[  2] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/PrivateFrameworks/BulletinBoard.framework/BulletinBoard\n[  3] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\n[  4] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit\n…\n[ 44] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/PrivateFrameworks/Preferences.framework/Preferences\n…  \n```\n我们要找的image的序号在这里是44，它的基地址偏移为0x2e50000，我们把从iPhone中导出的PrivateFrameworks中的Preferences.framework丢到IDA中进行分析，这个二进制文件比较小，很快就分析完成，在前面我们已经知道iPhone的唯一序列号serial number是通过PSListController生成的，并且我们知道这是一个cell，我们要去调试`[PSListController tableView:cellForRowAtIndexPath:]`这个方法，从中找到cell值的来源，从而找到获取序列号的方法。\n\n```ObjC\n__text:00000001908040C8 ; -[PSListController tableView:cellForRowAtIndexPath:]\n__text:00000001908040C8 __PSListController_tableView_cellForRowAtIndexPath__\n__text:00000001908040C8                                         ; DATA XREF: __objc_const:000000019C069B88\u0019o\n__text:00000001908040C8\n__text:00000001908040C8 var_80          = -0x80\n__text:00000001908040C8 var_78          = -0x78\n__text:00000001908040C8 var_70          = -0x70\n__text:00000001908040C8 var_68          = -0x68\n__text:00000001908040C8 var_60          = -0x60\n__text:00000001908040C8 var_50          = -0x50\n__text:00000001908040C8 var_40          = -0x40\n__text:00000001908040C8 var_30          = -0x30\n__text:00000001908040C8 var_20          = -0x20\n__text:00000001908040C8 var_10          = -0x10\n__text:00000001908040C8\n__text:00000001908040C8                 STP             X28, X27, [SP,#var_60]!\n__text:00000001908040CC                 STP             X26, X25, [SP,#0x60+var_50]\n__text:00000001908040D0                 STP             X24, X23, [SP,#0x60+var_40]\n__text:00000001908040D4                 STP             X22, X21, [SP,#0x60+var_30]\n__text:00000001908040D8                 STP             X20, X19, [SP,#0x60+var_20]\n__text:00000001908040DC                 STP             X29, X30, [SP,#0x60+var_10]\n__text:00000001908040E0                 ADD             X29, SP, #0x60+var_10\n__text:00000001908040E4                 SUB             SP, SP, #0x20\n__text:00000001908040E8                 MOV             X21, X3\n__text:00000001908040EC                 MOV             X20, X0\n__text:00000001908040F0                 MOV             X0, X2\n__text:00000001908040F4                 BL              0x96C400A0\n__text:00000001908040F8                 MOV             X26, X0\n__text:00000001908040FC                 ADRP            X8, #off_19DACC568@PAGE\n__text:0000000190804100                 LDR             X1, [X8,#off_19DACC568@PAGEOFF]\n__text:0000000190804104                 MOV             X0, X20\n__text:0000000190804108                 MOV             X2, X21\n__text:000000019080410C                 BL              0x96C39BC0\n__text:0000000190804110                 MOV             X2, X0\n__text:0000000190804114                 ADRP            X8, #_OBJC_IVAR_$_PSListController._specifiers@PAGE ; NSArray *_specifiers;\n__text:0000000190804118                 LDRSW           X27, [X8,#_OBJC_IVAR_$_PSListController._specifiers@PAGEOFF] ; NSArray *_specifiers;\n__text:000000019080411C                 LDR             X0, [X20,X27]\n__text:0000000190804120                 ADRP            X8, #off_19DACC558@PAGE\n……\n```\n我们在Preference.framework中基地址为0x190804114的位置打个断点，具体的做法是：\n\n```ObjC\n(lldb) br s -a 0x190804114+0x2e50000\nBreakpoint 1: where = Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 76, address = 0x0000000193654114\nProcess 1192 stopped\n* thread #1: tid = 0x523a6, 0x0000000193654114 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 76, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n    frame #0: 0x0000000193654114 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 76\nPreferences`-[PSListController tableView:cellForRowAtIndexPath:]:\n->  0x193654114 <+76>: adrp   x8, 53965\n    0x193654118 <+80>: ldrsw  x27, [x8, #516]\n    0x19365411c <+84>: ldr    x0, [x20, x27]\n    0x193654120 <+88>: adrp   x8, 53960\n```\n这里断点这样打是因为系统加载可执行文件和各种framework的时候会有一个地址偏移，我们在打断点的时候要把这个偏移量加上，这样我们打的断点才是准确的。\n可以看到我们已经成功打了一个断点，断点的address = 0x193654114。此时我们打印变量x0和x27的值\n\n```\n(lldb) po $x0\n13\n(lldb) po $x27\n1104\n```\n我们执行ni让程序继续（这里的`ni`命令相当于Xcode的那个下箭头命令，也就是下一行）\n\n```ObjC\n(lldb) ni\nProcess 1192 stopped\n* thread #1: tid = 0x523a6, 0x0000000193654118 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 80, queue = 'com.apple.main-thread', stop reason = instruction step over\n    frame #0: 0x0000000193654118 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 80\nPreferences`-[PSListController tableView:cellForRowAtIndexPath:]:\n->  0x193654118 <+80>: ldrsw  x27, [x8, #516]\n    0x19365411c <+84>: ldr    x0, [x20, x27]\n    0x193654120 <+88>: adrp   x8, 53960\n    0x193654124 <+92>: ldr    x22, [x8, #1368]\n(lldb) ni\nProcess 1192 stopped\n* thread #1: tid = 0x523a6, 0x000000019365411c Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 84, queue = 'com.apple.main-thread', stop reason = instruction step over\n    frame #0: 0x000000019365411c Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 84\nPreferences`-[PSListController tableView:cellForRowAtIndexPath:]:\n->  0x19365411c <+84>: ldr    x0, [x20, x27]\n    0x193654120 <+88>: adrp   x8, 53960\n    0x193654124 <+92>: ldr    x22, [x8, #1368]\n    0x193654128 <+96>: mov    x1, x22\n(lldb) po $x27\n848\n\n(lldb) po $x0\n13\n```\n我们ni的两次，程序已经走到0x19080411C的位置，然后我们继续打印变量x0和x27的值\n\n```\n(lldb) po $x0\n13\n(lldb) po $x27\n1104\n```\n打印出来的x0和x27都是随机数，还是没有什么收获，我们继续\n\n```ObjC\n(lldb) ni\nProcess 1192 stopped\n* thread #1: tid = 0x523a6, 0x0000000193654120 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 88, queue = 'com.apple.main-thread', stop reason = instruction step over\n    frame #0: 0x0000000193654120 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 88\nPreferences`-[PSListController tableView:cellForRowAtIndexPath:]:\n->  0x193654120 <+88>:  adrp   x8, 53960\n    0x193654124 <+92>:  ldr    x22, [x8, #1368]\n    0x193654128 <+96>:  mov    x1, x22\n    0x19365412c <+100>: bl     0x199a89bc0               ; objc_msgSend\n(lldb) po $x0\n<__NSArrayI 0x13105a780>(\nG: <PSSpecifier 0x12ff50cf0: ID 0, Name '' target <(null): 0x0>> 0x12ff50cf0,\n<PSSpecifier 0x12ff50f50: ID NAME_CELL_ID, Name 'Name' target <AboutDataSource: 0x131028390>>,\nG: <PSSpecifier 0x12ff51680: ID 2, Name '' target <(null): 0x0>> 0x12ff51680,\n<PSSpecifier 0x12ff52360: ID NETWORK, Name 'Network' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff52420: ID SONGS, Name 'Songs' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff519f0: ID VIDEOS, Name 'Videos' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff51ab0: ID PHOTOS, Name 'Photos' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff51b70: ID APPLICATIONS, Name 'Applications' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff524e0: ID User Data Capacity, Name 'Capacity' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff525a0: ID User Data Available, Name 'Available' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff526a0: ID ProductVersion, Name 'Version' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff52850: ID CARRIER_VERSION, Name 'Carrier' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff52980: ID ProductModel, Name 'Model' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff52a60: ID SerialNumber, Name 'Serial Number' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff52b90: ID MACAddress, Name 'Wi-Fi Address' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff51050: ID BTMACAddress, Name 'Bluetooth' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12fde95d0: ID ModemVersion, Name 'Modem Firmware' target <AboutDataSource: 0x131028390>>,\nG: <PSSpecifier 0x131031e90: ID 17, Name '' target <(null): 0x0>> 0x131031e90,\n<PSSpecifier 0x12fde9c40: ID LEGAL_AND_REGULATORY, Name 'Legal' target <(null): 0x0>>,\nG: <PSSpecifier 0x131029dc0: ID TRUST_STORE_GROUP, Name '' target <(null): 0x0>> 0x131029dc0,\n<PSSpecifier 0x131033520: ID TRUST_STORE, Name 'Trust Store' target <AboutDataSource: 0x131028390>>\n)\n```\n我们让程序执行下一步，发现此时x0已经有值了，可以明显的看出，x0的值是在0x190804114~0x19080411C这段代码生成的，下面我们的工作重点就是寻找这段代码干了什么，胜利就在眼前！下面我们验证一下这里面到底有没有我们要的序列号：\n\n```ObjC\n(lldb) po [[$x0 objectAtIndex:13] class]\nPSSpecifier\n(lldb) po [[$x0 objectAtIndex:13] properties]\n{\n    cellObject = \"<PSTableCell: 0x130800000; baseClass = UITableViewCell; frame = (0 565; 320 45); text = 'Serial Number'; hidden = YES; autoresize = W; tag = 4; gestureRecognizers = <NSArray: 0x12ff821c0>; layer = <CALayer: 0x12fd7d340>>\";\n    id = SerialNumber;\n    isCopyable = 1;\n    value = DNPMVG0EFF9V;\n}\n```\n我们打印数组中存放cell数据的object属于哪个类，发现是`PSSpecifier`，我们找到之前导出的类的头文件，发现这个类有一个叫做`properties`的实例方法，我们调用一下发现我们要的序列号就在里面`value = DNPMVG0EFF9V`，这跟iPhone设置中看到的序列号是一致的。猜测这个数组里面存放着系统设置中`PSUIAboutController`中所有cel的数据，这个数组下一个肯定要传递到cell生成的方法中，这个就不做验证了，大事重要，我们继续找序列号的生成方法。\n这个`PSSpecifier`中有一个`AboutDataSource`对象，这个非常可疑，从名称上可以判断，这个类是专门用于数据处理的，不过在这之前我们还是先验证一下，在0x190804114~0x19080411C这段地址中，执行了`_PSListController._specifiers`，我们从`PSListController`的头文件（下文有讲怎么获取）中可以看到有一个specifiers属性，我们在IDA分析的文件中找到`[PSListController specifiers]`，我们先定位到方法在二进制文件中的位置：\n\n```ObjC\n__text:00000001907FE4A8 ; -[PSListController specifiers]\n__text:00000001907FE4A8 __PSListController_specifiers_          ; DATA XREF: __objc_const:000000019C069A08\u0019o\n__text:00000001907FE4A8\n__text:00000001907FE4A8 var_40          = -0x40\n__text:00000001907FE4A8 var_30          = -0x30\n__text:00000001907FE4A8 var_20          = -0x20\n__text:00000001907FE4A8 var_10          = -0x10\n__text:00000001907FE4A8\n__text:00000001907FE4A8                 STP             X24, X23, [SP,#var_40]!\n__text:00000001907FE4AC                 STP             X22, X21, [SP,#0x40+var_30]\n__text:00000001907FE4B0                 STP             X20, X19, [SP,#0x40+var_20]\n__text:00000001907FE4B4                 STP             X29, X30, [SP,#0x40+var_10]\n__text:00000001907FE4B8                 ADD             X29, SP, #0x40+var_10\n__text:00000001907FE4BC                 MOV             X19, X0\n__text:00000001907FE4C0                 ADRP            X8, #_OBJC_IVAR_$_PSListController._specifiers@PAGE ; NSArray *_specifiers;\n__text:00000001907FE4C4                 LDRSW           X22, [X8,#_OBJC_IVAR_$_PSListController._specifiers@PAGEOFF] ; NSArray *_specifiers;\n__text:00000001907FE4C8                 LDR             X8, [X19,X22]\n__text:00000001907FE4CC                 CBNZ            X8, loc_1907FE5E0\n__text:00000001907FE4D0                 ADRP            X8, #_OBJC_IVAR_$_PSListController._dataSource@PAGE ; id <PSSpecifierDataSource> _dataSource;\n__text:00000001907FE4D4                 LDRSW           X8, [X8,#_OBJC_IVAR_$_PSListController._dataSource@PAGEOFF] ; id <PSSpecifierDataSource> _dataSource;\n__text:00000001907FE4D8                 LDR             X9, [X19,X8]\n__text:00000001907FE4DC                 CBZ             X9, loc_1907FE550\n__text:00000001907FE4E0                 ADRP            X9, #_OBJC_IVAR_$_PSListController._requestingSpecifiersFromDataSource@PAGE ; bool _requestingSpecifiersFromDataSource;\n__text:00000001907FE4E4                 LDRSW           X23, [X9,#_OBJC_IVAR_$_PSListController._requestingSpecifiersFromDataSource@PAGEOFF] ; bool _requestingSpecifiersFromDataSource;\n__text:00000001907FE4E8                 MOV             W9, #1\n__text:00000001907FE4EC                 STRB            W9, [X19,X23]\n__text:00000001907FE4F0                 LDR             X20, [X19,X8]\n__text:00000001907FE4F4                 ADRP            X8, #selRef_specifier@PAGE\n__text:00000001907FE4F8                 LDR             X1, [X8,#selRef_specifier@PAGEOFF]\n__text:00000001907FE4FC                 MOV             X0, X19\n__text:00000001907FE500                 BL              0x96C39BC0\n__text:00000001907FE504                 MOV             X29, X29\n__text:00000001907FE508                 BL              0x96C41EF0\n__text:00000001907FE50C                 MOV             X21, X0\n__text:00000001907FE510                 ADRP            X8, #selRef_specifiersForSpecifier_observer_@PAGE\n__text:00000001907FE514                 LDR             X1, \n……\n```\n然后在这里面下个断点看看会发生什么\n\n```\n(lldb) br s -a 0x1907FE4D0+0x198e58640\nBreakpoint 9: where = Preferences`-[PSListController specifiers] + 40, address = 0x000000019364e4d0\n```\n我们从设置中进入通用>关于，发现一开始就走到了这个断点，我们猜测，一进入关于页面，系统会首先把所有cell的数据都准备好，然后加载UI\n\n```ObjC\nProcess 1192 stopped\n* thread #1: tid = 0x523a6, 0x000000019364e4d0 Preferences`-[PSListController specifiers] + 40, queue = 'com.apple.main-thread', stop reason = breakpoint 9.1\n    frame #0: 0x000000019364e4d0 Preferences`-[PSListController specifiers] + 40\nPreferences`-[PSListController specifiers]:\n->  0x19364e4d0 <+40>: adrp   x8, 53971\n    0x19364e4d4 <+44>: ldrsw  x8, [x8, #536]\n    0x19364e4d8 <+48>: ldr    x9, [x19, x8]\n    0x19364e4dc <+52>: cbz    x9, 0x19364e550           ; <+168>\n```\n我们打印变量x8和x9的值，看一下系统做了什么\n\n```\n(lldb) po $x8\n<nil>\n(lldb) po $x9\nPSUIAboutController\n```\n并没有数据之类的东西值得我们关注，让断点继续往下走，走到0x19364e4dc的位置，我们再次打印变量x8和x9的值\n\n```\n(lldb) n\nProcess 1192 stopped\n* thread #1: tid = 0x523a6, 0x000000019364e4dc Preferences`-[PSListController specifiers] + 52, queue = 'com.apple.main-thread', stop reason = instruction step over\n    frame #0: 0x000000019364e4dc Preferences`-[PSListController specifiers] + 52\nPreferences`-[PSListController specifiers]:\n->  0x19364e4dc <+52>: cbz    x9, 0x19364e550           ; <+168>\n    0x19364e4e0 <+56>: adrp   x9, 53971\n    0x19364e4e4 <+60>: ldrsw  x23, [x9, #540]\n    0x19364e4e8 <+64>: orr    w9, wzr, #0x1\n(lldb) po $x8\n952\n(lldb) po $x9\n<AboutDataSource: 0x131130730>\n```\n此时的变量x9已经变成了`AboutDataSource`，这里验证了我们上一步的猜想，所以我们重点来研究它，我们先找到这个类在哪个framework中，这里使用的是grep命令\n\n```\nLeonLei-MBP:~ gaoshilei$ grep AboutDataSource -r /Users/gaoshilei/Desktop/reverse/iOS-Runtime-Headers-9.1 \n/Users/gaoshilei/Desktop/reverse/iOS-Runtime-Headers-9.1/PrivateFrameworks/PreferencesUI.framework/AboutDataSource.h:@interface AboutDataSource : PSSpecifierDataSource {\n```\n这里要说明一下iOS-Runtime-Headers-9.1这个文件夹是iOS9.1系统的所有头文件（共有+私有），这个你可以自己导（iOS9之后只能用runtime导，class-dump已经不行了），你也可以拿现成的用，github上面已经有雷锋把所有系统的头文件都导出来了，直接下载就可以了。我们发现`AboutDataSource`这个类在`PrivateFrameworks/PreferencesUI.framework`中，先看一下这个类里面有什么方法和属性，有一个方法`- (void)_loadValues;` 我们对它进行分析。这里又要借助IDA分析，把PreferencesUI这个二进制文件丢到IDA里面，在0x19091EBB8这个位置打个断点\n\n```\n(lldb) br s -a 0x19091EBB8+0x2e50000\nBreakpoint 3: where = PreferencesUI`-[AboutDataSource _loadValues] + 1956, address = 0x000000019376ebb8\n```\n接下来我们进入关于来触发断点\n\n```\n(lldb) po (char *) $x28\n\"_setValue:forSpecifierWithKey:\"\n```\n在这里打印变量x28的值，发现它是一个方法名，从名称来看是给`specifier`赋值的，看来我们要寻找的真相已经很近了，让代码走到下面的位置0x19376ebd8\n\n```\nProcess 2107 stopped\n* thread #1: tid = 0xe8e23, 0x000000019376ebd8 PreferencesUI`-[AboutDataSource _loadValues] + 1988, queue = 'com.apple.main-thread', stop reason = instruction step over\n    frame #0: 0x000000019376ebd8 PreferencesUI`-[AboutDataSource _loadValues] + 1988\nPreferencesUI`-[AboutDataSource _loadValues]:\n->  0x19376ebd8 <+1988>: bl     0x198e58640               ; MGCopyAnswer\n    0x19376ebdc <+1992>: mov    x22, x0\n    0x19376ebe0 <+1996>: mov    x1, x19\n    0x19376ebe4 <+2000>: bl     0x199a89bc0               ; objc_msgSend\n(lldb) po $x0\nSerialNumber\n```\n此时我们打印的x0是一个`NSCFConstantString`，本质就是一个`NSString`，继续`ni`让程序运行到0x19376ebdc\n\n```\nProcess 2107 stopped\n* thread #1: tid = 0xe8e23, 0x000000019376ebdc PreferencesUI`-[AboutDataSource _loadValues] + 1992, queue = 'com.apple.main-thread', stop reason = instruction step over\n    frame #0: 0x000000019376ebdc PreferencesUI`-[AboutDataSource _loadValues] + 1992\nPreferencesUI`-[AboutDataSource _loadValues]:\n->  0x19376ebdc <+1992>: mov    x22, x0\n    0x19376ebe0 <+1996>: mov    x1, x19\n    0x19376ebe4 <+2000>: bl     0x199a89bc0               ; objc_msgSend\n    0x19376ebe8 <+2004>: cbnz   x0, 0x19376ec4c           ; <+2104>\n(lldb) po $x0\nDNPMVG0EFF9V\n```\n在这里我们打印了变量x0的值为**DNPMVG0EFF9V**，这就是我们苦苦寻找的序列号。不难看出，序列号就是在0x19376ebd8这行拿到的，范围越来越小，敌人无路可逃！下面我们就要对这行进行分析，我们按照之前的步骤，再次走到0x19376ebd8这个位置，这不过这次我们不要`step-over`，我们用`si`跳入看看\n\n```ObjC\n(lldb) si\nProcess 2107 stopped\n* thread #1: tid = 0xe8e23, 0x0000000198e58640 libMobileGestalt.dylib`MGCopyAnswer, queue = 'com.apple.main-thread', stop reason = instruction step into\n    frame #0: 0x0000000198e58640 libMobileGestalt.dylib`MGCopyAnswer\nlibMobileGestalt.dylib`MGCopyAnswer:\n->  0x198e58640 <+0>: movz   x1, #0\n    0x198e58644 <+4>: b      0x198e58648               ; ___lldb_unnamed_symbol64$$libMobileGestalt.dylib\n\nlibMobileGestalt.dylib`___lldb_unnamed_symbol64$$libMobileGestalt.dylib:\n    0x198e58648 <+0>: stp    x24, x23, [sp, #-64]!\n    0x198e5864c <+4>: stp    x22, x21, [sp, #16]\n此时跳入了一个静态库libMobileGestalt.dylib，我们可以在usr/lib/ibMobileGestalt.dylib找到它，我们将它扔进IDA，用当前的addr减去libMobileGestalt.dylib的基地址偏移得到它的静态地址0x196008640，对应的是一个函数MGCopyAnswer\n__text:0000000196008640\n__text:0000000196008640 ; =============== S U B R O U T I N E =======================================\n__text:0000000196008640\n__text:0000000196008640\n__text:0000000196008640                 EXPORT _MGCopyAnswer\n__text:0000000196008640 _MGCopyAnswer                           ; CODE XREF: sub_196005958+30\u0018p\n__text:0000000196008640                                         ; sub_196006258+28\u0018p ...\n__text:0000000196008640                 MOV             X1, #0\n__text:0000000196008644                 B               sub_196008648\n__text:0000000196008644 ; End of function _MGCopyAnswer\n```\n这个函数最外层只有两行代码，将立即数0赋给x1，然后跳进了子程序sub_196008648，跳进去之后进行了一些很复杂的运算，这里就不做介绍了，里面的实现大概是这样的：\nx0是作为一个参数传入的，并且这里x0的值为`SerialNumber`，在地址为0x196008678的地方，这个函数中x1变成了一串随机数，有点像MD5加密之后的东西，应该是“钥匙”\n\n```\n(lldb) po (char*) $x1\n\"l92SaBpqIvQs+KBljuwGA\"\n```\n在0x196008690这里，我们`setp-into`这个函数，在函数的末尾返回值的地方0x196007474打个断点，打印返回值x0\n\n```\n(lldb) po $x0\nDNPMVG0EFF9V\n```\n这里的x0由`SerialNumber`变成了真正的序列号，并且就是在0x196008690对应的子程序sub_19600738C里面拿到的，所以我们就这样一个猜测，在`MGCopyAnswer`函数中，x0作为一个参数传入，并且在内部进行了一系列复杂的运算，拿到了获取序列号的“钥匙”x1，然后在sub_19600738C中拿到了最终的序列号。这里笔者也没有对序列号的拿到在进行进一步的深究，这里苹果做了很大的限制，再继续研究恐怕也是收获不大，而且我们在这里已经能拿到序列号了。  \n###\t三、验证结果  \n接下来就是验证的过程了，我们写一个tweak来验证，当然也可以用其他方式来验证：\ntweak的创建这里就不赘述了，我把我的tweak和makefile文件内容贴一下：\n> tweak文件：\n\n```ObjC\ntweak.xm:\nextern \"C\" NSString *MGCopyAnswer(NSString*);\n%hook SpringBoard\n- (void)applicationDidFinishLaunching:(id)application {\n%orig;\nNSString *serialNumber = [NSString stringWithFormat:@\"%@\",[MGCopyAnswer(@\"SerialNumber\") autorelease]];\nUIAlertView *alert = [[UIAlertView alloc] initWithTitle:serialNumber message:nil delegate:self cancelButtonTitle:@\"OK\" otherButtonTitles:nil];\n[alert show];\n}\n%end\n```\n这里注入系统的SpringBoard，在SB启动的时候hook住applicationDidFinishLaunching：函数，并且在这个函数里面添加获取序列号的代码，并且以弹框的形式展现出来。  \n> makefile文件:\n\n```ObjC\nTHEOS_DEVICE_IP = 192.168.0.115\ninclude $(THEOS)/makefiles/common.mk\nTWEAK_NAME = SerialNumber\nSerialNumber_FILES = Tweak.xm\ninclude $(THEOS_MAKE_PATH)/tweak.mk\nSerialNumber_LDFLAGS = -lMobileGestalt\nafter-install::\n\tinstall.exec \"killall -9 SpringBoard\"\n```\n其中有一行`SerialNumber_LDFLAGS = -lMobileGestalt`千万要注意，使用的时候要加载这个静态库，因为SpringBoard加载的时候我也不确定是否有加载这个库，然后我们验证一下吧！\n![序列号验证-获取](http://oeat6c2zg.bkt.clouddn.com/%E6%9F%A5%E6%89%BE%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B01.jpg)![序列号验证-系统](http://oeat6c2zg.bkt.clouddn.com/%E6%9F%A5%E6%89%BE%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B02.jpg)  \n\n [此文参考了《iOS逆向工程（第二版）》](https://www.amazon.cn/iOS应用逆向工程-沙梓社/dp/B00VFDVY7E/ref=sr_1_1?ie=UTF8&qid=1477453672&sr=8-1&keywords=iOS逆向工程)\n","source":"_posts/iPhone查找序列号生成函数.md","raw":"title: iPhone查找序列号生成函数\ndate: 2016-09-08\ncategories:\n- iOS逆向\ntags:\n- serial Number\n- UDID\n---\n\n##  前言  \n在iOS7之前我们可以通过`- (NSString *)uniqueIdentifier`这个方法获取iPhone的唯一标识符，也叫作UDID。不过自从iOS7苹果就把这个方法给禁了，此时我们想要获取iPhone的唯一标识符就很困难。  \n不过苹果提供一个叫做IDFA的标识符，这个IDFA是广告标识符用来追踪广告投放的，不过用户可以在设置中手动重置IDFA，可靠性很低，目前常见的两种标记iPhone的方式为  \n*  openUDID  \n*  IDFA或UUID+keychain  \n\n这两种模式都有个弊端，用户重置手机或者刷机唯一标识符会发生变化，不过对于大多数情况是够用了。看来苹果是把路给封死了，有没有办法拿到之前的UDID呢？我们注意到iPhone的设置通用关于里面有手机的硬件信息，其中有一个serialNumber，这个serialnumber就是我们查询手机是否过保的依据，那么它肯定是唯一的，所以下文是围绕这个进行的探索。最终是可以拿到这个serialNumber的， 不过由于苹果的沙盒限制，所以只能在越狱机中拿到，如果想在非越狱机中拿到必须添加entitlements文件来获取权限，可想而知这个应用是无法上架的。**下文仅作为逆向工程的一种思路和探索** \n<!-- more -->\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n##  正文\n###\t一、SSH连接手机（USB模式）\n####\t1.映射端口\n```shell\nLeonLei-MBP:~ gaoshilei$ /Users/gaoshilei/Desktop/reverse/USBSSH/tcprelay.py -t 22:6666\nForwarding local port 6666 to remote port 22\n```\n####\t2.连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试\n```OC\nLeonLei-MBP:~ gaoshilei$ ssh root@localhost -p 6666\niPhone-5S:~ root# ps -e | grep Pre\n  270 ??         0:00.29 /System/Library/PrivateFrameworks/MobileSoftwareUpdate.framework/XPCServices/com.apple.MobileSoftwareUpdate.CleanupPreparePathService.xpc/com.apple.MobileSoftwareUpdate.CleanupPreparePathService\n 1192 ??         0:14.26 /var/db/stash/_.fP74Fg/Applications/Preferences.app/Preferences\n 1289 ttys000    0:00.01 grep Pre\niPhone-5S:~ root# debugserver *:1234 -a \"Preferences\"\ndebugserver-@(#)PROGRAM:debugserver  PROJECT:debugserver-340.3.51.1\n for arm64.\nAttaching to process Preferences...\nListening to port 1234 for a connection from *...\n```\n####\t3.完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样\n```Object-C\nLeonLei-MBP:~ gaoshilei$ /Users/gaoshilei/Desktop/reverse/USBSSH/tcprelay.py -t 1234:1234\nForwarding local port 1234 to remote port 1234\n```\n###\t二、通过LLDB、IDA寻找线索\nlldb的调试端口已经打开，此时我们可以进入调试\n\n```\nLeonLei-MBP:~ gaoshilei$ lldb\n(lldb) process connect connect://localhost:1234\nProcess 1192 stopped  \n* thread #1: tid = 0x523a6, 0x000000019a3c8a40 libsystem_kernel.dylib`mach_msg_trap + 8, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP  \n    frame #0: 0x000000019a3c8a40 libsystem_kernel.dylib`mach_msg_trap + 8\nlibsystem_kernel.dylib`mach_msg_trap:\n->  0x19a3c8a40 <+8>: ret    \nlibsystem_kernel.dylib`mach_msg_overwrite_trap:\n    0x19a3c8a44 <+0>: movn   x16, #0x1f\n    0x19a3c8a48 <+4>: svc    #0x80\n    0x19a3c8a4c <+8>: ret    \n```\n此时我们已经成功进入Preferences的调试阶段，先c一下，让程序继续运行\n  \n```\n(lldb) c\nProcess 1192 resuming\n```\n这么做的原因是我们待会要打印image的基地址偏移，有可能在我们打印的image list中没有我们想要的image。\n此时我们已经找到到Preference.framework的基地址偏移，见下图\n\n```\n(lldb) im li -o -f\n[  0] 0x00000000000dc000 /var/db/stash/_.fP74Fg/Applications/Preferences.app/Preferences(0x00000001000dc000)\n[  1] 0x0000000100100000 /Library/MobileSubstrate/MobileSubstrate.dylib(0x0000000100100000)\n[  2] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/PrivateFrameworks/BulletinBoard.framework/BulletinBoard\n[  3] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\n[  4] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit\n…\n[ 44] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/PrivateFrameworks/Preferences.framework/Preferences\n…  \n```\n我们要找的image的序号在这里是44，它的基地址偏移为0x2e50000，我们把从iPhone中导出的PrivateFrameworks中的Preferences.framework丢到IDA中进行分析，这个二进制文件比较小，很快就分析完成，在前面我们已经知道iPhone的唯一序列号serial number是通过PSListController生成的，并且我们知道这是一个cell，我们要去调试`[PSListController tableView:cellForRowAtIndexPath:]`这个方法，从中找到cell值的来源，从而找到获取序列号的方法。\n\n```ObjC\n__text:00000001908040C8 ; -[PSListController tableView:cellForRowAtIndexPath:]\n__text:00000001908040C8 __PSListController_tableView_cellForRowAtIndexPath__\n__text:00000001908040C8                                         ; DATA XREF: __objc_const:000000019C069B88\u0019o\n__text:00000001908040C8\n__text:00000001908040C8 var_80          = -0x80\n__text:00000001908040C8 var_78          = -0x78\n__text:00000001908040C8 var_70          = -0x70\n__text:00000001908040C8 var_68          = -0x68\n__text:00000001908040C8 var_60          = -0x60\n__text:00000001908040C8 var_50          = -0x50\n__text:00000001908040C8 var_40          = -0x40\n__text:00000001908040C8 var_30          = -0x30\n__text:00000001908040C8 var_20          = -0x20\n__text:00000001908040C8 var_10          = -0x10\n__text:00000001908040C8\n__text:00000001908040C8                 STP             X28, X27, [SP,#var_60]!\n__text:00000001908040CC                 STP             X26, X25, [SP,#0x60+var_50]\n__text:00000001908040D0                 STP             X24, X23, [SP,#0x60+var_40]\n__text:00000001908040D4                 STP             X22, X21, [SP,#0x60+var_30]\n__text:00000001908040D8                 STP             X20, X19, [SP,#0x60+var_20]\n__text:00000001908040DC                 STP             X29, X30, [SP,#0x60+var_10]\n__text:00000001908040E0                 ADD             X29, SP, #0x60+var_10\n__text:00000001908040E4                 SUB             SP, SP, #0x20\n__text:00000001908040E8                 MOV             X21, X3\n__text:00000001908040EC                 MOV             X20, X0\n__text:00000001908040F0                 MOV             X0, X2\n__text:00000001908040F4                 BL              0x96C400A0\n__text:00000001908040F8                 MOV             X26, X0\n__text:00000001908040FC                 ADRP            X8, #off_19DACC568@PAGE\n__text:0000000190804100                 LDR             X1, [X8,#off_19DACC568@PAGEOFF]\n__text:0000000190804104                 MOV             X0, X20\n__text:0000000190804108                 MOV             X2, X21\n__text:000000019080410C                 BL              0x96C39BC0\n__text:0000000190804110                 MOV             X2, X0\n__text:0000000190804114                 ADRP            X8, #_OBJC_IVAR_$_PSListController._specifiers@PAGE ; NSArray *_specifiers;\n__text:0000000190804118                 LDRSW           X27, [X8,#_OBJC_IVAR_$_PSListController._specifiers@PAGEOFF] ; NSArray *_specifiers;\n__text:000000019080411C                 LDR             X0, [X20,X27]\n__text:0000000190804120                 ADRP            X8, #off_19DACC558@PAGE\n……\n```\n我们在Preference.framework中基地址为0x190804114的位置打个断点，具体的做法是：\n\n```ObjC\n(lldb) br s -a 0x190804114+0x2e50000\nBreakpoint 1: where = Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 76, address = 0x0000000193654114\nProcess 1192 stopped\n* thread #1: tid = 0x523a6, 0x0000000193654114 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 76, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n    frame #0: 0x0000000193654114 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 76\nPreferences`-[PSListController tableView:cellForRowAtIndexPath:]:\n->  0x193654114 <+76>: adrp   x8, 53965\n    0x193654118 <+80>: ldrsw  x27, [x8, #516]\n    0x19365411c <+84>: ldr    x0, [x20, x27]\n    0x193654120 <+88>: adrp   x8, 53960\n```\n这里断点这样打是因为系统加载可执行文件和各种framework的时候会有一个地址偏移，我们在打断点的时候要把这个偏移量加上，这样我们打的断点才是准确的。\n可以看到我们已经成功打了一个断点，断点的address = 0x193654114。此时我们打印变量x0和x27的值\n\n```\n(lldb) po $x0\n13\n(lldb) po $x27\n1104\n```\n我们执行ni让程序继续（这里的`ni`命令相当于Xcode的那个下箭头命令，也就是下一行）\n\n```ObjC\n(lldb) ni\nProcess 1192 stopped\n* thread #1: tid = 0x523a6, 0x0000000193654118 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 80, queue = 'com.apple.main-thread', stop reason = instruction step over\n    frame #0: 0x0000000193654118 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 80\nPreferences`-[PSListController tableView:cellForRowAtIndexPath:]:\n->  0x193654118 <+80>: ldrsw  x27, [x8, #516]\n    0x19365411c <+84>: ldr    x0, [x20, x27]\n    0x193654120 <+88>: adrp   x8, 53960\n    0x193654124 <+92>: ldr    x22, [x8, #1368]\n(lldb) ni\nProcess 1192 stopped\n* thread #1: tid = 0x523a6, 0x000000019365411c Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 84, queue = 'com.apple.main-thread', stop reason = instruction step over\n    frame #0: 0x000000019365411c Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 84\nPreferences`-[PSListController tableView:cellForRowAtIndexPath:]:\n->  0x19365411c <+84>: ldr    x0, [x20, x27]\n    0x193654120 <+88>: adrp   x8, 53960\n    0x193654124 <+92>: ldr    x22, [x8, #1368]\n    0x193654128 <+96>: mov    x1, x22\n(lldb) po $x27\n848\n\n(lldb) po $x0\n13\n```\n我们ni的两次，程序已经走到0x19080411C的位置，然后我们继续打印变量x0和x27的值\n\n```\n(lldb) po $x0\n13\n(lldb) po $x27\n1104\n```\n打印出来的x0和x27都是随机数，还是没有什么收获，我们继续\n\n```ObjC\n(lldb) ni\nProcess 1192 stopped\n* thread #1: tid = 0x523a6, 0x0000000193654120 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 88, queue = 'com.apple.main-thread', stop reason = instruction step over\n    frame #0: 0x0000000193654120 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 88\nPreferences`-[PSListController tableView:cellForRowAtIndexPath:]:\n->  0x193654120 <+88>:  adrp   x8, 53960\n    0x193654124 <+92>:  ldr    x22, [x8, #1368]\n    0x193654128 <+96>:  mov    x1, x22\n    0x19365412c <+100>: bl     0x199a89bc0               ; objc_msgSend\n(lldb) po $x0\n<__NSArrayI 0x13105a780>(\nG: <PSSpecifier 0x12ff50cf0: ID 0, Name '' target <(null): 0x0>> 0x12ff50cf0,\n<PSSpecifier 0x12ff50f50: ID NAME_CELL_ID, Name 'Name' target <AboutDataSource: 0x131028390>>,\nG: <PSSpecifier 0x12ff51680: ID 2, Name '' target <(null): 0x0>> 0x12ff51680,\n<PSSpecifier 0x12ff52360: ID NETWORK, Name 'Network' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff52420: ID SONGS, Name 'Songs' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff519f0: ID VIDEOS, Name 'Videos' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff51ab0: ID PHOTOS, Name 'Photos' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff51b70: ID APPLICATIONS, Name 'Applications' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff524e0: ID User Data Capacity, Name 'Capacity' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff525a0: ID User Data Available, Name 'Available' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff526a0: ID ProductVersion, Name 'Version' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff52850: ID CARRIER_VERSION, Name 'Carrier' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff52980: ID ProductModel, Name 'Model' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff52a60: ID SerialNumber, Name 'Serial Number' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff52b90: ID MACAddress, Name 'Wi-Fi Address' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12ff51050: ID BTMACAddress, Name 'Bluetooth' target <AboutDataSource: 0x131028390>>,\n<PSSpecifier 0x12fde95d0: ID ModemVersion, Name 'Modem Firmware' target <AboutDataSource: 0x131028390>>,\nG: <PSSpecifier 0x131031e90: ID 17, Name '' target <(null): 0x0>> 0x131031e90,\n<PSSpecifier 0x12fde9c40: ID LEGAL_AND_REGULATORY, Name 'Legal' target <(null): 0x0>>,\nG: <PSSpecifier 0x131029dc0: ID TRUST_STORE_GROUP, Name '' target <(null): 0x0>> 0x131029dc0,\n<PSSpecifier 0x131033520: ID TRUST_STORE, Name 'Trust Store' target <AboutDataSource: 0x131028390>>\n)\n```\n我们让程序执行下一步，发现此时x0已经有值了，可以明显的看出，x0的值是在0x190804114~0x19080411C这段代码生成的，下面我们的工作重点就是寻找这段代码干了什么，胜利就在眼前！下面我们验证一下这里面到底有没有我们要的序列号：\n\n```ObjC\n(lldb) po [[$x0 objectAtIndex:13] class]\nPSSpecifier\n(lldb) po [[$x0 objectAtIndex:13] properties]\n{\n    cellObject = \"<PSTableCell: 0x130800000; baseClass = UITableViewCell; frame = (0 565; 320 45); text = 'Serial Number'; hidden = YES; autoresize = W; tag = 4; gestureRecognizers = <NSArray: 0x12ff821c0>; layer = <CALayer: 0x12fd7d340>>\";\n    id = SerialNumber;\n    isCopyable = 1;\n    value = DNPMVG0EFF9V;\n}\n```\n我们打印数组中存放cell数据的object属于哪个类，发现是`PSSpecifier`，我们找到之前导出的类的头文件，发现这个类有一个叫做`properties`的实例方法，我们调用一下发现我们要的序列号就在里面`value = DNPMVG0EFF9V`，这跟iPhone设置中看到的序列号是一致的。猜测这个数组里面存放着系统设置中`PSUIAboutController`中所有cel的数据，这个数组下一个肯定要传递到cell生成的方法中，这个就不做验证了，大事重要，我们继续找序列号的生成方法。\n这个`PSSpecifier`中有一个`AboutDataSource`对象，这个非常可疑，从名称上可以判断，这个类是专门用于数据处理的，不过在这之前我们还是先验证一下，在0x190804114~0x19080411C这段地址中，执行了`_PSListController._specifiers`，我们从`PSListController`的头文件（下文有讲怎么获取）中可以看到有一个specifiers属性，我们在IDA分析的文件中找到`[PSListController specifiers]`，我们先定位到方法在二进制文件中的位置：\n\n```ObjC\n__text:00000001907FE4A8 ; -[PSListController specifiers]\n__text:00000001907FE4A8 __PSListController_specifiers_          ; DATA XREF: __objc_const:000000019C069A08\u0019o\n__text:00000001907FE4A8\n__text:00000001907FE4A8 var_40          = -0x40\n__text:00000001907FE4A8 var_30          = -0x30\n__text:00000001907FE4A8 var_20          = -0x20\n__text:00000001907FE4A8 var_10          = -0x10\n__text:00000001907FE4A8\n__text:00000001907FE4A8                 STP             X24, X23, [SP,#var_40]!\n__text:00000001907FE4AC                 STP             X22, X21, [SP,#0x40+var_30]\n__text:00000001907FE4B0                 STP             X20, X19, [SP,#0x40+var_20]\n__text:00000001907FE4B4                 STP             X29, X30, [SP,#0x40+var_10]\n__text:00000001907FE4B8                 ADD             X29, SP, #0x40+var_10\n__text:00000001907FE4BC                 MOV             X19, X0\n__text:00000001907FE4C0                 ADRP            X8, #_OBJC_IVAR_$_PSListController._specifiers@PAGE ; NSArray *_specifiers;\n__text:00000001907FE4C4                 LDRSW           X22, [X8,#_OBJC_IVAR_$_PSListController._specifiers@PAGEOFF] ; NSArray *_specifiers;\n__text:00000001907FE4C8                 LDR             X8, [X19,X22]\n__text:00000001907FE4CC                 CBNZ            X8, loc_1907FE5E0\n__text:00000001907FE4D0                 ADRP            X8, #_OBJC_IVAR_$_PSListController._dataSource@PAGE ; id <PSSpecifierDataSource> _dataSource;\n__text:00000001907FE4D4                 LDRSW           X8, [X8,#_OBJC_IVAR_$_PSListController._dataSource@PAGEOFF] ; id <PSSpecifierDataSource> _dataSource;\n__text:00000001907FE4D8                 LDR             X9, [X19,X8]\n__text:00000001907FE4DC                 CBZ             X9, loc_1907FE550\n__text:00000001907FE4E0                 ADRP            X9, #_OBJC_IVAR_$_PSListController._requestingSpecifiersFromDataSource@PAGE ; bool _requestingSpecifiersFromDataSource;\n__text:00000001907FE4E4                 LDRSW           X23, [X9,#_OBJC_IVAR_$_PSListController._requestingSpecifiersFromDataSource@PAGEOFF] ; bool _requestingSpecifiersFromDataSource;\n__text:00000001907FE4E8                 MOV             W9, #1\n__text:00000001907FE4EC                 STRB            W9, [X19,X23]\n__text:00000001907FE4F0                 LDR             X20, [X19,X8]\n__text:00000001907FE4F4                 ADRP            X8, #selRef_specifier@PAGE\n__text:00000001907FE4F8                 LDR             X1, [X8,#selRef_specifier@PAGEOFF]\n__text:00000001907FE4FC                 MOV             X0, X19\n__text:00000001907FE500                 BL              0x96C39BC0\n__text:00000001907FE504                 MOV             X29, X29\n__text:00000001907FE508                 BL              0x96C41EF0\n__text:00000001907FE50C                 MOV             X21, X0\n__text:00000001907FE510                 ADRP            X8, #selRef_specifiersForSpecifier_observer_@PAGE\n__text:00000001907FE514                 LDR             X1, \n……\n```\n然后在这里面下个断点看看会发生什么\n\n```\n(lldb) br s -a 0x1907FE4D0+0x198e58640\nBreakpoint 9: where = Preferences`-[PSListController specifiers] + 40, address = 0x000000019364e4d0\n```\n我们从设置中进入通用>关于，发现一开始就走到了这个断点，我们猜测，一进入关于页面，系统会首先把所有cell的数据都准备好，然后加载UI\n\n```ObjC\nProcess 1192 stopped\n* thread #1: tid = 0x523a6, 0x000000019364e4d0 Preferences`-[PSListController specifiers] + 40, queue = 'com.apple.main-thread', stop reason = breakpoint 9.1\n    frame #0: 0x000000019364e4d0 Preferences`-[PSListController specifiers] + 40\nPreferences`-[PSListController specifiers]:\n->  0x19364e4d0 <+40>: adrp   x8, 53971\n    0x19364e4d4 <+44>: ldrsw  x8, [x8, #536]\n    0x19364e4d8 <+48>: ldr    x9, [x19, x8]\n    0x19364e4dc <+52>: cbz    x9, 0x19364e550           ; <+168>\n```\n我们打印变量x8和x9的值，看一下系统做了什么\n\n```\n(lldb) po $x8\n<nil>\n(lldb) po $x9\nPSUIAboutController\n```\n并没有数据之类的东西值得我们关注，让断点继续往下走，走到0x19364e4dc的位置，我们再次打印变量x8和x9的值\n\n```\n(lldb) n\nProcess 1192 stopped\n* thread #1: tid = 0x523a6, 0x000000019364e4dc Preferences`-[PSListController specifiers] + 52, queue = 'com.apple.main-thread', stop reason = instruction step over\n    frame #0: 0x000000019364e4dc Preferences`-[PSListController specifiers] + 52\nPreferences`-[PSListController specifiers]:\n->  0x19364e4dc <+52>: cbz    x9, 0x19364e550           ; <+168>\n    0x19364e4e0 <+56>: adrp   x9, 53971\n    0x19364e4e4 <+60>: ldrsw  x23, [x9, #540]\n    0x19364e4e8 <+64>: orr    w9, wzr, #0x1\n(lldb) po $x8\n952\n(lldb) po $x9\n<AboutDataSource: 0x131130730>\n```\n此时的变量x9已经变成了`AboutDataSource`，这里验证了我们上一步的猜想，所以我们重点来研究它，我们先找到这个类在哪个framework中，这里使用的是grep命令\n\n```\nLeonLei-MBP:~ gaoshilei$ grep AboutDataSource -r /Users/gaoshilei/Desktop/reverse/iOS-Runtime-Headers-9.1 \n/Users/gaoshilei/Desktop/reverse/iOS-Runtime-Headers-9.1/PrivateFrameworks/PreferencesUI.framework/AboutDataSource.h:@interface AboutDataSource : PSSpecifierDataSource {\n```\n这里要说明一下iOS-Runtime-Headers-9.1这个文件夹是iOS9.1系统的所有头文件（共有+私有），这个你可以自己导（iOS9之后只能用runtime导，class-dump已经不行了），你也可以拿现成的用，github上面已经有雷锋把所有系统的头文件都导出来了，直接下载就可以了。我们发现`AboutDataSource`这个类在`PrivateFrameworks/PreferencesUI.framework`中，先看一下这个类里面有什么方法和属性，有一个方法`- (void)_loadValues;` 我们对它进行分析。这里又要借助IDA分析，把PreferencesUI这个二进制文件丢到IDA里面，在0x19091EBB8这个位置打个断点\n\n```\n(lldb) br s -a 0x19091EBB8+0x2e50000\nBreakpoint 3: where = PreferencesUI`-[AboutDataSource _loadValues] + 1956, address = 0x000000019376ebb8\n```\n接下来我们进入关于来触发断点\n\n```\n(lldb) po (char *) $x28\n\"_setValue:forSpecifierWithKey:\"\n```\n在这里打印变量x28的值，发现它是一个方法名，从名称来看是给`specifier`赋值的，看来我们要寻找的真相已经很近了，让代码走到下面的位置0x19376ebd8\n\n```\nProcess 2107 stopped\n* thread #1: tid = 0xe8e23, 0x000000019376ebd8 PreferencesUI`-[AboutDataSource _loadValues] + 1988, queue = 'com.apple.main-thread', stop reason = instruction step over\n    frame #0: 0x000000019376ebd8 PreferencesUI`-[AboutDataSource _loadValues] + 1988\nPreferencesUI`-[AboutDataSource _loadValues]:\n->  0x19376ebd8 <+1988>: bl     0x198e58640               ; MGCopyAnswer\n    0x19376ebdc <+1992>: mov    x22, x0\n    0x19376ebe0 <+1996>: mov    x1, x19\n    0x19376ebe4 <+2000>: bl     0x199a89bc0               ; objc_msgSend\n(lldb) po $x0\nSerialNumber\n```\n此时我们打印的x0是一个`NSCFConstantString`，本质就是一个`NSString`，继续`ni`让程序运行到0x19376ebdc\n\n```\nProcess 2107 stopped\n* thread #1: tid = 0xe8e23, 0x000000019376ebdc PreferencesUI`-[AboutDataSource _loadValues] + 1992, queue = 'com.apple.main-thread', stop reason = instruction step over\n    frame #0: 0x000000019376ebdc PreferencesUI`-[AboutDataSource _loadValues] + 1992\nPreferencesUI`-[AboutDataSource _loadValues]:\n->  0x19376ebdc <+1992>: mov    x22, x0\n    0x19376ebe0 <+1996>: mov    x1, x19\n    0x19376ebe4 <+2000>: bl     0x199a89bc0               ; objc_msgSend\n    0x19376ebe8 <+2004>: cbnz   x0, 0x19376ec4c           ; <+2104>\n(lldb) po $x0\nDNPMVG0EFF9V\n```\n在这里我们打印了变量x0的值为**DNPMVG0EFF9V**，这就是我们苦苦寻找的序列号。不难看出，序列号就是在0x19376ebd8这行拿到的，范围越来越小，敌人无路可逃！下面我们就要对这行进行分析，我们按照之前的步骤，再次走到0x19376ebd8这个位置，这不过这次我们不要`step-over`，我们用`si`跳入看看\n\n```ObjC\n(lldb) si\nProcess 2107 stopped\n* thread #1: tid = 0xe8e23, 0x0000000198e58640 libMobileGestalt.dylib`MGCopyAnswer, queue = 'com.apple.main-thread', stop reason = instruction step into\n    frame #0: 0x0000000198e58640 libMobileGestalt.dylib`MGCopyAnswer\nlibMobileGestalt.dylib`MGCopyAnswer:\n->  0x198e58640 <+0>: movz   x1, #0\n    0x198e58644 <+4>: b      0x198e58648               ; ___lldb_unnamed_symbol64$$libMobileGestalt.dylib\n\nlibMobileGestalt.dylib`___lldb_unnamed_symbol64$$libMobileGestalt.dylib:\n    0x198e58648 <+0>: stp    x24, x23, [sp, #-64]!\n    0x198e5864c <+4>: stp    x22, x21, [sp, #16]\n此时跳入了一个静态库libMobileGestalt.dylib，我们可以在usr/lib/ibMobileGestalt.dylib找到它，我们将它扔进IDA，用当前的addr减去libMobileGestalt.dylib的基地址偏移得到它的静态地址0x196008640，对应的是一个函数MGCopyAnswer\n__text:0000000196008640\n__text:0000000196008640 ; =============== S U B R O U T I N E =======================================\n__text:0000000196008640\n__text:0000000196008640\n__text:0000000196008640                 EXPORT _MGCopyAnswer\n__text:0000000196008640 _MGCopyAnswer                           ; CODE XREF: sub_196005958+30\u0018p\n__text:0000000196008640                                         ; sub_196006258+28\u0018p ...\n__text:0000000196008640                 MOV             X1, #0\n__text:0000000196008644                 B               sub_196008648\n__text:0000000196008644 ; End of function _MGCopyAnswer\n```\n这个函数最外层只有两行代码，将立即数0赋给x1，然后跳进了子程序sub_196008648，跳进去之后进行了一些很复杂的运算，这里就不做介绍了，里面的实现大概是这样的：\nx0是作为一个参数传入的，并且这里x0的值为`SerialNumber`，在地址为0x196008678的地方，这个函数中x1变成了一串随机数，有点像MD5加密之后的东西，应该是“钥匙”\n\n```\n(lldb) po (char*) $x1\n\"l92SaBpqIvQs+KBljuwGA\"\n```\n在0x196008690这里，我们`setp-into`这个函数，在函数的末尾返回值的地方0x196007474打个断点，打印返回值x0\n\n```\n(lldb) po $x0\nDNPMVG0EFF9V\n```\n这里的x0由`SerialNumber`变成了真正的序列号，并且就是在0x196008690对应的子程序sub_19600738C里面拿到的，所以我们就这样一个猜测，在`MGCopyAnswer`函数中，x0作为一个参数传入，并且在内部进行了一系列复杂的运算，拿到了获取序列号的“钥匙”x1，然后在sub_19600738C中拿到了最终的序列号。这里笔者也没有对序列号的拿到在进行进一步的深究，这里苹果做了很大的限制，再继续研究恐怕也是收获不大，而且我们在这里已经能拿到序列号了。  \n###\t三、验证结果  \n接下来就是验证的过程了，我们写一个tweak来验证，当然也可以用其他方式来验证：\ntweak的创建这里就不赘述了，我把我的tweak和makefile文件内容贴一下：\n> tweak文件：\n\n```ObjC\ntweak.xm:\nextern \"C\" NSString *MGCopyAnswer(NSString*);\n%hook SpringBoard\n- (void)applicationDidFinishLaunching:(id)application {\n%orig;\nNSString *serialNumber = [NSString stringWithFormat:@\"%@\",[MGCopyAnswer(@\"SerialNumber\") autorelease]];\nUIAlertView *alert = [[UIAlertView alloc] initWithTitle:serialNumber message:nil delegate:self cancelButtonTitle:@\"OK\" otherButtonTitles:nil];\n[alert show];\n}\n%end\n```\n这里注入系统的SpringBoard，在SB启动的时候hook住applicationDidFinishLaunching：函数，并且在这个函数里面添加获取序列号的代码，并且以弹框的形式展现出来。  \n> makefile文件:\n\n```ObjC\nTHEOS_DEVICE_IP = 192.168.0.115\ninclude $(THEOS)/makefiles/common.mk\nTWEAK_NAME = SerialNumber\nSerialNumber_FILES = Tweak.xm\ninclude $(THEOS_MAKE_PATH)/tweak.mk\nSerialNumber_LDFLAGS = -lMobileGestalt\nafter-install::\n\tinstall.exec \"killall -9 SpringBoard\"\n```\n其中有一行`SerialNumber_LDFLAGS = -lMobileGestalt`千万要注意，使用的时候要加载这个静态库，因为SpringBoard加载的时候我也不确定是否有加载这个库，然后我们验证一下吧！\n![序列号验证-获取](http://oeat6c2zg.bkt.clouddn.com/%E6%9F%A5%E6%89%BE%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B01.jpg)![序列号验证-系统](http://oeat6c2zg.bkt.clouddn.com/%E6%9F%A5%E6%89%BE%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B02.jpg)  \n\n [此文参考了《iOS逆向工程（第二版）》](https://www.amazon.cn/iOS应用逆向工程-沙梓社/dp/B00VFDVY7E/ref=sr_1_1?ie=UTF8&qid=1477453672&sr=8-1&keywords=iOS逆向工程)\n","slug":"iPhone查找序列号生成函数","published":1,"updated":"2017-11-02T13:09:57.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9no6vmq000gjaenm90zjodj","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在iOS7之前我们可以通过<code>- (NSString *)uniqueIdentifier</code>这个方法获取iPhone的唯一标识符，也叫作UDID。不过自从iOS7苹果就把这个方法给禁了，此时我们想要获取iPhone的唯一标识符就很困难。<br>不过苹果提供一个叫做IDFA的标识符，这个IDFA是广告标识符用来追踪广告投放的，不过用户可以在设置中手动重置IDFA，可靠性很低，目前常见的两种标记iPhone的方式为  </p>\n<ul>\n<li>openUDID  </li>\n<li>IDFA或UUID+keychain  </li>\n</ul>\n<p>这两种模式都有个弊端，用户重置手机或者刷机唯一标识符会发生变化，不过对于大多数情况是够用了。看来苹果是把路给封死了，有没有办法拿到之前的UDID呢？我们注意到iPhone的设置通用关于里面有手机的硬件信息，其中有一个serialNumber，这个serialnumber就是我们查询手机是否过保的依据，那么它肯定是唯一的，所以下文是围绕这个进行的探索。最终是可以拿到这个serialNumber的， 不过由于苹果的沙盒限制，所以只能在越狱机中拿到，如果想在非越狱机中拿到必须添加entitlements文件来获取权限，可想而知这个应用是无法上架的。<strong>下文仅作为逆向工程的一种思路和探索</strong><br><a id=\"more\"></a><br>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"一、SSH连接手机（USB模式）\"><a href=\"#一、SSH连接手机（USB模式）\" class=\"headerlink\" title=\"一、SSH连接手机（USB模式）\"></a>一、SSH连接手机（USB模式）</h3><h4 id=\"1-映射端口\"><a href=\"#1-映射端口\" class=\"headerlink\" title=\"1.映射端口\"></a>1.映射端口</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ /Users/gaoshilei/Desktop/reverse/USBSSH/tcprelay.py -t 22:6666</div><div class=\"line\">Forwarding local port 6666 to remote port 22</div></pre></td></tr></table></figure>\n<h4 id=\"2-连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试\"><a href=\"#2-连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试\" class=\"headerlink\" title=\"2.连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试\"></a>2.连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ ssh root@localhost -p 6666</div><div class=\"line\">iPhone-5S:~ root# ps -e | grep Pre</div><div class=\"line\">  270 ??         0:00.29 /System/Library/PrivateFrameworks/MobileSoftwareUpdate.framework/XPCServices/com.apple.MobileSoftwareUpdate.CleanupPreparePathService.xpc/com.apple.MobileSoftwareUpdate.CleanupPreparePathService</div><div class=\"line\"> 1192 ??         0:14.26 /var/db/stash/_.fP74Fg/Applications/Preferences.app/Preferences</div><div class=\"line\"> 1289 ttys000    0:00.01 grep Pre</div><div class=\"line\">iPhone-5S:~ root# debugserver *:1234 -a &quot;Preferences&quot;</div><div class=\"line\">debugserver-@(#)PROGRAM:debugserver  PROJECT:debugserver-340.3.51.1</div><div class=\"line\"> for arm64.</div><div class=\"line\">Attaching to process Preferences...</div><div class=\"line\">Listening to port 1234 for a connection from *...</div></pre></td></tr></table></figure>\n<h4 id=\"3-完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样\"><a href=\"#3-完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样\" class=\"headerlink\" title=\"3.完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样\"></a>3.完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ /Users/gaoshilei/Desktop/reverse/USBSSH/tcprelay.py -t 1234:1234</div><div class=\"line\">Forwarding local port 1234 to remote port 1234</div></pre></td></tr></table></figure>\n<h3 id=\"二、通过LLDB、IDA寻找线索\"><a href=\"#二、通过LLDB、IDA寻找线索\" class=\"headerlink\" title=\"二、通过LLDB、IDA寻找线索\"></a>二、通过LLDB、IDA寻找线索</h3><p>lldb的调试端口已经打开，此时我们可以进入调试</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ lldb</div><div class=\"line\">(lldb) process connect connect://localhost:1234</div><div class=\"line\">Process 1192 stopped  </div><div class=\"line\">* thread #1: tid = 0x523a6, 0x000000019a3c8a40 libsystem_kernel.dylib`mach_msg_trap + 8, queue = &apos;com.apple.main-thread&apos;, stop reason = signal SIGSTOP  </div><div class=\"line\">    frame #0: 0x000000019a3c8a40 libsystem_kernel.dylib`mach_msg_trap + 8</div><div class=\"line\">libsystem_kernel.dylib`mach_msg_trap:</div><div class=\"line\">-&gt;  0x19a3c8a40 &lt;+8&gt;: ret    </div><div class=\"line\">libsystem_kernel.dylib`mach_msg_overwrite_trap:</div><div class=\"line\">    0x19a3c8a44 &lt;+0&gt;: movn   x16, #0x1f</div><div class=\"line\">    0x19a3c8a48 &lt;+4&gt;: svc    #0x80</div><div class=\"line\">    0x19a3c8a4c &lt;+8&gt;: ret</div></pre></td></tr></table></figure>\n<p>此时我们已经成功进入Preferences的调试阶段，先c一下，让程序继续运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) c</div><div class=\"line\">Process 1192 resuming</div></pre></td></tr></table></figure>\n<p>这么做的原因是我们待会要打印image的基地址偏移，有可能在我们打印的image list中没有我们想要的image。<br>此时我们已经找到到Preference.framework的基地址偏移，见下图</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) im li -o -f</div><div class=\"line\">[  0] 0x00000000000dc000 /var/db/stash/_.fP74Fg/Applications/Preferences.app/Preferences(0x00000001000dc000)</div><div class=\"line\">[  1] 0x0000000100100000 /Library/MobileSubstrate/MobileSubstrate.dylib(0x0000000100100000)</div><div class=\"line\">[  2] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/PrivateFrameworks/BulletinBoard.framework/BulletinBoard</div><div class=\"line\">[  3] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation</div><div class=\"line\">[  4] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit</div><div class=\"line\">…</div><div class=\"line\">[ 44] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/PrivateFrameworks/Preferences.framework/Preferences</div><div class=\"line\">…</div></pre></td></tr></table></figure>\n<p>我们要找的image的序号在这里是44，它的基地址偏移为0x2e50000，我们把从iPhone中导出的PrivateFrameworks中的Preferences.framework丢到IDA中进行分析，这个二进制文件比较小，很快就分析完成，在前面我们已经知道iPhone的唯一序列号serial number是通过PSListController生成的，并且我们知道这是一个cell，我们要去调试<code>[PSListController tableView:cellForRowAtIndexPath:]</code>这个方法，从中找到cell值的来源，从而找到获取序列号的方法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 ; -[PSListController tableView:cellForRowAtIndexPath:]</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 __PSListController_tableView_cellForRowAtIndexPath__</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8                                         ; DATA XREF: __objc_const:<span class=\"number\">000000019</span>C069B88\u0019o</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_80          = <span class=\"number\">-0x80</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_78          = <span class=\"number\">-0x78</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_70          = <span class=\"number\">-0x70</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_68          = <span class=\"number\">-0x68</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_60          = <span class=\"number\">-0x60</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_50          = <span class=\"number\">-0x50</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_40          = <span class=\"number\">-0x40</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_30          = <span class=\"number\">-0x30</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_20          = <span class=\"number\">-0x20</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_10          = <span class=\"number\">-0x10</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8                 STP             X28, X27, [SP,<span class=\"meta\">#var_60]!</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>CC                 STP             X26, X25, [SP,<span class=\"meta\">#0x60+var_50]</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>D0                 STP             X24, X23, [SP,<span class=\"meta\">#0x60+var_40]</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>D4                 STP             X22, X21, [SP,<span class=\"meta\">#0x60+var_30]</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>D8                 STP             X20, X19, [SP,<span class=\"meta\">#0x60+var_20]</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>DC                 STP             X29, X30, [SP,<span class=\"meta\">#0x60+var_10]</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040E0</span>                 ADD             X29, SP, <span class=\"meta\">#0x60+var_10</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040E4</span>                 SUB             SP, SP, <span class=\"meta\">#0x20</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040E8</span>                 MOV             X21, X3</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>EC                 MOV             X20, X0</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>F0                 MOV             X0, X2</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>F4                 BL              <span class=\"number\">0x96C400A0</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>F8                 MOV             X26, X0</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>FC                 ADRP            X8, <span class=\"meta\">#off_19DACC568@PAGE</span></div><div class=\"line\">__text:<span class=\"number\">0000000190804100</span>                 LDR             X1, [X8,<span class=\"meta\">#off_19DACC568@PAGEOFF]</span></div><div class=\"line\">__text:<span class=\"number\">0000000190804104</span>                 MOV             X0, X20</div><div class=\"line\">__text:<span class=\"number\">0000000190804108</span>                 MOV             X2, X21</div><div class=\"line\">__text:<span class=\"number\">000000019080410</span>C                 BL              <span class=\"number\">0x96C39BC0</span></div><div class=\"line\">__text:<span class=\"number\">0000000190804110</span>                 MOV             X2, X0</div><div class=\"line\">__text:<span class=\"number\">0000000190804114</span>                 ADRP            X8, <span class=\"meta\">#_OBJC_IVAR_$_PSListController._specifiers@PAGE ; NSArray *_specifiers;</span></div><div class=\"line\">__text:<span class=\"number\">0000000190804118</span>                 LDRSW           X27, [X8,<span class=\"meta\">#_OBJC_IVAR_$_PSListController._specifiers@PAGEOFF] ; NSArray *_specifiers;</span></div><div class=\"line\">__text:<span class=\"number\">000000019080411</span>C                 LDR             X0, [X20,X27]</div><div class=\"line\">__text:<span class=\"number\">0000000190804120</span>                 ADRP            X8, <span class=\"meta\">#off_19DACC558@PAGE</span></div><div class=\"line\">……</div></pre></td></tr></table></figure>\n<p>我们在Preference.framework中基地址为0x190804114的位置打个断点，具体的做法是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a <span class=\"number\">0x190804114</span>+<span class=\"number\">0x2e50000</span></div><div class=\"line\">Breakpoint <span class=\"number\">1</span>: where = Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + <span class=\"number\">76</span>, address = <span class=\"number\">0x0000000193654114</span></div><div class=\"line\">Process <span class=\"number\">1192</span> stopped</div><div class=\"line\">* thread <span class=\"meta\">#1: tid = 0x523a6, 0x0000000193654114 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 76, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span></div><div class=\"line\">    frame <span class=\"meta\">#0: 0x0000000193654114 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 76</span></div><div class=\"line\">Preferences`-[PSListController tableView:cellForRowAtIndexPath:]:</div><div class=\"line\">-&gt;  <span class=\"number\">0x193654114</span> &lt;+<span class=\"number\">76</span>&gt;: adrp   x8, <span class=\"number\">53965</span></div><div class=\"line\">    <span class=\"number\">0x193654118</span> &lt;+<span class=\"number\">80</span>&gt;: ldrsw  x27, [x8, <span class=\"meta\">#516]</span></div><div class=\"line\">    <span class=\"number\">0x19365411c</span> &lt;+<span class=\"number\">84</span>&gt;: ldr    x0, [x20, x27]</div><div class=\"line\">    <span class=\"number\">0x193654120</span> &lt;+<span class=\"number\">88</span>&gt;: adrp   x8, <span class=\"number\">53960</span></div></pre></td></tr></table></figure>\n<p>这里断点这样打是因为系统加载可执行文件和各种framework的时候会有一个地址偏移，我们在打断点的时候要把这个偏移量加上，这样我们打的断点才是准确的。<br>可以看到我们已经成功打了一个断点，断点的address = 0x193654114。此时我们打印变量x0和x27的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x0</div><div class=\"line\">13</div><div class=\"line\">(lldb) po $x27</div><div class=\"line\">1104</div></pre></td></tr></table></figure>\n<p>我们执行ni让程序继续（这里的<code>ni</code>命令相当于Xcode的那个下箭头命令，也就是下一行）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) ni</div><div class=\"line\">Process <span class=\"number\">1192</span> stopped</div><div class=\"line\">* thread <span class=\"meta\">#1: tid = 0x523a6, 0x0000000193654118 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 80, queue = 'com.apple.main-thread', stop reason = instruction step over</span></div><div class=\"line\">    frame <span class=\"meta\">#0: 0x0000000193654118 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 80</span></div><div class=\"line\">Preferences`-[PSListController tableView:cellForRowAtIndexPath:]:</div><div class=\"line\">-&gt;  <span class=\"number\">0x193654118</span> &lt;+<span class=\"number\">80</span>&gt;: ldrsw  x27, [x8, <span class=\"meta\">#516]</span></div><div class=\"line\">    <span class=\"number\">0x19365411c</span> &lt;+<span class=\"number\">84</span>&gt;: ldr    x0, [x20, x27]</div><div class=\"line\">    <span class=\"number\">0x193654120</span> &lt;+<span class=\"number\">88</span>&gt;: adrp   x8, <span class=\"number\">53960</span></div><div class=\"line\">    <span class=\"number\">0x193654124</span> &lt;+<span class=\"number\">92</span>&gt;: ldr    x22, [x8, <span class=\"meta\">#1368]</span></div><div class=\"line\">(lldb) ni</div><div class=\"line\">Process <span class=\"number\">1192</span> stopped</div><div class=\"line\">* thread <span class=\"meta\">#1: tid = 0x523a6, 0x000000019365411c Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 84, queue = 'com.apple.main-thread', stop reason = instruction step over</span></div><div class=\"line\">    frame <span class=\"meta\">#0: 0x000000019365411c Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 84</span></div><div class=\"line\">Preferences`-[PSListController tableView:cellForRowAtIndexPath:]:</div><div class=\"line\">-&gt;  <span class=\"number\">0x19365411c</span> &lt;+<span class=\"number\">84</span>&gt;: ldr    x0, [x20, x27]</div><div class=\"line\">    <span class=\"number\">0x193654120</span> &lt;+<span class=\"number\">88</span>&gt;: adrp   x8, <span class=\"number\">53960</span></div><div class=\"line\">    <span class=\"number\">0x193654124</span> &lt;+<span class=\"number\">92</span>&gt;: ldr    x22, [x8, <span class=\"meta\">#1368]</span></div><div class=\"line\">    <span class=\"number\">0x193654128</span> &lt;+<span class=\"number\">96</span>&gt;: mov    x1, x22</div><div class=\"line\">(lldb) po $x27</div><div class=\"line\"><span class=\"number\">848</span></div><div class=\"line\"></div><div class=\"line\">(lldb) po $x0</div><div class=\"line\"><span class=\"number\">13</span></div></pre></td></tr></table></figure>\n<p>我们ni的两次，程序已经走到0x19080411C的位置，然后我们继续打印变量x0和x27的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x0</div><div class=\"line\">13</div><div class=\"line\">(lldb) po $x27</div><div class=\"line\">1104</div></pre></td></tr></table></figure>\n<p>打印出来的x0和x27都是随机数，还是没有什么收获，我们继续</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) ni</div><div class=\"line\">Process 1192 stopped</div><div class=\"line\">* thread #1: tid = 0x523a6, 0x0000000193654120 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 88, queue = 'com.apple.main-thread', stop reason = instruction step over</div><div class=\"line\">    frame #0: 0x0000000193654120 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 88</div><div class=\"line\">Preferences`-[PSListController tableView:cellForRowAtIndexPath:]:</div><div class=\"line\">-&gt;  0x193654120 &lt;+88&gt;:  adrp   x8, 53960</div><div class=\"line\">    0x193654124 &lt;+92&gt;:  ldr    x22, [x8, #1368]</div><div class=\"line\">    0x193654128 &lt;+96&gt;:  mov    x1, x22</div><div class=\"line\">    0x19365412c &lt;+100&gt;: bl     0x199a89bc0               ; objc_msgSend</div><div class=\"line\">(lldb) po $x0</div><div class=\"line\">&lt;__NSArrayI 0x13105a780&gt;(</div><div class=\"line\">G: &lt;PSSpecifier 0x12ff50cf0: ID 0, Name '' target &lt;(null): 0x0&gt;&gt; 0x12ff50cf0,</div><div class=\"line\">&lt;PSSpecifier 0x12ff50f50: ID NAME_CELL_ID, Name 'Name' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">G: &lt;PSSpecifier 0x12ff51680: ID 2, Name '' target &lt;(null): 0x0&gt;&gt; 0x12ff51680,</div><div class=\"line\">&lt;PSSpecifier 0x12ff52360: ID NETWORK, Name 'Network' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff52420: ID SONGS, Name 'Songs' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff519f0: ID VIDEOS, Name 'Videos' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff51ab0: ID PHOTOS, Name 'Photos' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff51b70: ID APPLICATIONS, Name 'Applications' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff524e0: ID User Data Capacity, Name 'Capacity' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff525a0: ID User Data Available, Name 'Available' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff526a0: ID ProductVersion, Name 'Version' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff52850: ID CARRIER_VERSION, Name 'Carrier' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff52980: ID ProductModel, Name 'Model' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff52a60: ID SerialNumber, Name 'Serial Number' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff52b90: ID MACAddress, Name 'Wi-Fi Address' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff51050: ID BTMACAddress, Name 'Bluetooth' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12fde95d0: ID ModemVersion, Name 'Modem Firmware' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">G: &lt;PSSpecifier 0x131031e90: ID 17, Name '' target &lt;(null): 0x0&gt;&gt; 0x131031e90,</div><div class=\"line\">&lt;PSSpecifier 0x12fde9c40: ID LEGAL_AND_REGULATORY, Name 'Legal' target &lt;(null): 0x0&gt;&gt;,</div><div class=\"line\">G: &lt;PSSpecifier 0x131029dc0: ID TRUST_STORE_GROUP, Name '' target &lt;(null): 0x0&gt;&gt; 0x131029dc0,</div><div class=\"line\">&lt;PSSpecifier 0x131033520: ID TRUST_STORE, Name 'Trust Store' target &lt;AboutDataSource: 0x131028390&gt;&gt;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>我们让程序执行下一步，发现此时x0已经有值了，可以明显的看出，x0的值是在0x190804114~0x19080411C这段代码生成的，下面我们的工作重点就是寻找这段代码干了什么，胜利就在眼前！下面我们验证一下这里面到底有没有我们要的序列号：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po [[$x0 objectAtIndex:<span class=\"number\">13</span>] <span class=\"keyword\">class</span>]</div><div class=\"line\">PSSpecifier</div><div class=\"line\">(lldb) po [[$x0 objectAtIndex:<span class=\"number\">13</span>] properties]</div><div class=\"line\">&#123;</div><div class=\"line\">    cellObject = <span class=\"string\">\"&lt;PSTableCell: 0x130800000; baseClass = UITableViewCell; frame = (0 565; 320 45); text = 'Serial Number'; hidden = YES; autoresize = W; tag = 4; gestureRecognizers = &lt;NSArray: 0x12ff821c0&gt;; layer = &lt;CALayer: 0x12fd7d340&gt;&gt;\"</span>;</div><div class=\"line\">    <span class=\"keyword\">id</span> = SerialNumber;</div><div class=\"line\">    isCopyable = <span class=\"number\">1</span>;</div><div class=\"line\">    value = DNPMVG0EFF9V;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们打印数组中存放cell数据的object属于哪个类，发现是<code>PSSpecifier</code>，我们找到之前导出的类的头文件，发现这个类有一个叫做<code>properties</code>的实例方法，我们调用一下发现我们要的序列号就在里面<code>value = DNPMVG0EFF9V</code>，这跟iPhone设置中看到的序列号是一致的。猜测这个数组里面存放着系统设置中<code>PSUIAboutController</code>中所有cel的数据，这个数组下一个肯定要传递到cell生成的方法中，这个就不做验证了，大事重要，我们继续找序列号的生成方法。<br>这个<code>PSSpecifier</code>中有一个<code>AboutDataSource</code>对象，这个非常可疑，从名称上可以判断，这个类是专门用于数据处理的，不过在这之前我们还是先验证一下，在0x190804114~0x19080411C这段地址中，执行了<code>_PSListController._specifiers</code>，我们从<code>PSListController</code>的头文件（下文有讲怎么获取）中可以看到有一个specifiers属性，我们在IDA分析的文件中找到<code>[PSListController specifiers]</code>，我们先定位到方法在二进制文件中的位置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8 ; -[PSListController specifiers]</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8 __PSListController_specifiers_          ; DATA XREF: __objc_const:<span class=\"number\">000000019</span>C069A08\u0019o</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8 var_40          = <span class=\"number\">-0x40</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8 var_30          = <span class=\"number\">-0x30</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8 var_20          = <span class=\"number\">-0x20</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8 var_10          = <span class=\"number\">-0x10</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8                 STP             X24, X23, [SP,<span class=\"meta\">#var_40]!</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4AC                 STP             X22, X21, [SP,<span class=\"meta\">#0x40+var_30]</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4B0                 STP             X20, X19, [SP,<span class=\"meta\">#0x40+var_20]</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4B4                 STP             X29, X30, [SP,<span class=\"meta\">#0x40+var_10]</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4B8                 ADD             X29, SP, <span class=\"meta\">#0x40+var_10</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4BC                 MOV             X19, X0</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4C0                 ADRP            X8, <span class=\"meta\">#_OBJC_IVAR_$_PSListController._specifiers@PAGE ; NSArray *_specifiers;</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4C4                 LDRSW           X22, [X8,<span class=\"meta\">#_OBJC_IVAR_$_PSListController._specifiers@PAGEOFF] ; NSArray *_specifiers;</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4C8                 LDR             X8, [X19,X22]</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4CC                 CBNZ            X8, loc_1907FE5E0</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4D0                 ADRP            X8, <span class=\"meta\">#_OBJC_IVAR_$_PSListController._dataSource@PAGE ; id <span class=\"meta-string\">&lt;PSSpecifierDataSource&gt;</span> _dataSource;</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4D4                 LDRSW           X8, [X8,<span class=\"meta\">#_OBJC_IVAR_$_PSListController._dataSource@PAGEOFF] ; id <span class=\"meta-string\">&lt;PSSpecifierDataSource&gt;</span> _dataSource;</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4D8                 LDR             X9, [X19,X8]</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4DC                 CBZ             X9, loc_1907FE550</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4E0                 ADRP            X9, <span class=\"meta\">#_OBJC_IVAR_$_PSListController._requestingSpecifiersFromDataSource@PAGE ; bool _requestingSpecifiersFromDataSource;</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4E4                 LDRSW           X23, [X9,<span class=\"meta\">#_OBJC_IVAR_$_PSListController._requestingSpecifiersFromDataSource@PAGEOFF] ; bool _requestingSpecifiersFromDataSource;</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4E8                 MOV             W9, <span class=\"meta\">#1</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4EC                 STRB            W9, [X19,X23]</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4F0                 LDR             X20, [X19,X8]</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4F4                 ADRP            X8, <span class=\"meta\">#selRef_specifier@PAGE</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4F8                 LDR             X1, [X8,<span class=\"meta\">#selRef_specifier@PAGEOFF]</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4FC                 MOV             X0, X19</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE500                 BL              <span class=\"number\">0x96C39BC0</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE504                 MOV             X29, X29</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE508                 BL              <span class=\"number\">0x96C41EF0</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE50C                 MOV             X21, X0</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE510                 ADRP            X8, <span class=\"meta\">#selRef_specifiersForSpecifier_observer_@PAGE</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE514                 LDR             X1, </div><div class=\"line\">……</div></pre></td></tr></table></figure>\n<p>然后在这里面下个断点看看会发生什么</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a 0x1907FE4D0+0x198e58640</div><div class=\"line\">Breakpoint 9: where = Preferences`-[PSListController specifiers] + 40, address = 0x000000019364e4d0</div></pre></td></tr></table></figure>\n<p>我们从设置中进入通用&gt;关于，发现一开始就走到了这个断点，我们猜测，一进入关于页面，系统会首先把所有cell的数据都准备好，然后加载UI</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Process <span class=\"number\">1192</span> stopped</div><div class=\"line\">* thread <span class=\"meta\">#1: tid = 0x523a6, 0x000000019364e4d0 Preferences`-[PSListController specifiers] + 40, queue = 'com.apple.main-thread', stop reason = breakpoint 9.1</span></div><div class=\"line\">    frame <span class=\"meta\">#0: 0x000000019364e4d0 Preferences`-[PSListController specifiers] + 40</span></div><div class=\"line\">Preferences`-[PSListController specifiers]:</div><div class=\"line\">-&gt;  <span class=\"number\">0x19364e4d0</span> &lt;+<span class=\"number\">40</span>&gt;: adrp   x8, <span class=\"number\">53971</span></div><div class=\"line\">    <span class=\"number\">0x19364e4d4</span> &lt;+<span class=\"number\">44</span>&gt;: ldrsw  x8, [x8, <span class=\"meta\">#536]</span></div><div class=\"line\">    <span class=\"number\">0x19364e4d8</span> &lt;+<span class=\"number\">48</span>&gt;: ldr    x9, [x19, x8]</div><div class=\"line\">    <span class=\"number\">0x19364e4dc</span> &lt;+<span class=\"number\">52</span>&gt;: cbz    x9, <span class=\"number\">0x19364e550</span>           ; &lt;+<span class=\"number\">168</span>&gt;</div></pre></td></tr></table></figure>\n<p>我们打印变量x8和x9的值，看一下系统做了什么</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x8</div><div class=\"line\">&lt;nil&gt;</div><div class=\"line\">(lldb) po $x9</div><div class=\"line\">PSUIAboutController</div></pre></td></tr></table></figure>\n<p>并没有数据之类的东西值得我们关注，让断点继续往下走，走到0x19364e4dc的位置，我们再次打印变量x8和x9的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) n</div><div class=\"line\">Process 1192 stopped</div><div class=\"line\">* thread #1: tid = 0x523a6, 0x000000019364e4dc Preferences`-[PSListController specifiers] + 52, queue = &apos;com.apple.main-thread&apos;, stop reason = instruction step over</div><div class=\"line\">    frame #0: 0x000000019364e4dc Preferences`-[PSListController specifiers] + 52</div><div class=\"line\">Preferences`-[PSListController specifiers]:</div><div class=\"line\">-&gt;  0x19364e4dc &lt;+52&gt;: cbz    x9, 0x19364e550           ; &lt;+168&gt;</div><div class=\"line\">    0x19364e4e0 &lt;+56&gt;: adrp   x9, 53971</div><div class=\"line\">    0x19364e4e4 &lt;+60&gt;: ldrsw  x23, [x9, #540]</div><div class=\"line\">    0x19364e4e8 &lt;+64&gt;: orr    w9, wzr, #0x1</div><div class=\"line\">(lldb) po $x8</div><div class=\"line\">952</div><div class=\"line\">(lldb) po $x9</div><div class=\"line\">&lt;AboutDataSource: 0x131130730&gt;</div></pre></td></tr></table></figure>\n<p>此时的变量x9已经变成了<code>AboutDataSource</code>，这里验证了我们上一步的猜想，所以我们重点来研究它，我们先找到这个类在哪个framework中，这里使用的是grep命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ grep AboutDataSource -r /Users/gaoshilei/Desktop/reverse/iOS-Runtime-Headers-9.1 </div><div class=\"line\">/Users/gaoshilei/Desktop/reverse/iOS-Runtime-Headers-9.1/PrivateFrameworks/PreferencesUI.framework/AboutDataSource.h:@interface AboutDataSource : PSSpecifierDataSource &#123;</div></pre></td></tr></table></figure>\n<p>这里要说明一下iOS-Runtime-Headers-9.1这个文件夹是iOS9.1系统的所有头文件（共有+私有），这个你可以自己导（iOS9之后只能用runtime导，class-dump已经不行了），你也可以拿现成的用，github上面已经有雷锋把所有系统的头文件都导出来了，直接下载就可以了。我们发现<code>AboutDataSource</code>这个类在<code>PrivateFrameworks/PreferencesUI.framework</code>中，先看一下这个类里面有什么方法和属性，有一个方法<code>- (void)_loadValues;</code> 我们对它进行分析。这里又要借助IDA分析，把PreferencesUI这个二进制文件丢到IDA里面，在0x19091EBB8这个位置打个断点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a 0x19091EBB8+0x2e50000</div><div class=\"line\">Breakpoint 3: where = PreferencesUI`-[AboutDataSource _loadValues] + 1956, address = 0x000000019376ebb8</div></pre></td></tr></table></figure>\n<p>接下来我们进入关于来触发断点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po (char *) $x28</div><div class=\"line\">&quot;_setValue:forSpecifierWithKey:&quot;</div></pre></td></tr></table></figure>\n<p>在这里打印变量x28的值，发现它是一个方法名，从名称来看是给<code>specifier</code>赋值的，看来我们要寻找的真相已经很近了，让代码走到下面的位置0x19376ebd8</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Process 2107 stopped</div><div class=\"line\">* thread #1: tid = 0xe8e23, 0x000000019376ebd8 PreferencesUI`-[AboutDataSource _loadValues] + 1988, queue = &apos;com.apple.main-thread&apos;, stop reason = instruction step over</div><div class=\"line\">    frame #0: 0x000000019376ebd8 PreferencesUI`-[AboutDataSource _loadValues] + 1988</div><div class=\"line\">PreferencesUI`-[AboutDataSource _loadValues]:</div><div class=\"line\">-&gt;  0x19376ebd8 &lt;+1988&gt;: bl     0x198e58640               ; MGCopyAnswer</div><div class=\"line\">    0x19376ebdc &lt;+1992&gt;: mov    x22, x0</div><div class=\"line\">    0x19376ebe0 &lt;+1996&gt;: mov    x1, x19</div><div class=\"line\">    0x19376ebe4 &lt;+2000&gt;: bl     0x199a89bc0               ; objc_msgSend</div><div class=\"line\">(lldb) po $x0</div><div class=\"line\">SerialNumber</div></pre></td></tr></table></figure>\n<p>此时我们打印的x0是一个<code>NSCFConstantString</code>，本质就是一个<code>NSString</code>，继续<code>ni</code>让程序运行到0x19376ebdc</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Process 2107 stopped</div><div class=\"line\">* thread #1: tid = 0xe8e23, 0x000000019376ebdc PreferencesUI`-[AboutDataSource _loadValues] + 1992, queue = &apos;com.apple.main-thread&apos;, stop reason = instruction step over</div><div class=\"line\">    frame #0: 0x000000019376ebdc PreferencesUI`-[AboutDataSource _loadValues] + 1992</div><div class=\"line\">PreferencesUI`-[AboutDataSource _loadValues]:</div><div class=\"line\">-&gt;  0x19376ebdc &lt;+1992&gt;: mov    x22, x0</div><div class=\"line\">    0x19376ebe0 &lt;+1996&gt;: mov    x1, x19</div><div class=\"line\">    0x19376ebe4 &lt;+2000&gt;: bl     0x199a89bc0               ; objc_msgSend</div><div class=\"line\">    0x19376ebe8 &lt;+2004&gt;: cbnz   x0, 0x19376ec4c           ; &lt;+2104&gt;</div><div class=\"line\">(lldb) po $x0</div><div class=\"line\">DNPMVG0EFF9V</div></pre></td></tr></table></figure>\n<p>在这里我们打印了变量x0的值为<strong>DNPMVG0EFF9V</strong>，这就是我们苦苦寻找的序列号。不难看出，序列号就是在0x19376ebd8这行拿到的，范围越来越小，敌人无路可逃！下面我们就要对这行进行分析，我们按照之前的步骤，再次走到0x19376ebd8这个位置，这不过这次我们不要<code>step-over</code>，我们用<code>si</code>跳入看看</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) si</div><div class=\"line\">Process <span class=\"number\">2107</span> stopped</div><div class=\"line\">* thread <span class=\"meta\">#1: tid = 0xe8e23, 0x0000000198e58640 libMobileGestalt.dylib`MGCopyAnswer, queue = 'com.apple.main-thread', stop reason = instruction step into</span></div><div class=\"line\">    frame <span class=\"meta\">#0: 0x0000000198e58640 libMobileGestalt.dylib`MGCopyAnswer</span></div><div class=\"line\">libMobileGestalt.dylib`MGCopyAnswer:</div><div class=\"line\">-&gt;  <span class=\"number\">0x198e58640</span> &lt;+<span class=\"number\">0</span>&gt;: movz   x1, <span class=\"meta\">#0</span></div><div class=\"line\">    <span class=\"number\">0x198e58644</span> &lt;+<span class=\"number\">4</span>&gt;: b      <span class=\"number\">0x198e58648</span>               ; ___lldb_unnamed_symbol64$$libMobileGestalt.dylib</div><div class=\"line\"></div><div class=\"line\">libMobileGestalt.dylib`___lldb_unnamed_symbol64$$libMobileGestalt.dylib:</div><div class=\"line\">    <span class=\"number\">0x198e58648</span> &lt;+<span class=\"number\">0</span>&gt;: stp    x24, x23, [sp, <span class=\"meta\">#-64]!</span></div><div class=\"line\">    <span class=\"number\">0x198e5864c</span> &lt;+<span class=\"number\">4</span>&gt;: stp    x22, x21, [sp, <span class=\"meta\">#16]</span></div><div class=\"line\">此时跳入了一个静态库libMobileGestalt.dylib，我们可以在usr/lib/ibMobileGestalt.dylib找到它，我们将它扔进IDA，用当前的addr减去libMobileGestalt.dylib的基地址偏移得到它的静态地址<span class=\"number\">0x196008640</span>，对应的是一个函数MGCopyAnswer</div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span></div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span> ; =============== S U B R O U T I N E =======================================</div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span></div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span></div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span>                 EXPORT _MGCopyAnswer</div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span> _MGCopyAnswer                           ; CODE XREF: sub_196005958+<span class=\"number\">30</span>\u0018p</div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span>                                         ; sub_196006258+<span class=\"number\">28</span>\u0018p ...</div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span>                 MOV             X1, <span class=\"meta\">#0</span></div><div class=\"line\">__text:<span class=\"number\">0000000196008644</span>                 B               sub_196008648</div><div class=\"line\">__text:<span class=\"number\">0000000196008644</span> ; End of function _MGCopyAnswer</div></pre></td></tr></table></figure>\n<p>这个函数最外层只有两行代码，将立即数0赋给x1，然后跳进了子程序sub_196008648，跳进去之后进行了一些很复杂的运算，这里就不做介绍了，里面的实现大概是这样的：<br>x0是作为一个参数传入的，并且这里x0的值为<code>SerialNumber</code>，在地址为0x196008678的地方，这个函数中x1变成了一串随机数，有点像MD5加密之后的东西，应该是“钥匙”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po (char*) $x1</div><div class=\"line\">&quot;l92SaBpqIvQs+KBljuwGA&quot;</div></pre></td></tr></table></figure>\n<p>在0x196008690这里，我们<code>setp-into</code>这个函数，在函数的末尾返回值的地方0x196007474打个断点，打印返回值x0</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x0</div><div class=\"line\">DNPMVG0EFF9V</div></pre></td></tr></table></figure>\n<p>这里的x0由<code>SerialNumber</code>变成了真正的序列号，并且就是在0x196008690对应的子程序sub_19600738C里面拿到的，所以我们就这样一个猜测，在<code>MGCopyAnswer</code>函数中，x0作为一个参数传入，并且在内部进行了一系列复杂的运算，拿到了获取序列号的“钥匙”x1，然后在sub_19600738C中拿到了最终的序列号。这里笔者也没有对序列号的拿到在进行进一步的深究，这里苹果做了很大的限制，再继续研究恐怕也是收获不大，而且我们在这里已经能拿到序列号了。  </p>\n<h3 id=\"三、验证结果\"><a href=\"#三、验证结果\" class=\"headerlink\" title=\"三、验证结果\"></a>三、验证结果</h3><p>接下来就是验证的过程了，我们写一个tweak来验证，当然也可以用其他方式来验证：<br>tweak的创建这里就不赘述了，我把我的tweak和makefile文件内容贴一下：</p>\n<blockquote>\n<p>tweak文件：</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">tweak.xm:</div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> <span class=\"built_in\">NSString</span> *MGCopyAnswer(<span class=\"built_in\">NSString</span>*);</div><div class=\"line\">%hook SpringBoard</div><div class=\"line\">- (<span class=\"keyword\">void</span>)applicationDidFinishLaunching:(<span class=\"keyword\">id</span>)application &#123;</div><div class=\"line\">%orig;</div><div class=\"line\"><span class=\"built_in\">NSString</span> *serialNumber = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@\"</span>,[MGCopyAnswer(<span class=\"string\">@\"SerialNumber\"</span>) autorelease]];</div><div class=\"line\"><span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc] initWithTitle:serialNumber message:<span class=\"literal\">nil</span> delegate:<span class=\"keyword\">self</span> cancelButtonTitle:<span class=\"string\">@\"OK\"</span> otherButtonTitles:<span class=\"literal\">nil</span>];</div><div class=\"line\">[alert show];</div><div class=\"line\">&#125;</div><div class=\"line\">%end</div></pre></td></tr></table></figure>\n<p>这里注入系统的SpringBoard，在SB启动的时候hook住applicationDidFinishLaunching：函数，并且在这个函数里面添加获取序列号的代码，并且以弹框的形式展现出来。  </p>\n<blockquote>\n<p>makefile文件:</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">THEOS_DEVICE_IP = <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.115</span></div><div class=\"line\">include $(THEOS)/makefiles/common.mk</div><div class=\"line\">TWEAK_NAME = SerialNumber</div><div class=\"line\">SerialNumber_FILES = Tweak.xm</div><div class=\"line\">include $(THEOS_MAKE_PATH)/tweak.mk</div><div class=\"line\">SerialNumber_LDFLAGS = -lMobileGestalt</div><div class=\"line\">after-install::</div><div class=\"line\">\tinstall.exec <span class=\"string\">\"killall -9 SpringBoard\"</span></div></pre></td></tr></table></figure>\n<p>其中有一行<code>SerialNumber_LDFLAGS = -lMobileGestalt</code>千万要注意，使用的时候要加载这个静态库，因为SpringBoard加载的时候我也不确定是否有加载这个库，然后我们验证一下吧！<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%9F%A5%E6%89%BE%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B01.jpg\" alt=\"序列号验证-获取\"><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%9F%A5%E6%89%BE%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B02.jpg\" alt=\"序列号验证-系统\">  </p>\n<p> <a href=\"https://www.amazon.cn/iOS应用逆向工程-沙梓社/dp/B00VFDVY7E/ref=sr_1_1?ie=UTF8&amp;qid=1477453672&amp;sr=8-1&amp;keywords=iOS逆向工程\" target=\"_blank\" rel=\"external\">此文参考了《iOS逆向工程（第二版）》</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在iOS7之前我们可以通过<code>- (NSString *)uniqueIdentifier</code>这个方法获取iPhone的唯一标识符，也叫作UDID。不过自从iOS7苹果就把这个方法给禁了，此时我们想要获取iPhone的唯一标识符就很困难。<br>不过苹果提供一个叫做IDFA的标识符，这个IDFA是广告标识符用来追踪广告投放的，不过用户可以在设置中手动重置IDFA，可靠性很低，目前常见的两种标记iPhone的方式为  </p>\n<ul>\n<li>openUDID  </li>\n<li>IDFA或UUID+keychain  </li>\n</ul>\n<p>这两种模式都有个弊端，用户重置手机或者刷机唯一标识符会发生变化，不过对于大多数情况是够用了。看来苹果是把路给封死了，有没有办法拿到之前的UDID呢？我们注意到iPhone的设置通用关于里面有手机的硬件信息，其中有一个serialNumber，这个serialnumber就是我们查询手机是否过保的依据，那么它肯定是唯一的，所以下文是围绕这个进行的探索。最终是可以拿到这个serialNumber的， 不过由于苹果的沙盒限制，所以只能在越狱机中拿到，如果想在非越狱机中拿到必须添加entitlements文件来获取权限，可想而知这个应用是无法上架的。<strong>下文仅作为逆向工程的一种思路和探索</strong><br>","more":"<br>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"一、SSH连接手机（USB模式）\"><a href=\"#一、SSH连接手机（USB模式）\" class=\"headerlink\" title=\"一、SSH连接手机（USB模式）\"></a>一、SSH连接手机（USB模式）</h3><h4 id=\"1-映射端口\"><a href=\"#1-映射端口\" class=\"headerlink\" title=\"1.映射端口\"></a>1.映射端口</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ /Users/gaoshilei/Desktop/reverse/USBSSH/tcprelay.py -t 22:6666</div><div class=\"line\">Forwarding local port 6666 to remote port 22</div></pre></td></tr></table></figure>\n<h4 id=\"2-连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试\"><a href=\"#2-连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试\" class=\"headerlink\" title=\"2.连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试\"></a>2.连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ ssh root@localhost -p 6666</div><div class=\"line\">iPhone-5S:~ root# ps -e | grep Pre</div><div class=\"line\">  270 ??         0:00.29 /System/Library/PrivateFrameworks/MobileSoftwareUpdate.framework/XPCServices/com.apple.MobileSoftwareUpdate.CleanupPreparePathService.xpc/com.apple.MobileSoftwareUpdate.CleanupPreparePathService</div><div class=\"line\"> 1192 ??         0:14.26 /var/db/stash/_.fP74Fg/Applications/Preferences.app/Preferences</div><div class=\"line\"> 1289 ttys000    0:00.01 grep Pre</div><div class=\"line\">iPhone-5S:~ root# debugserver *:1234 -a &quot;Preferences&quot;</div><div class=\"line\">debugserver-@(#)PROGRAM:debugserver  PROJECT:debugserver-340.3.51.1</div><div class=\"line\"> for arm64.</div><div class=\"line\">Attaching to process Preferences...</div><div class=\"line\">Listening to port 1234 for a connection from *...</div></pre></td></tr></table></figure>\n<h4 id=\"3-完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样\"><a href=\"#3-完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样\" class=\"headerlink\" title=\"3.完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样\"></a>3.完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ /Users/gaoshilei/Desktop/reverse/USBSSH/tcprelay.py -t 1234:1234</div><div class=\"line\">Forwarding local port 1234 to remote port 1234</div></pre></td></tr></table></figure>\n<h3 id=\"二、通过LLDB、IDA寻找线索\"><a href=\"#二、通过LLDB、IDA寻找线索\" class=\"headerlink\" title=\"二、通过LLDB、IDA寻找线索\"></a>二、通过LLDB、IDA寻找线索</h3><p>lldb的调试端口已经打开，此时我们可以进入调试</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ lldb</div><div class=\"line\">(lldb) process connect connect://localhost:1234</div><div class=\"line\">Process 1192 stopped  </div><div class=\"line\">* thread #1: tid = 0x523a6, 0x000000019a3c8a40 libsystem_kernel.dylib`mach_msg_trap + 8, queue = &apos;com.apple.main-thread&apos;, stop reason = signal SIGSTOP  </div><div class=\"line\">    frame #0: 0x000000019a3c8a40 libsystem_kernel.dylib`mach_msg_trap + 8</div><div class=\"line\">libsystem_kernel.dylib`mach_msg_trap:</div><div class=\"line\">-&gt;  0x19a3c8a40 &lt;+8&gt;: ret    </div><div class=\"line\">libsystem_kernel.dylib`mach_msg_overwrite_trap:</div><div class=\"line\">    0x19a3c8a44 &lt;+0&gt;: movn   x16, #0x1f</div><div class=\"line\">    0x19a3c8a48 &lt;+4&gt;: svc    #0x80</div><div class=\"line\">    0x19a3c8a4c &lt;+8&gt;: ret</div></pre></td></tr></table></figure>\n<p>此时我们已经成功进入Preferences的调试阶段，先c一下，让程序继续运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) c</div><div class=\"line\">Process 1192 resuming</div></pre></td></tr></table></figure>\n<p>这么做的原因是我们待会要打印image的基地址偏移，有可能在我们打印的image list中没有我们想要的image。<br>此时我们已经找到到Preference.framework的基地址偏移，见下图</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) im li -o -f</div><div class=\"line\">[  0] 0x00000000000dc000 /var/db/stash/_.fP74Fg/Applications/Preferences.app/Preferences(0x00000001000dc000)</div><div class=\"line\">[  1] 0x0000000100100000 /Library/MobileSubstrate/MobileSubstrate.dylib(0x0000000100100000)</div><div class=\"line\">[  2] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/PrivateFrameworks/BulletinBoard.framework/BulletinBoard</div><div class=\"line\">[  3] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation</div><div class=\"line\">[  4] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit</div><div class=\"line\">…</div><div class=\"line\">[ 44] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/PrivateFrameworks/Preferences.framework/Preferences</div><div class=\"line\">…</div></pre></td></tr></table></figure>\n<p>我们要找的image的序号在这里是44，它的基地址偏移为0x2e50000，我们把从iPhone中导出的PrivateFrameworks中的Preferences.framework丢到IDA中进行分析，这个二进制文件比较小，很快就分析完成，在前面我们已经知道iPhone的唯一序列号serial number是通过PSListController生成的，并且我们知道这是一个cell，我们要去调试<code>[PSListController tableView:cellForRowAtIndexPath:]</code>这个方法，从中找到cell值的来源，从而找到获取序列号的方法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 ; -[PSListController tableView:cellForRowAtIndexPath:]</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 __PSListController_tableView_cellForRowAtIndexPath__</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8                                         ; DATA XREF: __objc_const:<span class=\"number\">000000019</span>C069B88\u0019o</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_80          = <span class=\"number\">-0x80</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_78          = <span class=\"number\">-0x78</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_70          = <span class=\"number\">-0x70</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_68          = <span class=\"number\">-0x68</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_60          = <span class=\"number\">-0x60</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_50          = <span class=\"number\">-0x50</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_40          = <span class=\"number\">-0x40</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_30          = <span class=\"number\">-0x30</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_20          = <span class=\"number\">-0x20</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8 var_10          = <span class=\"number\">-0x10</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>C8                 STP             X28, X27, [SP,<span class=\"meta\">#var_60]!</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>CC                 STP             X26, X25, [SP,<span class=\"meta\">#0x60+var_50]</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>D0                 STP             X24, X23, [SP,<span class=\"meta\">#0x60+var_40]</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>D4                 STP             X22, X21, [SP,<span class=\"meta\">#0x60+var_30]</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>D8                 STP             X20, X19, [SP,<span class=\"meta\">#0x60+var_20]</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>DC                 STP             X29, X30, [SP,<span class=\"meta\">#0x60+var_10]</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040E0</span>                 ADD             X29, SP, <span class=\"meta\">#0x60+var_10</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040E4</span>                 SUB             SP, SP, <span class=\"meta\">#0x20</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040E8</span>                 MOV             X21, X3</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>EC                 MOV             X20, X0</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>F0                 MOV             X0, X2</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>F4                 BL              <span class=\"number\">0x96C400A0</span></div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>F8                 MOV             X26, X0</div><div class=\"line\">__text:<span class=\"number\">00000001908040</span>FC                 ADRP            X8, <span class=\"meta\">#off_19DACC568@PAGE</span></div><div class=\"line\">__text:<span class=\"number\">0000000190804100</span>                 LDR             X1, [X8,<span class=\"meta\">#off_19DACC568@PAGEOFF]</span></div><div class=\"line\">__text:<span class=\"number\">0000000190804104</span>                 MOV             X0, X20</div><div class=\"line\">__text:<span class=\"number\">0000000190804108</span>                 MOV             X2, X21</div><div class=\"line\">__text:<span class=\"number\">000000019080410</span>C                 BL              <span class=\"number\">0x96C39BC0</span></div><div class=\"line\">__text:<span class=\"number\">0000000190804110</span>                 MOV             X2, X0</div><div class=\"line\">__text:<span class=\"number\">0000000190804114</span>                 ADRP            X8, <span class=\"meta\">#_OBJC_IVAR_$_PSListController._specifiers@PAGE ; NSArray *_specifiers;</span></div><div class=\"line\">__text:<span class=\"number\">0000000190804118</span>                 LDRSW           X27, [X8,<span class=\"meta\">#_OBJC_IVAR_$_PSListController._specifiers@PAGEOFF] ; NSArray *_specifiers;</span></div><div class=\"line\">__text:<span class=\"number\">000000019080411</span>C                 LDR             X0, [X20,X27]</div><div class=\"line\">__text:<span class=\"number\">0000000190804120</span>                 ADRP            X8, <span class=\"meta\">#off_19DACC558@PAGE</span></div><div class=\"line\">……</div></pre></td></tr></table></figure>\n<p>我们在Preference.framework中基地址为0x190804114的位置打个断点，具体的做法是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a <span class=\"number\">0x190804114</span>+<span class=\"number\">0x2e50000</span></div><div class=\"line\">Breakpoint <span class=\"number\">1</span>: where = Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + <span class=\"number\">76</span>, address = <span class=\"number\">0x0000000193654114</span></div><div class=\"line\">Process <span class=\"number\">1192</span> stopped</div><div class=\"line\">* thread <span class=\"meta\">#1: tid = 0x523a6, 0x0000000193654114 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 76, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span></div><div class=\"line\">    frame <span class=\"meta\">#0: 0x0000000193654114 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 76</span></div><div class=\"line\">Preferences`-[PSListController tableView:cellForRowAtIndexPath:]:</div><div class=\"line\">-&gt;  <span class=\"number\">0x193654114</span> &lt;+<span class=\"number\">76</span>&gt;: adrp   x8, <span class=\"number\">53965</span></div><div class=\"line\">    <span class=\"number\">0x193654118</span> &lt;+<span class=\"number\">80</span>&gt;: ldrsw  x27, [x8, <span class=\"meta\">#516]</span></div><div class=\"line\">    <span class=\"number\">0x19365411c</span> &lt;+<span class=\"number\">84</span>&gt;: ldr    x0, [x20, x27]</div><div class=\"line\">    <span class=\"number\">0x193654120</span> &lt;+<span class=\"number\">88</span>&gt;: adrp   x8, <span class=\"number\">53960</span></div></pre></td></tr></table></figure>\n<p>这里断点这样打是因为系统加载可执行文件和各种framework的时候会有一个地址偏移，我们在打断点的时候要把这个偏移量加上，这样我们打的断点才是准确的。<br>可以看到我们已经成功打了一个断点，断点的address = 0x193654114。此时我们打印变量x0和x27的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x0</div><div class=\"line\">13</div><div class=\"line\">(lldb) po $x27</div><div class=\"line\">1104</div></pre></td></tr></table></figure>\n<p>我们执行ni让程序继续（这里的<code>ni</code>命令相当于Xcode的那个下箭头命令，也就是下一行）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) ni</div><div class=\"line\">Process <span class=\"number\">1192</span> stopped</div><div class=\"line\">* thread <span class=\"meta\">#1: tid = 0x523a6, 0x0000000193654118 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 80, queue = 'com.apple.main-thread', stop reason = instruction step over</span></div><div class=\"line\">    frame <span class=\"meta\">#0: 0x0000000193654118 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 80</span></div><div class=\"line\">Preferences`-[PSListController tableView:cellForRowAtIndexPath:]:</div><div class=\"line\">-&gt;  <span class=\"number\">0x193654118</span> &lt;+<span class=\"number\">80</span>&gt;: ldrsw  x27, [x8, <span class=\"meta\">#516]</span></div><div class=\"line\">    <span class=\"number\">0x19365411c</span> &lt;+<span class=\"number\">84</span>&gt;: ldr    x0, [x20, x27]</div><div class=\"line\">    <span class=\"number\">0x193654120</span> &lt;+<span class=\"number\">88</span>&gt;: adrp   x8, <span class=\"number\">53960</span></div><div class=\"line\">    <span class=\"number\">0x193654124</span> &lt;+<span class=\"number\">92</span>&gt;: ldr    x22, [x8, <span class=\"meta\">#1368]</span></div><div class=\"line\">(lldb) ni</div><div class=\"line\">Process <span class=\"number\">1192</span> stopped</div><div class=\"line\">* thread <span class=\"meta\">#1: tid = 0x523a6, 0x000000019365411c Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 84, queue = 'com.apple.main-thread', stop reason = instruction step over</span></div><div class=\"line\">    frame <span class=\"meta\">#0: 0x000000019365411c Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 84</span></div><div class=\"line\">Preferences`-[PSListController tableView:cellForRowAtIndexPath:]:</div><div class=\"line\">-&gt;  <span class=\"number\">0x19365411c</span> &lt;+<span class=\"number\">84</span>&gt;: ldr    x0, [x20, x27]</div><div class=\"line\">    <span class=\"number\">0x193654120</span> &lt;+<span class=\"number\">88</span>&gt;: adrp   x8, <span class=\"number\">53960</span></div><div class=\"line\">    <span class=\"number\">0x193654124</span> &lt;+<span class=\"number\">92</span>&gt;: ldr    x22, [x8, <span class=\"meta\">#1368]</span></div><div class=\"line\">    <span class=\"number\">0x193654128</span> &lt;+<span class=\"number\">96</span>&gt;: mov    x1, x22</div><div class=\"line\">(lldb) po $x27</div><div class=\"line\"><span class=\"number\">848</span></div><div class=\"line\"></div><div class=\"line\">(lldb) po $x0</div><div class=\"line\"><span class=\"number\">13</span></div></pre></td></tr></table></figure>\n<p>我们ni的两次，程序已经走到0x19080411C的位置，然后我们继续打印变量x0和x27的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x0</div><div class=\"line\">13</div><div class=\"line\">(lldb) po $x27</div><div class=\"line\">1104</div></pre></td></tr></table></figure>\n<p>打印出来的x0和x27都是随机数，还是没有什么收获，我们继续</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) ni</div><div class=\"line\">Process 1192 stopped</div><div class=\"line\">* thread #1: tid = 0x523a6, 0x0000000193654120 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 88, queue = 'com.apple.main-thread', stop reason = instruction step over</div><div class=\"line\">    frame #0: 0x0000000193654120 Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + 88</div><div class=\"line\">Preferences`-[PSListController tableView:cellForRowAtIndexPath:]:</div><div class=\"line\">-&gt;  0x193654120 &lt;+88&gt;:  adrp   x8, 53960</div><div class=\"line\">    0x193654124 &lt;+92&gt;:  ldr    x22, [x8, #1368]</div><div class=\"line\">    0x193654128 &lt;+96&gt;:  mov    x1, x22</div><div class=\"line\">    0x19365412c &lt;+100&gt;: bl     0x199a89bc0               ; objc_msgSend</div><div class=\"line\">(lldb) po $x0</div><div class=\"line\">&lt;__NSArrayI 0x13105a780&gt;(</div><div class=\"line\">G: &lt;PSSpecifier 0x12ff50cf0: ID 0, Name '' target &lt;(null): 0x0&gt;&gt; 0x12ff50cf0,</div><div class=\"line\">&lt;PSSpecifier 0x12ff50f50: ID NAME_CELL_ID, Name 'Name' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">G: &lt;PSSpecifier 0x12ff51680: ID 2, Name '' target &lt;(null): 0x0&gt;&gt; 0x12ff51680,</div><div class=\"line\">&lt;PSSpecifier 0x12ff52360: ID NETWORK, Name 'Network' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff52420: ID SONGS, Name 'Songs' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff519f0: ID VIDEOS, Name 'Videos' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff51ab0: ID PHOTOS, Name 'Photos' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff51b70: ID APPLICATIONS, Name 'Applications' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff524e0: ID User Data Capacity, Name 'Capacity' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff525a0: ID User Data Available, Name 'Available' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff526a0: ID ProductVersion, Name 'Version' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff52850: ID CARRIER_VERSION, Name 'Carrier' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff52980: ID ProductModel, Name 'Model' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff52a60: ID SerialNumber, Name 'Serial Number' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff52b90: ID MACAddress, Name 'Wi-Fi Address' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12ff51050: ID BTMACAddress, Name 'Bluetooth' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">&lt;PSSpecifier 0x12fde95d0: ID ModemVersion, Name 'Modem Firmware' target &lt;AboutDataSource: 0x131028390&gt;&gt;,</div><div class=\"line\">G: &lt;PSSpecifier 0x131031e90: ID 17, Name '' target &lt;(null): 0x0&gt;&gt; 0x131031e90,</div><div class=\"line\">&lt;PSSpecifier 0x12fde9c40: ID LEGAL_AND_REGULATORY, Name 'Legal' target &lt;(null): 0x0&gt;&gt;,</div><div class=\"line\">G: &lt;PSSpecifier 0x131029dc0: ID TRUST_STORE_GROUP, Name '' target &lt;(null): 0x0&gt;&gt; 0x131029dc0,</div><div class=\"line\">&lt;PSSpecifier 0x131033520: ID TRUST_STORE, Name 'Trust Store' target &lt;AboutDataSource: 0x131028390&gt;&gt;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>我们让程序执行下一步，发现此时x0已经有值了，可以明显的看出，x0的值是在0x190804114~0x19080411C这段代码生成的，下面我们的工作重点就是寻找这段代码干了什么，胜利就在眼前！下面我们验证一下这里面到底有没有我们要的序列号：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po [[$x0 objectAtIndex:<span class=\"number\">13</span>] <span class=\"keyword\">class</span>]</div><div class=\"line\">PSSpecifier</div><div class=\"line\">(lldb) po [[$x0 objectAtIndex:<span class=\"number\">13</span>] properties]</div><div class=\"line\">&#123;</div><div class=\"line\">    cellObject = <span class=\"string\">\"&lt;PSTableCell: 0x130800000; baseClass = UITableViewCell; frame = (0 565; 320 45); text = 'Serial Number'; hidden = YES; autoresize = W; tag = 4; gestureRecognizers = &lt;NSArray: 0x12ff821c0&gt;; layer = &lt;CALayer: 0x12fd7d340&gt;&gt;\"</span>;</div><div class=\"line\">    <span class=\"keyword\">id</span> = SerialNumber;</div><div class=\"line\">    isCopyable = <span class=\"number\">1</span>;</div><div class=\"line\">    value = DNPMVG0EFF9V;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们打印数组中存放cell数据的object属于哪个类，发现是<code>PSSpecifier</code>，我们找到之前导出的类的头文件，发现这个类有一个叫做<code>properties</code>的实例方法，我们调用一下发现我们要的序列号就在里面<code>value = DNPMVG0EFF9V</code>，这跟iPhone设置中看到的序列号是一致的。猜测这个数组里面存放着系统设置中<code>PSUIAboutController</code>中所有cel的数据，这个数组下一个肯定要传递到cell生成的方法中，这个就不做验证了，大事重要，我们继续找序列号的生成方法。<br>这个<code>PSSpecifier</code>中有一个<code>AboutDataSource</code>对象，这个非常可疑，从名称上可以判断，这个类是专门用于数据处理的，不过在这之前我们还是先验证一下，在0x190804114~0x19080411C这段地址中，执行了<code>_PSListController._specifiers</code>，我们从<code>PSListController</code>的头文件（下文有讲怎么获取）中可以看到有一个specifiers属性，我们在IDA分析的文件中找到<code>[PSListController specifiers]</code>，我们先定位到方法在二进制文件中的位置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8 ; -[PSListController specifiers]</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8 __PSListController_specifiers_          ; DATA XREF: __objc_const:<span class=\"number\">000000019</span>C069A08\u0019o</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8 var_40          = <span class=\"number\">-0x40</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8 var_30          = <span class=\"number\">-0x30</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8 var_20          = <span class=\"number\">-0x20</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8 var_10          = <span class=\"number\">-0x10</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4A8                 STP             X24, X23, [SP,<span class=\"meta\">#var_40]!</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4AC                 STP             X22, X21, [SP,<span class=\"meta\">#0x40+var_30]</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4B0                 STP             X20, X19, [SP,<span class=\"meta\">#0x40+var_20]</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4B4                 STP             X29, X30, [SP,<span class=\"meta\">#0x40+var_10]</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4B8                 ADD             X29, SP, <span class=\"meta\">#0x40+var_10</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4BC                 MOV             X19, X0</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4C0                 ADRP            X8, <span class=\"meta\">#_OBJC_IVAR_$_PSListController._specifiers@PAGE ; NSArray *_specifiers;</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4C4                 LDRSW           X22, [X8,<span class=\"meta\">#_OBJC_IVAR_$_PSListController._specifiers@PAGEOFF] ; NSArray *_specifiers;</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4C8                 LDR             X8, [X19,X22]</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4CC                 CBNZ            X8, loc_1907FE5E0</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4D0                 ADRP            X8, <span class=\"meta\">#_OBJC_IVAR_$_PSListController._dataSource@PAGE ; id <span class=\"meta-string\">&lt;PSSpecifierDataSource&gt;</span> _dataSource;</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4D4                 LDRSW           X8, [X8,<span class=\"meta\">#_OBJC_IVAR_$_PSListController._dataSource@PAGEOFF] ; id <span class=\"meta-string\">&lt;PSSpecifierDataSource&gt;</span> _dataSource;</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4D8                 LDR             X9, [X19,X8]</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4DC                 CBZ             X9, loc_1907FE550</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4E0                 ADRP            X9, <span class=\"meta\">#_OBJC_IVAR_$_PSListController._requestingSpecifiersFromDataSource@PAGE ; bool _requestingSpecifiersFromDataSource;</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4E4                 LDRSW           X23, [X9,<span class=\"meta\">#_OBJC_IVAR_$_PSListController._requestingSpecifiersFromDataSource@PAGEOFF] ; bool _requestingSpecifiersFromDataSource;</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4E8                 MOV             W9, <span class=\"meta\">#1</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4EC                 STRB            W9, [X19,X23]</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4F0                 LDR             X20, [X19,X8]</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4F4                 ADRP            X8, <span class=\"meta\">#selRef_specifier@PAGE</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4F8                 LDR             X1, [X8,<span class=\"meta\">#selRef_specifier@PAGEOFF]</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE4FC                 MOV             X0, X19</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE500                 BL              <span class=\"number\">0x96C39BC0</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE504                 MOV             X29, X29</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE508                 BL              <span class=\"number\">0x96C41EF0</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE50C                 MOV             X21, X0</div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE510                 ADRP            X8, <span class=\"meta\">#selRef_specifiersForSpecifier_observer_@PAGE</span></div><div class=\"line\">__text:<span class=\"number\">00000001907</span>FE514                 LDR             X1, </div><div class=\"line\">……</div></pre></td></tr></table></figure>\n<p>然后在这里面下个断点看看会发生什么</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a 0x1907FE4D0+0x198e58640</div><div class=\"line\">Breakpoint 9: where = Preferences`-[PSListController specifiers] + 40, address = 0x000000019364e4d0</div></pre></td></tr></table></figure>\n<p>我们从设置中进入通用&gt;关于，发现一开始就走到了这个断点，我们猜测，一进入关于页面，系统会首先把所有cell的数据都准备好，然后加载UI</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Process <span class=\"number\">1192</span> stopped</div><div class=\"line\">* thread <span class=\"meta\">#1: tid = 0x523a6, 0x000000019364e4d0 Preferences`-[PSListController specifiers] + 40, queue = 'com.apple.main-thread', stop reason = breakpoint 9.1</span></div><div class=\"line\">    frame <span class=\"meta\">#0: 0x000000019364e4d0 Preferences`-[PSListController specifiers] + 40</span></div><div class=\"line\">Preferences`-[PSListController specifiers]:</div><div class=\"line\">-&gt;  <span class=\"number\">0x19364e4d0</span> &lt;+<span class=\"number\">40</span>&gt;: adrp   x8, <span class=\"number\">53971</span></div><div class=\"line\">    <span class=\"number\">0x19364e4d4</span> &lt;+<span class=\"number\">44</span>&gt;: ldrsw  x8, [x8, <span class=\"meta\">#536]</span></div><div class=\"line\">    <span class=\"number\">0x19364e4d8</span> &lt;+<span class=\"number\">48</span>&gt;: ldr    x9, [x19, x8]</div><div class=\"line\">    <span class=\"number\">0x19364e4dc</span> &lt;+<span class=\"number\">52</span>&gt;: cbz    x9, <span class=\"number\">0x19364e550</span>           ; &lt;+<span class=\"number\">168</span>&gt;</div></pre></td></tr></table></figure>\n<p>我们打印变量x8和x9的值，看一下系统做了什么</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x8</div><div class=\"line\">&lt;nil&gt;</div><div class=\"line\">(lldb) po $x9</div><div class=\"line\">PSUIAboutController</div></pre></td></tr></table></figure>\n<p>并没有数据之类的东西值得我们关注，让断点继续往下走，走到0x19364e4dc的位置，我们再次打印变量x8和x9的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) n</div><div class=\"line\">Process 1192 stopped</div><div class=\"line\">* thread #1: tid = 0x523a6, 0x000000019364e4dc Preferences`-[PSListController specifiers] + 52, queue = &apos;com.apple.main-thread&apos;, stop reason = instruction step over</div><div class=\"line\">    frame #0: 0x000000019364e4dc Preferences`-[PSListController specifiers] + 52</div><div class=\"line\">Preferences`-[PSListController specifiers]:</div><div class=\"line\">-&gt;  0x19364e4dc &lt;+52&gt;: cbz    x9, 0x19364e550           ; &lt;+168&gt;</div><div class=\"line\">    0x19364e4e0 &lt;+56&gt;: adrp   x9, 53971</div><div class=\"line\">    0x19364e4e4 &lt;+60&gt;: ldrsw  x23, [x9, #540]</div><div class=\"line\">    0x19364e4e8 &lt;+64&gt;: orr    w9, wzr, #0x1</div><div class=\"line\">(lldb) po $x8</div><div class=\"line\">952</div><div class=\"line\">(lldb) po $x9</div><div class=\"line\">&lt;AboutDataSource: 0x131130730&gt;</div></pre></td></tr></table></figure>\n<p>此时的变量x9已经变成了<code>AboutDataSource</code>，这里验证了我们上一步的猜想，所以我们重点来研究它，我们先找到这个类在哪个framework中，这里使用的是grep命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ grep AboutDataSource -r /Users/gaoshilei/Desktop/reverse/iOS-Runtime-Headers-9.1 </div><div class=\"line\">/Users/gaoshilei/Desktop/reverse/iOS-Runtime-Headers-9.1/PrivateFrameworks/PreferencesUI.framework/AboutDataSource.h:@interface AboutDataSource : PSSpecifierDataSource &#123;</div></pre></td></tr></table></figure>\n<p>这里要说明一下iOS-Runtime-Headers-9.1这个文件夹是iOS9.1系统的所有头文件（共有+私有），这个你可以自己导（iOS9之后只能用runtime导，class-dump已经不行了），你也可以拿现成的用，github上面已经有雷锋把所有系统的头文件都导出来了，直接下载就可以了。我们发现<code>AboutDataSource</code>这个类在<code>PrivateFrameworks/PreferencesUI.framework</code>中，先看一下这个类里面有什么方法和属性，有一个方法<code>- (void)_loadValues;</code> 我们对它进行分析。这里又要借助IDA分析，把PreferencesUI这个二进制文件丢到IDA里面，在0x19091EBB8这个位置打个断点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a 0x19091EBB8+0x2e50000</div><div class=\"line\">Breakpoint 3: where = PreferencesUI`-[AboutDataSource _loadValues] + 1956, address = 0x000000019376ebb8</div></pre></td></tr></table></figure>\n<p>接下来我们进入关于来触发断点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po (char *) $x28</div><div class=\"line\">&quot;_setValue:forSpecifierWithKey:&quot;</div></pre></td></tr></table></figure>\n<p>在这里打印变量x28的值，发现它是一个方法名，从名称来看是给<code>specifier</code>赋值的，看来我们要寻找的真相已经很近了，让代码走到下面的位置0x19376ebd8</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Process 2107 stopped</div><div class=\"line\">* thread #1: tid = 0xe8e23, 0x000000019376ebd8 PreferencesUI`-[AboutDataSource _loadValues] + 1988, queue = &apos;com.apple.main-thread&apos;, stop reason = instruction step over</div><div class=\"line\">    frame #0: 0x000000019376ebd8 PreferencesUI`-[AboutDataSource _loadValues] + 1988</div><div class=\"line\">PreferencesUI`-[AboutDataSource _loadValues]:</div><div class=\"line\">-&gt;  0x19376ebd8 &lt;+1988&gt;: bl     0x198e58640               ; MGCopyAnswer</div><div class=\"line\">    0x19376ebdc &lt;+1992&gt;: mov    x22, x0</div><div class=\"line\">    0x19376ebe0 &lt;+1996&gt;: mov    x1, x19</div><div class=\"line\">    0x19376ebe4 &lt;+2000&gt;: bl     0x199a89bc0               ; objc_msgSend</div><div class=\"line\">(lldb) po $x0</div><div class=\"line\">SerialNumber</div></pre></td></tr></table></figure>\n<p>此时我们打印的x0是一个<code>NSCFConstantString</code>，本质就是一个<code>NSString</code>，继续<code>ni</code>让程序运行到0x19376ebdc</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Process 2107 stopped</div><div class=\"line\">* thread #1: tid = 0xe8e23, 0x000000019376ebdc PreferencesUI`-[AboutDataSource _loadValues] + 1992, queue = &apos;com.apple.main-thread&apos;, stop reason = instruction step over</div><div class=\"line\">    frame #0: 0x000000019376ebdc PreferencesUI`-[AboutDataSource _loadValues] + 1992</div><div class=\"line\">PreferencesUI`-[AboutDataSource _loadValues]:</div><div class=\"line\">-&gt;  0x19376ebdc &lt;+1992&gt;: mov    x22, x0</div><div class=\"line\">    0x19376ebe0 &lt;+1996&gt;: mov    x1, x19</div><div class=\"line\">    0x19376ebe4 &lt;+2000&gt;: bl     0x199a89bc0               ; objc_msgSend</div><div class=\"line\">    0x19376ebe8 &lt;+2004&gt;: cbnz   x0, 0x19376ec4c           ; &lt;+2104&gt;</div><div class=\"line\">(lldb) po $x0</div><div class=\"line\">DNPMVG0EFF9V</div></pre></td></tr></table></figure>\n<p>在这里我们打印了变量x0的值为<strong>DNPMVG0EFF9V</strong>，这就是我们苦苦寻找的序列号。不难看出，序列号就是在0x19376ebd8这行拿到的，范围越来越小，敌人无路可逃！下面我们就要对这行进行分析，我们按照之前的步骤，再次走到0x19376ebd8这个位置，这不过这次我们不要<code>step-over</code>，我们用<code>si</code>跳入看看</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) si</div><div class=\"line\">Process <span class=\"number\">2107</span> stopped</div><div class=\"line\">* thread <span class=\"meta\">#1: tid = 0xe8e23, 0x0000000198e58640 libMobileGestalt.dylib`MGCopyAnswer, queue = 'com.apple.main-thread', stop reason = instruction step into</span></div><div class=\"line\">    frame <span class=\"meta\">#0: 0x0000000198e58640 libMobileGestalt.dylib`MGCopyAnswer</span></div><div class=\"line\">libMobileGestalt.dylib`MGCopyAnswer:</div><div class=\"line\">-&gt;  <span class=\"number\">0x198e58640</span> &lt;+<span class=\"number\">0</span>&gt;: movz   x1, <span class=\"meta\">#0</span></div><div class=\"line\">    <span class=\"number\">0x198e58644</span> &lt;+<span class=\"number\">4</span>&gt;: b      <span class=\"number\">0x198e58648</span>               ; ___lldb_unnamed_symbol64$$libMobileGestalt.dylib</div><div class=\"line\"></div><div class=\"line\">libMobileGestalt.dylib`___lldb_unnamed_symbol64$$libMobileGestalt.dylib:</div><div class=\"line\">    <span class=\"number\">0x198e58648</span> &lt;+<span class=\"number\">0</span>&gt;: stp    x24, x23, [sp, <span class=\"meta\">#-64]!</span></div><div class=\"line\">    <span class=\"number\">0x198e5864c</span> &lt;+<span class=\"number\">4</span>&gt;: stp    x22, x21, [sp, <span class=\"meta\">#16]</span></div><div class=\"line\">此时跳入了一个静态库libMobileGestalt.dylib，我们可以在usr/lib/ibMobileGestalt.dylib找到它，我们将它扔进IDA，用当前的addr减去libMobileGestalt.dylib的基地址偏移得到它的静态地址<span class=\"number\">0x196008640</span>，对应的是一个函数MGCopyAnswer</div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span></div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span> ; =============== S U B R O U T I N E =======================================</div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span></div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span></div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span>                 EXPORT _MGCopyAnswer</div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span> _MGCopyAnswer                           ; CODE XREF: sub_196005958+<span class=\"number\">30</span>\u0018p</div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span>                                         ; sub_196006258+<span class=\"number\">28</span>\u0018p ...</div><div class=\"line\">__text:<span class=\"number\">0000000196008640</span>                 MOV             X1, <span class=\"meta\">#0</span></div><div class=\"line\">__text:<span class=\"number\">0000000196008644</span>                 B               sub_196008648</div><div class=\"line\">__text:<span class=\"number\">0000000196008644</span> ; End of function _MGCopyAnswer</div></pre></td></tr></table></figure>\n<p>这个函数最外层只有两行代码，将立即数0赋给x1，然后跳进了子程序sub_196008648，跳进去之后进行了一些很复杂的运算，这里就不做介绍了，里面的实现大概是这样的：<br>x0是作为一个参数传入的，并且这里x0的值为<code>SerialNumber</code>，在地址为0x196008678的地方，这个函数中x1变成了一串随机数，有点像MD5加密之后的东西，应该是“钥匙”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po (char*) $x1</div><div class=\"line\">&quot;l92SaBpqIvQs+KBljuwGA&quot;</div></pre></td></tr></table></figure>\n<p>在0x196008690这里，我们<code>setp-into</code>这个函数，在函数的末尾返回值的地方0x196007474打个断点，打印返回值x0</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x0</div><div class=\"line\">DNPMVG0EFF9V</div></pre></td></tr></table></figure>\n<p>这里的x0由<code>SerialNumber</code>变成了真正的序列号，并且就是在0x196008690对应的子程序sub_19600738C里面拿到的，所以我们就这样一个猜测，在<code>MGCopyAnswer</code>函数中，x0作为一个参数传入，并且在内部进行了一系列复杂的运算，拿到了获取序列号的“钥匙”x1，然后在sub_19600738C中拿到了最终的序列号。这里笔者也没有对序列号的拿到在进行进一步的深究，这里苹果做了很大的限制，再继续研究恐怕也是收获不大，而且我们在这里已经能拿到序列号了。  </p>\n<h3 id=\"三、验证结果\"><a href=\"#三、验证结果\" class=\"headerlink\" title=\"三、验证结果\"></a>三、验证结果</h3><p>接下来就是验证的过程了，我们写一个tweak来验证，当然也可以用其他方式来验证：<br>tweak的创建这里就不赘述了，我把我的tweak和makefile文件内容贴一下：</p>\n<blockquote>\n<p>tweak文件：</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">tweak.xm:</div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> <span class=\"built_in\">NSString</span> *MGCopyAnswer(<span class=\"built_in\">NSString</span>*);</div><div class=\"line\">%hook SpringBoard</div><div class=\"line\">- (<span class=\"keyword\">void</span>)applicationDidFinishLaunching:(<span class=\"keyword\">id</span>)application &#123;</div><div class=\"line\">%orig;</div><div class=\"line\"><span class=\"built_in\">NSString</span> *serialNumber = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@\"</span>,[MGCopyAnswer(<span class=\"string\">@\"SerialNumber\"</span>) autorelease]];</div><div class=\"line\"><span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc] initWithTitle:serialNumber message:<span class=\"literal\">nil</span> delegate:<span class=\"keyword\">self</span> cancelButtonTitle:<span class=\"string\">@\"OK\"</span> otherButtonTitles:<span class=\"literal\">nil</span>];</div><div class=\"line\">[alert show];</div><div class=\"line\">&#125;</div><div class=\"line\">%end</div></pre></td></tr></table></figure>\n<p>这里注入系统的SpringBoard，在SB启动的时候hook住applicationDidFinishLaunching：函数，并且在这个函数里面添加获取序列号的代码，并且以弹框的形式展现出来。  </p>\n<blockquote>\n<p>makefile文件:</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">THEOS_DEVICE_IP = <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.115</span></div><div class=\"line\">include $(THEOS)/makefiles/common.mk</div><div class=\"line\">TWEAK_NAME = SerialNumber</div><div class=\"line\">SerialNumber_FILES = Tweak.xm</div><div class=\"line\">include $(THEOS_MAKE_PATH)/tweak.mk</div><div class=\"line\">SerialNumber_LDFLAGS = -lMobileGestalt</div><div class=\"line\">after-install::</div><div class=\"line\">\tinstall.exec <span class=\"string\">\"killall -9 SpringBoard\"</span></div></pre></td></tr></table></figure>\n<p>其中有一行<code>SerialNumber_LDFLAGS = -lMobileGestalt</code>千万要注意，使用的时候要加载这个静态库，因为SpringBoard加载的时候我也不确定是否有加载这个库，然后我们验证一下吧！<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%9F%A5%E6%89%BE%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B01.jpg\" alt=\"序列号验证-获取\"><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%9F%A5%E6%89%BE%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B02.jpg\" alt=\"序列号验证-系统\">  </p>\n<p> <a href=\"https://www.amazon.cn/iOS应用逆向工程-沙梓社/dp/B00VFDVY7E/ref=sr_1_1?ie=UTF8&amp;qid=1477453672&amp;sr=8-1&amp;keywords=iOS逆向工程\" target=\"_blank\" rel=\"external\">此文参考了《iOS逆向工程（第二版）》</a></p>"},{"title":"手把手教你逆向微信之朋友圈小视频转发（上）","date":"2016-11-09T16:00:00.000Z","_content":"#\t前言\n此文为逆向微信二进制文件，实现朋友圈小视频转发的教程，从最开始的汇编代码入手到最后重签名安装等操作，手把手教你玩转微信！学会之后再去逆向微信其他功能易如反掌。  \n本篇文章由于篇幅太长分成了两篇，**上篇**讲解的是逆向工作，也就是怎么找到相关的函数和方法实现，**下篇**讲解的是怎么在非越狱机重签名安装和越狱机tweak安装的详细过程。  \n**正文的第二部分还提供了微信自动抢红包、修改微信步数的代码，这些都可以照葫芦画瓢按照本文的套路一步步逆向找到，这里就不再赘述。**  \n在实践之前，需要准备好一部越狱的手机，然后将下文列出的所有工具安装好。IDA跟Reveal都是破解版，IDA的正版要2000多刀，对于这么牛逼的逆向工具确实物有所值，不过不是专门研究逆向的公司也没必要用正版的，下个Windows的破解版就好，Mac上暂时没找到。Mac上可以用hopper代替IDA，也是一款很牛逼的逆向工具。废话不多说，正式开始吧！\n\n<!-- more -->\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n#\t逆向微信朋友圈（上篇）\n## 一、获取朋友圈的小视频\n>\t注意：本文逆向的微信的二进制文件为6.3.28版本，如果是不同的微信版本，二进制文件中的基地址也不相同\n\n####\t本文涉及到的工具  \n1. [cycript](http://www.cycript.org) \n2. LLDB与debugserver（Xcode自带）\n3. OpenSSH\n4. IDA\n5. Reveal\n6. [theos](https://github.com/theos/theos)\n7. [CydiaSubstrate](http://www.cydiasubstrate.com)\n8. iOSOpenDev\n9. ideviceinstaller\n10. tcprelay（本地端口映射，USB连接SSH，不映射可通过WiFi连接） \n11. [dumpdecrypted](https://github.com/stefanesser/dumpdecrypted)\n12. [class-dump](http://stevenygard.com/projects/class-dump/) \n13. [iOS App Signer](https://github.com/DanTheMan827/ios-app-signer)\n14. 编译好的[yololib](https://github.com/gaoshilei/yololib)\n\n**逆向环境为MacOS\t+\tiPhone5S 9.1越狱机**  \n先用dumpdecrypted给微信砸壳（不会的请我写的看[这篇教程](http://www.gaoshilei.com/2016/08/08/dumpdecrypted给App砸壳/)），获得一个WeChat.decrypted文件，先把这个文件扔到IDA中分析（60MB左右的二进制文件，IDA差不多40分钟才能分析完），用class-dump导出所有头文件\n\n```\nLeonLei-MBP:~ gaoshilei$ class-dump -S -s -H /Users/gaoshilei/Desktop/reverse/binary_for_class-dump/WeChat.decrypted -o /Users/gaoshilei/Desktop/reverse/binary_for_class-dump/class-Header/WeChat\n```\n\n我滴个亲娘！一共有8000个头文件，微信果然工程量浩大！稳定一下情绪，理一理思路继续搞。要取得小视频的下载链接，找到播放视频的View，顺藤摸瓜就能找到小视频的URL。用Reveal查看小视频的播放窗口\n![Reveal](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91Reveal.png)  \n可以看出来WCContentItemViewTemplateNewSigh这个对象是小视频的播放窗口，它的subView有WCSightView，SightView、SightPlayerView，这几个类就是我们的切入点。\n保存视频到favorite的时候是长按视频弹出选项的，那么在WCContentItemViewTemplateNewSight这个类里面可能有手势相关的方法，去刚才导出的头文件中找线索。\n\n```\n- (void)onLongTouch;\n- (void)onLongPressedWCSight:(id)arg1;\n- (void)onLongPressedWCSightFullScreenWindow:(id)arg1;\n```\n\n这几个方法跟长按手势相关，再去IDA中找到这些函数，逐个查看。onLongPressedWCSight和onLongPressedWCSightFullScreenWindow都比较简单，onLongTouch比较长，而且发现了内部调用了方法Favorites_Add，因为长按视频的时候出来一个选项就是Favorites，并且我看到这个函数调用\n\n```\nADRP            X8, #selRef_sightVideoPath@PAGE\nLDR             X1, [X8,#selRef_sightVideoPath@PAGEOFF]\n```\n\n这里拿到了小视频的地址，可以推测这个函数跟收藏有关，下面打断点测试。\n\n```\n(lldb) im li -o -f\n[  0] 0x000000000003c000 /var/mobile/Containers/Bundle/Application/2F1D52EC-C57E-4F95-B715-EF04351232E8/WeChat.app/WeChat(0x000000010003c000)\n```\n\n可以看到WeChat的ASLR为0x3c000，在IDA查找到这三个函数的基地址，分别下断点\n\n```\n(lldb) br s -a 0x1020D3A10+0x3c000\nBreakpoint 1: where = WeChat`___lldb_unnamed_symbol110094$$WeChat + 28, address = 0x000000010210fa10\n(lldb) br s -a 0x1020D3370+0x3c000\nBreakpoint 2: where = WeChat`___lldb_unnamed_symbol110091$$WeChat + 8, address = 0x000000010210f370\n(lldb) br s -a 0x1020D33E4+0x3c000\nBreakpoint 3: where = WeChat`___lldb_unnamed_symbol110092$$WeChat + 12, address = 0x000000010210f3e4\n```\n\n回到微信里面长按小视频，看断点触发情况\n\n```\nProcess 3721 stopped\n* thread #1: tid = 0x658fc, 0x000000010210f370 WeChat`___lldb_unnamed_symbol110091$$WeChat + 8, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1\n    frame #0: 0x000000010210f370 WeChat`___lldb_unnamed_symbol110091$$WeChat + 8\nWeChat`___lldb_unnamed_symbol110091$$WeChat:\n->  0x10210f370 <+8>:  add    x29, sp, #16              ; =16 \n    0x10210f374 <+12>: mov    x19, x0\n    0x10210f378 <+16>: adrp   x8, 4968\n    0x10210f37c <+20>: ldr    x0, [x8, #744]\n(lldb) c\nProcess 3721 resuming\nProcess 3721 stopped\n* thread #1: tid = 0x658fc, 0x000000010210fa10 WeChat`___lldb_unnamed_symbol110094$$WeChat + 28, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n    frame #0: 0x000000010210fa10 WeChat`___lldb_unnamed_symbol110094$$WeChat + 28\nWeChat`___lldb_unnamed_symbol110094$$WeChat:\n->  0x10210fa10 <+28>: add    x29, sp, #96              ; =96 \n    0x10210fa14 <+32>: sub    sp, sp, #96               ; =96 \n    0x10210fa18 <+36>: mov    x19, x0\n    0x10210fa1c <+40>: adrp   x8, 4863\n……\n```\n\n发现断点2先被触发，接着触发断点1，后面断点2和1又各触发了1次，断点3一直很安静。可以排除onLongPressedWCSightFullScreenWindow与收藏小视频的联系。小视频的踪影就要在剩下的两个方法中寻找了。通过V找到C，顺藤摸瓜找到M屡试不爽！用cycript注入WeChat，拿到播放小视频的view所在的Controller。\n\n```\ncy# [#0x138c18030 nextResponder]\n#\"<WCTimeLineCellView: 0x138c34620; frame = (0 0; 319 249); tag = 1048577; layer = <CALayer: 0x138362ba0>>\"\ncy# [#0x138c34620 nextResponder]\n#\"<UITableViewCellContentView: 0x138223c70; frame = (0 0; 320 256); gestureRecognizers = <NSArray: 0x1384ec480>; layer = <CALayer: 0x138081dc0>>\"\ncy# [#0x138223c70 nextResponder]\n#\"<MMTableViewCell: 0x138c9f930; baseClass = UITableViewCell; frame = (0 307; 320 256); autoresize = W; layer = <CALayer: 0x1382dcd10>>\"\ncy# [#0x138c9f930 nextResponder]\n#\"<UITableViewWrapperView: 0x137b57800; frame = (0 0; 320 504); gestureRecognizers = <NSArray: 0x1383db660>; layer = <CALayer: 0x138af20c0>; contentOffset: {0, 0}; contentSize: {320, 504}>\"\ncy# [#0x137b57800 nextResponder]\n#\"<MMTableView: 0x137b8ae00; baseClass = UITableView; frame = (0 0; 320 568); gestureRecognizers = <NSArray: 0x138adb590>; layer = <CALayer: 0x138956890>; contentOffset: {0, 99.5}; contentSize: {320, 3193}>\"\ncy# [#0x137b8ae00 nextResponder]\n#\"<UIView: 0x138ade5c0; frame = (0 0; 320 568); autoresize = W+H; layer = <CALayer: 0x138ac9990>>\"\ncy# [#0x138ade5c0 nextResponder]\n#\"<WCTimeLineViewController: 0x1379eb000>\"\n```\n\n通过响应者链条找到\nWCContentItemViewTemplateNewSight所属的Controller为WCTimeLineViewController。在这个类的头文件中并没有发现有价值的线索，不过我们注意到小视频所在的view是属于MMTableVIewCell的（见上图Reveal分析图），这是每一个iOS最熟悉的TableView，cell的数据是通过UITableViewDataSource的代理方法`- tableView:cellForRowAtIndexPath:`赋值的，通过这个方法肯定能知道到M的影子。在IDA中找到`[WCTimeLineViewController tableView:cellForRowAtIndexPath:]`,定位到基地址0x10128B6B0位置：\n\n```\n__text:000000010128B6B0     ADRP     X8, #selRef_genNormalCell_indexPath_@PAGE\n```\n\n这里的函数是WCTimeLineViewController中生成cell的方法，除了这个方法在这个类中还有另外三个生成cell的方法：\n\n```\n- (void)genABTestTipCell:(id)arg1 indexPath:(id)arg2;\n- (void)genRedHeartCell:(id)arg1 indexPath:(id)arg2;\n- (void)genUploadFailCell:(id)arg1 indexPath:(id)arg2;\n```\n\n通过字面意思可以猜测出normal这个应该是生成小视频cell的方法。继续在IDA中寻找线索\n\n```\n__text:0000000101287CC8     ADRP     X8, #selRef_getTimelineDataItemOfIndex_@PAGE\n```\n\n在`genNormalCell:IndexPath:`方法中发现上面这个方法，可以大胆猜想这个方法是获取TimeLine（朋友圈）数据的方法，那小视频的数据肯定也是通过这个方法获取的，并且IDA可以看到这个方法中调用一个叫做`selRef_getTimelineDataItemOfIndex_`的方法，获取DataItem貌似就是cell的数据源啊！接下来用LLDB下断点验证猜想。\n通过IDA可以找到这个方法对应的基地址为：0x101287CE4，先打印正在运行WeChat的ASLR偏移\n\n```\nLeonLei-MBP:~ gaoshilei$ lldb\n(lldb) process connect connect://localhost:1234\n(lldb) im li -o -f \n[0] 0x0000000000050000 /var/mobile/Containers/Bundle/Application/2DCE8F30-9B6B-4652-901C-37EB1FF2A40D/WeChat.app/WeChat(0x0000000100050000)\n```\n\n所以我们下断点的位置是0x50000+0x101287CE4\n\n```\n(lldb) br s -a 0x50000+0x101287CE4\nBreakpoint 1: where = WeChat`___lldb_unnamed_symbol63721$$WeChat + 252, address = 0x00000001012d7ce4\n```\n\n打印x0的值\n\n```\n(lldb) po $x0\nClass name: WCDataItem, addr: 0x15f5f03b0\ntid: 12393001887435993280\nusername: wxid_z8twcz4o18fg12\ncreatetime: 1477360950\ncommentUsers: (\n)\ncontentObj: <WCContentItem: 0x15f57d000>\n\n```\n\n得到一个WCDataItem的对象，这里x0的值就是`selRef_getTimelineDataItemOfIndex_`执行完的返回值，然后把x0的值改掉\n\n```\n(lldb) register write $x0 0\n(lldb) c\n```\n\n此时会发现我们要刷新的那条小视频内容全部为空  \n![小视频内容为空](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91-%E8%BD%AC%E5%8F%91%E5%B0%8F%E8%A7%86%E9%A2%91%E4%B8%BA%E7%A9%BA.jpg)  \n到这里已经找到了小视频的源数据获取方法，问题是我们怎么拿到这个WCDataItem呢？继续看IDA分析函数的调用情况：  \n>\tWCTimeLineViewController - (void)genNormalCell:(id) indexPath:(id)  \n\n\n```\n__text:0000000101287BCC                 STP             X28, X27, [SP,#var_60]!\n__text:0000000101287BD0                 STP             X26, X25, [SP,#0x60+var_50]\n__text:0000000101287BD4                 STP             X24, X23, [SP,#0x60+var_40]\n__text:0000000101287BD8                 STP             X22, X21, [SP,#0x60+var_30]\n__text:0000000101287BDC                 STP             X20, X19, [SP,#0x60+var_20]\n__text:0000000101287BE0                 STP             X29, X30, [SP,#0x60+var_10]\n__text:0000000101287BE4                 ADD             X29, SP, #0x60+var_10\n__text:0000000101287BE8                 SUB             SP, SP, #0x80\n__text:0000000101287BEC                 MOV             X19, X3\n__text:0000000101287BF0                 MOV             X22, X0\n__text:0000000101287BF4                 MOV             W25, #0x100000\n__text:0000000101287BF8                 MOVK            W25, #1\n__text:0000000101287BFC                 MOV             X0, X2\n__text:0000000101287C00                 BL              _objc_retain\n__text:0000000101287C04                 MOV             X28, X0\n__text:0000000101287C08                 MOV             X0, X19\n__text:0000000101287C0C                 BL              _objc_retain\n__text:0000000101287C10                 MOV             X20, X0\n__text:0000000101287C14                 STR             X20, [SP,#0xE0+var_98]\n__text:0000000101287C18                 ADRP            X8, #selRef_row@PAGE\n__text:0000000101287C1C                 LDR             X1, [X8,#selRef_row@PAGEOFF]\n__text:0000000101287C20                 BL              _objc_msgSend\n__text:0000000101287C24                 MOV             X26, X0\n__text:0000000101287C28                 ADRP            X8, #selRef_section@PAGE\n__text:0000000101287C2C                 LDR             X19, [X8,#selRef_section@PAGEOFF]\n__text:0000000101287C30                 MOV             X0, X20\n__text:0000000101287C34                 MOV             X1, X19\n__text:0000000101287C38                 BL              _objc_msgSend\n__text:0000000101287C3C                 STR             X0, [SP,#0xE0+var_A8]\n__text:0000000101287C40                 MOV             X0, X20\n__text:0000000101287C44                 MOV             X1, X19\n__text:0000000101287C48                 BL              _objc_msgSend\n__text:0000000101287C4C                 MOV             X2, X0\n__text:0000000101287C50                 ADRP            X8, #selRef_calcDataItemIndex_@PAGE\n__text:0000000101287C54                 LDR             X1, [X8,#selRef_calcDataItemIndex_@PAGEOFF]\n__text:0000000101287C58                 MOV             X0, X22\n__text:0000000101287C5C                 BL              _objc_msgSend\n__text:0000000101287C60                 MOV             X21, X0\n__text:0000000101287C64                 STR             X21, [SP,#0xE0+var_C0]\n__text:0000000101287C68                 ADRP            X8, #classRef_MMServiceCenter@PAGE\n__text:0000000101287C6C                 LDR             X0, [X8,#classRef_MMServiceCenter@PAGEOFF]\n__text:0000000101287C70                 ADRP            X8, #selRef_defaultCenter@PAGE\n__text:0000000101287C74                 LDR             X1, [X8,#selRef_defaultCenter@PAGEOFF]\n__text:0000000101287C78                 STR             X1, [SP,#0xE0+var_B8]\n__text:0000000101287C7C                 BL              _objc_msgSend\n__text:0000000101287C80                 MOV             X29, X29\n__text:0000000101287C84                 BL              _objc_retainAutoreleasedReturnValue\n__text:0000000101287C88                 MOV             X19, X0\n__text:0000000101287C8C                 ADRP            X8, #classRef_WCFacade@PAGE\n__text:0000000101287C90                 LDR             X0, [X8,#classRef_WCFacade@PAGEOFF]\n__text:0000000101287C94                 ADRP            X8, #selRef_class@PAGE\n__text:0000000101287C98                 LDR             X1, [X8,#selRef_class@PAGEOFF]\n__text:0000000101287C9C                 STR             X1, [SP,#0xE0+var_B0]\n__text:0000000101287CA0                 BL              _objc_msgSend\n__text:0000000101287CA4                 MOV             X2, X0\n__text:0000000101287CA8                 ADRP            X8, #selRef_getService_@PAGE\n__text:0000000101287CAC                 LDR             X1, [X8,#selRef_getService_@PAGEOFF]\n__text:0000000101287CB0                 STR             X1, [SP,#0xE0+var_A0]\n__text:0000000101287CB4                 MOV             X0, X19\n__text:0000000101287CB8                 BL              _objc_msgSend\n__text:0000000101287CBC                 MOV             X29, X29\n__text:0000000101287CC0                 BL              _objc_retainAutoreleasedReturnValue\n__text:0000000101287CC4                 MOV             X20, X0\n__text:0000000101287CC8                 ADRP            X8, #selRef_getTimelineDataItemOfIndex_@PAGE\n__text:0000000101287CCC                 LDR             X1, [X8,#selRef_getTimelineDataItemOfIndex_@PAGEOFF]\n__text:0000000101287CD0                 STR             X1, [SP,#0xE0+var_C8]\n__text:0000000101287CD4                 MOV             X2, X21\n__text:0000000101287CD8                 BL              _objc_msgSend\n__text:0000000101287CDC                 MOV             X29, X29\n__text:0000000101287CE0                 BL              _objc_retainAutoreleasedReturnValue\n__text:0000000101287CE4                 MOV             X21, X0\n__text:0000000101287CE8                 MOV             X0, X20\n......\n```\n\n`selRef_getTimelineDataItemOfIndex_ `传入的参数是x2，可以看到传值给x2的x21是函数`selRef_calcDataItemIndex_ `的返回值，是一个unsigned long数据类型。继续分析，`selRef_getTimelineDataItemOfIndex_ `函数的调用者是上一步`selRef_getService_ `的返回值，经过断点分析发现是一个`WCFacade`对象。整理一下`selRef_getTimelineDataItemOfIndex_ `的调用：  \n**调用者是`selRef_getService_ `的返回值；参数是`selRef_calcDataItemIndex_ `的返回值**  \n下面把目光转向那两个函数，用相同的原理分析它们各自怎么实现调用  \n1.\t先看`selRef_getService_`：  \n在0x101287CB4这个位置可以发现，这个函数的调用者是从通过x19 MOV的，打印x19发现是一个`MMServiceCenter`对象，往上找x19是在0x101287C88这个位置赋值的，结果很清晰x19是`[MMServiceCenter defaultCenter]`的返回值。   \n在0x101287CA4位置可以找到传入的参数x2，往上分析可以看出来它的参数是`[WCFacade class]`的返回值。  \n2.\t接着找`selRef_calcDataItemIndex_ `：  \n在0x101287C58的位置找到它的调用者x0，x0通过x22赋值，继续向上寻找，发现在最上面0x101287BF0的位置，x22是x0赋值的，一开始的x0就是`WCTimeLineViewController`自身。  \n在0x101287C4C位置发现传入的参数来自x2,x2是通过上一步`selRef_section`函数的返回值x0赋值的，在0x101287C30位置可以发现`selRef_section`函数的调用者是x20赋值的，如下图所示，最终找到`selRef_section`的调用者是x3  \n![selRef_section函数的调用者](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-selRef_section%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%80%85.png)  \nx3就是函数` WCTimeLineViewController - (void)genNormalCell:(id) indexPath:(id)`的第二个参数indexPath,，所以`selRef_calcDataItemIndex_ `的参数是`[IndexPath section]`。  \n对上面的分析结果做个梳理：  \n因此`getTimelineDataItemOfIndex:`的调用者可以通过\n\n```\n[[MMServiceCenter defaultCenter] getService:[WCFacade class]]\n```\n\n来获得,它的参数可以通过下面的函数获取\n\n```OC\n[WCTimeLineViewController calcDataItemIndex:[indexPath section]]\n```\n\n总感觉还少点什么？indexPath我们还没拿到呢！下一步就是拿到indexPath,这个就比较简单了，因为我们位于`[WCContentItemViewTemplateNewSight onLongTouch]`中，所以可以通过`[self nextResponder]`依次拿到MMTableViewCell、MMTableView和WCTimeLineViewController，再通过`[MMTableView indexPathForCell:MMTableViewCell]`拿到indexPath。  \n做完这些，已经拿到WCDataItem对象，接下来的重点要放在WCDataItem上，最终要获取我们要的小视频。到这个类的头文件中找线索，因为视频是下载完成后才能播放的，所以这里应该拿到了视频的路径，所以要注意url和path相关的属性或方法，然后找到下面这几个嫌疑对象\n\n```\n@property(retain, nonatomic) NSString *sourceUrl2; \n@property(retain, nonatomic) NSString *sourceUrl; \n- (id)descriptionForKeyPaths;\n- (id)keyPaths;\n```\n\n回到LLDB中，用断点打印这些值，看看有什么。\n\n```\n(lldb) po [$x0 keyPaths]\n<__NSArrayI 0x15f74e9d0>(\n\ttid,\n\tusername,\n\tcreatetime,\n\tcommentUsers,\n\tcontentObj\n)\n(lldb) po [$x0 descriptionForKeyPaths]\nClass name: WCDataItem, addr: 0x15f5f03b0\ntid: 12393001887435993280\nusername: wxid_z8twcz4o18fg12\ncreatetime: 1477360950\ncommentUsers: (\n)\ncontentObj: <WCContentItem: 0x15f57d000>\n(lldb) po [$x0 sourceUrl]\n nil\n(lldb) po [$x0 sourceUrl2]\n nil\n```\n\n并没有什么有价值的线索，不过注意到WCDataItem里面有一个WCContentItem，看来只能从这儿入手了，去看一下头文件吧！\n\n```\n@property(retain, nonatomic) NSString *linkUrl; \n@property(retain, nonatomic) NSString *linkUrl2; \n@property(retain, nonatomic) NSMutableArray *mediaList;\n```\n\n在LLDB打印出来\n\n```\n(lldb) po [[$x0 valueForKey:@\"contentObj\"] linkUrl]\nhttps://support.weixin.qq.com/cgi-bin/mmsupport-bin/readtemplate?t=page/common_page__upgrade&v=1\n(lldb) po [[$x0 valueForKey:@\"contentObj\"] linkUrl2]\n nil\n(lldb) po [[$x0 valueForKey:@\"contentObj\"] mediaList]\n<__NSArrayM 0x15f985e10>(\n<WCMediaItem: 0x15dfebdf0>\n)\n```\n\nmediaList数组里面有一个WCMediaItem对象，Media一般用来表示视频和音频，大胆猜测就是它了！赶紧找到头文件搜索一遍。\n\n```\n@property(retain, nonatomic) WCUrl *dataUrl;\n- (id)pathForData;\n- (id)pathForSightData;\n- (id)pathForTempAttachVideoData;\n- (id)videoStreamForData;\n```\n上面这些属性和方法中`pathForSightData`是最有可能拿到小视频路径的，继续验证\n\n```OC\n(lldb) po [[[[$x0 valueForKey:@\"contentObj\"] mediaList] lastObject] dataUrl]\ntype[1], url[http://vweixinf.tc.qq.com/102/20202/snsvideodownload?filekey=30270201010420301e020166040253480410d14adcddf086f4e131d11a5b1cca1bdf0203039fa00400&bizid=1023&hy=SH&fileparam=302c0201010425302302040fde55e20204580ebd3602024eea02031e8d7d02030f42400204d970370a0201000400], enckey[0], encIdx[-1], token[]\n(lldb) po [[[[$x0 valueForKey:@\"contentObj\"] mediaList] lastObject] pathForData]\n/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45\n(lldb) po [[[[$x0 valueForKey:@\"contentObj\"] mediaList] lastObject] pathForSightData]\n/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45.mp4\n(lldb) po [[[[$x0 valueForKey:@\"contentObj\"] mediaList] lastObject] pathForAttachVideoData]\n nil\n(lldb) po [[[[$x0 valueForKey:@\"contentObj\"] mediaList] lastObject] videoStreamForData]\n nil\n```\n\n拿到小视频的网络url和本地路径了！这里可以用iFunBox或者scp从沙盒拷贝这个文件看看是不是这个cell应该播放的小视频。\n\n```OC\nLeonLei-MBP:~ gaoshilei$ scp root@192.168.0.115:/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45.mp4 Desktop/\n8fb0cdd77208de5b56169fb3458b45.mp4                100%  232KB 231.9KB/s   00:00    \n```\n\n用QuickTime打开发现果然是我们要寻找的小视频。再验证一下url是否正确，把上面打印的dataUrl在浏览器中打开，发现也是这个小视频。分析这个类可以得出下面的结论：  \n\n- **dataUrl：**小视频的网络url\n- **pathForData：**小视频的本地路径\n- **pathForSightData：**小视频的本地路径（不带后缀）\n\n至此小视频的路径和取得方式分析已经完成，要实现转发还要继续分析微信的朋友圈发布。\n\n##\t 二、实现转发功能\n###\t1.“走进死胡同”\n>\t这节是我在找小视频转发功能时走的弯路，扒到最后并没有找到实现方法，不过也提供了一些逆向中常用的思路和方法，不想看的可以跳到第二节。  \n\n####\t（1）找到小视频拍摄完成调用的方法名称\n打开小视频的拍摄界面，用cycript注入，我们要找到发布小视频的方法是哪个，然后查看当前的窗口有哪些window（因为小视频的拍摄并不是在UIApplication的keyWindow中进行的）\n\n```OC\ncy# [UIApp windows].toString()\n(\n    \"<iConsoleWindow: 0x125f75e20; baseClass = UIWindow; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = <NSArray: 0x125f77b70>; layer = <UIWindowLayer: 0x125df4810>>\",\n    \"<SvrErrorTipWindow: 0x127414d40; baseClass = UIWindow; frame = (0 64; 320 45); hidden = YES; gestureRecognizers = <NSArray: 0x12740d930>; layer = <UIWindowLayer: 0x1274030b0>>\",\n    \"<MMUIWindow: 0x127796440; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = <NSArray: 0x1278083c0>; layer = <UIWindowLayer: 0x127796750>>\",\n    \"<UITextEffectsWindow: 0x1270e0d40; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = <UIWindowLayer: 0x1270b4ba0>>\",\n    \"<NewYearActionSheet: 0x127797e10; baseClass = UIWindow; frame = (0 0; 320 568); hidden = YES; userInteractionEnabled = NO; layer = <UIWindowLayer: 0x1277d5490>>\"\n)\n```\n\n发现当前页面一共有5个window，其中MMUIWindow是小视频拍摄所在的window，打印它的UI树状结构\n\n```OC\ncy# [#0x127796440 recursiveDescription]\n```\n\n打印结果比较长，不贴了。找到这个按钮是拍摄小视频的按钮\n\n```OC\n   |    |    |    |    |    | <UIButton: 0x1277a9d70; frame = (89.5 368.827; 141 141); opaque = NO; gestureRecognizers = <NSArray: 0x1277aaeb0>; layer = <CALayer: 0x1277a9600>>\n   |    |    |    |    |    |    | <UIView: 0x1277aa0a0; frame = (0 0; 141 141); userInteractionEnabled = NO; tag = 252707333; layer = <CALayer: 0x1277aa210>>\n   |    |    |    |    |    |    |    | <UIImageView: 0x1277aa2e0; frame = (0 0; 141 141); opaque = NO; userInteractionEnabled = NO; layer = <CALayer: 0x1277aa490>>\n```\n\n然后执行\n\n```OC\ncy# [#0x1277a9d70 setHidden:YES]\n```\n\n发现拍摄的按钮消失了，验证了我的猜想。寻找按钮的响应事件，可以通过target来寻找\n\n```OC\ncy# [#0x1277a9d70 allTargets]\n[NSSet setWithArray:@[#\"<MainFrameSightViewController: 0x1269a4600>\"]]]\ncy# [#0x1277a9d70 allControlEvents]\n193\ncy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:193]\nnull\n```\n\n发现按钮并没有对应的action，这就奇怪了！UIButton必须要有target和action，不然这个Button不能响应事件。我们试试其他的ControlEvent\n\n```OC\ncy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchDown]\n@[\"btnPress\"]\ncy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchUpOutside]\n@[\"btnRelease\"]\ncy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchUpInside]\n@[\"btnRelease\"]\n```\n\n结果发现这三个ContrlEvent有对应的action，我们再看看这三个枚举的值\n\n```OC\ntypedef enum UIControlEvents : NSUInteger {\n    UIControlEventTouchDown = 1 <<  0,\n    UIControlEventTouchDownRepeat = 1 <<  1,\n    UIControlEventTouchDragInside = 1 <<  2,\n    UIControlEventTouchDragOutside = 1 <<  3,\n    UIControlEventTouchDragEnter = 1 <<  4,\n    UIControlEventTouchDragExit = 1 <<  5,\n    UIControlEventTouchUpInside = 1 <<  6,\n    UIControlEventTouchUpOutside = 1 <<  7,\n    UIControlEventTouchCancel = 1 <<  8,\n\t......\n} UIControlEvents;\n```\n\n可以看出来UIControlEventTouchDown对应1，UIControlEventTouchUpInside对应128，UIControlEventTouchUpOutside对应64，三者相加正好193！原来调用`[#0x1277a9d70 allControlEvents]`的时候返回的应该是枚举，有多个枚举则把它们的值相加，是不是略坑？我也是这样觉得的！刚才我们把三种ControlEvent对应的action都打印出来了，继续LLDB+IDA进行动态分析。\n####\t（2）找到小视频拍摄完成跳转到发布界面的方法  \n因为要找到小视频发布的方法，所以对应的`btnPress`函数我们并不关心，把重点放在`btnRelease`上面，拍摄按钮松开后就会调用的方法。在IDA中找到这个方法\n![MainFrameSightViewController - (void)btnRelease](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-btnRelease.png)  \n找到之后下个断点\n\n```OC\n(lldb) br s -a 0xac000+0x10209369C\nBreakpoint 4: where = WeChat`___lldb_unnamed_symbol108894$$WeChat + 32, address = 0x000000010213f69c\nProcess 3813 stopped\n* thread #1: tid = 0xf1ef0, 0x000000010213f69c WeChat`___lldb_unnamed_symbol108894$$WeChat + 32, queue = 'com.apple.main-thread', stop reason = breakpoint 4.1\n    frame #0: 0x000000010213f69c WeChat`___lldb_unnamed_symbol108894$$WeChat + 32\nWeChat`___lldb_unnamed_symbol108894$$WeChat:\n->  0x10213f69c <+32>: bl     0x1028d0b60               ; symbol stub for: objc_msgSend\n    0x10213f6a0 <+36>: cmp    w0, #2                    ; =2 \n    0x10213f6a4 <+40>: b.ne   0x10213f6dc               ; <+96>\n    0x10213f6a8 <+44>: adrp   x8, 5489\n```\n\n用手机拍摄小视频然后松开，触发了断点，说明我们的猜想是正确的。继续分析发现代码是从上图的右边走的，看了一下没有什么方法是跳转到发布视频的，不过仔细看一下有一个block，是系统的延时block，位置在0x102093760。然后我们跟着断点进去，在0x1028255A0跳转到x16所存的地址\n\n```OC\n(lldb) si\nProcess 3873 stopped\n* thread #1: tid = 0xf62c4, 0x00000001028d9598 WeChat`dispatch_after, queue = 'com.apple.main-thread', stop reason = instruction step into\n    frame #0: 0x00000001028d9598 WeChat`dispatch_after\nWeChat`dispatch_after:\n->  0x1028d9598 <+0>: adrp   x16, 1655\n    0x1028d959c <+4>: ldr    x16, [x16, #1056]\n    0x1028d95a0 <+8>: br     x16\n\nWeChat`dispatch_apply:\n    0x1028d95a4 <+0>: adrp   x16, 1655\n(lldb) po $x2\n<__NSStackBlock__: 0x16fd49f88>\n```\n\n发现传入的参数x2是一个block，我们再回顾一下dispatch_after函数\n\n```OC\nvoid dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);\n```\n\n这个函数有三个参数，分别是dispatch_time_t、dispatch_queue_t、dispatch_block_t，那这里打印的x2就是要传入的block，所以我们猜测拍摄完小视频会有一个延时，然后执行刚才传入的block，所以x2中肯定有其他方法调用，下一步就是要知道这个block的位置。\n\n```OC\n(lldb) memory read --size 8 --format x 0x16fd49f88\n0x16fd49f88: 0x000000019f8fd218 0x00000000c2000000\n0x16fd49f98: 0x000000010214777c 0x0000000102fb0e60\n0x16fd49fa8: 0x000000015da32600 0x000000015ea1a430\n0x16fd49fb8: 0x000000015cf5fee0 0x000000016fd49ff0\n```\n\n0x000000010214777c就是block所在的位置，当然要减掉当前WeChat的ASLR偏移，最终在IDA中的地址为0x10209377C，突然发现这就是`btnRelease`的子程序sub_10209377C。这个子程序非常简单，只有一个方法`selRef_logicCheckState_`有可能是我们的目标。先看看这个方法是谁调用的\n\n```OC\n(lldb) br s -a 0xb4000+0x1020937BC\n......\nProcess 3873 stopped\n* thread #1: tid = 0xf62c4, 0x00000001021477bc WeChat`___lldb_unnamed_symbol108895$$WeChat + 64, queue = 'com.apple.main-thread', stop reason = breakpoint 3.1\n    frame #0: 0x00000001021477bc WeChat`___lldb_unnamed_symbol108895$$WeChat + 64\nWeChat`___lldb_unnamed_symbol108895$$WeChat:\n->  0x1021477bc <+64>: adrp   x8, 5489\n    0x1021477c0 <+68>: ldr    x1, [x8, #1552]\n    0x1021477c4 <+72>: orr    w2, wzr, #0x1\n    0x1021477c8 <+76>: ldp    x29, x30, [sp, #16]\n(lldb) po $x0\n<MainFrameSightViewController: 0x15d1f0c00>\n```\n发现还是MainFrameSightViewController这个对象调用的，那`selRef_logicCheckState_ `肯定也在这个类的头文件中，寻找一下果然发现了  \n\n```OC\n- (void)logicCheckState:(int)arg1;\n```\n\n在IDA左侧窗口中寻找[MainFrameSightViewController logicCheckState:]，发现这个方法超级复杂，逻辑太多了，不着急慢慢捋。\n在0x102094D6C位置我们发现一个switch jump，思路就很清晰了，我们只要找到小视频拍摄完成的这条线往下看就行了，LLDB来帮忙看看走的那条线。在0x102094D6C位置下个断点，这个断点在拍摄小视频的时候会多次触发，可以在拍摄之前把断点dis掉，拍摄松手之前再启用断点，打印此时的x8值  \n\n```OC\n(lldb) p/x $x8\n(unsigned long) $38 = 0x0000000102174e10\n```\n\nx8是一个指针，它指向的地址是0x102174e10，用这个地址减去当前ASLR的偏移就可以找到在IDA中的基地址，发现是0x102094E10，拍摄完成的逻辑处理这条线找到了，一直走到0x102094E24位置之后跳转0x1020951C4，这个分支的内容较少，里面有三个函数  \n\n```OC\nloc_1020951C4\nADRP            X8, #selRef_hideTips@PAGE\nLDR             X1, [X8,#selRef_hideTips@PAGEOFF]\nMOV             X0, X19\nBL              _objc_msgSend\nADRP            X8, #selRef_finishWriter@PAGE\nLDR             X1, [X8,#selRef_finishWriter@PAGEOFF]\nMOV             X0, X19\nBL              _objc_msgSend\nADRP            X8, #selRef_turnCancelBtnForFinishRecording@PAGE\nLDR             X1, [X8,#selRef_turnCancelBtnForFinishRecording@PAGEOFF]\nMOV             X0, X19\nBL              _objc_msgSend\nB               loc_102095288\n```\n\n其中`selRef_finishWriter`和`selRef_turnCancelBtnForFinishRecording`需要重点关注，这两个方法看上去都是小视频录制结束的意思，线索极有可能就在这两个函数中。通过查看调用者发现这两个方法都属于MainFrameSightViewController，继续在IDA中查看这两个方法。在`selRef_finishWriter `中靠近末尾0x102094248的位置发现一个方法名叫做`f_switchToSendingPanel`，下个断点，然后拍摄视频，发现这个方法并没有被触发。应该不是通过这个方法调用发布界面的，继续回到`selRef_finishWriter `方法中；在0x1020941DC的位置调用方法`selRef_stopRecording`，打印它的调用者发现这个方法属于`SightFacade`，继续在IDA中寻找这个方法的实现。在这个方法的0x101F9BED4位置又调用了`selRef_stopRecord`，同样打印调用者发现这个方法属于SightCaptureLogicF4，有点像剥洋葱，继续在寻找这个方法的实现。在这个方法内部0x101A98778位置又调用了`selRef_finishWriting`，同样的原理找到这个方法是属于SightMovieWriter。已经剥了3层了，继续往下：  \n在`SightMovieWriter - (void)finishWriting`中的0x10261D004位置分了两条线，这个位置下个断点，然后拍摄完小视频触发断点，打印x19的值  \n\n```OC\n(lldb) po $x19\n<OS_dispatch_queue: CAPTURE.CALLBACK[0x13610bcd0] = { xrefcnt = 0x4, refcnt = 0x4, suspend_cnt = 0x0, locked = 1, target = com.apple.root.default-qos.overcommit[0x1a0aa3700], width = 0x0, running = 0x0, barrier = 1 }>\n```\n\n所以代码不会跳转到loc_10261D054而是走的左侧，在左侧的代码中发现启用了一个block，这个block是子程序sub_10261D0AC，地址为0x10261D0AC，找到这个地址，结构如下图所示：\n![sub_10261D0AC](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91sub_10261D0AC.png)  \n可以看出来主要分两条线，我们在第一个方框的末尾也就是0x10261D108位置下个断点，等拍摄完毕触发断点之后打印x0的值为1，这里的汇编代码为  \n\n```OC\n__text:000000010261D104                 CMP             X0, #2\n__text:000000010261D108                 B.EQ            loc_10261D234\n```\n\nB.EQ是在上一步的结果为0才会跳转到loc_10261D234，但是这里的结果是不为0的，将x0的值改为2让上一步的结果为0  \n\n```OC\n(lldb) po $x0\n1\n(lldb) register write $x0 2\n(lldb) po $x0\n2\n```\n\n此时放开断点，等待跳转到小视频发布界面，结果是一直卡在这个界面没有任何反应，所以猜测实现跳转的逻辑应该在右边的那条线，继续顺着右边的线寻找：\n在右侧0x10261D3AC位置发现调用了下面的这个方法  \n\n```OC  \n- (void)finishWritingWithCompletionHandler:(void (^)(void))handler;\n```\n\n这个方法是系统提供的AVAssetWriter里面的方法，在视频写入完成之后要做的操作，这个里是要传入一个block的，因为只有一个参数所以对应的变量是x2，打印x2的值\n\n```oc\n(lldb) po $x2\n<__NSStackBlock__: 0x16e086c78>\n(lldb) memory read --size 8 --format x 0x16e086c78\n0x16e086c78: 0x00000001a0aa5218 0x00000000c2000000\n0x16e086c88: 0x00000001026d94b0 0x0000000102fc98c0\n0x16e086c98: 0x0000000136229fd0 0x000000016e086d00\n0x16e086ca8: 0x00000001997f5318 0xfffffffec9e882ff\n```\n\n并且通过栈内存找到block位置为0x10261D4B0（需要减去ASLR的偏移）\n\n```oc\nsub_10261D4B0\nvar_20= -0x20\nvar_10= -0x10\nSTP             X20, X19, [SP,#var_20]!\nSTP             X29, X30, [SP,#0x20+var_10]\nADD             X29, SP, #0x20+var_10\nMOV             X19, X0\nLDR             X0, [X19,#0x20]\nADRP            X8, #selRef_stopAmr@PAGE\nLDR             X1, [X8,#selRef_stopAmr@PAGEOFF]\nBL              _objc_msgSend\nLDR             X0, [X19,#0x20]\nADRP            X8, #selRef_compressAudio@PAGE\nLDR             X1, [X8,#selRef_compressAudio@PAGEOFF]\nLDP             X29, X30, [SP,#0x20+var_10]\nLDP             X20, X19, [SP+0x20+var_20],#0x20\nB               _objc_msgSend\n; End of function sub_10261D4B0\n```\n\n只调用了两个方法，一个是`selRef_stopAmr`停止amr（一种音频格式），另一个是`selRef_compressAudio`压缩音频，拍摄完成的下一步操作应该不会放在这两个方法里面，找了这么久也没有头绪，这个路看来走不通了，不要钻牛角尖，战略性撤退寻找其他入口。  \n**逆向的乐趣就是一直寻找真相的路上，能体会到成功的乐趣，也有可能方向错了离真相反而越来越远，不要气馁调整方向继续前进！**\n   \n###\t2.“另辟蹊径”\n>（由于微信在后台偷偷升级了，下面的内容都是微信6.3.30版本的ASLR，上面的分析基于6.3.28版本）\n\n注意到在点击朋友圈右上角的相机按钮底部会弹出一个Sheet，第一个就是Sight小视频，从这里入手，用cycript查看Sight按钮对应的事件是哪个  \n\n```oc\niPhone-5S:~ root# cycript -p \"WeChat\"\ncy# [UIApp windows].toString()\n`(\n    \"<iConsoleWindow: 0x14d6ccc00; baseClass = UIWindow; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = <NSArray: 0x14d7df110>; layer = <UIWindowLayer: 0x14d7d6f60>>\",\n    \"<SvrErrorTipWindow: 0x14eaa5800; baseClass = UIWindow; frame = (0 0; 320 45); hidden = YES; gestureRecognizers = <NSArray: 0x14e9e8950>; layer = <UIWindowLayer: 0x14e9e6510>>\",\n    \"<UITextEffectsWindow: 0x14ec38ba0; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = <UIWindowLayer: 0x14ec39360>>\",\n    \"<UITextEffectsWindow: 0x14e9c67a0; frame = (0 0; 320 568); layer = <UIWindowLayer: 0x14d683ff0>>\",\n    \"<UIRemoteKeyboardWindow: 0x14f226e40; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = <UIWindowLayer: 0x14d6f4de0>>\",\n    \"<NewYearActionSheet: 0x14f1704a0; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = <NSArray: 0x14ef9bf90>; layer = <UIWindowLayer: 0x14ef61a20>>\"\n)`\ncy# [#0x14f1704a0 recursiveDescription].toString()\n```\n\n底部的Sheet是NewYearActionSheet，然后打印NewYearActionSheet的UI树状结构图（比较长不贴了）。然后找到Sight对应的UIButton是0x14f36d470   \n\n```oc\ncy# [#0x14f36d470 allTargets]\n[NSSet setWithArray:@[#\"<NewYearActionSheet: 0x14f1704a0; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = <NSArray: 0x14ef9bf90>; layer = <UIWindowLayer: 0x14ef61a20>>\"]]]\ncy# [#0x14f36d470 allControlEvents]\n64\ncy# [#0x14f36d470 actionsForTarget:#0x14f1704a0 forControlEvent:64]\n@[\"OnDefaultButtonTapped:\"]\n```\n\n通过UIControl的`actionsForTarget:forControlEvent:`方法可以找到按钮绑定的事件，Sight按钮的触发方法为`OnDefaultButtonTapped:`，回到IDA中在NewYearActionSheet中找到这个方法们继续往下分析只有这个方法`selRef_dismissWithClickedButtonIndex_animated`，通过打印它的调用者发现还是NewYearActionSheet，继续点进去找到`newYearActionSheet_clickedButtonAtIndex`方法，看样子不是NewYearActionSheet自己的，打印调用者x0发现它属于类WCTimeLineViewController。跟着断点走下去在0x1012B78CC位置调用了方法`#selRef_showSightWindowForMomentWithMask_byViewController_scene`\n通过观察发现这个方法的调用者是0x1012B78AC这个位置的返回值x0，这是一个类SightFacade，猜测这个方法在SightFacade里面，去头文件里找一下果然发现这个方法  \n\n```oc\n- (void)showSightWindowForMomentWithMask:(id)arg1 byViewController:(id)arg2 scene:(int)arg3;\n```\n\n这个方法应该就是跳转到小视频界面的方法了。下面分别打印它的参数  \n\n```oc\n(lldb) po $x2\n<UIImage: 0x14f046660>, {320, 568}\n(lldb) po $x3\n<WCTimeLineViewController: 0x14e214800>\n(lldb) po $x4\n2\n(lldb) po $x0\n<SightFacade: 0x14f124b40>\n```\n\n其中x2、x3、x4分别对应三个参数，x0是调用者，跳到这个方法内部查看怎么实现的。发现在这个方法中进行了小视频拍摄界面的初始化工作，首先初始化一个MainFrameSightViewController，再创建一个UINavigationController将MainFrameSightViewController放进去，接下来初始化一个MMWindowController调用  \n\n```oc\n- (id)initWithViewController:(id)arg1 windowLevel:(int)arg2;\n```\n\n方法将UINavigationController放了进去，完成小视频拍摄界面的所有UI创建工作。\n拍摄完成之后进入发布界面，此时用cycript找到当前的Controller是SightMomentEditViewController，由此萌生一个想法，跳过前面的拍摄界面直接进入发布界面不就可以了吗？我们自己创建一个SightMomentEditViewController然后放到UINavigationController里面，然后再将这个导航控制器放到MMWindowController里面。**（这里我已经写好tweak进行了验证，具体的tweak思路编写在后文有）**结果是的确可以弹出发布的界面，但是导航栏的NavgationBar遮住了原来的，整个界面是透明的，很难看，而且发布完成之后无法销毁整个MMWindowController，还是停留在发布界面。我们要的结果不是这个，不过确实有很大的收获，最起码可以直接调用发布界面了，小视频也能正常转发。我个人猜测，当前界面不能被销毁的原因是因为MMWindowController新建了一个window,它跟TimeLine所在的keyWindow不是同一个，SightMomentEditViewController的按钮触发的方法是没有办法销毁这个window的，所以有一个大胆的猜想，我直接在当前的WCTimeLineViewController上把SightMomentEditViewController展示出来不就可以了吗？  \n\n```oc\n[WCTimelineVC presentViewController:editSightVC animated:YES completion:^{\n}];\n```\n\n像这样展示岂不妙哉？不过通过观察SightMomentEditViewController的头文件，结合小视频发布时界面上的元素，推测创建这个控制器至少需要两个属性，一个是小视频的路径，另一个是小视频的缩略图，将这两个关键属性给了SightMomentEditViewController那么应该就可以正常展示了   \n\n```oc\nSightMomentEditViewController *editSightVC = [[%c(SightMomentEditViewController) alloc] init];\nNSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];\nUIImage *image = [[self valueForKey:@\"_sightView\"] getImage];\n[editSightVC setRealMoviePath:localPath];\n[editSightVC setMoviePath:localPath];\n[editSightVC setRealThumbImage:image];\n[editSightVC setThumbImage:image];\n[WCTimelineVC presentViewController:editSightVC animated:YES completion:^{\n}];\n```\n\n小视频的发布界面可以正常显示并且所有功能都可以正常使用，唯一的问题是返回按钮没有效果，并不能销毁SightMomentEditViewController。用cycript查看左侧按钮的actionEvent找到它的响应函数是`- (void)popSelf;`，点击左侧返回触发的是pop方法，但是这个控制器并不在navgationController里面，所以无效，我们要对这个方法进行重写  \n\n```oc\n- (void)popSelf\n{\n    [self dismissViewControllerAnimated:YES completion:^{\n\n    }];\n}\n```\n\n此时再点击返回按钮就可以正常退出了，此外，在WCContentItemViewTemplateNewSight中发现了一个方法叫做`- (void)sendSightToFriend;`，可以直接将小视频转发给好友，至此小视频转发的功能已经找到了。\n","source":"_posts/手把手教你逆向微信之朋友圈小视频转发（上）.md","raw":"---\ntitle: 手把手教你逆向微信之朋友圈小视频转发（上）\ndate: 2016-11-10\ncategories:\n- iOS逆向\ntags:\n- 微信\n- 汇编语言\n- IDA\n- 重签名  \npermalink: 手把手教你逆向微信之朋友圈小视频转发（上）  \n\n---\n#\t前言\n此文为逆向微信二进制文件，实现朋友圈小视频转发的教程，从最开始的汇编代码入手到最后重签名安装等操作，手把手教你玩转微信！学会之后再去逆向微信其他功能易如反掌。  \n本篇文章由于篇幅太长分成了两篇，**上篇**讲解的是逆向工作，也就是怎么找到相关的函数和方法实现，**下篇**讲解的是怎么在非越狱机重签名安装和越狱机tweak安装的详细过程。  \n**正文的第二部分还提供了微信自动抢红包、修改微信步数的代码，这些都可以照葫芦画瓢按照本文的套路一步步逆向找到，这里就不再赘述。**  \n在实践之前，需要准备好一部越狱的手机，然后将下文列出的所有工具安装好。IDA跟Reveal都是破解版，IDA的正版要2000多刀，对于这么牛逼的逆向工具确实物有所值，不过不是专门研究逆向的公司也没必要用正版的，下个Windows的破解版就好，Mac上暂时没找到。Mac上可以用hopper代替IDA，也是一款很牛逼的逆向工具。废话不多说，正式开始吧！\n\n<!-- more -->\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n#\t逆向微信朋友圈（上篇）\n## 一、获取朋友圈的小视频\n>\t注意：本文逆向的微信的二进制文件为6.3.28版本，如果是不同的微信版本，二进制文件中的基地址也不相同\n\n####\t本文涉及到的工具  \n1. [cycript](http://www.cycript.org) \n2. LLDB与debugserver（Xcode自带）\n3. OpenSSH\n4. IDA\n5. Reveal\n6. [theos](https://github.com/theos/theos)\n7. [CydiaSubstrate](http://www.cydiasubstrate.com)\n8. iOSOpenDev\n9. ideviceinstaller\n10. tcprelay（本地端口映射，USB连接SSH，不映射可通过WiFi连接） \n11. [dumpdecrypted](https://github.com/stefanesser/dumpdecrypted)\n12. [class-dump](http://stevenygard.com/projects/class-dump/) \n13. [iOS App Signer](https://github.com/DanTheMan827/ios-app-signer)\n14. 编译好的[yololib](https://github.com/gaoshilei/yololib)\n\n**逆向环境为MacOS\t+\tiPhone5S 9.1越狱机**  \n先用dumpdecrypted给微信砸壳（不会的请我写的看[这篇教程](http://www.gaoshilei.com/2016/08/08/dumpdecrypted给App砸壳/)），获得一个WeChat.decrypted文件，先把这个文件扔到IDA中分析（60MB左右的二进制文件，IDA差不多40分钟才能分析完），用class-dump导出所有头文件\n\n```\nLeonLei-MBP:~ gaoshilei$ class-dump -S -s -H /Users/gaoshilei/Desktop/reverse/binary_for_class-dump/WeChat.decrypted -o /Users/gaoshilei/Desktop/reverse/binary_for_class-dump/class-Header/WeChat\n```\n\n我滴个亲娘！一共有8000个头文件，微信果然工程量浩大！稳定一下情绪，理一理思路继续搞。要取得小视频的下载链接，找到播放视频的View，顺藤摸瓜就能找到小视频的URL。用Reveal查看小视频的播放窗口\n![Reveal](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91Reveal.png)  \n可以看出来WCContentItemViewTemplateNewSigh这个对象是小视频的播放窗口，它的subView有WCSightView，SightView、SightPlayerView，这几个类就是我们的切入点。\n保存视频到favorite的时候是长按视频弹出选项的，那么在WCContentItemViewTemplateNewSight这个类里面可能有手势相关的方法，去刚才导出的头文件中找线索。\n\n```\n- (void)onLongTouch;\n- (void)onLongPressedWCSight:(id)arg1;\n- (void)onLongPressedWCSightFullScreenWindow:(id)arg1;\n```\n\n这几个方法跟长按手势相关，再去IDA中找到这些函数，逐个查看。onLongPressedWCSight和onLongPressedWCSightFullScreenWindow都比较简单，onLongTouch比较长，而且发现了内部调用了方法Favorites_Add，因为长按视频的时候出来一个选项就是Favorites，并且我看到这个函数调用\n\n```\nADRP            X8, #selRef_sightVideoPath@PAGE\nLDR             X1, [X8,#selRef_sightVideoPath@PAGEOFF]\n```\n\n这里拿到了小视频的地址，可以推测这个函数跟收藏有关，下面打断点测试。\n\n```\n(lldb) im li -o -f\n[  0] 0x000000000003c000 /var/mobile/Containers/Bundle/Application/2F1D52EC-C57E-4F95-B715-EF04351232E8/WeChat.app/WeChat(0x000000010003c000)\n```\n\n可以看到WeChat的ASLR为0x3c000，在IDA查找到这三个函数的基地址，分别下断点\n\n```\n(lldb) br s -a 0x1020D3A10+0x3c000\nBreakpoint 1: where = WeChat`___lldb_unnamed_symbol110094$$WeChat + 28, address = 0x000000010210fa10\n(lldb) br s -a 0x1020D3370+0x3c000\nBreakpoint 2: where = WeChat`___lldb_unnamed_symbol110091$$WeChat + 8, address = 0x000000010210f370\n(lldb) br s -a 0x1020D33E4+0x3c000\nBreakpoint 3: where = WeChat`___lldb_unnamed_symbol110092$$WeChat + 12, address = 0x000000010210f3e4\n```\n\n回到微信里面长按小视频，看断点触发情况\n\n```\nProcess 3721 stopped\n* thread #1: tid = 0x658fc, 0x000000010210f370 WeChat`___lldb_unnamed_symbol110091$$WeChat + 8, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1\n    frame #0: 0x000000010210f370 WeChat`___lldb_unnamed_symbol110091$$WeChat + 8\nWeChat`___lldb_unnamed_symbol110091$$WeChat:\n->  0x10210f370 <+8>:  add    x29, sp, #16              ; =16 \n    0x10210f374 <+12>: mov    x19, x0\n    0x10210f378 <+16>: adrp   x8, 4968\n    0x10210f37c <+20>: ldr    x0, [x8, #744]\n(lldb) c\nProcess 3721 resuming\nProcess 3721 stopped\n* thread #1: tid = 0x658fc, 0x000000010210fa10 WeChat`___lldb_unnamed_symbol110094$$WeChat + 28, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n    frame #0: 0x000000010210fa10 WeChat`___lldb_unnamed_symbol110094$$WeChat + 28\nWeChat`___lldb_unnamed_symbol110094$$WeChat:\n->  0x10210fa10 <+28>: add    x29, sp, #96              ; =96 \n    0x10210fa14 <+32>: sub    sp, sp, #96               ; =96 \n    0x10210fa18 <+36>: mov    x19, x0\n    0x10210fa1c <+40>: adrp   x8, 4863\n……\n```\n\n发现断点2先被触发，接着触发断点1，后面断点2和1又各触发了1次，断点3一直很安静。可以排除onLongPressedWCSightFullScreenWindow与收藏小视频的联系。小视频的踪影就要在剩下的两个方法中寻找了。通过V找到C，顺藤摸瓜找到M屡试不爽！用cycript注入WeChat，拿到播放小视频的view所在的Controller。\n\n```\ncy# [#0x138c18030 nextResponder]\n#\"<WCTimeLineCellView: 0x138c34620; frame = (0 0; 319 249); tag = 1048577; layer = <CALayer: 0x138362ba0>>\"\ncy# [#0x138c34620 nextResponder]\n#\"<UITableViewCellContentView: 0x138223c70; frame = (0 0; 320 256); gestureRecognizers = <NSArray: 0x1384ec480>; layer = <CALayer: 0x138081dc0>>\"\ncy# [#0x138223c70 nextResponder]\n#\"<MMTableViewCell: 0x138c9f930; baseClass = UITableViewCell; frame = (0 307; 320 256); autoresize = W; layer = <CALayer: 0x1382dcd10>>\"\ncy# [#0x138c9f930 nextResponder]\n#\"<UITableViewWrapperView: 0x137b57800; frame = (0 0; 320 504); gestureRecognizers = <NSArray: 0x1383db660>; layer = <CALayer: 0x138af20c0>; contentOffset: {0, 0}; contentSize: {320, 504}>\"\ncy# [#0x137b57800 nextResponder]\n#\"<MMTableView: 0x137b8ae00; baseClass = UITableView; frame = (0 0; 320 568); gestureRecognizers = <NSArray: 0x138adb590>; layer = <CALayer: 0x138956890>; contentOffset: {0, 99.5}; contentSize: {320, 3193}>\"\ncy# [#0x137b8ae00 nextResponder]\n#\"<UIView: 0x138ade5c0; frame = (0 0; 320 568); autoresize = W+H; layer = <CALayer: 0x138ac9990>>\"\ncy# [#0x138ade5c0 nextResponder]\n#\"<WCTimeLineViewController: 0x1379eb000>\"\n```\n\n通过响应者链条找到\nWCContentItemViewTemplateNewSight所属的Controller为WCTimeLineViewController。在这个类的头文件中并没有发现有价值的线索，不过我们注意到小视频所在的view是属于MMTableVIewCell的（见上图Reveal分析图），这是每一个iOS最熟悉的TableView，cell的数据是通过UITableViewDataSource的代理方法`- tableView:cellForRowAtIndexPath:`赋值的，通过这个方法肯定能知道到M的影子。在IDA中找到`[WCTimeLineViewController tableView:cellForRowAtIndexPath:]`,定位到基地址0x10128B6B0位置：\n\n```\n__text:000000010128B6B0     ADRP     X8, #selRef_genNormalCell_indexPath_@PAGE\n```\n\n这里的函数是WCTimeLineViewController中生成cell的方法，除了这个方法在这个类中还有另外三个生成cell的方法：\n\n```\n- (void)genABTestTipCell:(id)arg1 indexPath:(id)arg2;\n- (void)genRedHeartCell:(id)arg1 indexPath:(id)arg2;\n- (void)genUploadFailCell:(id)arg1 indexPath:(id)arg2;\n```\n\n通过字面意思可以猜测出normal这个应该是生成小视频cell的方法。继续在IDA中寻找线索\n\n```\n__text:0000000101287CC8     ADRP     X8, #selRef_getTimelineDataItemOfIndex_@PAGE\n```\n\n在`genNormalCell:IndexPath:`方法中发现上面这个方法，可以大胆猜想这个方法是获取TimeLine（朋友圈）数据的方法，那小视频的数据肯定也是通过这个方法获取的，并且IDA可以看到这个方法中调用一个叫做`selRef_getTimelineDataItemOfIndex_`的方法，获取DataItem貌似就是cell的数据源啊！接下来用LLDB下断点验证猜想。\n通过IDA可以找到这个方法对应的基地址为：0x101287CE4，先打印正在运行WeChat的ASLR偏移\n\n```\nLeonLei-MBP:~ gaoshilei$ lldb\n(lldb) process connect connect://localhost:1234\n(lldb) im li -o -f \n[0] 0x0000000000050000 /var/mobile/Containers/Bundle/Application/2DCE8F30-9B6B-4652-901C-37EB1FF2A40D/WeChat.app/WeChat(0x0000000100050000)\n```\n\n所以我们下断点的位置是0x50000+0x101287CE4\n\n```\n(lldb) br s -a 0x50000+0x101287CE4\nBreakpoint 1: where = WeChat`___lldb_unnamed_symbol63721$$WeChat + 252, address = 0x00000001012d7ce4\n```\n\n打印x0的值\n\n```\n(lldb) po $x0\nClass name: WCDataItem, addr: 0x15f5f03b0\ntid: 12393001887435993280\nusername: wxid_z8twcz4o18fg12\ncreatetime: 1477360950\ncommentUsers: (\n)\ncontentObj: <WCContentItem: 0x15f57d000>\n\n```\n\n得到一个WCDataItem的对象，这里x0的值就是`selRef_getTimelineDataItemOfIndex_`执行完的返回值，然后把x0的值改掉\n\n```\n(lldb) register write $x0 0\n(lldb) c\n```\n\n此时会发现我们要刷新的那条小视频内容全部为空  \n![小视频内容为空](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91-%E8%BD%AC%E5%8F%91%E5%B0%8F%E8%A7%86%E9%A2%91%E4%B8%BA%E7%A9%BA.jpg)  \n到这里已经找到了小视频的源数据获取方法，问题是我们怎么拿到这个WCDataItem呢？继续看IDA分析函数的调用情况：  \n>\tWCTimeLineViewController - (void)genNormalCell:(id) indexPath:(id)  \n\n\n```\n__text:0000000101287BCC                 STP             X28, X27, [SP,#var_60]!\n__text:0000000101287BD0                 STP             X26, X25, [SP,#0x60+var_50]\n__text:0000000101287BD4                 STP             X24, X23, [SP,#0x60+var_40]\n__text:0000000101287BD8                 STP             X22, X21, [SP,#0x60+var_30]\n__text:0000000101287BDC                 STP             X20, X19, [SP,#0x60+var_20]\n__text:0000000101287BE0                 STP             X29, X30, [SP,#0x60+var_10]\n__text:0000000101287BE4                 ADD             X29, SP, #0x60+var_10\n__text:0000000101287BE8                 SUB             SP, SP, #0x80\n__text:0000000101287BEC                 MOV             X19, X3\n__text:0000000101287BF0                 MOV             X22, X0\n__text:0000000101287BF4                 MOV             W25, #0x100000\n__text:0000000101287BF8                 MOVK            W25, #1\n__text:0000000101287BFC                 MOV             X0, X2\n__text:0000000101287C00                 BL              _objc_retain\n__text:0000000101287C04                 MOV             X28, X0\n__text:0000000101287C08                 MOV             X0, X19\n__text:0000000101287C0C                 BL              _objc_retain\n__text:0000000101287C10                 MOV             X20, X0\n__text:0000000101287C14                 STR             X20, [SP,#0xE0+var_98]\n__text:0000000101287C18                 ADRP            X8, #selRef_row@PAGE\n__text:0000000101287C1C                 LDR             X1, [X8,#selRef_row@PAGEOFF]\n__text:0000000101287C20                 BL              _objc_msgSend\n__text:0000000101287C24                 MOV             X26, X0\n__text:0000000101287C28                 ADRP            X8, #selRef_section@PAGE\n__text:0000000101287C2C                 LDR             X19, [X8,#selRef_section@PAGEOFF]\n__text:0000000101287C30                 MOV             X0, X20\n__text:0000000101287C34                 MOV             X1, X19\n__text:0000000101287C38                 BL              _objc_msgSend\n__text:0000000101287C3C                 STR             X0, [SP,#0xE0+var_A8]\n__text:0000000101287C40                 MOV             X0, X20\n__text:0000000101287C44                 MOV             X1, X19\n__text:0000000101287C48                 BL              _objc_msgSend\n__text:0000000101287C4C                 MOV             X2, X0\n__text:0000000101287C50                 ADRP            X8, #selRef_calcDataItemIndex_@PAGE\n__text:0000000101287C54                 LDR             X1, [X8,#selRef_calcDataItemIndex_@PAGEOFF]\n__text:0000000101287C58                 MOV             X0, X22\n__text:0000000101287C5C                 BL              _objc_msgSend\n__text:0000000101287C60                 MOV             X21, X0\n__text:0000000101287C64                 STR             X21, [SP,#0xE0+var_C0]\n__text:0000000101287C68                 ADRP            X8, #classRef_MMServiceCenter@PAGE\n__text:0000000101287C6C                 LDR             X0, [X8,#classRef_MMServiceCenter@PAGEOFF]\n__text:0000000101287C70                 ADRP            X8, #selRef_defaultCenter@PAGE\n__text:0000000101287C74                 LDR             X1, [X8,#selRef_defaultCenter@PAGEOFF]\n__text:0000000101287C78                 STR             X1, [SP,#0xE0+var_B8]\n__text:0000000101287C7C                 BL              _objc_msgSend\n__text:0000000101287C80                 MOV             X29, X29\n__text:0000000101287C84                 BL              _objc_retainAutoreleasedReturnValue\n__text:0000000101287C88                 MOV             X19, X0\n__text:0000000101287C8C                 ADRP            X8, #classRef_WCFacade@PAGE\n__text:0000000101287C90                 LDR             X0, [X8,#classRef_WCFacade@PAGEOFF]\n__text:0000000101287C94                 ADRP            X8, #selRef_class@PAGE\n__text:0000000101287C98                 LDR             X1, [X8,#selRef_class@PAGEOFF]\n__text:0000000101287C9C                 STR             X1, [SP,#0xE0+var_B0]\n__text:0000000101287CA0                 BL              _objc_msgSend\n__text:0000000101287CA4                 MOV             X2, X0\n__text:0000000101287CA8                 ADRP            X8, #selRef_getService_@PAGE\n__text:0000000101287CAC                 LDR             X1, [X8,#selRef_getService_@PAGEOFF]\n__text:0000000101287CB0                 STR             X1, [SP,#0xE0+var_A0]\n__text:0000000101287CB4                 MOV             X0, X19\n__text:0000000101287CB8                 BL              _objc_msgSend\n__text:0000000101287CBC                 MOV             X29, X29\n__text:0000000101287CC0                 BL              _objc_retainAutoreleasedReturnValue\n__text:0000000101287CC4                 MOV             X20, X0\n__text:0000000101287CC8                 ADRP            X8, #selRef_getTimelineDataItemOfIndex_@PAGE\n__text:0000000101287CCC                 LDR             X1, [X8,#selRef_getTimelineDataItemOfIndex_@PAGEOFF]\n__text:0000000101287CD0                 STR             X1, [SP,#0xE0+var_C8]\n__text:0000000101287CD4                 MOV             X2, X21\n__text:0000000101287CD8                 BL              _objc_msgSend\n__text:0000000101287CDC                 MOV             X29, X29\n__text:0000000101287CE0                 BL              _objc_retainAutoreleasedReturnValue\n__text:0000000101287CE4                 MOV             X21, X0\n__text:0000000101287CE8                 MOV             X0, X20\n......\n```\n\n`selRef_getTimelineDataItemOfIndex_ `传入的参数是x2，可以看到传值给x2的x21是函数`selRef_calcDataItemIndex_ `的返回值，是一个unsigned long数据类型。继续分析，`selRef_getTimelineDataItemOfIndex_ `函数的调用者是上一步`selRef_getService_ `的返回值，经过断点分析发现是一个`WCFacade`对象。整理一下`selRef_getTimelineDataItemOfIndex_ `的调用：  \n**调用者是`selRef_getService_ `的返回值；参数是`selRef_calcDataItemIndex_ `的返回值**  \n下面把目光转向那两个函数，用相同的原理分析它们各自怎么实现调用  \n1.\t先看`selRef_getService_`：  \n在0x101287CB4这个位置可以发现，这个函数的调用者是从通过x19 MOV的，打印x19发现是一个`MMServiceCenter`对象，往上找x19是在0x101287C88这个位置赋值的，结果很清晰x19是`[MMServiceCenter defaultCenter]`的返回值。   \n在0x101287CA4位置可以找到传入的参数x2，往上分析可以看出来它的参数是`[WCFacade class]`的返回值。  \n2.\t接着找`selRef_calcDataItemIndex_ `：  \n在0x101287C58的位置找到它的调用者x0，x0通过x22赋值，继续向上寻找，发现在最上面0x101287BF0的位置，x22是x0赋值的，一开始的x0就是`WCTimeLineViewController`自身。  \n在0x101287C4C位置发现传入的参数来自x2,x2是通过上一步`selRef_section`函数的返回值x0赋值的，在0x101287C30位置可以发现`selRef_section`函数的调用者是x20赋值的，如下图所示，最终找到`selRef_section`的调用者是x3  \n![selRef_section函数的调用者](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-selRef_section%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%80%85.png)  \nx3就是函数` WCTimeLineViewController - (void)genNormalCell:(id) indexPath:(id)`的第二个参数indexPath,，所以`selRef_calcDataItemIndex_ `的参数是`[IndexPath section]`。  \n对上面的分析结果做个梳理：  \n因此`getTimelineDataItemOfIndex:`的调用者可以通过\n\n```\n[[MMServiceCenter defaultCenter] getService:[WCFacade class]]\n```\n\n来获得,它的参数可以通过下面的函数获取\n\n```OC\n[WCTimeLineViewController calcDataItemIndex:[indexPath section]]\n```\n\n总感觉还少点什么？indexPath我们还没拿到呢！下一步就是拿到indexPath,这个就比较简单了，因为我们位于`[WCContentItemViewTemplateNewSight onLongTouch]`中，所以可以通过`[self nextResponder]`依次拿到MMTableViewCell、MMTableView和WCTimeLineViewController，再通过`[MMTableView indexPathForCell:MMTableViewCell]`拿到indexPath。  \n做完这些，已经拿到WCDataItem对象，接下来的重点要放在WCDataItem上，最终要获取我们要的小视频。到这个类的头文件中找线索，因为视频是下载完成后才能播放的，所以这里应该拿到了视频的路径，所以要注意url和path相关的属性或方法，然后找到下面这几个嫌疑对象\n\n```\n@property(retain, nonatomic) NSString *sourceUrl2; \n@property(retain, nonatomic) NSString *sourceUrl; \n- (id)descriptionForKeyPaths;\n- (id)keyPaths;\n```\n\n回到LLDB中，用断点打印这些值，看看有什么。\n\n```\n(lldb) po [$x0 keyPaths]\n<__NSArrayI 0x15f74e9d0>(\n\ttid,\n\tusername,\n\tcreatetime,\n\tcommentUsers,\n\tcontentObj\n)\n(lldb) po [$x0 descriptionForKeyPaths]\nClass name: WCDataItem, addr: 0x15f5f03b0\ntid: 12393001887435993280\nusername: wxid_z8twcz4o18fg12\ncreatetime: 1477360950\ncommentUsers: (\n)\ncontentObj: <WCContentItem: 0x15f57d000>\n(lldb) po [$x0 sourceUrl]\n nil\n(lldb) po [$x0 sourceUrl2]\n nil\n```\n\n并没有什么有价值的线索，不过注意到WCDataItem里面有一个WCContentItem，看来只能从这儿入手了，去看一下头文件吧！\n\n```\n@property(retain, nonatomic) NSString *linkUrl; \n@property(retain, nonatomic) NSString *linkUrl2; \n@property(retain, nonatomic) NSMutableArray *mediaList;\n```\n\n在LLDB打印出来\n\n```\n(lldb) po [[$x0 valueForKey:@\"contentObj\"] linkUrl]\nhttps://support.weixin.qq.com/cgi-bin/mmsupport-bin/readtemplate?t=page/common_page__upgrade&v=1\n(lldb) po [[$x0 valueForKey:@\"contentObj\"] linkUrl2]\n nil\n(lldb) po [[$x0 valueForKey:@\"contentObj\"] mediaList]\n<__NSArrayM 0x15f985e10>(\n<WCMediaItem: 0x15dfebdf0>\n)\n```\n\nmediaList数组里面有一个WCMediaItem对象，Media一般用来表示视频和音频，大胆猜测就是它了！赶紧找到头文件搜索一遍。\n\n```\n@property(retain, nonatomic) WCUrl *dataUrl;\n- (id)pathForData;\n- (id)pathForSightData;\n- (id)pathForTempAttachVideoData;\n- (id)videoStreamForData;\n```\n上面这些属性和方法中`pathForSightData`是最有可能拿到小视频路径的，继续验证\n\n```OC\n(lldb) po [[[[$x0 valueForKey:@\"contentObj\"] mediaList] lastObject] dataUrl]\ntype[1], url[http://vweixinf.tc.qq.com/102/20202/snsvideodownload?filekey=30270201010420301e020166040253480410d14adcddf086f4e131d11a5b1cca1bdf0203039fa00400&bizid=1023&hy=SH&fileparam=302c0201010425302302040fde55e20204580ebd3602024eea02031e8d7d02030f42400204d970370a0201000400], enckey[0], encIdx[-1], token[]\n(lldb) po [[[[$x0 valueForKey:@\"contentObj\"] mediaList] lastObject] pathForData]\n/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45\n(lldb) po [[[[$x0 valueForKey:@\"contentObj\"] mediaList] lastObject] pathForSightData]\n/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45.mp4\n(lldb) po [[[[$x0 valueForKey:@\"contentObj\"] mediaList] lastObject] pathForAttachVideoData]\n nil\n(lldb) po [[[[$x0 valueForKey:@\"contentObj\"] mediaList] lastObject] videoStreamForData]\n nil\n```\n\n拿到小视频的网络url和本地路径了！这里可以用iFunBox或者scp从沙盒拷贝这个文件看看是不是这个cell应该播放的小视频。\n\n```OC\nLeonLei-MBP:~ gaoshilei$ scp root@192.168.0.115:/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45.mp4 Desktop/\n8fb0cdd77208de5b56169fb3458b45.mp4                100%  232KB 231.9KB/s   00:00    \n```\n\n用QuickTime打开发现果然是我们要寻找的小视频。再验证一下url是否正确，把上面打印的dataUrl在浏览器中打开，发现也是这个小视频。分析这个类可以得出下面的结论：  \n\n- **dataUrl：**小视频的网络url\n- **pathForData：**小视频的本地路径\n- **pathForSightData：**小视频的本地路径（不带后缀）\n\n至此小视频的路径和取得方式分析已经完成，要实现转发还要继续分析微信的朋友圈发布。\n\n##\t 二、实现转发功能\n###\t1.“走进死胡同”\n>\t这节是我在找小视频转发功能时走的弯路，扒到最后并没有找到实现方法，不过也提供了一些逆向中常用的思路和方法，不想看的可以跳到第二节。  \n\n####\t（1）找到小视频拍摄完成调用的方法名称\n打开小视频的拍摄界面，用cycript注入，我们要找到发布小视频的方法是哪个，然后查看当前的窗口有哪些window（因为小视频的拍摄并不是在UIApplication的keyWindow中进行的）\n\n```OC\ncy# [UIApp windows].toString()\n(\n    \"<iConsoleWindow: 0x125f75e20; baseClass = UIWindow; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = <NSArray: 0x125f77b70>; layer = <UIWindowLayer: 0x125df4810>>\",\n    \"<SvrErrorTipWindow: 0x127414d40; baseClass = UIWindow; frame = (0 64; 320 45); hidden = YES; gestureRecognizers = <NSArray: 0x12740d930>; layer = <UIWindowLayer: 0x1274030b0>>\",\n    \"<MMUIWindow: 0x127796440; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = <NSArray: 0x1278083c0>; layer = <UIWindowLayer: 0x127796750>>\",\n    \"<UITextEffectsWindow: 0x1270e0d40; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = <UIWindowLayer: 0x1270b4ba0>>\",\n    \"<NewYearActionSheet: 0x127797e10; baseClass = UIWindow; frame = (0 0; 320 568); hidden = YES; userInteractionEnabled = NO; layer = <UIWindowLayer: 0x1277d5490>>\"\n)\n```\n\n发现当前页面一共有5个window，其中MMUIWindow是小视频拍摄所在的window，打印它的UI树状结构\n\n```OC\ncy# [#0x127796440 recursiveDescription]\n```\n\n打印结果比较长，不贴了。找到这个按钮是拍摄小视频的按钮\n\n```OC\n   |    |    |    |    |    | <UIButton: 0x1277a9d70; frame = (89.5 368.827; 141 141); opaque = NO; gestureRecognizers = <NSArray: 0x1277aaeb0>; layer = <CALayer: 0x1277a9600>>\n   |    |    |    |    |    |    | <UIView: 0x1277aa0a0; frame = (0 0; 141 141); userInteractionEnabled = NO; tag = 252707333; layer = <CALayer: 0x1277aa210>>\n   |    |    |    |    |    |    |    | <UIImageView: 0x1277aa2e0; frame = (0 0; 141 141); opaque = NO; userInteractionEnabled = NO; layer = <CALayer: 0x1277aa490>>\n```\n\n然后执行\n\n```OC\ncy# [#0x1277a9d70 setHidden:YES]\n```\n\n发现拍摄的按钮消失了，验证了我的猜想。寻找按钮的响应事件，可以通过target来寻找\n\n```OC\ncy# [#0x1277a9d70 allTargets]\n[NSSet setWithArray:@[#\"<MainFrameSightViewController: 0x1269a4600>\"]]]\ncy# [#0x1277a9d70 allControlEvents]\n193\ncy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:193]\nnull\n```\n\n发现按钮并没有对应的action，这就奇怪了！UIButton必须要有target和action，不然这个Button不能响应事件。我们试试其他的ControlEvent\n\n```OC\ncy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchDown]\n@[\"btnPress\"]\ncy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchUpOutside]\n@[\"btnRelease\"]\ncy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchUpInside]\n@[\"btnRelease\"]\n```\n\n结果发现这三个ContrlEvent有对应的action，我们再看看这三个枚举的值\n\n```OC\ntypedef enum UIControlEvents : NSUInteger {\n    UIControlEventTouchDown = 1 <<  0,\n    UIControlEventTouchDownRepeat = 1 <<  1,\n    UIControlEventTouchDragInside = 1 <<  2,\n    UIControlEventTouchDragOutside = 1 <<  3,\n    UIControlEventTouchDragEnter = 1 <<  4,\n    UIControlEventTouchDragExit = 1 <<  5,\n    UIControlEventTouchUpInside = 1 <<  6,\n    UIControlEventTouchUpOutside = 1 <<  7,\n    UIControlEventTouchCancel = 1 <<  8,\n\t......\n} UIControlEvents;\n```\n\n可以看出来UIControlEventTouchDown对应1，UIControlEventTouchUpInside对应128，UIControlEventTouchUpOutside对应64，三者相加正好193！原来调用`[#0x1277a9d70 allControlEvents]`的时候返回的应该是枚举，有多个枚举则把它们的值相加，是不是略坑？我也是这样觉得的！刚才我们把三种ControlEvent对应的action都打印出来了，继续LLDB+IDA进行动态分析。\n####\t（2）找到小视频拍摄完成跳转到发布界面的方法  \n因为要找到小视频发布的方法，所以对应的`btnPress`函数我们并不关心，把重点放在`btnRelease`上面，拍摄按钮松开后就会调用的方法。在IDA中找到这个方法\n![MainFrameSightViewController - (void)btnRelease](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-btnRelease.png)  \n找到之后下个断点\n\n```OC\n(lldb) br s -a 0xac000+0x10209369C\nBreakpoint 4: where = WeChat`___lldb_unnamed_symbol108894$$WeChat + 32, address = 0x000000010213f69c\nProcess 3813 stopped\n* thread #1: tid = 0xf1ef0, 0x000000010213f69c WeChat`___lldb_unnamed_symbol108894$$WeChat + 32, queue = 'com.apple.main-thread', stop reason = breakpoint 4.1\n    frame #0: 0x000000010213f69c WeChat`___lldb_unnamed_symbol108894$$WeChat + 32\nWeChat`___lldb_unnamed_symbol108894$$WeChat:\n->  0x10213f69c <+32>: bl     0x1028d0b60               ; symbol stub for: objc_msgSend\n    0x10213f6a0 <+36>: cmp    w0, #2                    ; =2 \n    0x10213f6a4 <+40>: b.ne   0x10213f6dc               ; <+96>\n    0x10213f6a8 <+44>: adrp   x8, 5489\n```\n\n用手机拍摄小视频然后松开，触发了断点，说明我们的猜想是正确的。继续分析发现代码是从上图的右边走的，看了一下没有什么方法是跳转到发布视频的，不过仔细看一下有一个block，是系统的延时block，位置在0x102093760。然后我们跟着断点进去，在0x1028255A0跳转到x16所存的地址\n\n```OC\n(lldb) si\nProcess 3873 stopped\n* thread #1: tid = 0xf62c4, 0x00000001028d9598 WeChat`dispatch_after, queue = 'com.apple.main-thread', stop reason = instruction step into\n    frame #0: 0x00000001028d9598 WeChat`dispatch_after\nWeChat`dispatch_after:\n->  0x1028d9598 <+0>: adrp   x16, 1655\n    0x1028d959c <+4>: ldr    x16, [x16, #1056]\n    0x1028d95a0 <+8>: br     x16\n\nWeChat`dispatch_apply:\n    0x1028d95a4 <+0>: adrp   x16, 1655\n(lldb) po $x2\n<__NSStackBlock__: 0x16fd49f88>\n```\n\n发现传入的参数x2是一个block，我们再回顾一下dispatch_after函数\n\n```OC\nvoid dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);\n```\n\n这个函数有三个参数，分别是dispatch_time_t、dispatch_queue_t、dispatch_block_t，那这里打印的x2就是要传入的block，所以我们猜测拍摄完小视频会有一个延时，然后执行刚才传入的block，所以x2中肯定有其他方法调用，下一步就是要知道这个block的位置。\n\n```OC\n(lldb) memory read --size 8 --format x 0x16fd49f88\n0x16fd49f88: 0x000000019f8fd218 0x00000000c2000000\n0x16fd49f98: 0x000000010214777c 0x0000000102fb0e60\n0x16fd49fa8: 0x000000015da32600 0x000000015ea1a430\n0x16fd49fb8: 0x000000015cf5fee0 0x000000016fd49ff0\n```\n\n0x000000010214777c就是block所在的位置，当然要减掉当前WeChat的ASLR偏移，最终在IDA中的地址为0x10209377C，突然发现这就是`btnRelease`的子程序sub_10209377C。这个子程序非常简单，只有一个方法`selRef_logicCheckState_`有可能是我们的目标。先看看这个方法是谁调用的\n\n```OC\n(lldb) br s -a 0xb4000+0x1020937BC\n......\nProcess 3873 stopped\n* thread #1: tid = 0xf62c4, 0x00000001021477bc WeChat`___lldb_unnamed_symbol108895$$WeChat + 64, queue = 'com.apple.main-thread', stop reason = breakpoint 3.1\n    frame #0: 0x00000001021477bc WeChat`___lldb_unnamed_symbol108895$$WeChat + 64\nWeChat`___lldb_unnamed_symbol108895$$WeChat:\n->  0x1021477bc <+64>: adrp   x8, 5489\n    0x1021477c0 <+68>: ldr    x1, [x8, #1552]\n    0x1021477c4 <+72>: orr    w2, wzr, #0x1\n    0x1021477c8 <+76>: ldp    x29, x30, [sp, #16]\n(lldb) po $x0\n<MainFrameSightViewController: 0x15d1f0c00>\n```\n发现还是MainFrameSightViewController这个对象调用的，那`selRef_logicCheckState_ `肯定也在这个类的头文件中，寻找一下果然发现了  \n\n```OC\n- (void)logicCheckState:(int)arg1;\n```\n\n在IDA左侧窗口中寻找[MainFrameSightViewController logicCheckState:]，发现这个方法超级复杂，逻辑太多了，不着急慢慢捋。\n在0x102094D6C位置我们发现一个switch jump，思路就很清晰了，我们只要找到小视频拍摄完成的这条线往下看就行了，LLDB来帮忙看看走的那条线。在0x102094D6C位置下个断点，这个断点在拍摄小视频的时候会多次触发，可以在拍摄之前把断点dis掉，拍摄松手之前再启用断点，打印此时的x8值  \n\n```OC\n(lldb) p/x $x8\n(unsigned long) $38 = 0x0000000102174e10\n```\n\nx8是一个指针，它指向的地址是0x102174e10，用这个地址减去当前ASLR的偏移就可以找到在IDA中的基地址，发现是0x102094E10，拍摄完成的逻辑处理这条线找到了，一直走到0x102094E24位置之后跳转0x1020951C4，这个分支的内容较少，里面有三个函数  \n\n```OC\nloc_1020951C4\nADRP            X8, #selRef_hideTips@PAGE\nLDR             X1, [X8,#selRef_hideTips@PAGEOFF]\nMOV             X0, X19\nBL              _objc_msgSend\nADRP            X8, #selRef_finishWriter@PAGE\nLDR             X1, [X8,#selRef_finishWriter@PAGEOFF]\nMOV             X0, X19\nBL              _objc_msgSend\nADRP            X8, #selRef_turnCancelBtnForFinishRecording@PAGE\nLDR             X1, [X8,#selRef_turnCancelBtnForFinishRecording@PAGEOFF]\nMOV             X0, X19\nBL              _objc_msgSend\nB               loc_102095288\n```\n\n其中`selRef_finishWriter`和`selRef_turnCancelBtnForFinishRecording`需要重点关注，这两个方法看上去都是小视频录制结束的意思，线索极有可能就在这两个函数中。通过查看调用者发现这两个方法都属于MainFrameSightViewController，继续在IDA中查看这两个方法。在`selRef_finishWriter `中靠近末尾0x102094248的位置发现一个方法名叫做`f_switchToSendingPanel`，下个断点，然后拍摄视频，发现这个方法并没有被触发。应该不是通过这个方法调用发布界面的，继续回到`selRef_finishWriter `方法中；在0x1020941DC的位置调用方法`selRef_stopRecording`，打印它的调用者发现这个方法属于`SightFacade`，继续在IDA中寻找这个方法的实现。在这个方法的0x101F9BED4位置又调用了`selRef_stopRecord`，同样打印调用者发现这个方法属于SightCaptureLogicF4，有点像剥洋葱，继续在寻找这个方法的实现。在这个方法内部0x101A98778位置又调用了`selRef_finishWriting`，同样的原理找到这个方法是属于SightMovieWriter。已经剥了3层了，继续往下：  \n在`SightMovieWriter - (void)finishWriting`中的0x10261D004位置分了两条线，这个位置下个断点，然后拍摄完小视频触发断点，打印x19的值  \n\n```OC\n(lldb) po $x19\n<OS_dispatch_queue: CAPTURE.CALLBACK[0x13610bcd0] = { xrefcnt = 0x4, refcnt = 0x4, suspend_cnt = 0x0, locked = 1, target = com.apple.root.default-qos.overcommit[0x1a0aa3700], width = 0x0, running = 0x0, barrier = 1 }>\n```\n\n所以代码不会跳转到loc_10261D054而是走的左侧，在左侧的代码中发现启用了一个block，这个block是子程序sub_10261D0AC，地址为0x10261D0AC，找到这个地址，结构如下图所示：\n![sub_10261D0AC](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91sub_10261D0AC.png)  \n可以看出来主要分两条线，我们在第一个方框的末尾也就是0x10261D108位置下个断点，等拍摄完毕触发断点之后打印x0的值为1，这里的汇编代码为  \n\n```OC\n__text:000000010261D104                 CMP             X0, #2\n__text:000000010261D108                 B.EQ            loc_10261D234\n```\n\nB.EQ是在上一步的结果为0才会跳转到loc_10261D234，但是这里的结果是不为0的，将x0的值改为2让上一步的结果为0  \n\n```OC\n(lldb) po $x0\n1\n(lldb) register write $x0 2\n(lldb) po $x0\n2\n```\n\n此时放开断点，等待跳转到小视频发布界面，结果是一直卡在这个界面没有任何反应，所以猜测实现跳转的逻辑应该在右边的那条线，继续顺着右边的线寻找：\n在右侧0x10261D3AC位置发现调用了下面的这个方法  \n\n```OC  \n- (void)finishWritingWithCompletionHandler:(void (^)(void))handler;\n```\n\n这个方法是系统提供的AVAssetWriter里面的方法，在视频写入完成之后要做的操作，这个里是要传入一个block的，因为只有一个参数所以对应的变量是x2，打印x2的值\n\n```oc\n(lldb) po $x2\n<__NSStackBlock__: 0x16e086c78>\n(lldb) memory read --size 8 --format x 0x16e086c78\n0x16e086c78: 0x00000001a0aa5218 0x00000000c2000000\n0x16e086c88: 0x00000001026d94b0 0x0000000102fc98c0\n0x16e086c98: 0x0000000136229fd0 0x000000016e086d00\n0x16e086ca8: 0x00000001997f5318 0xfffffffec9e882ff\n```\n\n并且通过栈内存找到block位置为0x10261D4B0（需要减去ASLR的偏移）\n\n```oc\nsub_10261D4B0\nvar_20= -0x20\nvar_10= -0x10\nSTP             X20, X19, [SP,#var_20]!\nSTP             X29, X30, [SP,#0x20+var_10]\nADD             X29, SP, #0x20+var_10\nMOV             X19, X0\nLDR             X0, [X19,#0x20]\nADRP            X8, #selRef_stopAmr@PAGE\nLDR             X1, [X8,#selRef_stopAmr@PAGEOFF]\nBL              _objc_msgSend\nLDR             X0, [X19,#0x20]\nADRP            X8, #selRef_compressAudio@PAGE\nLDR             X1, [X8,#selRef_compressAudio@PAGEOFF]\nLDP             X29, X30, [SP,#0x20+var_10]\nLDP             X20, X19, [SP+0x20+var_20],#0x20\nB               _objc_msgSend\n; End of function sub_10261D4B0\n```\n\n只调用了两个方法，一个是`selRef_stopAmr`停止amr（一种音频格式），另一个是`selRef_compressAudio`压缩音频，拍摄完成的下一步操作应该不会放在这两个方法里面，找了这么久也没有头绪，这个路看来走不通了，不要钻牛角尖，战略性撤退寻找其他入口。  \n**逆向的乐趣就是一直寻找真相的路上，能体会到成功的乐趣，也有可能方向错了离真相反而越来越远，不要气馁调整方向继续前进！**\n   \n###\t2.“另辟蹊径”\n>（由于微信在后台偷偷升级了，下面的内容都是微信6.3.30版本的ASLR，上面的分析基于6.3.28版本）\n\n注意到在点击朋友圈右上角的相机按钮底部会弹出一个Sheet，第一个就是Sight小视频，从这里入手，用cycript查看Sight按钮对应的事件是哪个  \n\n```oc\niPhone-5S:~ root# cycript -p \"WeChat\"\ncy# [UIApp windows].toString()\n`(\n    \"<iConsoleWindow: 0x14d6ccc00; baseClass = UIWindow; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = <NSArray: 0x14d7df110>; layer = <UIWindowLayer: 0x14d7d6f60>>\",\n    \"<SvrErrorTipWindow: 0x14eaa5800; baseClass = UIWindow; frame = (0 0; 320 45); hidden = YES; gestureRecognizers = <NSArray: 0x14e9e8950>; layer = <UIWindowLayer: 0x14e9e6510>>\",\n    \"<UITextEffectsWindow: 0x14ec38ba0; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = <UIWindowLayer: 0x14ec39360>>\",\n    \"<UITextEffectsWindow: 0x14e9c67a0; frame = (0 0; 320 568); layer = <UIWindowLayer: 0x14d683ff0>>\",\n    \"<UIRemoteKeyboardWindow: 0x14f226e40; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = <UIWindowLayer: 0x14d6f4de0>>\",\n    \"<NewYearActionSheet: 0x14f1704a0; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = <NSArray: 0x14ef9bf90>; layer = <UIWindowLayer: 0x14ef61a20>>\"\n)`\ncy# [#0x14f1704a0 recursiveDescription].toString()\n```\n\n底部的Sheet是NewYearActionSheet，然后打印NewYearActionSheet的UI树状结构图（比较长不贴了）。然后找到Sight对应的UIButton是0x14f36d470   \n\n```oc\ncy# [#0x14f36d470 allTargets]\n[NSSet setWithArray:@[#\"<NewYearActionSheet: 0x14f1704a0; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = <NSArray: 0x14ef9bf90>; layer = <UIWindowLayer: 0x14ef61a20>>\"]]]\ncy# [#0x14f36d470 allControlEvents]\n64\ncy# [#0x14f36d470 actionsForTarget:#0x14f1704a0 forControlEvent:64]\n@[\"OnDefaultButtonTapped:\"]\n```\n\n通过UIControl的`actionsForTarget:forControlEvent:`方法可以找到按钮绑定的事件，Sight按钮的触发方法为`OnDefaultButtonTapped:`，回到IDA中在NewYearActionSheet中找到这个方法们继续往下分析只有这个方法`selRef_dismissWithClickedButtonIndex_animated`，通过打印它的调用者发现还是NewYearActionSheet，继续点进去找到`newYearActionSheet_clickedButtonAtIndex`方法，看样子不是NewYearActionSheet自己的，打印调用者x0发现它属于类WCTimeLineViewController。跟着断点走下去在0x1012B78CC位置调用了方法`#selRef_showSightWindowForMomentWithMask_byViewController_scene`\n通过观察发现这个方法的调用者是0x1012B78AC这个位置的返回值x0，这是一个类SightFacade，猜测这个方法在SightFacade里面，去头文件里找一下果然发现这个方法  \n\n```oc\n- (void)showSightWindowForMomentWithMask:(id)arg1 byViewController:(id)arg2 scene:(int)arg3;\n```\n\n这个方法应该就是跳转到小视频界面的方法了。下面分别打印它的参数  \n\n```oc\n(lldb) po $x2\n<UIImage: 0x14f046660>, {320, 568}\n(lldb) po $x3\n<WCTimeLineViewController: 0x14e214800>\n(lldb) po $x4\n2\n(lldb) po $x0\n<SightFacade: 0x14f124b40>\n```\n\n其中x2、x3、x4分别对应三个参数，x0是调用者，跳到这个方法内部查看怎么实现的。发现在这个方法中进行了小视频拍摄界面的初始化工作，首先初始化一个MainFrameSightViewController，再创建一个UINavigationController将MainFrameSightViewController放进去，接下来初始化一个MMWindowController调用  \n\n```oc\n- (id)initWithViewController:(id)arg1 windowLevel:(int)arg2;\n```\n\n方法将UINavigationController放了进去，完成小视频拍摄界面的所有UI创建工作。\n拍摄完成之后进入发布界面，此时用cycript找到当前的Controller是SightMomentEditViewController，由此萌生一个想法，跳过前面的拍摄界面直接进入发布界面不就可以了吗？我们自己创建一个SightMomentEditViewController然后放到UINavigationController里面，然后再将这个导航控制器放到MMWindowController里面。**（这里我已经写好tweak进行了验证，具体的tweak思路编写在后文有）**结果是的确可以弹出发布的界面，但是导航栏的NavgationBar遮住了原来的，整个界面是透明的，很难看，而且发布完成之后无法销毁整个MMWindowController，还是停留在发布界面。我们要的结果不是这个，不过确实有很大的收获，最起码可以直接调用发布界面了，小视频也能正常转发。我个人猜测，当前界面不能被销毁的原因是因为MMWindowController新建了一个window,它跟TimeLine所在的keyWindow不是同一个，SightMomentEditViewController的按钮触发的方法是没有办法销毁这个window的，所以有一个大胆的猜想，我直接在当前的WCTimeLineViewController上把SightMomentEditViewController展示出来不就可以了吗？  \n\n```oc\n[WCTimelineVC presentViewController:editSightVC animated:YES completion:^{\n}];\n```\n\n像这样展示岂不妙哉？不过通过观察SightMomentEditViewController的头文件，结合小视频发布时界面上的元素，推测创建这个控制器至少需要两个属性，一个是小视频的路径，另一个是小视频的缩略图，将这两个关键属性给了SightMomentEditViewController那么应该就可以正常展示了   \n\n```oc\nSightMomentEditViewController *editSightVC = [[%c(SightMomentEditViewController) alloc] init];\nNSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];\nUIImage *image = [[self valueForKey:@\"_sightView\"] getImage];\n[editSightVC setRealMoviePath:localPath];\n[editSightVC setMoviePath:localPath];\n[editSightVC setRealThumbImage:image];\n[editSightVC setThumbImage:image];\n[WCTimelineVC presentViewController:editSightVC animated:YES completion:^{\n}];\n```\n\n小视频的发布界面可以正常显示并且所有功能都可以正常使用，唯一的问题是返回按钮没有效果，并不能销毁SightMomentEditViewController。用cycript查看左侧按钮的actionEvent找到它的响应函数是`- (void)popSelf;`，点击左侧返回触发的是pop方法，但是这个控制器并不在navgationController里面，所以无效，我们要对这个方法进行重写  \n\n```oc\n- (void)popSelf\n{\n    [self dismissViewControllerAnimated:YES completion:^{\n\n    }];\n}\n```\n\n此时再点击返回按钮就可以正常退出了，此外，在WCContentItemViewTemplateNewSight中发现了一个方法叫做`- (void)sendSightToFriend;`，可以直接将小视频转发给好友，至此小视频转发的功能已经找到了。\n","slug":"手把手教你逆向微信之朋友圈小视频转发（上）","published":1,"updated":"2017-11-02T13:09:57.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9no6vnu002cjaeny56df995","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>此文为逆向微信二进制文件，实现朋友圈小视频转发的教程，从最开始的汇编代码入手到最后重签名安装等操作，手把手教你玩转微信！学会之后再去逆向微信其他功能易如反掌。<br>本篇文章由于篇幅太长分成了两篇，<strong>上篇</strong>讲解的是逆向工作，也就是怎么找到相关的函数和方法实现，<strong>下篇</strong>讲解的是怎么在非越狱机重签名安装和越狱机tweak安装的详细过程。<br><strong>正文的第二部分还提供了微信自动抢红包、修改微信步数的代码，这些都可以照葫芦画瓢按照本文的套路一步步逆向找到，这里就不再赘述。</strong><br>在实践之前，需要准备好一部越狱的手机，然后将下文列出的所有工具安装好。IDA跟Reveal都是破解版，IDA的正版要2000多刀，对于这么牛逼的逆向工具确实物有所值，不过不是专门研究逆向的公司也没必要用正版的，下个Windows的破解版就好，Mac上暂时没找到。Mac上可以用hopper代替IDA，也是一款很牛逼的逆向工具。废话不多说，正式开始吧！</p>\n<a id=\"more\"></a>\n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<h1 id=\"逆向微信朋友圈（上篇）\"><a href=\"#逆向微信朋友圈（上篇）\" class=\"headerlink\" title=\"逆向微信朋友圈（上篇）\"></a>逆向微信朋友圈（上篇）</h1><h2 id=\"一、获取朋友圈的小视频\"><a href=\"#一、获取朋友圈的小视频\" class=\"headerlink\" title=\"一、获取朋友圈的小视频\"></a>一、获取朋友圈的小视频</h2><blockquote>\n<p>   注意：本文逆向的微信的二进制文件为6.3.28版本，如果是不同的微信版本，二进制文件中的基地址也不相同</p>\n</blockquote>\n<h4 id=\"本文涉及到的工具\"><a href=\"#本文涉及到的工具\" class=\"headerlink\" title=\"本文涉及到的工具\"></a>本文涉及到的工具</h4><ol>\n<li><a href=\"http://www.cycript.org\" target=\"_blank\" rel=\"external\">cycript</a> </li>\n<li>LLDB与debugserver（Xcode自带）</li>\n<li>OpenSSH</li>\n<li>IDA</li>\n<li>Reveal</li>\n<li><a href=\"https://github.com/theos/theos\" target=\"_blank\" rel=\"external\">theos</a></li>\n<li><a href=\"http://www.cydiasubstrate.com\" target=\"_blank\" rel=\"external\">CydiaSubstrate</a></li>\n<li>iOSOpenDev</li>\n<li>ideviceinstaller</li>\n<li>tcprelay（本地端口映射，USB连接SSH，不映射可通过WiFi连接） </li>\n<li><a href=\"https://github.com/stefanesser/dumpdecrypted\" target=\"_blank\" rel=\"external\">dumpdecrypted</a></li>\n<li><a href=\"http://stevenygard.com/projects/class-dump/\" target=\"_blank\" rel=\"external\">class-dump</a> </li>\n<li><a href=\"https://github.com/DanTheMan827/ios-app-signer\" target=\"_blank\" rel=\"external\">iOS App Signer</a></li>\n<li>编译好的<a href=\"https://github.com/gaoshilei/yololib\" target=\"_blank\" rel=\"external\">yololib</a></li>\n</ol>\n<p><strong>逆向环境为MacOS    +    iPhone5S 9.1越狱机</strong><br>先用dumpdecrypted给微信砸壳（不会的请我写的看<a href=\"http://www.gaoshilei.com/2016/08/08/dumpdecrypted给App砸壳/\">这篇教程</a>），获得一个WeChat.decrypted文件，先把这个文件扔到IDA中分析（60MB左右的二进制文件，IDA差不多40分钟才能分析完），用class-dump导出所有头文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ class-dump -S -s -H /Users/gaoshilei/Desktop/reverse/binary_for_class-dump/WeChat.decrypted -o /Users/gaoshilei/Desktop/reverse/binary_for_class-dump/class-Header/WeChat</div></pre></td></tr></table></figure>\n<p>我滴个亲娘！一共有8000个头文件，微信果然工程量浩大！稳定一下情绪，理一理思路继续搞。要取得小视频的下载链接，找到播放视频的View，顺藤摸瓜就能找到小视频的URL。用Reveal查看小视频的播放窗口<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91Reveal.png\" alt=\"Reveal\"><br>可以看出来WCContentItemViewTemplateNewSigh这个对象是小视频的播放窗口，它的subView有WCSightView，SightView、SightPlayerView，这几个类就是我们的切入点。<br>保存视频到favorite的时候是长按视频弹出选项的，那么在WCContentItemViewTemplateNewSight这个类里面可能有手势相关的方法，去刚才导出的头文件中找线索。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)onLongTouch;</div><div class=\"line\">- (void)onLongPressedWCSight:(id)arg1;</div><div class=\"line\">- (void)onLongPressedWCSightFullScreenWindow:(id)arg1;</div></pre></td></tr></table></figure>\n<p>这几个方法跟长按手势相关，再去IDA中找到这些函数，逐个查看。onLongPressedWCSight和onLongPressedWCSightFullScreenWindow都比较简单，onLongTouch比较长，而且发现了内部调用了方法Favorites_Add，因为长按视频的时候出来一个选项就是Favorites，并且我看到这个函数调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ADRP            X8, #selRef_sightVideoPath@PAGE</div><div class=\"line\">LDR             X1, [X8,#selRef_sightVideoPath@PAGEOFF]</div></pre></td></tr></table></figure>\n<p>这里拿到了小视频的地址，可以推测这个函数跟收藏有关，下面打断点测试。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) im li -o -f</div><div class=\"line\">[  0] 0x000000000003c000 /var/mobile/Containers/Bundle/Application/2F1D52EC-C57E-4F95-B715-EF04351232E8/WeChat.app/WeChat(0x000000010003c000)</div></pre></td></tr></table></figure>\n<p>可以看到WeChat的ASLR为0x3c000，在IDA查找到这三个函数的基地址，分别下断点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a 0x1020D3A10+0x3c000</div><div class=\"line\">Breakpoint 1: where = WeChat`___lldb_unnamed_symbol110094$$WeChat + 28, address = 0x000000010210fa10</div><div class=\"line\">(lldb) br s -a 0x1020D3370+0x3c000</div><div class=\"line\">Breakpoint 2: where = WeChat`___lldb_unnamed_symbol110091$$WeChat + 8, address = 0x000000010210f370</div><div class=\"line\">(lldb) br s -a 0x1020D33E4+0x3c000</div><div class=\"line\">Breakpoint 3: where = WeChat`___lldb_unnamed_symbol110092$$WeChat + 12, address = 0x000000010210f3e4</div></pre></td></tr></table></figure>\n<p>回到微信里面长按小视频，看断点触发情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Process 3721 stopped</div><div class=\"line\">* thread #1: tid = 0x658fc, 0x000000010210f370 WeChat`___lldb_unnamed_symbol110091$$WeChat + 8, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 2.1</div><div class=\"line\">    frame #0: 0x000000010210f370 WeChat`___lldb_unnamed_symbol110091$$WeChat + 8</div><div class=\"line\">WeChat`___lldb_unnamed_symbol110091$$WeChat:</div><div class=\"line\">-&gt;  0x10210f370 &lt;+8&gt;:  add    x29, sp, #16              ; =16 </div><div class=\"line\">    0x10210f374 &lt;+12&gt;: mov    x19, x0</div><div class=\"line\">    0x10210f378 &lt;+16&gt;: adrp   x8, 4968</div><div class=\"line\">    0x10210f37c &lt;+20&gt;: ldr    x0, [x8, #744]</div><div class=\"line\">(lldb) c</div><div class=\"line\">Process 3721 resuming</div><div class=\"line\">Process 3721 stopped</div><div class=\"line\">* thread #1: tid = 0x658fc, 0x000000010210fa10 WeChat`___lldb_unnamed_symbol110094$$WeChat + 28, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</div><div class=\"line\">    frame #0: 0x000000010210fa10 WeChat`___lldb_unnamed_symbol110094$$WeChat + 28</div><div class=\"line\">WeChat`___lldb_unnamed_symbol110094$$WeChat:</div><div class=\"line\">-&gt;  0x10210fa10 &lt;+28&gt;: add    x29, sp, #96              ; =96 </div><div class=\"line\">    0x10210fa14 &lt;+32&gt;: sub    sp, sp, #96               ; =96 </div><div class=\"line\">    0x10210fa18 &lt;+36&gt;: mov    x19, x0</div><div class=\"line\">    0x10210fa1c &lt;+40&gt;: adrp   x8, 4863</div><div class=\"line\">……</div></pre></td></tr></table></figure>\n<p>发现断点2先被触发，接着触发断点1，后面断点2和1又各触发了1次，断点3一直很安静。可以排除onLongPressedWCSightFullScreenWindow与收藏小视频的联系。小视频的踪影就要在剩下的两个方法中寻找了。通过V找到C，顺藤摸瓜找到M屡试不爽！用cycript注入WeChat，拿到播放小视频的view所在的Controller。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [#0x138c18030 nextResponder]</div><div class=\"line\">#&quot;&lt;WCTimeLineCellView: 0x138c34620; frame = (0 0; 319 249); tag = 1048577; layer = &lt;CALayer: 0x138362ba0&gt;&gt;&quot;</div><div class=\"line\">cy# [#0x138c34620 nextResponder]</div><div class=\"line\">#&quot;&lt;UITableViewCellContentView: 0x138223c70; frame = (0 0; 320 256); gestureRecognizers = &lt;NSArray: 0x1384ec480&gt;; layer = &lt;CALayer: 0x138081dc0&gt;&gt;&quot;</div><div class=\"line\">cy# [#0x138223c70 nextResponder]</div><div class=\"line\">#&quot;&lt;MMTableViewCell: 0x138c9f930; baseClass = UITableViewCell; frame = (0 307; 320 256); autoresize = W; layer = &lt;CALayer: 0x1382dcd10&gt;&gt;&quot;</div><div class=\"line\">cy# [#0x138c9f930 nextResponder]</div><div class=\"line\">#&quot;&lt;UITableViewWrapperView: 0x137b57800; frame = (0 0; 320 504); gestureRecognizers = &lt;NSArray: 0x1383db660&gt;; layer = &lt;CALayer: 0x138af20c0&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;320, 504&#125;&gt;&quot;</div><div class=\"line\">cy# [#0x137b57800 nextResponder]</div><div class=\"line\">#&quot;&lt;MMTableView: 0x137b8ae00; baseClass = UITableView; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x138adb590&gt;; layer = &lt;CALayer: 0x138956890&gt;; contentOffset: &#123;0, 99.5&#125;; contentSize: &#123;320, 3193&#125;&gt;&quot;</div><div class=\"line\">cy# [#0x137b8ae00 nextResponder]</div><div class=\"line\">#&quot;&lt;UIView: 0x138ade5c0; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x138ac9990&gt;&gt;&quot;</div><div class=\"line\">cy# [#0x138ade5c0 nextResponder]</div><div class=\"line\">#&quot;&lt;WCTimeLineViewController: 0x1379eb000&gt;&quot;</div></pre></td></tr></table></figure>\n<p>通过响应者链条找到<br>WCContentItemViewTemplateNewSight所属的Controller为WCTimeLineViewController。在这个类的头文件中并没有发现有价值的线索，不过我们注意到小视频所在的view是属于MMTableVIewCell的（见上图Reveal分析图），这是每一个iOS最熟悉的TableView，cell的数据是通过UITableViewDataSource的代理方法<code>- tableView:cellForRowAtIndexPath:</code>赋值的，通过这个方法肯定能知道到M的影子。在IDA中找到<code>[WCTimeLineViewController tableView:cellForRowAtIndexPath:]</code>,定位到基地址0x10128B6B0位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">__text:000000010128B6B0     ADRP     X8, #selRef_genNormalCell_indexPath_@PAGE</div></pre></td></tr></table></figure>\n<p>这里的函数是WCTimeLineViewController中生成cell的方法，除了这个方法在这个类中还有另外三个生成cell的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)genABTestTipCell:(id)arg1 indexPath:(id)arg2;</div><div class=\"line\">- (void)genRedHeartCell:(id)arg1 indexPath:(id)arg2;</div><div class=\"line\">- (void)genUploadFailCell:(id)arg1 indexPath:(id)arg2;</div></pre></td></tr></table></figure>\n<p>通过字面意思可以猜测出normal这个应该是生成小视频cell的方法。继续在IDA中寻找线索</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">__text:0000000101287CC8     ADRP     X8, #selRef_getTimelineDataItemOfIndex_@PAGE</div></pre></td></tr></table></figure>\n<p>在<code>genNormalCell:IndexPath:</code>方法中发现上面这个方法，可以大胆猜想这个方法是获取TimeLine（朋友圈）数据的方法，那小视频的数据肯定也是通过这个方法获取的，并且IDA可以看到这个方法中调用一个叫做<code>selRef_getTimelineDataItemOfIndex_</code>的方法，获取DataItem貌似就是cell的数据源啊！接下来用LLDB下断点验证猜想。<br>通过IDA可以找到这个方法对应的基地址为：0x101287CE4，先打印正在运行WeChat的ASLR偏移</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ lldb</div><div class=\"line\">(lldb) process connect connect://localhost:1234</div><div class=\"line\">(lldb) im li -o -f </div><div class=\"line\">[0] 0x0000000000050000 /var/mobile/Containers/Bundle/Application/2DCE8F30-9B6B-4652-901C-37EB1FF2A40D/WeChat.app/WeChat(0x0000000100050000)</div></pre></td></tr></table></figure>\n<p>所以我们下断点的位置是0x50000+0x101287CE4</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a 0x50000+0x101287CE4</div><div class=\"line\">Breakpoint 1: where = WeChat`___lldb_unnamed_symbol63721$$WeChat + 252, address = 0x00000001012d7ce4</div></pre></td></tr></table></figure>\n<p>打印x0的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x0</div><div class=\"line\">Class name: WCDataItem, addr: 0x15f5f03b0</div><div class=\"line\">tid: 12393001887435993280</div><div class=\"line\">username: wxid_z8twcz4o18fg12</div><div class=\"line\">createtime: 1477360950</div><div class=\"line\">commentUsers: (</div><div class=\"line\">)</div><div class=\"line\">contentObj: &lt;WCContentItem: 0x15f57d000&gt;</div></pre></td></tr></table></figure>\n<p>得到一个WCDataItem的对象，这里x0的值就是<code>selRef_getTimelineDataItemOfIndex_</code>执行完的返回值，然后把x0的值改掉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) register write $x0 0</div><div class=\"line\">(lldb) c</div></pre></td></tr></table></figure>\n<p>此时会发现我们要刷新的那条小视频内容全部为空<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91-%E8%BD%AC%E5%8F%91%E5%B0%8F%E8%A7%86%E9%A2%91%E4%B8%BA%E7%A9%BA.jpg\" alt=\"小视频内容为空\"><br>到这里已经找到了小视频的源数据获取方法，问题是我们怎么拿到这个WCDataItem呢？继续看IDA分析函数的调用情况：  </p>\n<blockquote>\n<p>   WCTimeLineViewController - (void)genNormalCell:(id) indexPath:(id)  </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\">__text:0000000101287BCC                 STP             X28, X27, [SP,#var_60]!</div><div class=\"line\">__text:0000000101287BD0                 STP             X26, X25, [SP,#0x60+var_50]</div><div class=\"line\">__text:0000000101287BD4                 STP             X24, X23, [SP,#0x60+var_40]</div><div class=\"line\">__text:0000000101287BD8                 STP             X22, X21, [SP,#0x60+var_30]</div><div class=\"line\">__text:0000000101287BDC                 STP             X20, X19, [SP,#0x60+var_20]</div><div class=\"line\">__text:0000000101287BE0                 STP             X29, X30, [SP,#0x60+var_10]</div><div class=\"line\">__text:0000000101287BE4                 ADD             X29, SP, #0x60+var_10</div><div class=\"line\">__text:0000000101287BE8                 SUB             SP, SP, #0x80</div><div class=\"line\">__text:0000000101287BEC                 MOV             X19, X3</div><div class=\"line\">__text:0000000101287BF0                 MOV             X22, X0</div><div class=\"line\">__text:0000000101287BF4                 MOV             W25, #0x100000</div><div class=\"line\">__text:0000000101287BF8                 MOVK            W25, #1</div><div class=\"line\">__text:0000000101287BFC                 MOV             X0, X2</div><div class=\"line\">__text:0000000101287C00                 BL              _objc_retain</div><div class=\"line\">__text:0000000101287C04                 MOV             X28, X0</div><div class=\"line\">__text:0000000101287C08                 MOV             X0, X19</div><div class=\"line\">__text:0000000101287C0C                 BL              _objc_retain</div><div class=\"line\">__text:0000000101287C10                 MOV             X20, X0</div><div class=\"line\">__text:0000000101287C14                 STR             X20, [SP,#0xE0+var_98]</div><div class=\"line\">__text:0000000101287C18                 ADRP            X8, #selRef_row@PAGE</div><div class=\"line\">__text:0000000101287C1C                 LDR             X1, [X8,#selRef_row@PAGEOFF]</div><div class=\"line\">__text:0000000101287C20                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287C24                 MOV             X26, X0</div><div class=\"line\">__text:0000000101287C28                 ADRP            X8, #selRef_section@PAGE</div><div class=\"line\">__text:0000000101287C2C                 LDR             X19, [X8,#selRef_section@PAGEOFF]</div><div class=\"line\">__text:0000000101287C30                 MOV             X0, X20</div><div class=\"line\">__text:0000000101287C34                 MOV             X1, X19</div><div class=\"line\">__text:0000000101287C38                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287C3C                 STR             X0, [SP,#0xE0+var_A8]</div><div class=\"line\">__text:0000000101287C40                 MOV             X0, X20</div><div class=\"line\">__text:0000000101287C44                 MOV             X1, X19</div><div class=\"line\">__text:0000000101287C48                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287C4C                 MOV             X2, X0</div><div class=\"line\">__text:0000000101287C50                 ADRP            X8, #selRef_calcDataItemIndex_@PAGE</div><div class=\"line\">__text:0000000101287C54                 LDR             X1, [X8,#selRef_calcDataItemIndex_@PAGEOFF]</div><div class=\"line\">__text:0000000101287C58                 MOV             X0, X22</div><div class=\"line\">__text:0000000101287C5C                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287C60                 MOV             X21, X0</div><div class=\"line\">__text:0000000101287C64                 STR             X21, [SP,#0xE0+var_C0]</div><div class=\"line\">__text:0000000101287C68                 ADRP            X8, #classRef_MMServiceCenter@PAGE</div><div class=\"line\">__text:0000000101287C6C                 LDR             X0, [X8,#classRef_MMServiceCenter@PAGEOFF]</div><div class=\"line\">__text:0000000101287C70                 ADRP            X8, #selRef_defaultCenter@PAGE</div><div class=\"line\">__text:0000000101287C74                 LDR             X1, [X8,#selRef_defaultCenter@PAGEOFF]</div><div class=\"line\">__text:0000000101287C78                 STR             X1, [SP,#0xE0+var_B8]</div><div class=\"line\">__text:0000000101287C7C                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287C80                 MOV             X29, X29</div><div class=\"line\">__text:0000000101287C84                 BL              _objc_retainAutoreleasedReturnValue</div><div class=\"line\">__text:0000000101287C88                 MOV             X19, X0</div><div class=\"line\">__text:0000000101287C8C                 ADRP            X8, #classRef_WCFacade@PAGE</div><div class=\"line\">__text:0000000101287C90                 LDR             X0, [X8,#classRef_WCFacade@PAGEOFF]</div><div class=\"line\">__text:0000000101287C94                 ADRP            X8, #selRef_class@PAGE</div><div class=\"line\">__text:0000000101287C98                 LDR             X1, [X8,#selRef_class@PAGEOFF]</div><div class=\"line\">__text:0000000101287C9C                 STR             X1, [SP,#0xE0+var_B0]</div><div class=\"line\">__text:0000000101287CA0                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287CA4                 MOV             X2, X0</div><div class=\"line\">__text:0000000101287CA8                 ADRP            X8, #selRef_getService_@PAGE</div><div class=\"line\">__text:0000000101287CAC                 LDR             X1, [X8,#selRef_getService_@PAGEOFF]</div><div class=\"line\">__text:0000000101287CB0                 STR             X1, [SP,#0xE0+var_A0]</div><div class=\"line\">__text:0000000101287CB4                 MOV             X0, X19</div><div class=\"line\">__text:0000000101287CB8                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287CBC                 MOV             X29, X29</div><div class=\"line\">__text:0000000101287CC0                 BL              _objc_retainAutoreleasedReturnValue</div><div class=\"line\">__text:0000000101287CC4                 MOV             X20, X0</div><div class=\"line\">__text:0000000101287CC8                 ADRP            X8, #selRef_getTimelineDataItemOfIndex_@PAGE</div><div class=\"line\">__text:0000000101287CCC                 LDR             X1, [X8,#selRef_getTimelineDataItemOfIndex_@PAGEOFF]</div><div class=\"line\">__text:0000000101287CD0                 STR             X1, [SP,#0xE0+var_C8]</div><div class=\"line\">__text:0000000101287CD4                 MOV             X2, X21</div><div class=\"line\">__text:0000000101287CD8                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287CDC                 MOV             X29, X29</div><div class=\"line\">__text:0000000101287CE0                 BL              _objc_retainAutoreleasedReturnValue</div><div class=\"line\">__text:0000000101287CE4                 MOV             X21, X0</div><div class=\"line\">__text:0000000101287CE8                 MOV             X0, X20</div><div class=\"line\">......</div></pre></td></tr></table></figure>\n<p><code>selRef_getTimelineDataItemOfIndex_</code>传入的参数是x2，可以看到传值给x2的x21是函数<code>selRef_calcDataItemIndex_</code>的返回值，是一个unsigned long数据类型。继续分析，<code>selRef_getTimelineDataItemOfIndex_</code>函数的调用者是上一步<code>selRef_getService_</code>的返回值，经过断点分析发现是一个<code>WCFacade</code>对象。整理一下<code>selRef_getTimelineDataItemOfIndex_</code>的调用：<br><strong>调用者是<code>selRef_getService_</code>的返回值；参数是<code>selRef_calcDataItemIndex_</code>的返回值</strong><br>下面把目光转向那两个函数，用相同的原理分析它们各自怎么实现调用  </p>\n<ol>\n<li>先看<code>selRef_getService_</code>：<br>在0x101287CB4这个位置可以发现，这个函数的调用者是从通过x19 MOV的，打印x19发现是一个<code>MMServiceCenter</code>对象，往上找x19是在0x101287C88这个位置赋值的，结果很清晰x19是<code>[MMServiceCenter defaultCenter]</code>的返回值。<br>在0x101287CA4位置可以找到传入的参数x2，往上分析可以看出来它的参数是<code>[WCFacade class]</code>的返回值。  </li>\n<li>接着找<code>selRef_calcDataItemIndex_</code>：<br>在0x101287C58的位置找到它的调用者x0，x0通过x22赋值，继续向上寻找，发现在最上面0x101287BF0的位置，x22是x0赋值的，一开始的x0就是<code>WCTimeLineViewController</code>自身。<br>在0x101287C4C位置发现传入的参数来自x2,x2是通过上一步<code>selRef_section</code>函数的返回值x0赋值的，在0x101287C30位置可以发现<code>selRef_section</code>函数的调用者是x20赋值的，如下图所示，最终找到<code>selRef_section</code>的调用者是x3<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-selRef_section%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%80%85.png\" alt=\"selRef_section函数的调用者\"><br>x3就是函数<code>WCTimeLineViewController - (void)genNormalCell:(id) indexPath:(id)</code>的第二个参数indexPath,，所以<code>selRef_calcDataItemIndex_</code>的参数是<code>[IndexPath section]</code>。<br>对上面的分析结果做个梳理：<br>因此<code>getTimelineDataItemOfIndex:</code>的调用者可以通过</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[MMServiceCenter defaultCenter] getService:[WCFacade class]]</div></pre></td></tr></table></figure>\n<p>来获得,它的参数可以通过下面的函数获取</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[WCTimeLineViewController calcDataItemIndex:[indexPath section]]</div></pre></td></tr></table></figure>\n<p>总感觉还少点什么？indexPath我们还没拿到呢！下一步就是拿到indexPath,这个就比较简单了，因为我们位于<code>[WCContentItemViewTemplateNewSight onLongTouch]</code>中，所以可以通过<code>[self nextResponder]</code>依次拿到MMTableViewCell、MMTableView和WCTimeLineViewController，再通过<code>[MMTableView indexPathForCell:MMTableViewCell]</code>拿到indexPath。<br>做完这些，已经拿到WCDataItem对象，接下来的重点要放在WCDataItem上，最终要获取我们要的小视频。到这个类的头文件中找线索，因为视频是下载完成后才能播放的，所以这里应该拿到了视频的路径，所以要注意url和path相关的属性或方法，然后找到下面这几个嫌疑对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property(retain, nonatomic) NSString *sourceUrl2; </div><div class=\"line\">@property(retain, nonatomic) NSString *sourceUrl; </div><div class=\"line\">- (id)descriptionForKeyPaths;</div><div class=\"line\">- (id)keyPaths;</div></pre></td></tr></table></figure>\n<p>回到LLDB中，用断点打印这些值，看看有什么。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po [$x0 keyPaths]</div><div class=\"line\">&lt;__NSArrayI 0x15f74e9d0&gt;(</div><div class=\"line\">\ttid,</div><div class=\"line\">\tusername,</div><div class=\"line\">\tcreatetime,</div><div class=\"line\">\tcommentUsers,</div><div class=\"line\">\tcontentObj</div><div class=\"line\">)</div><div class=\"line\">(lldb) po [$x0 descriptionForKeyPaths]</div><div class=\"line\">Class name: WCDataItem, addr: 0x15f5f03b0</div><div class=\"line\">tid: 12393001887435993280</div><div class=\"line\">username: wxid_z8twcz4o18fg12</div><div class=\"line\">createtime: 1477360950</div><div class=\"line\">commentUsers: (</div><div class=\"line\">)</div><div class=\"line\">contentObj: &lt;WCContentItem: 0x15f57d000&gt;</div><div class=\"line\">(lldb) po [$x0 sourceUrl]</div><div class=\"line\"> nil</div><div class=\"line\">(lldb) po [$x0 sourceUrl2]</div><div class=\"line\"> nil</div></pre></td></tr></table></figure>\n<p>并没有什么有价值的线索，不过注意到WCDataItem里面有一个WCContentItem，看来只能从这儿入手了，去看一下头文件吧！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property(retain, nonatomic) NSString *linkUrl; </div><div class=\"line\">@property(retain, nonatomic) NSString *linkUrl2; </div><div class=\"line\">@property(retain, nonatomic) NSMutableArray *mediaList;</div></pre></td></tr></table></figure>\n<p>在LLDB打印出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po [[$x0 valueForKey:@&quot;contentObj&quot;] linkUrl]</div><div class=\"line\">https://support.weixin.qq.com/cgi-bin/mmsupport-bin/readtemplate?t=page/common_page__upgrade&amp;v=1</div><div class=\"line\">(lldb) po [[$x0 valueForKey:@&quot;contentObj&quot;] linkUrl2]</div><div class=\"line\"> nil</div><div class=\"line\">(lldb) po [[$x0 valueForKey:@&quot;contentObj&quot;] mediaList]</div><div class=\"line\">&lt;__NSArrayM 0x15f985e10&gt;(</div><div class=\"line\">&lt;WCMediaItem: 0x15dfebdf0&gt;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>mediaList数组里面有一个WCMediaItem对象，Media一般用来表示视频和音频，大胆猜测就是它了！赶紧找到头文件搜索一遍。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property(retain, nonatomic) WCUrl *dataUrl;</div><div class=\"line\">- (id)pathForData;</div><div class=\"line\">- (id)pathForSightData;</div><div class=\"line\">- (id)pathForTempAttachVideoData;</div><div class=\"line\">- (id)videoStreamForData;</div></pre></td></tr></table></figure>\n<p>上面这些属性和方法中<code>pathForSightData</code>是最有可能拿到小视频路径的，继续验证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] dataUrl]</div><div class=\"line\">type[1], url[http://vweixinf.tc.qq.com/102/20202/snsvideodownload?filekey=30270201010420301e020166040253480410d14adcddf086f4e131d11a5b1cca1bdf0203039fa00400&amp;bizid=1023&amp;hy=SH&amp;fileparam=302c0201010425302302040fde55e20204580ebd3602024eea02031e8d7d02030f42400204d970370a0201000400], enckey[0], encIdx[-1], token[]</div><div class=\"line\">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] pathForData]</div><div class=\"line\">/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45</div><div class=\"line\">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] pathForSightData]</div><div class=\"line\">/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45.mp4</div><div class=\"line\">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] pathForAttachVideoData]</div><div class=\"line\"> nil</div><div class=\"line\">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] videoStreamForData]</div><div class=\"line\"> nil</div></pre></td></tr></table></figure>\n<p>拿到小视频的网络url和本地路径了！这里可以用iFunBox或者scp从沙盒拷贝这个文件看看是不是这个cell应该播放的小视频。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ scp root@192.168.0.115:/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45.mp4 Desktop/</div><div class=\"line\">8fb0cdd77208de5b56169fb3458b45.mp4                100%  232KB 231.9KB/s   00:00</div></pre></td></tr></table></figure>\n<p>用QuickTime打开发现果然是我们要寻找的小视频。再验证一下url是否正确，把上面打印的dataUrl在浏览器中打开，发现也是这个小视频。分析这个类可以得出下面的结论：  </p>\n<ul>\n<li><strong>dataUrl：</strong>小视频的网络url</li>\n<li><strong>pathForData：</strong>小视频的本地路径</li>\n<li><strong>pathForSightData：</strong>小视频的本地路径（不带后缀）</li>\n</ul>\n<p>至此小视频的路径和取得方式分析已经完成，要实现转发还要继续分析微信的朋友圈发布。</p>\n<h2 id=\"二、实现转发功能\"><a href=\"#二、实现转发功能\" class=\"headerlink\" title=\"二、实现转发功能\"></a>二、实现转发功能</h2><h3 id=\"1-“走进死胡同”\"><a href=\"#1-“走进死胡同”\" class=\"headerlink\" title=\"1.“走进死胡同”\"></a>1.“走进死胡同”</h3><blockquote>\n<p>   这节是我在找小视频转发功能时走的弯路，扒到最后并没有找到实现方法，不过也提供了一些逆向中常用的思路和方法，不想看的可以跳到第二节。  </p>\n</blockquote>\n<h4 id=\"（1）找到小视频拍摄完成调用的方法名称\"><a href=\"#（1）找到小视频拍摄完成调用的方法名称\" class=\"headerlink\" title=\"（1）找到小视频拍摄完成调用的方法名称\"></a>（1）找到小视频拍摄完成调用的方法名称</h4><p>打开小视频的拍摄界面，用cycript注入，我们要找到发布小视频的方法是哪个，然后查看当前的窗口有哪些window（因为小视频的拍摄并不是在UIApplication的keyWindow中进行的）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [UIApp windows].toString()</div><div class=\"line\">(</div><div class=\"line\">    &quot;&lt;iConsoleWindow: 0x125f75e20; baseClass = UIWindow; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x125f77b70&gt;; layer = &lt;UIWindowLayer: 0x125df4810&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;SvrErrorTipWindow: 0x127414d40; baseClass = UIWindow; frame = (0 64; 320 45); hidden = YES; gestureRecognizers = &lt;NSArray: 0x12740d930&gt;; layer = &lt;UIWindowLayer: 0x1274030b0&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;MMUIWindow: 0x127796440; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x1278083c0&gt;; layer = &lt;UIWindowLayer: 0x127796750&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;UITextEffectsWindow: 0x1270e0d40; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = &lt;UIWindowLayer: 0x1270b4ba0&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;NewYearActionSheet: 0x127797e10; baseClass = UIWindow; frame = (0 0; 320 568); hidden = YES; userInteractionEnabled = NO; layer = &lt;UIWindowLayer: 0x1277d5490&gt;&gt;&quot;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>发现当前页面一共有5个window，其中MMUIWindow是小视频拍摄所在的window，打印它的UI树状结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [#0x127796440 recursiveDescription]</div></pre></td></tr></table></figure>\n<p>打印结果比较长，不贴了。找到这个按钮是拍摄小视频的按钮</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">|    |    |    |    |    | &lt;UIButton: 0x1277a9d70; frame = (89.5 368.827; 141 141); opaque = NO; gestureRecognizers = &lt;NSArray: 0x1277aaeb0&gt;; layer = &lt;CALayer: 0x1277a9600&gt;&gt;</div><div class=\"line\">|    |    |    |    |    |    | &lt;UIView: 0x1277aa0a0; frame = (0 0; 141 141); userInteractionEnabled = NO; tag = 252707333; layer = &lt;CALayer: 0x1277aa210&gt;&gt;</div><div class=\"line\">|    |    |    |    |    |    |    | &lt;UIImageView: 0x1277aa2e0; frame = (0 0; 141 141); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1277aa490&gt;&gt;</div></pre></td></tr></table></figure>\n<p>然后执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [#0x1277a9d70 setHidden:YES]</div></pre></td></tr></table></figure>\n<p>发现拍摄的按钮消失了，验证了我的猜想。寻找按钮的响应事件，可以通过target来寻找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [#0x1277a9d70 allTargets]</div><div class=\"line\">[NSSet setWithArray:@[#&quot;&lt;MainFrameSightViewController: 0x1269a4600&gt;&quot;]]]</div><div class=\"line\">cy# [#0x1277a9d70 allControlEvents]</div><div class=\"line\">193</div><div class=\"line\">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:193]</div><div class=\"line\">null</div></pre></td></tr></table></figure>\n<p>发现按钮并没有对应的action，这就奇怪了！UIButton必须要有target和action，不然这个Button不能响应事件。我们试试其他的ControlEvent</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchDown]</div><div class=\"line\">@[&quot;btnPress&quot;]</div><div class=\"line\">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchUpOutside]</div><div class=\"line\">@[&quot;btnRelease&quot;]</div><div class=\"line\">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchUpInside]</div><div class=\"line\">@[&quot;btnRelease&quot;]</div></pre></td></tr></table></figure>\n<p>结果发现这三个ContrlEvent有对应的action，我们再看看这三个枚举的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef enum UIControlEvents : NSUInteger &#123;</div><div class=\"line\">    UIControlEventTouchDown = 1 &lt;&lt;  0,</div><div class=\"line\">    UIControlEventTouchDownRepeat = 1 &lt;&lt;  1,</div><div class=\"line\">    UIControlEventTouchDragInside = 1 &lt;&lt;  2,</div><div class=\"line\">    UIControlEventTouchDragOutside = 1 &lt;&lt;  3,</div><div class=\"line\">    UIControlEventTouchDragEnter = 1 &lt;&lt;  4,</div><div class=\"line\">    UIControlEventTouchDragExit = 1 &lt;&lt;  5,</div><div class=\"line\">    UIControlEventTouchUpInside = 1 &lt;&lt;  6,</div><div class=\"line\">    UIControlEventTouchUpOutside = 1 &lt;&lt;  7,</div><div class=\"line\">    UIControlEventTouchCancel = 1 &lt;&lt;  8,</div><div class=\"line\">\t......</div><div class=\"line\">&#125; UIControlEvents;</div></pre></td></tr></table></figure>\n<p>可以看出来UIControlEventTouchDown对应1，UIControlEventTouchUpInside对应128，UIControlEventTouchUpOutside对应64，三者相加正好193！原来调用<code>[#0x1277a9d70 allControlEvents]</code>的时候返回的应该是枚举，有多个枚举则把它们的值相加，是不是略坑？我也是这样觉得的！刚才我们把三种ControlEvent对应的action都打印出来了，继续LLDB+IDA进行动态分析。</p>\n<h4 id=\"（2）找到小视频拍摄完成跳转到发布界面的方法\"><a href=\"#（2）找到小视频拍摄完成跳转到发布界面的方法\" class=\"headerlink\" title=\"（2）找到小视频拍摄完成跳转到发布界面的方法\"></a>（2）找到小视频拍摄完成跳转到发布界面的方法</h4><p>因为要找到小视频发布的方法，所以对应的<code>btnPress</code>函数我们并不关心，把重点放在<code>btnRelease</code>上面，拍摄按钮松开后就会调用的方法。在IDA中找到这个方法<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-btnRelease.png\" alt=\"MainFrameSightViewController - (void)btnRelease\"><br>找到之后下个断点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a 0xac000+0x10209369C</div><div class=\"line\">Breakpoint 4: where = WeChat`___lldb_unnamed_symbol108894$$WeChat + 32, address = 0x000000010213f69c</div><div class=\"line\">Process 3813 stopped</div><div class=\"line\">* thread #1: tid = 0xf1ef0, 0x000000010213f69c WeChat`___lldb_unnamed_symbol108894$$WeChat + 32, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 4.1</div><div class=\"line\">    frame #0: 0x000000010213f69c WeChat`___lldb_unnamed_symbol108894$$WeChat + 32</div><div class=\"line\">WeChat`___lldb_unnamed_symbol108894$$WeChat:</div><div class=\"line\">-&gt;  0x10213f69c &lt;+32&gt;: bl     0x1028d0b60               ; symbol stub for: objc_msgSend</div><div class=\"line\">    0x10213f6a0 &lt;+36&gt;: cmp    w0, #2                    ; =2 </div><div class=\"line\">    0x10213f6a4 &lt;+40&gt;: b.ne   0x10213f6dc               ; &lt;+96&gt;</div><div class=\"line\">    0x10213f6a8 &lt;+44&gt;: adrp   x8, 5489</div></pre></td></tr></table></figure>\n<p>用手机拍摄小视频然后松开，触发了断点，说明我们的猜想是正确的。继续分析发现代码是从上图的右边走的，看了一下没有什么方法是跳转到发布视频的，不过仔细看一下有一个block，是系统的延时block，位置在0x102093760。然后我们跟着断点进去，在0x1028255A0跳转到x16所存的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) si</div><div class=\"line\">Process 3873 stopped</div><div class=\"line\">* thread #1: tid = 0xf62c4, 0x00000001028d9598 WeChat`dispatch_after, queue = &apos;com.apple.main-thread&apos;, stop reason = instruction step into</div><div class=\"line\">    frame #0: 0x00000001028d9598 WeChat`dispatch_after</div><div class=\"line\">WeChat`dispatch_after:</div><div class=\"line\">-&gt;  0x1028d9598 &lt;+0&gt;: adrp   x16, 1655</div><div class=\"line\">    0x1028d959c &lt;+4&gt;: ldr    x16, [x16, #1056]</div><div class=\"line\">    0x1028d95a0 &lt;+8&gt;: br     x16</div><div class=\"line\"></div><div class=\"line\">WeChat`dispatch_apply:</div><div class=\"line\">    0x1028d95a4 &lt;+0&gt;: adrp   x16, 1655</div><div class=\"line\">(lldb) po $x2</div><div class=\"line\">&lt;__NSStackBlock__: 0x16fd49f88&gt;</div></pre></td></tr></table></figure>\n<p>发现传入的参数x2是一个block，我们再回顾一下dispatch_after函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>\n<p>这个函数有三个参数，分别是dispatch_time_t、dispatch_queue_t、dispatch_block_t，那这里打印的x2就是要传入的block，所以我们猜测拍摄完小视频会有一个延时，然后执行刚才传入的block，所以x2中肯定有其他方法调用，下一步就是要知道这个block的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) memory read --size 8 --format x 0x16fd49f88</div><div class=\"line\">0x16fd49f88: 0x000000019f8fd218 0x00000000c2000000</div><div class=\"line\">0x16fd49f98: 0x000000010214777c 0x0000000102fb0e60</div><div class=\"line\">0x16fd49fa8: 0x000000015da32600 0x000000015ea1a430</div><div class=\"line\">0x16fd49fb8: 0x000000015cf5fee0 0x000000016fd49ff0</div></pre></td></tr></table></figure>\n<p>0x000000010214777c就是block所在的位置，当然要减掉当前WeChat的ASLR偏移，最终在IDA中的地址为0x10209377C，突然发现这就是<code>btnRelease</code>的子程序sub_10209377C。这个子程序非常简单，只有一个方法<code>selRef_logicCheckState_</code>有可能是我们的目标。先看看这个方法是谁调用的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a 0xb4000+0x1020937BC</div><div class=\"line\">......</div><div class=\"line\">Process 3873 stopped</div><div class=\"line\">* thread #1: tid = 0xf62c4, 0x00000001021477bc WeChat`___lldb_unnamed_symbol108895$$WeChat + 64, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 3.1</div><div class=\"line\">    frame #0: 0x00000001021477bc WeChat`___lldb_unnamed_symbol108895$$WeChat + 64</div><div class=\"line\">WeChat`___lldb_unnamed_symbol108895$$WeChat:</div><div class=\"line\">-&gt;  0x1021477bc &lt;+64&gt;: adrp   x8, 5489</div><div class=\"line\">    0x1021477c0 &lt;+68&gt;: ldr    x1, [x8, #1552]</div><div class=\"line\">    0x1021477c4 &lt;+72&gt;: orr    w2, wzr, #0x1</div><div class=\"line\">    0x1021477c8 &lt;+76&gt;: ldp    x29, x30, [sp, #16]</div><div class=\"line\">(lldb) po $x0</div><div class=\"line\">&lt;MainFrameSightViewController: 0x15d1f0c00&gt;</div></pre></td></tr></table></figure>\n<p>发现还是MainFrameSightViewController这个对象调用的，那<code>selRef_logicCheckState_</code>肯定也在这个类的头文件中，寻找一下果然发现了  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)logicCheckState:(int)arg1;</div></pre></td></tr></table></figure>\n<p>在IDA左侧窗口中寻找[MainFrameSightViewController logicCheckState:]，发现这个方法超级复杂，逻辑太多了，不着急慢慢捋。<br>在0x102094D6C位置我们发现一个switch jump，思路就很清晰了，我们只要找到小视频拍摄完成的这条线往下看就行了，LLDB来帮忙看看走的那条线。在0x102094D6C位置下个断点，这个断点在拍摄小视频的时候会多次触发，可以在拍摄之前把断点dis掉，拍摄松手之前再启用断点，打印此时的x8值  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) p/x $x8</div><div class=\"line\">(unsigned long) $38 = 0x0000000102174e10</div></pre></td></tr></table></figure>\n<p>x8是一个指针，它指向的地址是0x102174e10，用这个地址减去当前ASLR的偏移就可以找到在IDA中的基地址，发现是0x102094E10，拍摄完成的逻辑处理这条线找到了，一直走到0x102094E24位置之后跳转0x1020951C4，这个分支的内容较少，里面有三个函数  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">loc_1020951C4</div><div class=\"line\">ADRP            X8, #selRef_hideTips@PAGE</div><div class=\"line\">LDR             X1, [X8,#selRef_hideTips@PAGEOFF]</div><div class=\"line\">MOV             X0, X19</div><div class=\"line\">BL              _objc_msgSend</div><div class=\"line\">ADRP            X8, #selRef_finishWriter@PAGE</div><div class=\"line\">LDR             X1, [X8,#selRef_finishWriter@PAGEOFF]</div><div class=\"line\">MOV             X0, X19</div><div class=\"line\">BL              _objc_msgSend</div><div class=\"line\">ADRP            X8, #selRef_turnCancelBtnForFinishRecording@PAGE</div><div class=\"line\">LDR             X1, [X8,#selRef_turnCancelBtnForFinishRecording@PAGEOFF]</div><div class=\"line\">MOV             X0, X19</div><div class=\"line\">BL              _objc_msgSend</div><div class=\"line\">B               loc_102095288</div></pre></td></tr></table></figure>\n<p>其中<code>selRef_finishWriter</code>和<code>selRef_turnCancelBtnForFinishRecording</code>需要重点关注，这两个方法看上去都是小视频录制结束的意思，线索极有可能就在这两个函数中。通过查看调用者发现这两个方法都属于MainFrameSightViewController，继续在IDA中查看这两个方法。在<code>selRef_finishWriter</code>中靠近末尾0x102094248的位置发现一个方法名叫做<code>f_switchToSendingPanel</code>，下个断点，然后拍摄视频，发现这个方法并没有被触发。应该不是通过这个方法调用发布界面的，继续回到<code>selRef_finishWriter</code>方法中；在0x1020941DC的位置调用方法<code>selRef_stopRecording</code>，打印它的调用者发现这个方法属于<code>SightFacade</code>，继续在IDA中寻找这个方法的实现。在这个方法的0x101F9BED4位置又调用了<code>selRef_stopRecord</code>，同样打印调用者发现这个方法属于SightCaptureLogicF4，有点像剥洋葱，继续在寻找这个方法的实现。在这个方法内部0x101A98778位置又调用了<code>selRef_finishWriting</code>，同样的原理找到这个方法是属于SightMovieWriter。已经剥了3层了，继续往下：<br>在<code>SightMovieWriter - (void)finishWriting</code>中的0x10261D004位置分了两条线，这个位置下个断点，然后拍摄完小视频触发断点，打印x19的值  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x19</div><div class=\"line\">&lt;OS_dispatch_queue: CAPTURE.CALLBACK[0x13610bcd0] = &#123; xrefcnt = 0x4, refcnt = 0x4, suspend_cnt = 0x0, locked = 1, target = com.apple.root.default-qos.overcommit[0x1a0aa3700], width = 0x0, running = 0x0, barrier = 1 &#125;&gt;</div></pre></td></tr></table></figure>\n<p>所以代码不会跳转到loc_10261D054而是走的左侧，在左侧的代码中发现启用了一个block，这个block是子程序sub_10261D0AC，地址为0x10261D0AC，找到这个地址，结构如下图所示：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91sub_10261D0AC.png\" alt=\"sub_10261D0AC\"><br>可以看出来主要分两条线，我们在第一个方框的末尾也就是0x10261D108位置下个断点，等拍摄完毕触发断点之后打印x0的值为1，这里的汇编代码为  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">__text:000000010261D104                 CMP             X0, #2</div><div class=\"line\">__text:000000010261D108                 B.EQ            loc_10261D234</div></pre></td></tr></table></figure>\n<p>B.EQ是在上一步的结果为0才会跳转到loc_10261D234，但是这里的结果是不为0的，将x0的值改为2让上一步的结果为0  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x0</div><div class=\"line\">1</div><div class=\"line\">(lldb) register write $x0 2</div><div class=\"line\">(lldb) po $x0</div><div class=\"line\">2</div></pre></td></tr></table></figure>\n<p>此时放开断点，等待跳转到小视频发布界面，结果是一直卡在这个界面没有任何反应，所以猜测实现跳转的逻辑应该在右边的那条线，继续顺着右边的线寻找：<br>在右侧0x10261D3AC位置发现调用了下面的这个方法  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)finishWritingWithCompletionHandler:(void (^)(void))handler;</div></pre></td></tr></table></figure>\n<p>这个方法是系统提供的AVAssetWriter里面的方法，在视频写入完成之后要做的操作，这个里是要传入一个block的，因为只有一个参数所以对应的变量是x2，打印x2的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x2</div><div class=\"line\">&lt;__NSStackBlock__: 0x16e086c78&gt;</div><div class=\"line\">(lldb) memory read --size 8 --format x 0x16e086c78</div><div class=\"line\">0x16e086c78: 0x00000001a0aa5218 0x00000000c2000000</div><div class=\"line\">0x16e086c88: 0x00000001026d94b0 0x0000000102fc98c0</div><div class=\"line\">0x16e086c98: 0x0000000136229fd0 0x000000016e086d00</div><div class=\"line\">0x16e086ca8: 0x00000001997f5318 0xfffffffec9e882ff</div></pre></td></tr></table></figure>\n<p>并且通过栈内存找到block位置为0x10261D4B0（需要减去ASLR的偏移）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">sub_10261D4B0</div><div class=\"line\">var_20= -0x20</div><div class=\"line\">var_10= -0x10</div><div class=\"line\">STP             X20, X19, [SP,#var_20]!</div><div class=\"line\">STP             X29, X30, [SP,#0x20+var_10]</div><div class=\"line\">ADD             X29, SP, #0x20+var_10</div><div class=\"line\">MOV             X19, X0</div><div class=\"line\">LDR             X0, [X19,#0x20]</div><div class=\"line\">ADRP            X8, #selRef_stopAmr@PAGE</div><div class=\"line\">LDR             X1, [X8,#selRef_stopAmr@PAGEOFF]</div><div class=\"line\">BL              _objc_msgSend</div><div class=\"line\">LDR             X0, [X19,#0x20]</div><div class=\"line\">ADRP            X8, #selRef_compressAudio@PAGE</div><div class=\"line\">LDR             X1, [X8,#selRef_compressAudio@PAGEOFF]</div><div class=\"line\">LDP             X29, X30, [SP,#0x20+var_10]</div><div class=\"line\">LDP             X20, X19, [SP+0x20+var_20],#0x20</div><div class=\"line\">B               _objc_msgSend</div><div class=\"line\">; End of function sub_10261D4B0</div></pre></td></tr></table></figure>\n<p>只调用了两个方法，一个是<code>selRef_stopAmr</code>停止amr（一种音频格式），另一个是<code>selRef_compressAudio</code>压缩音频，拍摄完成的下一步操作应该不会放在这两个方法里面，找了这么久也没有头绪，这个路看来走不通了，不要钻牛角尖，战略性撤退寻找其他入口。<br><strong>逆向的乐趣就是一直寻找真相的路上，能体会到成功的乐趣，也有可能方向错了离真相反而越来越远，不要气馁调整方向继续前进！</strong></p>\n<h3 id=\"2-“另辟蹊径”\"><a href=\"#2-“另辟蹊径”\" class=\"headerlink\" title=\"2.“另辟蹊径”\"></a>2.“另辟蹊径”</h3><blockquote>\n<p>（由于微信在后台偷偷升级了，下面的内容都是微信6.3.30版本的ASLR，上面的分析基于6.3.28版本）</p>\n</blockquote>\n<p>注意到在点击朋友圈右上角的相机按钮底部会弹出一个Sheet，第一个就是Sight小视频，从这里入手，用cycript查看Sight按钮对应的事件是哪个  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">iPhone-5S:~ root# cycript -p &quot;WeChat&quot;</div><div class=\"line\">cy# [UIApp windows].toString()</div><div class=\"line\">`(</div><div class=\"line\">    &quot;&lt;iConsoleWindow: 0x14d6ccc00; baseClass = UIWindow; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x14d7df110&gt;; layer = &lt;UIWindowLayer: 0x14d7d6f60&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;SvrErrorTipWindow: 0x14eaa5800; baseClass = UIWindow; frame = (0 0; 320 45); hidden = YES; gestureRecognizers = &lt;NSArray: 0x14e9e8950&gt;; layer = &lt;UIWindowLayer: 0x14e9e6510&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;UITextEffectsWindow: 0x14ec38ba0; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = &lt;UIWindowLayer: 0x14ec39360&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;UITextEffectsWindow: 0x14e9c67a0; frame = (0 0; 320 568); layer = &lt;UIWindowLayer: 0x14d683ff0&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;UIRemoteKeyboardWindow: 0x14f226e40; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = &lt;UIWindowLayer: 0x14d6f4de0&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;NewYearActionSheet: 0x14f1704a0; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x14ef9bf90&gt;; layer = &lt;UIWindowLayer: 0x14ef61a20&gt;&gt;&quot;</div><div class=\"line\">)`</div><div class=\"line\">cy# [#0x14f1704a0 recursiveDescription].toString()</div></pre></td></tr></table></figure>\n<p>底部的Sheet是NewYearActionSheet，然后打印NewYearActionSheet的UI树状结构图（比较长不贴了）。然后找到Sight对应的UIButton是0x14f36d470   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [#0x14f36d470 allTargets]</div><div class=\"line\">[NSSet setWithArray:@[#&quot;&lt;NewYearActionSheet: 0x14f1704a0; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x14ef9bf90&gt;; layer = &lt;UIWindowLayer: 0x14ef61a20&gt;&gt;&quot;]]]</div><div class=\"line\">cy# [#0x14f36d470 allControlEvents]</div><div class=\"line\">64</div><div class=\"line\">cy# [#0x14f36d470 actionsForTarget:#0x14f1704a0 forControlEvent:64]</div><div class=\"line\">@[&quot;OnDefaultButtonTapped:&quot;]</div></pre></td></tr></table></figure>\n<p>通过UIControl的<code>actionsForTarget:forControlEvent:</code>方法可以找到按钮绑定的事件，Sight按钮的触发方法为<code>OnDefaultButtonTapped:</code>，回到IDA中在NewYearActionSheet中找到这个方法们继续往下分析只有这个方法<code>selRef_dismissWithClickedButtonIndex_animated</code>，通过打印它的调用者发现还是NewYearActionSheet，继续点进去找到<code>newYearActionSheet_clickedButtonAtIndex</code>方法，看样子不是NewYearActionSheet自己的，打印调用者x0发现它属于类WCTimeLineViewController。跟着断点走下去在0x1012B78CC位置调用了方法<code>#selRef_showSightWindowForMomentWithMask_byViewController_scene</code><br>通过观察发现这个方法的调用者是0x1012B78AC这个位置的返回值x0，这是一个类SightFacade，猜测这个方法在SightFacade里面，去头文件里找一下果然发现这个方法  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)showSightWindowForMomentWithMask:(id)arg1 byViewController:(id)arg2 scene:(int)arg3;</div></pre></td></tr></table></figure>\n<p>这个方法应该就是跳转到小视频界面的方法了。下面分别打印它的参数  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x2</div><div class=\"line\">&lt;UIImage: 0x14f046660&gt;, &#123;320, 568&#125;</div><div class=\"line\">(lldb) po $x3</div><div class=\"line\">&lt;WCTimeLineViewController: 0x14e214800&gt;</div><div class=\"line\">(lldb) po $x4</div><div class=\"line\">2</div><div class=\"line\">(lldb) po $x0</div><div class=\"line\">&lt;SightFacade: 0x14f124b40&gt;</div></pre></td></tr></table></figure>\n<p>其中x2、x3、x4分别对应三个参数，x0是调用者，跳到这个方法内部查看怎么实现的。发现在这个方法中进行了小视频拍摄界面的初始化工作，首先初始化一个MainFrameSightViewController，再创建一个UINavigationController将MainFrameSightViewController放进去，接下来初始化一个MMWindowController调用  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (id)initWithViewController:(id)arg1 windowLevel:(int)arg2;</div></pre></td></tr></table></figure>\n<p>方法将UINavigationController放了进去，完成小视频拍摄界面的所有UI创建工作。<br>拍摄完成之后进入发布界面，此时用cycript找到当前的Controller是SightMomentEditViewController，由此萌生一个想法，跳过前面的拍摄界面直接进入发布界面不就可以了吗？我们自己创建一个SightMomentEditViewController然后放到UINavigationController里面，然后再将这个导航控制器放到MMWindowController里面。<strong>（这里我已经写好tweak进行了验证，具体的tweak思路编写在后文有）</strong>结果是的确可以弹出发布的界面，但是导航栏的NavgationBar遮住了原来的，整个界面是透明的，很难看，而且发布完成之后无法销毁整个MMWindowController，还是停留在发布界面。我们要的结果不是这个，不过确实有很大的收获，最起码可以直接调用发布界面了，小视频也能正常转发。我个人猜测，当前界面不能被销毁的原因是因为MMWindowController新建了一个window,它跟TimeLine所在的keyWindow不是同一个，SightMomentEditViewController的按钮触发的方法是没有办法销毁这个window的，所以有一个大胆的猜想，我直接在当前的WCTimeLineViewController上把SightMomentEditViewController展示出来不就可以了吗？  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[WCTimelineVC presentViewController:editSightVC animated:YES completion:^&#123;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>像这样展示岂不妙哉？不过通过观察SightMomentEditViewController的头文件，结合小视频发布时界面上的元素，推测创建这个控制器至少需要两个属性，一个是小视频的路径，另一个是小视频的缩略图，将这两个关键属性给了SightMomentEditViewController那么应该就可以正常展示了   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">SightMomentEditViewController *editSightVC = [[%c(SightMomentEditViewController) alloc] init];</div><div class=\"line\">NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</div><div class=\"line\">UIImage *image = [[self valueForKey:@&quot;_sightView&quot;] getImage];</div><div class=\"line\">[editSightVC setRealMoviePath:localPath];</div><div class=\"line\">[editSightVC setMoviePath:localPath];</div><div class=\"line\">[editSightVC setRealThumbImage:image];</div><div class=\"line\">[editSightVC setThumbImage:image];</div><div class=\"line\">[WCTimelineVC presentViewController:editSightVC animated:YES completion:^&#123;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>小视频的发布界面可以正常显示并且所有功能都可以正常使用，唯一的问题是返回按钮没有效果，并不能销毁SightMomentEditViewController。用cycript查看左侧按钮的actionEvent找到它的响应函数是<code>- (void)popSelf;</code>，点击左侧返回触发的是pop方法，但是这个控制器并不在navgationController里面，所以无效，我们要对这个方法进行重写  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)popSelf</div><div class=\"line\">&#123;</div><div class=\"line\">    [self dismissViewControllerAnimated:YES completion:^&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>此时再点击返回按钮就可以正常退出了，此外，在WCContentItemViewTemplateNewSight中发现了一个方法叫做<code>- (void)sendSightToFriend;</code>，可以直接将小视频转发给好友，至此小视频转发的功能已经找到了。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>此文为逆向微信二进制文件，实现朋友圈小视频转发的教程，从最开始的汇编代码入手到最后重签名安装等操作，手把手教你玩转微信！学会之后再去逆向微信其他功能易如反掌。<br>本篇文章由于篇幅太长分成了两篇，<strong>上篇</strong>讲解的是逆向工作，也就是怎么找到相关的函数和方法实现，<strong>下篇</strong>讲解的是怎么在非越狱机重签名安装和越狱机tweak安装的详细过程。<br><strong>正文的第二部分还提供了微信自动抢红包、修改微信步数的代码，这些都可以照葫芦画瓢按照本文的套路一步步逆向找到，这里就不再赘述。</strong><br>在实践之前，需要准备好一部越狱的手机，然后将下文列出的所有工具安装好。IDA跟Reveal都是破解版，IDA的正版要2000多刀，对于这么牛逼的逆向工具确实物有所值，不过不是专门研究逆向的公司也没必要用正版的，下个Windows的破解版就好，Mac上暂时没找到。Mac上可以用hopper代替IDA，也是一款很牛逼的逆向工具。废话不多说，正式开始吧！</p>","more":"<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<h1 id=\"逆向微信朋友圈（上篇）\"><a href=\"#逆向微信朋友圈（上篇）\" class=\"headerlink\" title=\"逆向微信朋友圈（上篇）\"></a>逆向微信朋友圈（上篇）</h1><h2 id=\"一、获取朋友圈的小视频\"><a href=\"#一、获取朋友圈的小视频\" class=\"headerlink\" title=\"一、获取朋友圈的小视频\"></a>一、获取朋友圈的小视频</h2><blockquote>\n<p>   注意：本文逆向的微信的二进制文件为6.3.28版本，如果是不同的微信版本，二进制文件中的基地址也不相同</p>\n</blockquote>\n<h4 id=\"本文涉及到的工具\"><a href=\"#本文涉及到的工具\" class=\"headerlink\" title=\"本文涉及到的工具\"></a>本文涉及到的工具</h4><ol>\n<li><a href=\"http://www.cycript.org\" target=\"_blank\" rel=\"external\">cycript</a> </li>\n<li>LLDB与debugserver（Xcode自带）</li>\n<li>OpenSSH</li>\n<li>IDA</li>\n<li>Reveal</li>\n<li><a href=\"https://github.com/theos/theos\" target=\"_blank\" rel=\"external\">theos</a></li>\n<li><a href=\"http://www.cydiasubstrate.com\" target=\"_blank\" rel=\"external\">CydiaSubstrate</a></li>\n<li>iOSOpenDev</li>\n<li>ideviceinstaller</li>\n<li>tcprelay（本地端口映射，USB连接SSH，不映射可通过WiFi连接） </li>\n<li><a href=\"https://github.com/stefanesser/dumpdecrypted\" target=\"_blank\" rel=\"external\">dumpdecrypted</a></li>\n<li><a href=\"http://stevenygard.com/projects/class-dump/\" target=\"_blank\" rel=\"external\">class-dump</a> </li>\n<li><a href=\"https://github.com/DanTheMan827/ios-app-signer\" target=\"_blank\" rel=\"external\">iOS App Signer</a></li>\n<li>编译好的<a href=\"https://github.com/gaoshilei/yololib\" target=\"_blank\" rel=\"external\">yololib</a></li>\n</ol>\n<p><strong>逆向环境为MacOS    +    iPhone5S 9.1越狱机</strong><br>先用dumpdecrypted给微信砸壳（不会的请我写的看<a href=\"http://www.gaoshilei.com/2016/08/08/dumpdecrypted给App砸壳/\">这篇教程</a>），获得一个WeChat.decrypted文件，先把这个文件扔到IDA中分析（60MB左右的二进制文件，IDA差不多40分钟才能分析完），用class-dump导出所有头文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ class-dump -S -s -H /Users/gaoshilei/Desktop/reverse/binary_for_class-dump/WeChat.decrypted -o /Users/gaoshilei/Desktop/reverse/binary_for_class-dump/class-Header/WeChat</div></pre></td></tr></table></figure>\n<p>我滴个亲娘！一共有8000个头文件，微信果然工程量浩大！稳定一下情绪，理一理思路继续搞。要取得小视频的下载链接，找到播放视频的View，顺藤摸瓜就能找到小视频的URL。用Reveal查看小视频的播放窗口<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91Reveal.png\" alt=\"Reveal\"><br>可以看出来WCContentItemViewTemplateNewSigh这个对象是小视频的播放窗口，它的subView有WCSightView，SightView、SightPlayerView，这几个类就是我们的切入点。<br>保存视频到favorite的时候是长按视频弹出选项的，那么在WCContentItemViewTemplateNewSight这个类里面可能有手势相关的方法，去刚才导出的头文件中找线索。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)onLongTouch;</div><div class=\"line\">- (void)onLongPressedWCSight:(id)arg1;</div><div class=\"line\">- (void)onLongPressedWCSightFullScreenWindow:(id)arg1;</div></pre></td></tr></table></figure>\n<p>这几个方法跟长按手势相关，再去IDA中找到这些函数，逐个查看。onLongPressedWCSight和onLongPressedWCSightFullScreenWindow都比较简单，onLongTouch比较长，而且发现了内部调用了方法Favorites_Add，因为长按视频的时候出来一个选项就是Favorites，并且我看到这个函数调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ADRP            X8, #selRef_sightVideoPath@PAGE</div><div class=\"line\">LDR             X1, [X8,#selRef_sightVideoPath@PAGEOFF]</div></pre></td></tr></table></figure>\n<p>这里拿到了小视频的地址，可以推测这个函数跟收藏有关，下面打断点测试。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) im li -o -f</div><div class=\"line\">[  0] 0x000000000003c000 /var/mobile/Containers/Bundle/Application/2F1D52EC-C57E-4F95-B715-EF04351232E8/WeChat.app/WeChat(0x000000010003c000)</div></pre></td></tr></table></figure>\n<p>可以看到WeChat的ASLR为0x3c000，在IDA查找到这三个函数的基地址，分别下断点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a 0x1020D3A10+0x3c000</div><div class=\"line\">Breakpoint 1: where = WeChat`___lldb_unnamed_symbol110094$$WeChat + 28, address = 0x000000010210fa10</div><div class=\"line\">(lldb) br s -a 0x1020D3370+0x3c000</div><div class=\"line\">Breakpoint 2: where = WeChat`___lldb_unnamed_symbol110091$$WeChat + 8, address = 0x000000010210f370</div><div class=\"line\">(lldb) br s -a 0x1020D33E4+0x3c000</div><div class=\"line\">Breakpoint 3: where = WeChat`___lldb_unnamed_symbol110092$$WeChat + 12, address = 0x000000010210f3e4</div></pre></td></tr></table></figure>\n<p>回到微信里面长按小视频，看断点触发情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Process 3721 stopped</div><div class=\"line\">* thread #1: tid = 0x658fc, 0x000000010210f370 WeChat`___lldb_unnamed_symbol110091$$WeChat + 8, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 2.1</div><div class=\"line\">    frame #0: 0x000000010210f370 WeChat`___lldb_unnamed_symbol110091$$WeChat + 8</div><div class=\"line\">WeChat`___lldb_unnamed_symbol110091$$WeChat:</div><div class=\"line\">-&gt;  0x10210f370 &lt;+8&gt;:  add    x29, sp, #16              ; =16 </div><div class=\"line\">    0x10210f374 &lt;+12&gt;: mov    x19, x0</div><div class=\"line\">    0x10210f378 &lt;+16&gt;: adrp   x8, 4968</div><div class=\"line\">    0x10210f37c &lt;+20&gt;: ldr    x0, [x8, #744]</div><div class=\"line\">(lldb) c</div><div class=\"line\">Process 3721 resuming</div><div class=\"line\">Process 3721 stopped</div><div class=\"line\">* thread #1: tid = 0x658fc, 0x000000010210fa10 WeChat`___lldb_unnamed_symbol110094$$WeChat + 28, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</div><div class=\"line\">    frame #0: 0x000000010210fa10 WeChat`___lldb_unnamed_symbol110094$$WeChat + 28</div><div class=\"line\">WeChat`___lldb_unnamed_symbol110094$$WeChat:</div><div class=\"line\">-&gt;  0x10210fa10 &lt;+28&gt;: add    x29, sp, #96              ; =96 </div><div class=\"line\">    0x10210fa14 &lt;+32&gt;: sub    sp, sp, #96               ; =96 </div><div class=\"line\">    0x10210fa18 &lt;+36&gt;: mov    x19, x0</div><div class=\"line\">    0x10210fa1c &lt;+40&gt;: adrp   x8, 4863</div><div class=\"line\">……</div></pre></td></tr></table></figure>\n<p>发现断点2先被触发，接着触发断点1，后面断点2和1又各触发了1次，断点3一直很安静。可以排除onLongPressedWCSightFullScreenWindow与收藏小视频的联系。小视频的踪影就要在剩下的两个方法中寻找了。通过V找到C，顺藤摸瓜找到M屡试不爽！用cycript注入WeChat，拿到播放小视频的view所在的Controller。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [#0x138c18030 nextResponder]</div><div class=\"line\">#&quot;&lt;WCTimeLineCellView: 0x138c34620; frame = (0 0; 319 249); tag = 1048577; layer = &lt;CALayer: 0x138362ba0&gt;&gt;&quot;</div><div class=\"line\">cy# [#0x138c34620 nextResponder]</div><div class=\"line\">#&quot;&lt;UITableViewCellContentView: 0x138223c70; frame = (0 0; 320 256); gestureRecognizers = &lt;NSArray: 0x1384ec480&gt;; layer = &lt;CALayer: 0x138081dc0&gt;&gt;&quot;</div><div class=\"line\">cy# [#0x138223c70 nextResponder]</div><div class=\"line\">#&quot;&lt;MMTableViewCell: 0x138c9f930; baseClass = UITableViewCell; frame = (0 307; 320 256); autoresize = W; layer = &lt;CALayer: 0x1382dcd10&gt;&gt;&quot;</div><div class=\"line\">cy# [#0x138c9f930 nextResponder]</div><div class=\"line\">#&quot;&lt;UITableViewWrapperView: 0x137b57800; frame = (0 0; 320 504); gestureRecognizers = &lt;NSArray: 0x1383db660&gt;; layer = &lt;CALayer: 0x138af20c0&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;320, 504&#125;&gt;&quot;</div><div class=\"line\">cy# [#0x137b57800 nextResponder]</div><div class=\"line\">#&quot;&lt;MMTableView: 0x137b8ae00; baseClass = UITableView; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x138adb590&gt;; layer = &lt;CALayer: 0x138956890&gt;; contentOffset: &#123;0, 99.5&#125;; contentSize: &#123;320, 3193&#125;&gt;&quot;</div><div class=\"line\">cy# [#0x137b8ae00 nextResponder]</div><div class=\"line\">#&quot;&lt;UIView: 0x138ade5c0; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x138ac9990&gt;&gt;&quot;</div><div class=\"line\">cy# [#0x138ade5c0 nextResponder]</div><div class=\"line\">#&quot;&lt;WCTimeLineViewController: 0x1379eb000&gt;&quot;</div></pre></td></tr></table></figure>\n<p>通过响应者链条找到<br>WCContentItemViewTemplateNewSight所属的Controller为WCTimeLineViewController。在这个类的头文件中并没有发现有价值的线索，不过我们注意到小视频所在的view是属于MMTableVIewCell的（见上图Reveal分析图），这是每一个iOS最熟悉的TableView，cell的数据是通过UITableViewDataSource的代理方法<code>- tableView:cellForRowAtIndexPath:</code>赋值的，通过这个方法肯定能知道到M的影子。在IDA中找到<code>[WCTimeLineViewController tableView:cellForRowAtIndexPath:]</code>,定位到基地址0x10128B6B0位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">__text:000000010128B6B0     ADRP     X8, #selRef_genNormalCell_indexPath_@PAGE</div></pre></td></tr></table></figure>\n<p>这里的函数是WCTimeLineViewController中生成cell的方法，除了这个方法在这个类中还有另外三个生成cell的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)genABTestTipCell:(id)arg1 indexPath:(id)arg2;</div><div class=\"line\">- (void)genRedHeartCell:(id)arg1 indexPath:(id)arg2;</div><div class=\"line\">- (void)genUploadFailCell:(id)arg1 indexPath:(id)arg2;</div></pre></td></tr></table></figure>\n<p>通过字面意思可以猜测出normal这个应该是生成小视频cell的方法。继续在IDA中寻找线索</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">__text:0000000101287CC8     ADRP     X8, #selRef_getTimelineDataItemOfIndex_@PAGE</div></pre></td></tr></table></figure>\n<p>在<code>genNormalCell:IndexPath:</code>方法中发现上面这个方法，可以大胆猜想这个方法是获取TimeLine（朋友圈）数据的方法，那小视频的数据肯定也是通过这个方法获取的，并且IDA可以看到这个方法中调用一个叫做<code>selRef_getTimelineDataItemOfIndex_</code>的方法，获取DataItem貌似就是cell的数据源啊！接下来用LLDB下断点验证猜想。<br>通过IDA可以找到这个方法对应的基地址为：0x101287CE4，先打印正在运行WeChat的ASLR偏移</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ lldb</div><div class=\"line\">(lldb) process connect connect://localhost:1234</div><div class=\"line\">(lldb) im li -o -f </div><div class=\"line\">[0] 0x0000000000050000 /var/mobile/Containers/Bundle/Application/2DCE8F30-9B6B-4652-901C-37EB1FF2A40D/WeChat.app/WeChat(0x0000000100050000)</div></pre></td></tr></table></figure>\n<p>所以我们下断点的位置是0x50000+0x101287CE4</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a 0x50000+0x101287CE4</div><div class=\"line\">Breakpoint 1: where = WeChat`___lldb_unnamed_symbol63721$$WeChat + 252, address = 0x00000001012d7ce4</div></pre></td></tr></table></figure>\n<p>打印x0的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x0</div><div class=\"line\">Class name: WCDataItem, addr: 0x15f5f03b0</div><div class=\"line\">tid: 12393001887435993280</div><div class=\"line\">username: wxid_z8twcz4o18fg12</div><div class=\"line\">createtime: 1477360950</div><div class=\"line\">commentUsers: (</div><div class=\"line\">)</div><div class=\"line\">contentObj: &lt;WCContentItem: 0x15f57d000&gt;</div></pre></td></tr></table></figure>\n<p>得到一个WCDataItem的对象，这里x0的值就是<code>selRef_getTimelineDataItemOfIndex_</code>执行完的返回值，然后把x0的值改掉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) register write $x0 0</div><div class=\"line\">(lldb) c</div></pre></td></tr></table></figure>\n<p>此时会发现我们要刷新的那条小视频内容全部为空<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91-%E8%BD%AC%E5%8F%91%E5%B0%8F%E8%A7%86%E9%A2%91%E4%B8%BA%E7%A9%BA.jpg\" alt=\"小视频内容为空\"><br>到这里已经找到了小视频的源数据获取方法，问题是我们怎么拿到这个WCDataItem呢？继续看IDA分析函数的调用情况：  </p>\n<blockquote>\n<p>   WCTimeLineViewController - (void)genNormalCell:(id) indexPath:(id)  </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\">__text:0000000101287BCC                 STP             X28, X27, [SP,#var_60]!</div><div class=\"line\">__text:0000000101287BD0                 STP             X26, X25, [SP,#0x60+var_50]</div><div class=\"line\">__text:0000000101287BD4                 STP             X24, X23, [SP,#0x60+var_40]</div><div class=\"line\">__text:0000000101287BD8                 STP             X22, X21, [SP,#0x60+var_30]</div><div class=\"line\">__text:0000000101287BDC                 STP             X20, X19, [SP,#0x60+var_20]</div><div class=\"line\">__text:0000000101287BE0                 STP             X29, X30, [SP,#0x60+var_10]</div><div class=\"line\">__text:0000000101287BE4                 ADD             X29, SP, #0x60+var_10</div><div class=\"line\">__text:0000000101287BE8                 SUB             SP, SP, #0x80</div><div class=\"line\">__text:0000000101287BEC                 MOV             X19, X3</div><div class=\"line\">__text:0000000101287BF0                 MOV             X22, X0</div><div class=\"line\">__text:0000000101287BF4                 MOV             W25, #0x100000</div><div class=\"line\">__text:0000000101287BF8                 MOVK            W25, #1</div><div class=\"line\">__text:0000000101287BFC                 MOV             X0, X2</div><div class=\"line\">__text:0000000101287C00                 BL              _objc_retain</div><div class=\"line\">__text:0000000101287C04                 MOV             X28, X0</div><div class=\"line\">__text:0000000101287C08                 MOV             X0, X19</div><div class=\"line\">__text:0000000101287C0C                 BL              _objc_retain</div><div class=\"line\">__text:0000000101287C10                 MOV             X20, X0</div><div class=\"line\">__text:0000000101287C14                 STR             X20, [SP,#0xE0+var_98]</div><div class=\"line\">__text:0000000101287C18                 ADRP            X8, #selRef_row@PAGE</div><div class=\"line\">__text:0000000101287C1C                 LDR             X1, [X8,#selRef_row@PAGEOFF]</div><div class=\"line\">__text:0000000101287C20                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287C24                 MOV             X26, X0</div><div class=\"line\">__text:0000000101287C28                 ADRP            X8, #selRef_section@PAGE</div><div class=\"line\">__text:0000000101287C2C                 LDR             X19, [X8,#selRef_section@PAGEOFF]</div><div class=\"line\">__text:0000000101287C30                 MOV             X0, X20</div><div class=\"line\">__text:0000000101287C34                 MOV             X1, X19</div><div class=\"line\">__text:0000000101287C38                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287C3C                 STR             X0, [SP,#0xE0+var_A8]</div><div class=\"line\">__text:0000000101287C40                 MOV             X0, X20</div><div class=\"line\">__text:0000000101287C44                 MOV             X1, X19</div><div class=\"line\">__text:0000000101287C48                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287C4C                 MOV             X2, X0</div><div class=\"line\">__text:0000000101287C50                 ADRP            X8, #selRef_calcDataItemIndex_@PAGE</div><div class=\"line\">__text:0000000101287C54                 LDR             X1, [X8,#selRef_calcDataItemIndex_@PAGEOFF]</div><div class=\"line\">__text:0000000101287C58                 MOV             X0, X22</div><div class=\"line\">__text:0000000101287C5C                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287C60                 MOV             X21, X0</div><div class=\"line\">__text:0000000101287C64                 STR             X21, [SP,#0xE0+var_C0]</div><div class=\"line\">__text:0000000101287C68                 ADRP            X8, #classRef_MMServiceCenter@PAGE</div><div class=\"line\">__text:0000000101287C6C                 LDR             X0, [X8,#classRef_MMServiceCenter@PAGEOFF]</div><div class=\"line\">__text:0000000101287C70                 ADRP            X8, #selRef_defaultCenter@PAGE</div><div class=\"line\">__text:0000000101287C74                 LDR             X1, [X8,#selRef_defaultCenter@PAGEOFF]</div><div class=\"line\">__text:0000000101287C78                 STR             X1, [SP,#0xE0+var_B8]</div><div class=\"line\">__text:0000000101287C7C                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287C80                 MOV             X29, X29</div><div class=\"line\">__text:0000000101287C84                 BL              _objc_retainAutoreleasedReturnValue</div><div class=\"line\">__text:0000000101287C88                 MOV             X19, X0</div><div class=\"line\">__text:0000000101287C8C                 ADRP            X8, #classRef_WCFacade@PAGE</div><div class=\"line\">__text:0000000101287C90                 LDR             X0, [X8,#classRef_WCFacade@PAGEOFF]</div><div class=\"line\">__text:0000000101287C94                 ADRP            X8, #selRef_class@PAGE</div><div class=\"line\">__text:0000000101287C98                 LDR             X1, [X8,#selRef_class@PAGEOFF]</div><div class=\"line\">__text:0000000101287C9C                 STR             X1, [SP,#0xE0+var_B0]</div><div class=\"line\">__text:0000000101287CA0                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287CA4                 MOV             X2, X0</div><div class=\"line\">__text:0000000101287CA8                 ADRP            X8, #selRef_getService_@PAGE</div><div class=\"line\">__text:0000000101287CAC                 LDR             X1, [X8,#selRef_getService_@PAGEOFF]</div><div class=\"line\">__text:0000000101287CB0                 STR             X1, [SP,#0xE0+var_A0]</div><div class=\"line\">__text:0000000101287CB4                 MOV             X0, X19</div><div class=\"line\">__text:0000000101287CB8                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287CBC                 MOV             X29, X29</div><div class=\"line\">__text:0000000101287CC0                 BL              _objc_retainAutoreleasedReturnValue</div><div class=\"line\">__text:0000000101287CC4                 MOV             X20, X0</div><div class=\"line\">__text:0000000101287CC8                 ADRP            X8, #selRef_getTimelineDataItemOfIndex_@PAGE</div><div class=\"line\">__text:0000000101287CCC                 LDR             X1, [X8,#selRef_getTimelineDataItemOfIndex_@PAGEOFF]</div><div class=\"line\">__text:0000000101287CD0                 STR             X1, [SP,#0xE0+var_C8]</div><div class=\"line\">__text:0000000101287CD4                 MOV             X2, X21</div><div class=\"line\">__text:0000000101287CD8                 BL              _objc_msgSend</div><div class=\"line\">__text:0000000101287CDC                 MOV             X29, X29</div><div class=\"line\">__text:0000000101287CE0                 BL              _objc_retainAutoreleasedReturnValue</div><div class=\"line\">__text:0000000101287CE4                 MOV             X21, X0</div><div class=\"line\">__text:0000000101287CE8                 MOV             X0, X20</div><div class=\"line\">......</div></pre></td></tr></table></figure>\n<p><code>selRef_getTimelineDataItemOfIndex_</code>传入的参数是x2，可以看到传值给x2的x21是函数<code>selRef_calcDataItemIndex_</code>的返回值，是一个unsigned long数据类型。继续分析，<code>selRef_getTimelineDataItemOfIndex_</code>函数的调用者是上一步<code>selRef_getService_</code>的返回值，经过断点分析发现是一个<code>WCFacade</code>对象。整理一下<code>selRef_getTimelineDataItemOfIndex_</code>的调用：<br><strong>调用者是<code>selRef_getService_</code>的返回值；参数是<code>selRef_calcDataItemIndex_</code>的返回值</strong><br>下面把目光转向那两个函数，用相同的原理分析它们各自怎么实现调用  </p>\n<ol>\n<li>先看<code>selRef_getService_</code>：<br>在0x101287CB4这个位置可以发现，这个函数的调用者是从通过x19 MOV的，打印x19发现是一个<code>MMServiceCenter</code>对象，往上找x19是在0x101287C88这个位置赋值的，结果很清晰x19是<code>[MMServiceCenter defaultCenter]</code>的返回值。<br>在0x101287CA4位置可以找到传入的参数x2，往上分析可以看出来它的参数是<code>[WCFacade class]</code>的返回值。  </li>\n<li>接着找<code>selRef_calcDataItemIndex_</code>：<br>在0x101287C58的位置找到它的调用者x0，x0通过x22赋值，继续向上寻找，发现在最上面0x101287BF0的位置，x22是x0赋值的，一开始的x0就是<code>WCTimeLineViewController</code>自身。<br>在0x101287C4C位置发现传入的参数来自x2,x2是通过上一步<code>selRef_section</code>函数的返回值x0赋值的，在0x101287C30位置可以发现<code>selRef_section</code>函数的调用者是x20赋值的，如下图所示，最终找到<code>selRef_section</code>的调用者是x3<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-selRef_section%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%80%85.png\" alt=\"selRef_section函数的调用者\"><br>x3就是函数<code>WCTimeLineViewController - (void)genNormalCell:(id) indexPath:(id)</code>的第二个参数indexPath,，所以<code>selRef_calcDataItemIndex_</code>的参数是<code>[IndexPath section]</code>。<br>对上面的分析结果做个梳理：<br>因此<code>getTimelineDataItemOfIndex:</code>的调用者可以通过</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[MMServiceCenter defaultCenter] getService:[WCFacade class]]</div></pre></td></tr></table></figure>\n<p>来获得,它的参数可以通过下面的函数获取</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[WCTimeLineViewController calcDataItemIndex:[indexPath section]]</div></pre></td></tr></table></figure>\n<p>总感觉还少点什么？indexPath我们还没拿到呢！下一步就是拿到indexPath,这个就比较简单了，因为我们位于<code>[WCContentItemViewTemplateNewSight onLongTouch]</code>中，所以可以通过<code>[self nextResponder]</code>依次拿到MMTableViewCell、MMTableView和WCTimeLineViewController，再通过<code>[MMTableView indexPathForCell:MMTableViewCell]</code>拿到indexPath。<br>做完这些，已经拿到WCDataItem对象，接下来的重点要放在WCDataItem上，最终要获取我们要的小视频。到这个类的头文件中找线索，因为视频是下载完成后才能播放的，所以这里应该拿到了视频的路径，所以要注意url和path相关的属性或方法，然后找到下面这几个嫌疑对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property(retain, nonatomic) NSString *sourceUrl2; </div><div class=\"line\">@property(retain, nonatomic) NSString *sourceUrl; </div><div class=\"line\">- (id)descriptionForKeyPaths;</div><div class=\"line\">- (id)keyPaths;</div></pre></td></tr></table></figure>\n<p>回到LLDB中，用断点打印这些值，看看有什么。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po [$x0 keyPaths]</div><div class=\"line\">&lt;__NSArrayI 0x15f74e9d0&gt;(</div><div class=\"line\">\ttid,</div><div class=\"line\">\tusername,</div><div class=\"line\">\tcreatetime,</div><div class=\"line\">\tcommentUsers,</div><div class=\"line\">\tcontentObj</div><div class=\"line\">)</div><div class=\"line\">(lldb) po [$x0 descriptionForKeyPaths]</div><div class=\"line\">Class name: WCDataItem, addr: 0x15f5f03b0</div><div class=\"line\">tid: 12393001887435993280</div><div class=\"line\">username: wxid_z8twcz4o18fg12</div><div class=\"line\">createtime: 1477360950</div><div class=\"line\">commentUsers: (</div><div class=\"line\">)</div><div class=\"line\">contentObj: &lt;WCContentItem: 0x15f57d000&gt;</div><div class=\"line\">(lldb) po [$x0 sourceUrl]</div><div class=\"line\"> nil</div><div class=\"line\">(lldb) po [$x0 sourceUrl2]</div><div class=\"line\"> nil</div></pre></td></tr></table></figure>\n<p>并没有什么有价值的线索，不过注意到WCDataItem里面有一个WCContentItem，看来只能从这儿入手了，去看一下头文件吧！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property(retain, nonatomic) NSString *linkUrl; </div><div class=\"line\">@property(retain, nonatomic) NSString *linkUrl2; </div><div class=\"line\">@property(retain, nonatomic) NSMutableArray *mediaList;</div></pre></td></tr></table></figure>\n<p>在LLDB打印出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po [[$x0 valueForKey:@&quot;contentObj&quot;] linkUrl]</div><div class=\"line\">https://support.weixin.qq.com/cgi-bin/mmsupport-bin/readtemplate?t=page/common_page__upgrade&amp;v=1</div><div class=\"line\">(lldb) po [[$x0 valueForKey:@&quot;contentObj&quot;] linkUrl2]</div><div class=\"line\"> nil</div><div class=\"line\">(lldb) po [[$x0 valueForKey:@&quot;contentObj&quot;] mediaList]</div><div class=\"line\">&lt;__NSArrayM 0x15f985e10&gt;(</div><div class=\"line\">&lt;WCMediaItem: 0x15dfebdf0&gt;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>mediaList数组里面有一个WCMediaItem对象，Media一般用来表示视频和音频，大胆猜测就是它了！赶紧找到头文件搜索一遍。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property(retain, nonatomic) WCUrl *dataUrl;</div><div class=\"line\">- (id)pathForData;</div><div class=\"line\">- (id)pathForSightData;</div><div class=\"line\">- (id)pathForTempAttachVideoData;</div><div class=\"line\">- (id)videoStreamForData;</div></pre></td></tr></table></figure>\n<p>上面这些属性和方法中<code>pathForSightData</code>是最有可能拿到小视频路径的，继续验证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] dataUrl]</div><div class=\"line\">type[1], url[http://vweixinf.tc.qq.com/102/20202/snsvideodownload?filekey=30270201010420301e020166040253480410d14adcddf086f4e131d11a5b1cca1bdf0203039fa00400&amp;bizid=1023&amp;hy=SH&amp;fileparam=302c0201010425302302040fde55e20204580ebd3602024eea02031e8d7d02030f42400204d970370a0201000400], enckey[0], encIdx[-1], token[]</div><div class=\"line\">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] pathForData]</div><div class=\"line\">/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45</div><div class=\"line\">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] pathForSightData]</div><div class=\"line\">/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45.mp4</div><div class=\"line\">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] pathForAttachVideoData]</div><div class=\"line\"> nil</div><div class=\"line\">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] videoStreamForData]</div><div class=\"line\"> nil</div></pre></td></tr></table></figure>\n<p>拿到小视频的网络url和本地路径了！这里可以用iFunBox或者scp从沙盒拷贝这个文件看看是不是这个cell应该播放的小视频。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:~ gaoshilei$ scp root@192.168.0.115:/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45.mp4 Desktop/</div><div class=\"line\">8fb0cdd77208de5b56169fb3458b45.mp4                100%  232KB 231.9KB/s   00:00</div></pre></td></tr></table></figure>\n<p>用QuickTime打开发现果然是我们要寻找的小视频。再验证一下url是否正确，把上面打印的dataUrl在浏览器中打开，发现也是这个小视频。分析这个类可以得出下面的结论：  </p>\n<ul>\n<li><strong>dataUrl：</strong>小视频的网络url</li>\n<li><strong>pathForData：</strong>小视频的本地路径</li>\n<li><strong>pathForSightData：</strong>小视频的本地路径（不带后缀）</li>\n</ul>\n<p>至此小视频的路径和取得方式分析已经完成，要实现转发还要继续分析微信的朋友圈发布。</p>\n<h2 id=\"二、实现转发功能\"><a href=\"#二、实现转发功能\" class=\"headerlink\" title=\"二、实现转发功能\"></a>二、实现转发功能</h2><h3 id=\"1-“走进死胡同”\"><a href=\"#1-“走进死胡同”\" class=\"headerlink\" title=\"1.“走进死胡同”\"></a>1.“走进死胡同”</h3><blockquote>\n<p>   这节是我在找小视频转发功能时走的弯路，扒到最后并没有找到实现方法，不过也提供了一些逆向中常用的思路和方法，不想看的可以跳到第二节。  </p>\n</blockquote>\n<h4 id=\"（1）找到小视频拍摄完成调用的方法名称\"><a href=\"#（1）找到小视频拍摄完成调用的方法名称\" class=\"headerlink\" title=\"（1）找到小视频拍摄完成调用的方法名称\"></a>（1）找到小视频拍摄完成调用的方法名称</h4><p>打开小视频的拍摄界面，用cycript注入，我们要找到发布小视频的方法是哪个，然后查看当前的窗口有哪些window（因为小视频的拍摄并不是在UIApplication的keyWindow中进行的）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [UIApp windows].toString()</div><div class=\"line\">(</div><div class=\"line\">    &quot;&lt;iConsoleWindow: 0x125f75e20; baseClass = UIWindow; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x125f77b70&gt;; layer = &lt;UIWindowLayer: 0x125df4810&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;SvrErrorTipWindow: 0x127414d40; baseClass = UIWindow; frame = (0 64; 320 45); hidden = YES; gestureRecognizers = &lt;NSArray: 0x12740d930&gt;; layer = &lt;UIWindowLayer: 0x1274030b0&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;MMUIWindow: 0x127796440; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x1278083c0&gt;; layer = &lt;UIWindowLayer: 0x127796750&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;UITextEffectsWindow: 0x1270e0d40; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = &lt;UIWindowLayer: 0x1270b4ba0&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;NewYearActionSheet: 0x127797e10; baseClass = UIWindow; frame = (0 0; 320 568); hidden = YES; userInteractionEnabled = NO; layer = &lt;UIWindowLayer: 0x1277d5490&gt;&gt;&quot;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>发现当前页面一共有5个window，其中MMUIWindow是小视频拍摄所在的window，打印它的UI树状结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [#0x127796440 recursiveDescription]</div></pre></td></tr></table></figure>\n<p>打印结果比较长，不贴了。找到这个按钮是拍摄小视频的按钮</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">|    |    |    |    |    | &lt;UIButton: 0x1277a9d70; frame = (89.5 368.827; 141 141); opaque = NO; gestureRecognizers = &lt;NSArray: 0x1277aaeb0&gt;; layer = &lt;CALayer: 0x1277a9600&gt;&gt;</div><div class=\"line\">|    |    |    |    |    |    | &lt;UIView: 0x1277aa0a0; frame = (0 0; 141 141); userInteractionEnabled = NO; tag = 252707333; layer = &lt;CALayer: 0x1277aa210&gt;&gt;</div><div class=\"line\">|    |    |    |    |    |    |    | &lt;UIImageView: 0x1277aa2e0; frame = (0 0; 141 141); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1277aa490&gt;&gt;</div></pre></td></tr></table></figure>\n<p>然后执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [#0x1277a9d70 setHidden:YES]</div></pre></td></tr></table></figure>\n<p>发现拍摄的按钮消失了，验证了我的猜想。寻找按钮的响应事件，可以通过target来寻找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [#0x1277a9d70 allTargets]</div><div class=\"line\">[NSSet setWithArray:@[#&quot;&lt;MainFrameSightViewController: 0x1269a4600&gt;&quot;]]]</div><div class=\"line\">cy# [#0x1277a9d70 allControlEvents]</div><div class=\"line\">193</div><div class=\"line\">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:193]</div><div class=\"line\">null</div></pre></td></tr></table></figure>\n<p>发现按钮并没有对应的action，这就奇怪了！UIButton必须要有target和action，不然这个Button不能响应事件。我们试试其他的ControlEvent</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchDown]</div><div class=\"line\">@[&quot;btnPress&quot;]</div><div class=\"line\">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchUpOutside]</div><div class=\"line\">@[&quot;btnRelease&quot;]</div><div class=\"line\">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchUpInside]</div><div class=\"line\">@[&quot;btnRelease&quot;]</div></pre></td></tr></table></figure>\n<p>结果发现这三个ContrlEvent有对应的action，我们再看看这三个枚举的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef enum UIControlEvents : NSUInteger &#123;</div><div class=\"line\">    UIControlEventTouchDown = 1 &lt;&lt;  0,</div><div class=\"line\">    UIControlEventTouchDownRepeat = 1 &lt;&lt;  1,</div><div class=\"line\">    UIControlEventTouchDragInside = 1 &lt;&lt;  2,</div><div class=\"line\">    UIControlEventTouchDragOutside = 1 &lt;&lt;  3,</div><div class=\"line\">    UIControlEventTouchDragEnter = 1 &lt;&lt;  4,</div><div class=\"line\">    UIControlEventTouchDragExit = 1 &lt;&lt;  5,</div><div class=\"line\">    UIControlEventTouchUpInside = 1 &lt;&lt;  6,</div><div class=\"line\">    UIControlEventTouchUpOutside = 1 &lt;&lt;  7,</div><div class=\"line\">    UIControlEventTouchCancel = 1 &lt;&lt;  8,</div><div class=\"line\">\t......</div><div class=\"line\">&#125; UIControlEvents;</div></pre></td></tr></table></figure>\n<p>可以看出来UIControlEventTouchDown对应1，UIControlEventTouchUpInside对应128，UIControlEventTouchUpOutside对应64，三者相加正好193！原来调用<code>[#0x1277a9d70 allControlEvents]</code>的时候返回的应该是枚举，有多个枚举则把它们的值相加，是不是略坑？我也是这样觉得的！刚才我们把三种ControlEvent对应的action都打印出来了，继续LLDB+IDA进行动态分析。</p>\n<h4 id=\"（2）找到小视频拍摄完成跳转到发布界面的方法\"><a href=\"#（2）找到小视频拍摄完成跳转到发布界面的方法\" class=\"headerlink\" title=\"（2）找到小视频拍摄完成跳转到发布界面的方法\"></a>（2）找到小视频拍摄完成跳转到发布界面的方法</h4><p>因为要找到小视频发布的方法，所以对应的<code>btnPress</code>函数我们并不关心，把重点放在<code>btnRelease</code>上面，拍摄按钮松开后就会调用的方法。在IDA中找到这个方法<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-btnRelease.png\" alt=\"MainFrameSightViewController - (void)btnRelease\"><br>找到之后下个断点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a 0xac000+0x10209369C</div><div class=\"line\">Breakpoint 4: where = WeChat`___lldb_unnamed_symbol108894$$WeChat + 32, address = 0x000000010213f69c</div><div class=\"line\">Process 3813 stopped</div><div class=\"line\">* thread #1: tid = 0xf1ef0, 0x000000010213f69c WeChat`___lldb_unnamed_symbol108894$$WeChat + 32, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 4.1</div><div class=\"line\">    frame #0: 0x000000010213f69c WeChat`___lldb_unnamed_symbol108894$$WeChat + 32</div><div class=\"line\">WeChat`___lldb_unnamed_symbol108894$$WeChat:</div><div class=\"line\">-&gt;  0x10213f69c &lt;+32&gt;: bl     0x1028d0b60               ; symbol stub for: objc_msgSend</div><div class=\"line\">    0x10213f6a0 &lt;+36&gt;: cmp    w0, #2                    ; =2 </div><div class=\"line\">    0x10213f6a4 &lt;+40&gt;: b.ne   0x10213f6dc               ; &lt;+96&gt;</div><div class=\"line\">    0x10213f6a8 &lt;+44&gt;: adrp   x8, 5489</div></pre></td></tr></table></figure>\n<p>用手机拍摄小视频然后松开，触发了断点，说明我们的猜想是正确的。继续分析发现代码是从上图的右边走的，看了一下没有什么方法是跳转到发布视频的，不过仔细看一下有一个block，是系统的延时block，位置在0x102093760。然后我们跟着断点进去，在0x1028255A0跳转到x16所存的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) si</div><div class=\"line\">Process 3873 stopped</div><div class=\"line\">* thread #1: tid = 0xf62c4, 0x00000001028d9598 WeChat`dispatch_after, queue = &apos;com.apple.main-thread&apos;, stop reason = instruction step into</div><div class=\"line\">    frame #0: 0x00000001028d9598 WeChat`dispatch_after</div><div class=\"line\">WeChat`dispatch_after:</div><div class=\"line\">-&gt;  0x1028d9598 &lt;+0&gt;: adrp   x16, 1655</div><div class=\"line\">    0x1028d959c &lt;+4&gt;: ldr    x16, [x16, #1056]</div><div class=\"line\">    0x1028d95a0 &lt;+8&gt;: br     x16</div><div class=\"line\"></div><div class=\"line\">WeChat`dispatch_apply:</div><div class=\"line\">    0x1028d95a4 &lt;+0&gt;: adrp   x16, 1655</div><div class=\"line\">(lldb) po $x2</div><div class=\"line\">&lt;__NSStackBlock__: 0x16fd49f88&gt;</div></pre></td></tr></table></figure>\n<p>发现传入的参数x2是一个block，我们再回顾一下dispatch_after函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>\n<p>这个函数有三个参数，分别是dispatch_time_t、dispatch_queue_t、dispatch_block_t，那这里打印的x2就是要传入的block，所以我们猜测拍摄完小视频会有一个延时，然后执行刚才传入的block，所以x2中肯定有其他方法调用，下一步就是要知道这个block的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) memory read --size 8 --format x 0x16fd49f88</div><div class=\"line\">0x16fd49f88: 0x000000019f8fd218 0x00000000c2000000</div><div class=\"line\">0x16fd49f98: 0x000000010214777c 0x0000000102fb0e60</div><div class=\"line\">0x16fd49fa8: 0x000000015da32600 0x000000015ea1a430</div><div class=\"line\">0x16fd49fb8: 0x000000015cf5fee0 0x000000016fd49ff0</div></pre></td></tr></table></figure>\n<p>0x000000010214777c就是block所在的位置，当然要减掉当前WeChat的ASLR偏移，最终在IDA中的地址为0x10209377C，突然发现这就是<code>btnRelease</code>的子程序sub_10209377C。这个子程序非常简单，只有一个方法<code>selRef_logicCheckState_</code>有可能是我们的目标。先看看这个方法是谁调用的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) br s -a 0xb4000+0x1020937BC</div><div class=\"line\">......</div><div class=\"line\">Process 3873 stopped</div><div class=\"line\">* thread #1: tid = 0xf62c4, 0x00000001021477bc WeChat`___lldb_unnamed_symbol108895$$WeChat + 64, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 3.1</div><div class=\"line\">    frame #0: 0x00000001021477bc WeChat`___lldb_unnamed_symbol108895$$WeChat + 64</div><div class=\"line\">WeChat`___lldb_unnamed_symbol108895$$WeChat:</div><div class=\"line\">-&gt;  0x1021477bc &lt;+64&gt;: adrp   x8, 5489</div><div class=\"line\">    0x1021477c0 &lt;+68&gt;: ldr    x1, [x8, #1552]</div><div class=\"line\">    0x1021477c4 &lt;+72&gt;: orr    w2, wzr, #0x1</div><div class=\"line\">    0x1021477c8 &lt;+76&gt;: ldp    x29, x30, [sp, #16]</div><div class=\"line\">(lldb) po $x0</div><div class=\"line\">&lt;MainFrameSightViewController: 0x15d1f0c00&gt;</div></pre></td></tr></table></figure>\n<p>发现还是MainFrameSightViewController这个对象调用的，那<code>selRef_logicCheckState_</code>肯定也在这个类的头文件中，寻找一下果然发现了  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)logicCheckState:(int)arg1;</div></pre></td></tr></table></figure>\n<p>在IDA左侧窗口中寻找[MainFrameSightViewController logicCheckState:]，发现这个方法超级复杂，逻辑太多了，不着急慢慢捋。<br>在0x102094D6C位置我们发现一个switch jump，思路就很清晰了，我们只要找到小视频拍摄完成的这条线往下看就行了，LLDB来帮忙看看走的那条线。在0x102094D6C位置下个断点，这个断点在拍摄小视频的时候会多次触发，可以在拍摄之前把断点dis掉，拍摄松手之前再启用断点，打印此时的x8值  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) p/x $x8</div><div class=\"line\">(unsigned long) $38 = 0x0000000102174e10</div></pre></td></tr></table></figure>\n<p>x8是一个指针，它指向的地址是0x102174e10，用这个地址减去当前ASLR的偏移就可以找到在IDA中的基地址，发现是0x102094E10，拍摄完成的逻辑处理这条线找到了，一直走到0x102094E24位置之后跳转0x1020951C4，这个分支的内容较少，里面有三个函数  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">loc_1020951C4</div><div class=\"line\">ADRP            X8, #selRef_hideTips@PAGE</div><div class=\"line\">LDR             X1, [X8,#selRef_hideTips@PAGEOFF]</div><div class=\"line\">MOV             X0, X19</div><div class=\"line\">BL              _objc_msgSend</div><div class=\"line\">ADRP            X8, #selRef_finishWriter@PAGE</div><div class=\"line\">LDR             X1, [X8,#selRef_finishWriter@PAGEOFF]</div><div class=\"line\">MOV             X0, X19</div><div class=\"line\">BL              _objc_msgSend</div><div class=\"line\">ADRP            X8, #selRef_turnCancelBtnForFinishRecording@PAGE</div><div class=\"line\">LDR             X1, [X8,#selRef_turnCancelBtnForFinishRecording@PAGEOFF]</div><div class=\"line\">MOV             X0, X19</div><div class=\"line\">BL              _objc_msgSend</div><div class=\"line\">B               loc_102095288</div></pre></td></tr></table></figure>\n<p>其中<code>selRef_finishWriter</code>和<code>selRef_turnCancelBtnForFinishRecording</code>需要重点关注，这两个方法看上去都是小视频录制结束的意思，线索极有可能就在这两个函数中。通过查看调用者发现这两个方法都属于MainFrameSightViewController，继续在IDA中查看这两个方法。在<code>selRef_finishWriter</code>中靠近末尾0x102094248的位置发现一个方法名叫做<code>f_switchToSendingPanel</code>，下个断点，然后拍摄视频，发现这个方法并没有被触发。应该不是通过这个方法调用发布界面的，继续回到<code>selRef_finishWriter</code>方法中；在0x1020941DC的位置调用方法<code>selRef_stopRecording</code>，打印它的调用者发现这个方法属于<code>SightFacade</code>，继续在IDA中寻找这个方法的实现。在这个方法的0x101F9BED4位置又调用了<code>selRef_stopRecord</code>，同样打印调用者发现这个方法属于SightCaptureLogicF4，有点像剥洋葱，继续在寻找这个方法的实现。在这个方法内部0x101A98778位置又调用了<code>selRef_finishWriting</code>，同样的原理找到这个方法是属于SightMovieWriter。已经剥了3层了，继续往下：<br>在<code>SightMovieWriter - (void)finishWriting</code>中的0x10261D004位置分了两条线，这个位置下个断点，然后拍摄完小视频触发断点，打印x19的值  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x19</div><div class=\"line\">&lt;OS_dispatch_queue: CAPTURE.CALLBACK[0x13610bcd0] = &#123; xrefcnt = 0x4, refcnt = 0x4, suspend_cnt = 0x0, locked = 1, target = com.apple.root.default-qos.overcommit[0x1a0aa3700], width = 0x0, running = 0x0, barrier = 1 &#125;&gt;</div></pre></td></tr></table></figure>\n<p>所以代码不会跳转到loc_10261D054而是走的左侧，在左侧的代码中发现启用了一个block，这个block是子程序sub_10261D0AC，地址为0x10261D0AC，找到这个地址，结构如下图所示：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91sub_10261D0AC.png\" alt=\"sub_10261D0AC\"><br>可以看出来主要分两条线，我们在第一个方框的末尾也就是0x10261D108位置下个断点，等拍摄完毕触发断点之后打印x0的值为1，这里的汇编代码为  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">__text:000000010261D104                 CMP             X0, #2</div><div class=\"line\">__text:000000010261D108                 B.EQ            loc_10261D234</div></pre></td></tr></table></figure>\n<p>B.EQ是在上一步的结果为0才会跳转到loc_10261D234，但是这里的结果是不为0的，将x0的值改为2让上一步的结果为0  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x0</div><div class=\"line\">1</div><div class=\"line\">(lldb) register write $x0 2</div><div class=\"line\">(lldb) po $x0</div><div class=\"line\">2</div></pre></td></tr></table></figure>\n<p>此时放开断点，等待跳转到小视频发布界面，结果是一直卡在这个界面没有任何反应，所以猜测实现跳转的逻辑应该在右边的那条线，继续顺着右边的线寻找：<br>在右侧0x10261D3AC位置发现调用了下面的这个方法  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)finishWritingWithCompletionHandler:(void (^)(void))handler;</div></pre></td></tr></table></figure>\n<p>这个方法是系统提供的AVAssetWriter里面的方法，在视频写入完成之后要做的操作，这个里是要传入一个block的，因为只有一个参数所以对应的变量是x2，打印x2的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x2</div><div class=\"line\">&lt;__NSStackBlock__: 0x16e086c78&gt;</div><div class=\"line\">(lldb) memory read --size 8 --format x 0x16e086c78</div><div class=\"line\">0x16e086c78: 0x00000001a0aa5218 0x00000000c2000000</div><div class=\"line\">0x16e086c88: 0x00000001026d94b0 0x0000000102fc98c0</div><div class=\"line\">0x16e086c98: 0x0000000136229fd0 0x000000016e086d00</div><div class=\"line\">0x16e086ca8: 0x00000001997f5318 0xfffffffec9e882ff</div></pre></td></tr></table></figure>\n<p>并且通过栈内存找到block位置为0x10261D4B0（需要减去ASLR的偏移）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">sub_10261D4B0</div><div class=\"line\">var_20= -0x20</div><div class=\"line\">var_10= -0x10</div><div class=\"line\">STP             X20, X19, [SP,#var_20]!</div><div class=\"line\">STP             X29, X30, [SP,#0x20+var_10]</div><div class=\"line\">ADD             X29, SP, #0x20+var_10</div><div class=\"line\">MOV             X19, X0</div><div class=\"line\">LDR             X0, [X19,#0x20]</div><div class=\"line\">ADRP            X8, #selRef_stopAmr@PAGE</div><div class=\"line\">LDR             X1, [X8,#selRef_stopAmr@PAGEOFF]</div><div class=\"line\">BL              _objc_msgSend</div><div class=\"line\">LDR             X0, [X19,#0x20]</div><div class=\"line\">ADRP            X8, #selRef_compressAudio@PAGE</div><div class=\"line\">LDR             X1, [X8,#selRef_compressAudio@PAGEOFF]</div><div class=\"line\">LDP             X29, X30, [SP,#0x20+var_10]</div><div class=\"line\">LDP             X20, X19, [SP+0x20+var_20],#0x20</div><div class=\"line\">B               _objc_msgSend</div><div class=\"line\">; End of function sub_10261D4B0</div></pre></td></tr></table></figure>\n<p>只调用了两个方法，一个是<code>selRef_stopAmr</code>停止amr（一种音频格式），另一个是<code>selRef_compressAudio</code>压缩音频，拍摄完成的下一步操作应该不会放在这两个方法里面，找了这么久也没有头绪，这个路看来走不通了，不要钻牛角尖，战略性撤退寻找其他入口。<br><strong>逆向的乐趣就是一直寻找真相的路上，能体会到成功的乐趣，也有可能方向错了离真相反而越来越远，不要气馁调整方向继续前进！</strong></p>\n<h3 id=\"2-“另辟蹊径”\"><a href=\"#2-“另辟蹊径”\" class=\"headerlink\" title=\"2.“另辟蹊径”\"></a>2.“另辟蹊径”</h3><blockquote>\n<p>（由于微信在后台偷偷升级了，下面的内容都是微信6.3.30版本的ASLR，上面的分析基于6.3.28版本）</p>\n</blockquote>\n<p>注意到在点击朋友圈右上角的相机按钮底部会弹出一个Sheet，第一个就是Sight小视频，从这里入手，用cycript查看Sight按钮对应的事件是哪个  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">iPhone-5S:~ root# cycript -p &quot;WeChat&quot;</div><div class=\"line\">cy# [UIApp windows].toString()</div><div class=\"line\">`(</div><div class=\"line\">    &quot;&lt;iConsoleWindow: 0x14d6ccc00; baseClass = UIWindow; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x14d7df110&gt;; layer = &lt;UIWindowLayer: 0x14d7d6f60&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;SvrErrorTipWindow: 0x14eaa5800; baseClass = UIWindow; frame = (0 0; 320 45); hidden = YES; gestureRecognizers = &lt;NSArray: 0x14e9e8950&gt;; layer = &lt;UIWindowLayer: 0x14e9e6510&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;UITextEffectsWindow: 0x14ec38ba0; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = &lt;UIWindowLayer: 0x14ec39360&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;UITextEffectsWindow: 0x14e9c67a0; frame = (0 0; 320 568); layer = &lt;UIWindowLayer: 0x14d683ff0&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;UIRemoteKeyboardWindow: 0x14f226e40; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = &lt;UIWindowLayer: 0x14d6f4de0&gt;&gt;&quot;,</div><div class=\"line\">    &quot;&lt;NewYearActionSheet: 0x14f1704a0; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x14ef9bf90&gt;; layer = &lt;UIWindowLayer: 0x14ef61a20&gt;&gt;&quot;</div><div class=\"line\">)`</div><div class=\"line\">cy# [#0x14f1704a0 recursiveDescription].toString()</div></pre></td></tr></table></figure>\n<p>底部的Sheet是NewYearActionSheet，然后打印NewYearActionSheet的UI树状结构图（比较长不贴了）。然后找到Sight对应的UIButton是0x14f36d470   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">cy# [#0x14f36d470 allTargets]</div><div class=\"line\">[NSSet setWithArray:@[#&quot;&lt;NewYearActionSheet: 0x14f1704a0; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x14ef9bf90&gt;; layer = &lt;UIWindowLayer: 0x14ef61a20&gt;&gt;&quot;]]]</div><div class=\"line\">cy# [#0x14f36d470 allControlEvents]</div><div class=\"line\">64</div><div class=\"line\">cy# [#0x14f36d470 actionsForTarget:#0x14f1704a0 forControlEvent:64]</div><div class=\"line\">@[&quot;OnDefaultButtonTapped:&quot;]</div></pre></td></tr></table></figure>\n<p>通过UIControl的<code>actionsForTarget:forControlEvent:</code>方法可以找到按钮绑定的事件，Sight按钮的触发方法为<code>OnDefaultButtonTapped:</code>，回到IDA中在NewYearActionSheet中找到这个方法们继续往下分析只有这个方法<code>selRef_dismissWithClickedButtonIndex_animated</code>，通过打印它的调用者发现还是NewYearActionSheet，继续点进去找到<code>newYearActionSheet_clickedButtonAtIndex</code>方法，看样子不是NewYearActionSheet自己的，打印调用者x0发现它属于类WCTimeLineViewController。跟着断点走下去在0x1012B78CC位置调用了方法<code>#selRef_showSightWindowForMomentWithMask_byViewController_scene</code><br>通过观察发现这个方法的调用者是0x1012B78AC这个位置的返回值x0，这是一个类SightFacade，猜测这个方法在SightFacade里面，去头文件里找一下果然发现这个方法  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)showSightWindowForMomentWithMask:(id)arg1 byViewController:(id)arg2 scene:(int)arg3;</div></pre></td></tr></table></figure>\n<p>这个方法应该就是跳转到小视频界面的方法了。下面分别打印它的参数  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $x2</div><div class=\"line\">&lt;UIImage: 0x14f046660&gt;, &#123;320, 568&#125;</div><div class=\"line\">(lldb) po $x3</div><div class=\"line\">&lt;WCTimeLineViewController: 0x14e214800&gt;</div><div class=\"line\">(lldb) po $x4</div><div class=\"line\">2</div><div class=\"line\">(lldb) po $x0</div><div class=\"line\">&lt;SightFacade: 0x14f124b40&gt;</div></pre></td></tr></table></figure>\n<p>其中x2、x3、x4分别对应三个参数，x0是调用者，跳到这个方法内部查看怎么实现的。发现在这个方法中进行了小视频拍摄界面的初始化工作，首先初始化一个MainFrameSightViewController，再创建一个UINavigationController将MainFrameSightViewController放进去，接下来初始化一个MMWindowController调用  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (id)initWithViewController:(id)arg1 windowLevel:(int)arg2;</div></pre></td></tr></table></figure>\n<p>方法将UINavigationController放了进去，完成小视频拍摄界面的所有UI创建工作。<br>拍摄完成之后进入发布界面，此时用cycript找到当前的Controller是SightMomentEditViewController，由此萌生一个想法，跳过前面的拍摄界面直接进入发布界面不就可以了吗？我们自己创建一个SightMomentEditViewController然后放到UINavigationController里面，然后再将这个导航控制器放到MMWindowController里面。<strong>（这里我已经写好tweak进行了验证，具体的tweak思路编写在后文有）</strong>结果是的确可以弹出发布的界面，但是导航栏的NavgationBar遮住了原来的，整个界面是透明的，很难看，而且发布完成之后无法销毁整个MMWindowController，还是停留在发布界面。我们要的结果不是这个，不过确实有很大的收获，最起码可以直接调用发布界面了，小视频也能正常转发。我个人猜测，当前界面不能被销毁的原因是因为MMWindowController新建了一个window,它跟TimeLine所在的keyWindow不是同一个，SightMomentEditViewController的按钮触发的方法是没有办法销毁这个window的，所以有一个大胆的猜想，我直接在当前的WCTimeLineViewController上把SightMomentEditViewController展示出来不就可以了吗？  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[WCTimelineVC presentViewController:editSightVC animated:YES completion:^&#123;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>像这样展示岂不妙哉？不过通过观察SightMomentEditViewController的头文件，结合小视频发布时界面上的元素，推测创建这个控制器至少需要两个属性，一个是小视频的路径，另一个是小视频的缩略图，将这两个关键属性给了SightMomentEditViewController那么应该就可以正常展示了   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">SightMomentEditViewController *editSightVC = [[%c(SightMomentEditViewController) alloc] init];</div><div class=\"line\">NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</div><div class=\"line\">UIImage *image = [[self valueForKey:@&quot;_sightView&quot;] getImage];</div><div class=\"line\">[editSightVC setRealMoviePath:localPath];</div><div class=\"line\">[editSightVC setMoviePath:localPath];</div><div class=\"line\">[editSightVC setRealThumbImage:image];</div><div class=\"line\">[editSightVC setThumbImage:image];</div><div class=\"line\">[WCTimelineVC presentViewController:editSightVC animated:YES completion:^&#123;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>小视频的发布界面可以正常显示并且所有功能都可以正常使用，唯一的问题是返回按钮没有效果，并不能销毁SightMomentEditViewController。用cycript查看左侧按钮的actionEvent找到它的响应函数是<code>- (void)popSelf;</code>，点击左侧返回触发的是pop方法，但是这个控制器并不在navgationController里面，所以无效，我们要对这个方法进行重写  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)popSelf</div><div class=\"line\">&#123;</div><div class=\"line\">    [self dismissViewControllerAnimated:YES completion:^&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>此时再点击返回按钮就可以正常退出了，此外，在WCContentItemViewTemplateNewSight中发现了一个方法叫做<code>- (void)sendSightToFriend;</code>，可以直接将小视频转发给好友，至此小视频转发的功能已经找到了。</p>"},{"title":"手把手教你逆向微信之朋友圈小视频转发（下）","date":"2016-11-10T16:00:00.000Z","_content":">\t接上篇[《手把手教你逆向微信之朋友圈小视频转发（上）》](http://www.gaoshilei.com/2016/11/09/手把手教你逆向微信之朋友圈小视频转发（上）/)\n\n##\t\t代码编写及重签名打包安装 （下篇） \n小视频的转发支持4个功能，转发至朋友圈、转发至好友、保存到本地相册、拷贝小视频链接到粘贴板。如果小视频没有下载长按时只会出现拷贝url链接。 \n<!-- more -->\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n*（非越狱机和不想利用tweak安装的越狱机[点我跳到第二节](#section_two)）*\n###\t1.越狱机打包安装（tweak安装）  \n1>\t新建tweak工程  \n2>\t编写tweak文件\n\n这里要hook两个类，分别是WCContentItemViewTemplateNewSight和SightMomentEditViewController，在WCContentItemViewTemplateNewSight中hook住onLongTouch方法然后添加menu弹出菜单，依次添加响应的方法，具体的代码如下：  \n\n-\t拷贝小视频的url链接\n\n```oc\n  NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];\n    UISaveVideoAtPathToSavedPhotosAlbum(localPath, nil, nil, nil);\n}\n```\n\n-\t保存小视频到本地相册\n\n```oc\nNSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];\n    UISaveVideoAtPathToSavedPhotosAlbum(localPath, nil, nil, nil);\n```\n\n-\t转发到朋友圈\n\n```oc\n SightMomentEditViewController *editSightVC = [[%c(SightMomentEditViewController) alloc] init];\n    NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];\n    UIImage *image = [[self valueForKey:@\"_sightView\"] getImage];\n    [editSightVC setRealMoviePath:localPath];\n    [editSightVC setMoviePath:localPath];\n    [editSightVC setRealThumbImage:image];\n    [editSightVC setThumbImage:image];\n    [WCTimelineVC presentViewController:editSightVC animated:YES completion:^{\n\n    }];\n```\n\n-\t转发给好友\n\n```oc\n[self sendSightToFriend];\n```\n\n-\t长按手势\n\n```Objective-C\n    UIMenuController *menuController = [UIMenuController sharedMenuController];\n    if (menuController.isMenuVisible) return;//防止出现menu闪屏的情况\n    [self becomeFirstResponder];\n    NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];\n    BOOL isExist =[[NSFileManager defaultManager] fileExistsAtPath:localPath];\n    UIMenuItem *retweetMenuItem = [[UIMenuItem alloc] initWithTitle:@\"朋友圈\" action:@selector(SLRetweetSight)];\n    UIMenuItem *saveToDiskMenuItem = [[UIMenuItem alloc] initWithTitle:@\"保存到相册\" action:@selector(SLSightSaveToDisk)];\n    UIMenuItem *sendToFriendsMenuItem = [[UIMenuItem alloc] initWithTitle:@\"好友\" action:@selector(SLSightSendToFriends)];\n    UIMenuItem *copyURLMenuItem = [[UIMenuItem alloc] initWithTitle:@\"复制链接\" action:@selector(SLSightCopyUrl)];\n    if(isExist){\n        [menuController setMenuItems:@[retweetMenuItem,sendToFriendsMenuItem,saveToDiskMenuItem,copyURLMenuItem]];\n    }else{\n        [menuController setMenuItems:@[copyURLMenuItem]];\n    }\n    [menuController setTargetRect:CGRectZero inView:self];\n    [menuController setMenuVisible:YES animated:YES];\n```\n\n具体的tweak文件我放在了github上，[WCSightRetweet传送门](https://github.com/gaoshilei/WCSightRetweet)\n\n3>\t编写WCTimelineRetweet.h头文件\n编写这个头文件的目的是防止tweak在编译期间报错，我们可以在编写好tweak试着编译一下，然后根据报错信息来添加这个头文件的内容，在这个文件中要声明在tweak我们用到的微信的类和方法，具体请看代码：\n\n```\n@interface WCUrl : NSObject\n@property(retain, nonatomic) NSString *url;\n@end\n@interface WCContentItem : NSObject\n@property(retain, nonatomic) NSMutableArray *mediaList;\n@end\n@interface WCDataItem : NSObject\n@property(retain, nonatomic) WCContentItem *contentObj;\n@end\n@interface WCMediaItem : NSObject\n@property(retain, nonatomic) WCUrl *dataUrl;\n- (id)pathForSightData;\n@end\n@interface MMServiceCenter : NSObject\n+ (id)defaultCenter;\n- (id)getService:(Class)arg1;\n@end\n@interface WCFacade : NSObject\n- (id)getTimelineDataItemOfIndex:(long long)arg1;\n@end\n@interface WCSightView : UIView\n- (id)getImage;\n@end\n@interface WCContentItemViewTemplateNewSight : UIView{\n    WCSightView *_sightView;\n}\n- (WCMediaItem *)iOSREMediaItemFromSight;\n- (void)iOSREOnSaveToDisk;\n- (void)iOSREOnCopyURL;\n- (void)sendSightToFriend;\n@end\n@interface SightMomentEditViewController : UIViewController\n@property(retain, nonatomic) NSString *moviePath;\n@property(retain, nonatomic) NSString *realMoviePath;\n@property(retain, nonatomic) UIImage *thumbImage;\n@property(retain, nonatomic) UIImage *realThumbImage;\n- (void)makeInputController;\n@end\n@interface MMWindowController : NSObject\n- (id)initWithViewController:(id)arg1 windowLevel:(int)arg2;\n- (void)showWindowAnimated:(_Bool)arg1;\n@end\n@interface WCTimeLineViewController : UIViewController\n- (long long)calcDataItemIndex:(long long)arg1;\n@end\n@interface MMTableViewCell : UIView\n@end\n@interface MMTableView : UIView\n- (id)indexPathForCell:(id)cell;\n@end\n```\n\n4>\tMakefile文件修改\n\n```oc\nTHEOS_DEVICE_IP = 192.168.0.115//手机所在的IP\ninclude $(THEOS)/makefiles/common.mk\nARCHS = arm64//支持的CPU架构\nTWEAK_NAME = WCTimelineSightRetweet\nWCTimelineSightRetweet_FILES = Tweak.xm\nWCTimelineSightRetweet_FRAMEWORKS = UIKit CoreGraphics//导入系统的framework\ninclude $(THEOS_MAKE_PATH)/tweak.mk\n\nafter-install::\n\tinstall.exec \"killall -9 WeChat\"//安装完成杀掉的进程\n```\n\ncontrol文件不需要做修改，然后执行命令`make package install`安装到手机，微信会被杀掉，然后再次打开微信转发小视频的功能已经加上了。  \n\n###\t<span id=\"section_two\">2.微信重签名打包安装 </span> \n####\t准备工作\n#####\t（1）\t安装iOSOpenDev  \n1>\t安装 [macports](https://www.macports.org/install.php) (安装过程需要连接VPN,否则无法安装成功)\n\n2>\t安装完MacPorts后打开终端，输入 `sudo port -v selfupdate` 更新MacPorts到最新版本，时间可能比较长。\n\n3>\t更新完MacPorts后安装DPKG文件，在终端输入`sudo port -f install dpkg`\n\n4>\t下载安装 [iOSOpendev](http://iosopendev.com/download) 如果安装失败，可以通过 `Command + L` 查看安装中出现的问题。\n\n```\nPackageKit: Install Failed: Error Domain=PKInstallErrorDomain Code=112 \"运行软件包“iOSOpenDev-1.6-2.pkg”的脚本时出错。\" UserInfo={NSFilePath=./postinstall, NSURL=file://localhost/Users/ice/Downloads/iOSOpenDev-1.6-2.pkg#iodsetup.pkg, PKInstallPackageIdentifier=com.iosopendev.iosopendev162.iod-setup.pkg, NSLocalizedDescription=运行软件包“iOSOpenDev-1.6-2.pkg”的脚本时出错。} {\n        NSFilePath = \"./postinstall\";\n        NSLocalizedDescription = \"\\U8fd0\\U884c\\U8f6f\\U4ef6\\U5305\\U201ciOSOpenDev-1.6-2.pkg\\U201d\\U7684\\U811a\\U672c\\U65f6\\U51fa\\U9519\\U3002\";\n        NSURL = \"file://localhost/Users/ice/Downloads/iOSOpenDev-1.6-2.pkg#iodsetup.pkg\";\n        PKInstallPackageIdentifier = \"com.iosopendev.iosopendev162.iod-setup.pkg\"\n}\n```\n\n这里有一个解决方案：下载[iOSOpenDevInstallSolve](https://github.com/gaoshilei/iOSOpenDevInstallSolve)中的Specifications文件夹  \n\n**修复安装失败问题**  \n打开步骤4下载的Specifications文件夹，里面应该有8个文件,如果你有安装多个xcode注意放到对应的xcode里面。  \n1.\tiPhoneOS开头的四个文件放到/应用程序/Xcode/Content/Developer/Platforms/IphoneOS.platform/Developer/Library/Xcode/Specifications文件夹下（如果没有，请自己创建一个Specifications文件夹）  \n2.\tiPhone Simulator 开头的另外四个文件放入/应用程序/Xcode/Content/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications文件夹下(如果没有，请同样创建一个)  \n3.\t在/应用程序/Xcode/Content/Developer/Platforms/iPhoneSimulator.platform/Developer/文件夹下创建usr文件夹，usr文件夹下再创建一个名为bin的文件夹。  \n**注意：有时候会提示安装失败，打开Xcode新建工程，如果在工程的选项菜单中有iOSOpenDev就表示安装成功了，不用管那个安装提示。**  \n\n#####\t（2）\t安装ideviceinstaller\n>\t安装ipa包用的，也可以通过itool之类的工具，不过ideviceinstaller可以看到安装过程的过程，方便我们找到出错原因。\n\n执行命令\n\n```oc\nbrew install ideviceinstaller\n```\n如果提示brew命令找不到，那就是你的Mac还没有安装[Homebrew](http://brew.sh/index_zh-cn.html)  \n常见的报错信息：  \n\n```oc\nERROR: Could not connect to lockdownd, error code -5\n```\n这个时候只要重新安装libimobiledevice就可以了（因为ideviceinstaller依赖很多其他插件）  \n执行下面的命令：\n\n```oc\n$   brew uninstall libimobiledevice\n$   brew install --HEAD libimobiledevice\n```\n\n下载[iOS App Signer](https://github.com/DanTheMan827/ios-app-signer)重签名工具*（省去很多命令行操作，一键重签名！）*  \n\n（3）\t下载砸壳的微信应用\n>\t因为AppStore的包是被加密（有壳），无法进行重签名，所以要用砸壳的，可以用dumpdecrypted自己砸壳，也可以直接利用PP助手或者itool助手下载越狱版已经砸过壳的微信应用。  \n\n（4）\t安装yololib  \nyololib可以将dylib注入进WeChat二进制文件中，这样才能是你的Hook有作用，下载之后编译得到[yololib](https://github.com/gaoshilei/yololib)\n\n####\t代码注入以及打包安装 \n\n#####\t（1）生成静态库  \n在上一步中已经安装好iOSOpendev，此时打开Xcode新建项目，在选择工程界面会出现iOSOpendev的工程，这里我们要选择CaptainHook Tweak项目\n![iOSOpenDev](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8DiOSDev.png)\n新建好的工程只有一个.mm文件，我们只需要把所有hook方法写在这个文件中即可。  \n因为非越狱机不能像越狱机一样可以安装tweak插件对原来的应用进行hook，CaptainHook使用的Runtime机制实现，利用宏命令封装类定义、方法替换等功能，简单介绍它的使用方法：  \n\n1.\thook某个类\n \n```oc\nCHDeclareClass(WCContentItemViewTemplateNewSight); \n```\n`CHDeclareClass(ClassName)`表示要hook哪个类，一般写在对这个类操作的最前面。\n\n2.\t在hook的类种新建方法  \n\n```oc\nCHDeclareMethod0(id, WCContentItemViewTemplateNewSight, SLSightDataItem){......}\n```\n`CHDeclareMethod(count, return_type, class_type, name1, arg1, ....)`表示新建一个方法，count表示这个方法的参数个数，return_type表示返回类型，class_type填写这个方法所在的类名，name1表示方法名，arg1表示第一个参数，如果没有参数则不填，以此类推。  \n\n3.\thook原来的方法  \n\n```oc\nCHOptimizedMethod0(self, void, WCContentItemViewTemplateNewSight, onLongTouch){\nCHSuper(0, className, Method);//可选\n......\n}\n```\n`CHOptimizedMethod(count, optimization, return_type, class_type, name1, type1, arg1)` 表示hook原来的方法（如果不加`CHSuper(0, className, Method)`表示复写原来的方法，CHSuper表示在当前位置调用原来的方法实现），count表示hook的方法参数个数，optimization一般填self，return_type即方法返回值类型，class_type填当前类的类名，name1是方法名，arg1是参数，如果没有参数不同填写arg，以此类推。  \n\n4.\t构造函数\n\n```oc\nCHConstructor\n{\n    @autoreleasepool\n    {\n        CHLoadLateClass(WCContentItemViewTemplateNewSight);\n        CHHook(0, WCContentItemViewTemplateNewSight, onLongTouch);    \n     }\n}\n```\n这是CaptainHook的入口函数，所有被hook的类必须在这里声明加载，类里面的方法要在这里声明hook。  \n然后就可以往类和方法中写代码了，代码太长不贴了，请自行下载  \n**[MMPlugin传送门](https://github.com/gaoshilei/MMPlugin)**  \n**这个项目中包含了小视频转发、自动抢红包、修改微信运动步数功能，自动抢红包和修改微信运动步数功能可以手动关闭。**\n>\t注意：如果用到了系统的类记住要导入相应的类库（比方说UIKit）和头文件否则编译的时候会报错。\n\n编译成功之后就可以在Products文件夹中找到编译好的静态库了  \n![编译好的静态库](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-%E7%BC%96%E8%AF%91%E5%A5%BD%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93.png)  \n在finder中找到它，拷贝出来待用。\n#####\t(2)\t签名+打包+安装  \n进行到这里目前应该有的材料有：\n\n-\t砸壳的微信app    \n- \t编译好的MMPlugin.dylib\n-  安装好的iOS App Signer\n-  编译好的yololib文件  \n-  ideviceinstaller\n\n从原来的微信app中找到WeChat二进制文件拷贝出来待用，**删除weChat.app中的Watch文件夹、PlugIns文件夹中的WeChatShareExtensionNew.appex**，这步操作必须要做，不然安装的时候会报签名错误。  \n执行下面的命令将MMPlugin.dylib注入到WeChat二进制文件中，命令如下：\n\n```shell\nLeonLei-MBP:WeChat gaoshilei$ ./yololib WeChat MMPlugin.dylib\n```\n**执行这个命令时要确保yololib、WeChat、WeChat.app处于同一目录下。** \n\n完成之后将MMPlugin.dylib和WeChat拷贝到原来的WeChat.app中，覆盖掉原来的WeChat文件。  \n打开iOS App Signer按照下图选择好各项参数：\n![iOS App Signer](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-iOSAppSigner.png)  \n我这里选择的是企业级证书，个人开发者证书也是可以的，个人开发者一定要选择开发环境的并且要将需要安装的机器udid添加到prov文件里面去，选好之后点击start，稍等片刻一个经过重签名的ipa包就生成了。  \n连上你的手机执行下面的命令查看ideviceinstaller是否连接上手机：\n\n```shell\nLeonLei-MBP:WeChat gaoshilei$ ideviceinfo\n```\n如果打印出一大堆手机的信息表示连接成功可以安装ipa包，如果不成功请根据错误提示进行调整。执行下面的命令进行安装：  \n\n```shell\nLeonLei-MBP:WeChat gaoshilei$ ideviceinstaller -i WeChat.ipa \nWARNING: could not locate iTunesMetadata.plist in archive!\nWARNING: could not locate Payload/WeChat.app/SC_Info/WeChat.sinf in archive!\nCopying 'WeChat.ipa' to device... DONE.\nInstalling 'com.xxxxxxxxxxxx'\n - CreatingStagingDirectory (5%)\n - ExtractingPackage (15%)\n - InspectingPackage (20%)\n - TakingInstallLock (20%)\n - PreflightingApplication (30%)\n - InstallingEmbeddedProfile (30%)\n - VerifyingApplication (40%)\n - CreatingContainer (50%)\n - InstallingApplication (60%)\n - PostflightingApplication (70%)\n - SandboxingApplication (80%)\n - GeneratingApplicationMap (90%)\n - Complete\n```\n安装完成，在手机上打开微信试试我们添加的新功能吧！如果某个环节卡住会报错，请根据报错信息进行修改。请看效果图：  \n![小视频转发](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%E6%95%88%E6%9E%9C%E5%9B%BE.jpg)  \n\n####\t有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。\n","source":"_posts/手把手教你逆向微信之朋友圈小视频转发（下）.md","raw":"---\ntitle: 手把手教你逆向微信之朋友圈小视频转发（下）\ndate: 2016-11-11\ncategories:\n- iOS逆向\ntags:\n- 微信\n- 汇编语言\n- IDA\n- 重签名    \npermalink: 手把手教你逆向微信之朋友圈小视频转发（下）\n\n---\n>\t接上篇[《手把手教你逆向微信之朋友圈小视频转发（上）》](http://www.gaoshilei.com/2016/11/09/手把手教你逆向微信之朋友圈小视频转发（上）/)\n\n##\t\t代码编写及重签名打包安装 （下篇） \n小视频的转发支持4个功能，转发至朋友圈、转发至好友、保存到本地相册、拷贝小视频链接到粘贴板。如果小视频没有下载长按时只会出现拷贝url链接。 \n<!-- more -->\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n*（非越狱机和不想利用tweak安装的越狱机[点我跳到第二节](#section_two)）*\n###\t1.越狱机打包安装（tweak安装）  \n1>\t新建tweak工程  \n2>\t编写tweak文件\n\n这里要hook两个类，分别是WCContentItemViewTemplateNewSight和SightMomentEditViewController，在WCContentItemViewTemplateNewSight中hook住onLongTouch方法然后添加menu弹出菜单，依次添加响应的方法，具体的代码如下：  \n\n-\t拷贝小视频的url链接\n\n```oc\n  NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];\n    UISaveVideoAtPathToSavedPhotosAlbum(localPath, nil, nil, nil);\n}\n```\n\n-\t保存小视频到本地相册\n\n```oc\nNSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];\n    UISaveVideoAtPathToSavedPhotosAlbum(localPath, nil, nil, nil);\n```\n\n-\t转发到朋友圈\n\n```oc\n SightMomentEditViewController *editSightVC = [[%c(SightMomentEditViewController) alloc] init];\n    NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];\n    UIImage *image = [[self valueForKey:@\"_sightView\"] getImage];\n    [editSightVC setRealMoviePath:localPath];\n    [editSightVC setMoviePath:localPath];\n    [editSightVC setRealThumbImage:image];\n    [editSightVC setThumbImage:image];\n    [WCTimelineVC presentViewController:editSightVC animated:YES completion:^{\n\n    }];\n```\n\n-\t转发给好友\n\n```oc\n[self sendSightToFriend];\n```\n\n-\t长按手势\n\n```Objective-C\n    UIMenuController *menuController = [UIMenuController sharedMenuController];\n    if (menuController.isMenuVisible) return;//防止出现menu闪屏的情况\n    [self becomeFirstResponder];\n    NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];\n    BOOL isExist =[[NSFileManager defaultManager] fileExistsAtPath:localPath];\n    UIMenuItem *retweetMenuItem = [[UIMenuItem alloc] initWithTitle:@\"朋友圈\" action:@selector(SLRetweetSight)];\n    UIMenuItem *saveToDiskMenuItem = [[UIMenuItem alloc] initWithTitle:@\"保存到相册\" action:@selector(SLSightSaveToDisk)];\n    UIMenuItem *sendToFriendsMenuItem = [[UIMenuItem alloc] initWithTitle:@\"好友\" action:@selector(SLSightSendToFriends)];\n    UIMenuItem *copyURLMenuItem = [[UIMenuItem alloc] initWithTitle:@\"复制链接\" action:@selector(SLSightCopyUrl)];\n    if(isExist){\n        [menuController setMenuItems:@[retweetMenuItem,sendToFriendsMenuItem,saveToDiskMenuItem,copyURLMenuItem]];\n    }else{\n        [menuController setMenuItems:@[copyURLMenuItem]];\n    }\n    [menuController setTargetRect:CGRectZero inView:self];\n    [menuController setMenuVisible:YES animated:YES];\n```\n\n具体的tweak文件我放在了github上，[WCSightRetweet传送门](https://github.com/gaoshilei/WCSightRetweet)\n\n3>\t编写WCTimelineRetweet.h头文件\n编写这个头文件的目的是防止tweak在编译期间报错，我们可以在编写好tweak试着编译一下，然后根据报错信息来添加这个头文件的内容，在这个文件中要声明在tweak我们用到的微信的类和方法，具体请看代码：\n\n```\n@interface WCUrl : NSObject\n@property(retain, nonatomic) NSString *url;\n@end\n@interface WCContentItem : NSObject\n@property(retain, nonatomic) NSMutableArray *mediaList;\n@end\n@interface WCDataItem : NSObject\n@property(retain, nonatomic) WCContentItem *contentObj;\n@end\n@interface WCMediaItem : NSObject\n@property(retain, nonatomic) WCUrl *dataUrl;\n- (id)pathForSightData;\n@end\n@interface MMServiceCenter : NSObject\n+ (id)defaultCenter;\n- (id)getService:(Class)arg1;\n@end\n@interface WCFacade : NSObject\n- (id)getTimelineDataItemOfIndex:(long long)arg1;\n@end\n@interface WCSightView : UIView\n- (id)getImage;\n@end\n@interface WCContentItemViewTemplateNewSight : UIView{\n    WCSightView *_sightView;\n}\n- (WCMediaItem *)iOSREMediaItemFromSight;\n- (void)iOSREOnSaveToDisk;\n- (void)iOSREOnCopyURL;\n- (void)sendSightToFriend;\n@end\n@interface SightMomentEditViewController : UIViewController\n@property(retain, nonatomic) NSString *moviePath;\n@property(retain, nonatomic) NSString *realMoviePath;\n@property(retain, nonatomic) UIImage *thumbImage;\n@property(retain, nonatomic) UIImage *realThumbImage;\n- (void)makeInputController;\n@end\n@interface MMWindowController : NSObject\n- (id)initWithViewController:(id)arg1 windowLevel:(int)arg2;\n- (void)showWindowAnimated:(_Bool)arg1;\n@end\n@interface WCTimeLineViewController : UIViewController\n- (long long)calcDataItemIndex:(long long)arg1;\n@end\n@interface MMTableViewCell : UIView\n@end\n@interface MMTableView : UIView\n- (id)indexPathForCell:(id)cell;\n@end\n```\n\n4>\tMakefile文件修改\n\n```oc\nTHEOS_DEVICE_IP = 192.168.0.115//手机所在的IP\ninclude $(THEOS)/makefiles/common.mk\nARCHS = arm64//支持的CPU架构\nTWEAK_NAME = WCTimelineSightRetweet\nWCTimelineSightRetweet_FILES = Tweak.xm\nWCTimelineSightRetweet_FRAMEWORKS = UIKit CoreGraphics//导入系统的framework\ninclude $(THEOS_MAKE_PATH)/tweak.mk\n\nafter-install::\n\tinstall.exec \"killall -9 WeChat\"//安装完成杀掉的进程\n```\n\ncontrol文件不需要做修改，然后执行命令`make package install`安装到手机，微信会被杀掉，然后再次打开微信转发小视频的功能已经加上了。  \n\n###\t<span id=\"section_two\">2.微信重签名打包安装 </span> \n####\t准备工作\n#####\t（1）\t安装iOSOpenDev  \n1>\t安装 [macports](https://www.macports.org/install.php) (安装过程需要连接VPN,否则无法安装成功)\n\n2>\t安装完MacPorts后打开终端，输入 `sudo port -v selfupdate` 更新MacPorts到最新版本，时间可能比较长。\n\n3>\t更新完MacPorts后安装DPKG文件，在终端输入`sudo port -f install dpkg`\n\n4>\t下载安装 [iOSOpendev](http://iosopendev.com/download) 如果安装失败，可以通过 `Command + L` 查看安装中出现的问题。\n\n```\nPackageKit: Install Failed: Error Domain=PKInstallErrorDomain Code=112 \"运行软件包“iOSOpenDev-1.6-2.pkg”的脚本时出错。\" UserInfo={NSFilePath=./postinstall, NSURL=file://localhost/Users/ice/Downloads/iOSOpenDev-1.6-2.pkg#iodsetup.pkg, PKInstallPackageIdentifier=com.iosopendev.iosopendev162.iod-setup.pkg, NSLocalizedDescription=运行软件包“iOSOpenDev-1.6-2.pkg”的脚本时出错。} {\n        NSFilePath = \"./postinstall\";\n        NSLocalizedDescription = \"\\U8fd0\\U884c\\U8f6f\\U4ef6\\U5305\\U201ciOSOpenDev-1.6-2.pkg\\U201d\\U7684\\U811a\\U672c\\U65f6\\U51fa\\U9519\\U3002\";\n        NSURL = \"file://localhost/Users/ice/Downloads/iOSOpenDev-1.6-2.pkg#iodsetup.pkg\";\n        PKInstallPackageIdentifier = \"com.iosopendev.iosopendev162.iod-setup.pkg\"\n}\n```\n\n这里有一个解决方案：下载[iOSOpenDevInstallSolve](https://github.com/gaoshilei/iOSOpenDevInstallSolve)中的Specifications文件夹  \n\n**修复安装失败问题**  \n打开步骤4下载的Specifications文件夹，里面应该有8个文件,如果你有安装多个xcode注意放到对应的xcode里面。  \n1.\tiPhoneOS开头的四个文件放到/应用程序/Xcode/Content/Developer/Platforms/IphoneOS.platform/Developer/Library/Xcode/Specifications文件夹下（如果没有，请自己创建一个Specifications文件夹）  \n2.\tiPhone Simulator 开头的另外四个文件放入/应用程序/Xcode/Content/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications文件夹下(如果没有，请同样创建一个)  \n3.\t在/应用程序/Xcode/Content/Developer/Platforms/iPhoneSimulator.platform/Developer/文件夹下创建usr文件夹，usr文件夹下再创建一个名为bin的文件夹。  \n**注意：有时候会提示安装失败，打开Xcode新建工程，如果在工程的选项菜单中有iOSOpenDev就表示安装成功了，不用管那个安装提示。**  \n\n#####\t（2）\t安装ideviceinstaller\n>\t安装ipa包用的，也可以通过itool之类的工具，不过ideviceinstaller可以看到安装过程的过程，方便我们找到出错原因。\n\n执行命令\n\n```oc\nbrew install ideviceinstaller\n```\n如果提示brew命令找不到，那就是你的Mac还没有安装[Homebrew](http://brew.sh/index_zh-cn.html)  \n常见的报错信息：  \n\n```oc\nERROR: Could not connect to lockdownd, error code -5\n```\n这个时候只要重新安装libimobiledevice就可以了（因为ideviceinstaller依赖很多其他插件）  \n执行下面的命令：\n\n```oc\n$   brew uninstall libimobiledevice\n$   brew install --HEAD libimobiledevice\n```\n\n下载[iOS App Signer](https://github.com/DanTheMan827/ios-app-signer)重签名工具*（省去很多命令行操作，一键重签名！）*  \n\n（3）\t下载砸壳的微信应用\n>\t因为AppStore的包是被加密（有壳），无法进行重签名，所以要用砸壳的，可以用dumpdecrypted自己砸壳，也可以直接利用PP助手或者itool助手下载越狱版已经砸过壳的微信应用。  \n\n（4）\t安装yololib  \nyololib可以将dylib注入进WeChat二进制文件中，这样才能是你的Hook有作用，下载之后编译得到[yololib](https://github.com/gaoshilei/yololib)\n\n####\t代码注入以及打包安装 \n\n#####\t（1）生成静态库  \n在上一步中已经安装好iOSOpendev，此时打开Xcode新建项目，在选择工程界面会出现iOSOpendev的工程，这里我们要选择CaptainHook Tweak项目\n![iOSOpenDev](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8DiOSDev.png)\n新建好的工程只有一个.mm文件，我们只需要把所有hook方法写在这个文件中即可。  \n因为非越狱机不能像越狱机一样可以安装tweak插件对原来的应用进行hook，CaptainHook使用的Runtime机制实现，利用宏命令封装类定义、方法替换等功能，简单介绍它的使用方法：  \n\n1.\thook某个类\n \n```oc\nCHDeclareClass(WCContentItemViewTemplateNewSight); \n```\n`CHDeclareClass(ClassName)`表示要hook哪个类，一般写在对这个类操作的最前面。\n\n2.\t在hook的类种新建方法  \n\n```oc\nCHDeclareMethod0(id, WCContentItemViewTemplateNewSight, SLSightDataItem){......}\n```\n`CHDeclareMethod(count, return_type, class_type, name1, arg1, ....)`表示新建一个方法，count表示这个方法的参数个数，return_type表示返回类型，class_type填写这个方法所在的类名，name1表示方法名，arg1表示第一个参数，如果没有参数则不填，以此类推。  \n\n3.\thook原来的方法  \n\n```oc\nCHOptimizedMethod0(self, void, WCContentItemViewTemplateNewSight, onLongTouch){\nCHSuper(0, className, Method);//可选\n......\n}\n```\n`CHOptimizedMethod(count, optimization, return_type, class_type, name1, type1, arg1)` 表示hook原来的方法（如果不加`CHSuper(0, className, Method)`表示复写原来的方法，CHSuper表示在当前位置调用原来的方法实现），count表示hook的方法参数个数，optimization一般填self，return_type即方法返回值类型，class_type填当前类的类名，name1是方法名，arg1是参数，如果没有参数不同填写arg，以此类推。  \n\n4.\t构造函数\n\n```oc\nCHConstructor\n{\n    @autoreleasepool\n    {\n        CHLoadLateClass(WCContentItemViewTemplateNewSight);\n        CHHook(0, WCContentItemViewTemplateNewSight, onLongTouch);    \n     }\n}\n```\n这是CaptainHook的入口函数，所有被hook的类必须在这里声明加载，类里面的方法要在这里声明hook。  \n然后就可以往类和方法中写代码了，代码太长不贴了，请自行下载  \n**[MMPlugin传送门](https://github.com/gaoshilei/MMPlugin)**  \n**这个项目中包含了小视频转发、自动抢红包、修改微信运动步数功能，自动抢红包和修改微信运动步数功能可以手动关闭。**\n>\t注意：如果用到了系统的类记住要导入相应的类库（比方说UIKit）和头文件否则编译的时候会报错。\n\n编译成功之后就可以在Products文件夹中找到编译好的静态库了  \n![编译好的静态库](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-%E7%BC%96%E8%AF%91%E5%A5%BD%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93.png)  \n在finder中找到它，拷贝出来待用。\n#####\t(2)\t签名+打包+安装  \n进行到这里目前应该有的材料有：\n\n-\t砸壳的微信app    \n- \t编译好的MMPlugin.dylib\n-  安装好的iOS App Signer\n-  编译好的yololib文件  \n-  ideviceinstaller\n\n从原来的微信app中找到WeChat二进制文件拷贝出来待用，**删除weChat.app中的Watch文件夹、PlugIns文件夹中的WeChatShareExtensionNew.appex**，这步操作必须要做，不然安装的时候会报签名错误。  \n执行下面的命令将MMPlugin.dylib注入到WeChat二进制文件中，命令如下：\n\n```shell\nLeonLei-MBP:WeChat gaoshilei$ ./yololib WeChat MMPlugin.dylib\n```\n**执行这个命令时要确保yololib、WeChat、WeChat.app处于同一目录下。** \n\n完成之后将MMPlugin.dylib和WeChat拷贝到原来的WeChat.app中，覆盖掉原来的WeChat文件。  \n打开iOS App Signer按照下图选择好各项参数：\n![iOS App Signer](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-iOSAppSigner.png)  \n我这里选择的是企业级证书，个人开发者证书也是可以的，个人开发者一定要选择开发环境的并且要将需要安装的机器udid添加到prov文件里面去，选好之后点击start，稍等片刻一个经过重签名的ipa包就生成了。  \n连上你的手机执行下面的命令查看ideviceinstaller是否连接上手机：\n\n```shell\nLeonLei-MBP:WeChat gaoshilei$ ideviceinfo\n```\n如果打印出一大堆手机的信息表示连接成功可以安装ipa包，如果不成功请根据错误提示进行调整。执行下面的命令进行安装：  \n\n```shell\nLeonLei-MBP:WeChat gaoshilei$ ideviceinstaller -i WeChat.ipa \nWARNING: could not locate iTunesMetadata.plist in archive!\nWARNING: could not locate Payload/WeChat.app/SC_Info/WeChat.sinf in archive!\nCopying 'WeChat.ipa' to device... DONE.\nInstalling 'com.xxxxxxxxxxxx'\n - CreatingStagingDirectory (5%)\n - ExtractingPackage (15%)\n - InspectingPackage (20%)\n - TakingInstallLock (20%)\n - PreflightingApplication (30%)\n - InstallingEmbeddedProfile (30%)\n - VerifyingApplication (40%)\n - CreatingContainer (50%)\n - InstallingApplication (60%)\n - PostflightingApplication (70%)\n - SandboxingApplication (80%)\n - GeneratingApplicationMap (90%)\n - Complete\n```\n安装完成，在手机上打开微信试试我们添加的新功能吧！如果某个环节卡住会报错，请根据报错信息进行修改。请看效果图：  \n![小视频转发](http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%E6%95%88%E6%9E%9C%E5%9B%BE.jpg)  \n\n####\t有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。\n","slug":"手把手教你逆向微信之朋友圈小视频转发（下）","published":1,"updated":"2017-11-02T13:09:57.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9no6vnx002ejaen0xdg4moq","content":"<blockquote>\n<p>   接上篇<a href=\"http://www.gaoshilei.com/2016/11/09/手把手教你逆向微信之朋友圈小视频转发（上）/\">《手把手教你逆向微信之朋友圈小视频转发（上）》</a></p>\n</blockquote>\n<h2 id=\"代码编写及重签名打包安装-（下篇）\"><a href=\"#代码编写及重签名打包安装-（下篇）\" class=\"headerlink\" title=\"代码编写及重签名打包安装 （下篇）\"></a>代码编写及重签名打包安装 （下篇）</h2><p>小视频的转发支持4个功能，转发至朋友圈、转发至好友、保存到本地相册、拷贝小视频链接到粘贴板。如果小视频没有下载长按时只会出现拷贝url链接。<br><a id=\"more\"></a><br>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<p><em>（非越狱机和不想利用tweak安装的越狱机<a href=\"#section_two\">点我跳到第二节</a>）</em></p>\n<h3 id=\"1-越狱机打包安装（tweak安装）\"><a href=\"#1-越狱机打包安装（tweak安装）\" class=\"headerlink\" title=\"1.越狱机打包安装（tweak安装）\"></a>1.越狱机打包安装（tweak安装）</h3><p>1&gt;    新建tweak工程<br>2&gt;    编写tweak文件</p>\n<p>这里要hook两个类，分别是WCContentItemViewTemplateNewSight和SightMomentEditViewController，在WCContentItemViewTemplateNewSight中hook住onLongTouch方法然后添加menu弹出菜单，依次添加响应的方法，具体的代码如下：  </p>\n<ul>\n<li>拷贝小视频的url链接</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">  NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</div><div class=\"line\">    UISaveVideoAtPathToSavedPhotosAlbum(localPath, nil, nil, nil);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>保存小视频到本地相册</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</div><div class=\"line\">    UISaveVideoAtPathToSavedPhotosAlbum(localPath, nil, nil, nil);</div></pre></td></tr></table></figure>\n<ul>\n<li>转发到朋友圈</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">SightMomentEditViewController *editSightVC = [[%c(SightMomentEditViewController) alloc] init];</div><div class=\"line\">   NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</div><div class=\"line\">   UIImage *image = [[self valueForKey:@&quot;_sightView&quot;] getImage];</div><div class=\"line\">   [editSightVC setRealMoviePath:localPath];</div><div class=\"line\">   [editSightVC setMoviePath:localPath];</div><div class=\"line\">   [editSightVC setRealThumbImage:image];</div><div class=\"line\">   [editSightVC setThumbImage:image];</div><div class=\"line\">   [WCTimelineVC presentViewController:editSightVC animated:YES completion:^&#123;</div><div class=\"line\"></div><div class=\"line\">   &#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>转发给好友</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self sendSightToFriend];</div></pre></td></tr></table></figure>\n<ul>\n<li>长按手势</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIMenuController *menuController = [UIMenuController sharedMenuController];</div><div class=\"line\">if (menuController.isMenuVisible) return;//防止出现menu闪屏的情况</div><div class=\"line\">[self becomeFirstResponder];</div><div class=\"line\">NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</div><div class=\"line\">BOOL isExist =[[NSFileManager defaultManager] fileExistsAtPath:localPath];</div><div class=\"line\">UIMenuItem *retweetMenuItem = [[UIMenuItem alloc] initWithTitle:@&quot;朋友圈&quot; action:@selector(SLRetweetSight)];</div><div class=\"line\">UIMenuItem *saveToDiskMenuItem = [[UIMenuItem alloc] initWithTitle:@&quot;保存到相册&quot; action:@selector(SLSightSaveToDisk)];</div><div class=\"line\">UIMenuItem *sendToFriendsMenuItem = [[UIMenuItem alloc] initWithTitle:@&quot;好友&quot; action:@selector(SLSightSendToFriends)];</div><div class=\"line\">UIMenuItem *copyURLMenuItem = [[UIMenuItem alloc] initWithTitle:@&quot;复制链接&quot; action:@selector(SLSightCopyUrl)];</div><div class=\"line\">if(isExist)&#123;</div><div class=\"line\">    [menuController setMenuItems:@[retweetMenuItem,sendToFriendsMenuItem,saveToDiskMenuItem,copyURLMenuItem]];</div><div class=\"line\">&#125;else&#123;</div><div class=\"line\">    [menuController setMenuItems:@[copyURLMenuItem]];</div><div class=\"line\">&#125;</div><div class=\"line\">[menuController setTargetRect:CGRectZero inView:self];</div><div class=\"line\">[menuController setMenuVisible:YES animated:YES];</div></pre></td></tr></table></figure>\n<p>具体的tweak文件我放在了github上，<a href=\"https://github.com/gaoshilei/WCSightRetweet\" target=\"_blank\" rel=\"external\">WCSightRetweet传送门</a></p>\n<p>3&gt;    编写WCTimelineRetweet.h头文件<br>编写这个头文件的目的是防止tweak在编译期间报错，我们可以在编写好tweak试着编译一下，然后根据报错信息来添加这个头文件的内容，在这个文件中要声明在tweak我们用到的微信的类和方法，具体请看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface WCUrl : NSObject</div><div class=\"line\">@property(retain, nonatomic) NSString *url;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCContentItem : NSObject</div><div class=\"line\">@property(retain, nonatomic) NSMutableArray *mediaList;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCDataItem : NSObject</div><div class=\"line\">@property(retain, nonatomic) WCContentItem *contentObj;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCMediaItem : NSObject</div><div class=\"line\">@property(retain, nonatomic) WCUrl *dataUrl;</div><div class=\"line\">- (id)pathForSightData;</div><div class=\"line\">@end</div><div class=\"line\">@interface MMServiceCenter : NSObject</div><div class=\"line\">+ (id)defaultCenter;</div><div class=\"line\">- (id)getService:(Class)arg1;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCFacade : NSObject</div><div class=\"line\">- (id)getTimelineDataItemOfIndex:(long long)arg1;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCSightView : UIView</div><div class=\"line\">- (id)getImage;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCContentItemViewTemplateNewSight : UIView&#123;</div><div class=\"line\">    WCSightView *_sightView;</div><div class=\"line\">&#125;</div><div class=\"line\">- (WCMediaItem *)iOSREMediaItemFromSight;</div><div class=\"line\">- (void)iOSREOnSaveToDisk;</div><div class=\"line\">- (void)iOSREOnCopyURL;</div><div class=\"line\">- (void)sendSightToFriend;</div><div class=\"line\">@end</div><div class=\"line\">@interface SightMomentEditViewController : UIViewController</div><div class=\"line\">@property(retain, nonatomic) NSString *moviePath;</div><div class=\"line\">@property(retain, nonatomic) NSString *realMoviePath;</div><div class=\"line\">@property(retain, nonatomic) UIImage *thumbImage;</div><div class=\"line\">@property(retain, nonatomic) UIImage *realThumbImage;</div><div class=\"line\">- (void)makeInputController;</div><div class=\"line\">@end</div><div class=\"line\">@interface MMWindowController : NSObject</div><div class=\"line\">- (id)initWithViewController:(id)arg1 windowLevel:(int)arg2;</div><div class=\"line\">- (void)showWindowAnimated:(_Bool)arg1;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCTimeLineViewController : UIViewController</div><div class=\"line\">- (long long)calcDataItemIndex:(long long)arg1;</div><div class=\"line\">@end</div><div class=\"line\">@interface MMTableViewCell : UIView</div><div class=\"line\">@end</div><div class=\"line\">@interface MMTableView : UIView</div><div class=\"line\">- (id)indexPathForCell:(id)cell;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>4&gt;    Makefile文件修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">THEOS_DEVICE_IP = 192.168.0.115//手机所在的IP</div><div class=\"line\">include $(THEOS)/makefiles/common.mk</div><div class=\"line\">ARCHS = arm64//支持的CPU架构</div><div class=\"line\">TWEAK_NAME = WCTimelineSightRetweet</div><div class=\"line\">WCTimelineSightRetweet_FILES = Tweak.xm</div><div class=\"line\">WCTimelineSightRetweet_FRAMEWORKS = UIKit CoreGraphics//导入系统的framework</div><div class=\"line\">include $(THEOS_MAKE_PATH)/tweak.mk</div><div class=\"line\"></div><div class=\"line\">after-install::</div><div class=\"line\">\tinstall.exec &quot;killall -9 WeChat&quot;//安装完成杀掉的进程</div></pre></td></tr></table></figure>\n<p>control文件不需要做修改，然后执行命令<code>make package install</code>安装到手机，微信会被杀掉，然后再次打开微信转发小视频的功能已经加上了。  </p>\n<h3 id=\"2-微信重签名打包安装\"><a href=\"#2-微信重签名打包安装\" class=\"headerlink\" title=\"2.微信重签名打包安装 \"></a><span id=\"section_two\">2.微信重签名打包安装 </span></h3><h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><h5 id=\"（1）-安装iOSOpenDev\"><a href=\"#（1）-安装iOSOpenDev\" class=\"headerlink\" title=\"（1）    安装iOSOpenDev\"></a>（1）    安装iOSOpenDev</h5><p>1&gt;    安装 <a href=\"https://www.macports.org/install.php\" target=\"_blank\" rel=\"external\">macports</a> (安装过程需要连接VPN,否则无法安装成功)</p>\n<p>2&gt;    安装完MacPorts后打开终端，输入 <code>sudo port -v selfupdate</code> 更新MacPorts到最新版本，时间可能比较长。</p>\n<p>3&gt;    更新完MacPorts后安装DPKG文件，在终端输入<code>sudo port -f install dpkg</code></p>\n<p>4&gt;    下载安装 <a href=\"http://iosopendev.com/download\" target=\"_blank\" rel=\"external\">iOSOpendev</a> 如果安装失败，可以通过 <code>Command + L</code> 查看安装中出现的问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">PackageKit: Install Failed: Error Domain=PKInstallErrorDomain Code=112 &quot;运行软件包“iOSOpenDev-1.6-2.pkg”的脚本时出错。&quot; UserInfo=&#123;NSFilePath=./postinstall, NSURL=file://localhost/Users/ice/Downloads/iOSOpenDev-1.6-2.pkg#iodsetup.pkg, PKInstallPackageIdentifier=com.iosopendev.iosopendev162.iod-setup.pkg, NSLocalizedDescription=运行软件包“iOSOpenDev-1.6-2.pkg”的脚本时出错。&#125; &#123;</div><div class=\"line\">        NSFilePath = &quot;./postinstall&quot;;</div><div class=\"line\">        NSLocalizedDescription = &quot;\\U8fd0\\U884c\\U8f6f\\U4ef6\\U5305\\U201ciOSOpenDev-1.6-2.pkg\\U201d\\U7684\\U811a\\U672c\\U65f6\\U51fa\\U9519\\U3002&quot;;</div><div class=\"line\">        NSURL = &quot;file://localhost/Users/ice/Downloads/iOSOpenDev-1.6-2.pkg#iodsetup.pkg&quot;;</div><div class=\"line\">        PKInstallPackageIdentifier = &quot;com.iosopendev.iosopendev162.iod-setup.pkg&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里有一个解决方案：下载<a href=\"https://github.com/gaoshilei/iOSOpenDevInstallSolve\" target=\"_blank\" rel=\"external\">iOSOpenDevInstallSolve</a>中的Specifications文件夹  </p>\n<p><strong>修复安装失败问题</strong><br>打开步骤4下载的Specifications文件夹，里面应该有8个文件,如果你有安装多个xcode注意放到对应的xcode里面。  </p>\n<ol>\n<li>iPhoneOS开头的四个文件放到/应用程序/Xcode/Content/Developer/Platforms/IphoneOS.platform/Developer/Library/Xcode/Specifications文件夹下（如果没有，请自己创建一个Specifications文件夹）  </li>\n<li>iPhone Simulator 开头的另外四个文件放入/应用程序/Xcode/Content/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications文件夹下(如果没有，请同样创建一个)  </li>\n<li>在/应用程序/Xcode/Content/Developer/Platforms/iPhoneSimulator.platform/Developer/文件夹下创建usr文件夹，usr文件夹下再创建一个名为bin的文件夹。<br><strong>注意：有时候会提示安装失败，打开Xcode新建工程，如果在工程的选项菜单中有iOSOpenDev就表示安装成功了，不用管那个安装提示。</strong>  </li>\n</ol>\n<h5 id=\"（2）-安装ideviceinstaller\"><a href=\"#（2）-安装ideviceinstaller\" class=\"headerlink\" title=\"（2）    安装ideviceinstaller\"></a>（2）    安装ideviceinstaller</h5><blockquote>\n<p>   安装ipa包用的，也可以通过itool之类的工具，不过ideviceinstaller可以看到安装过程的过程，方便我们找到出错原因。</p>\n</blockquote>\n<p>执行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install ideviceinstaller</div></pre></td></tr></table></figure>\n<p>如果提示brew命令找不到，那就是你的Mac还没有安装<a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"external\">Homebrew</a><br>常见的报错信息：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR: Could not connect to lockdownd, error code -5</div></pre></td></tr></table></figure>\n<p>这个时候只要重新安装libimobiledevice就可以了（因为ideviceinstaller依赖很多其他插件）<br>执行下面的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$   brew uninstall libimobiledevice</div><div class=\"line\">$   brew install --HEAD libimobiledevice</div></pre></td></tr></table></figure>\n<p>下载<a href=\"https://github.com/DanTheMan827/ios-app-signer\" target=\"_blank\" rel=\"external\">iOS App Signer</a>重签名工具<em>（省去很多命令行操作，一键重签名！）</em>  </p>\n<p>（3）    下载砸壳的微信应用</p>\n<blockquote>\n<p>   因为AppStore的包是被加密（有壳），无法进行重签名，所以要用砸壳的，可以用dumpdecrypted自己砸壳，也可以直接利用PP助手或者itool助手下载越狱版已经砸过壳的微信应用。  </p>\n</blockquote>\n<p>（4）    安装yololib<br>yololib可以将dylib注入进WeChat二进制文件中，这样才能是你的Hook有作用，下载之后编译得到<a href=\"https://github.com/gaoshilei/yololib\" target=\"_blank\" rel=\"external\">yololib</a></p>\n<h4 id=\"代码注入以及打包安装\"><a href=\"#代码注入以及打包安装\" class=\"headerlink\" title=\"代码注入以及打包安装\"></a>代码注入以及打包安装</h4><h5 id=\"（1）生成静态库\"><a href=\"#（1）生成静态库\" class=\"headerlink\" title=\"（1）生成静态库\"></a>（1）生成静态库</h5><p>在上一步中已经安装好iOSOpendev，此时打开Xcode新建项目，在选择工程界面会出现iOSOpendev的工程，这里我们要选择CaptainHook Tweak项目<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8DiOSDev.png\" alt=\"iOSOpenDev\"><br>新建好的工程只有一个.mm文件，我们只需要把所有hook方法写在这个文件中即可。<br>因为非越狱机不能像越狱机一样可以安装tweak插件对原来的应用进行hook，CaptainHook使用的Runtime机制实现，利用宏命令封装类定义、方法替换等功能，简单介绍它的使用方法：  </p>\n<ol>\n<li>hook某个类</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CHDeclareClass(WCContentItemViewTemplateNewSight);</div></pre></td></tr></table></figure>\n<p><code>CHDeclareClass(ClassName)</code>表示要hook哪个类，一般写在对这个类操作的最前面。</p>\n<ol>\n<li>在hook的类种新建方法  </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CHDeclareMethod0(id, WCContentItemViewTemplateNewSight, SLSightDataItem)&#123;......&#125;</div></pre></td></tr></table></figure>\n<p><code>CHDeclareMethod(count, return_type, class_type, name1, arg1, ....)</code>表示新建一个方法，count表示这个方法的参数个数，return_type表示返回类型，class_type填写这个方法所在的类名，name1表示方法名，arg1表示第一个参数，如果没有参数则不填，以此类推。  </p>\n<ol>\n<li>hook原来的方法  </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">CHOptimizedMethod0(self, void, WCContentItemViewTemplateNewSight, onLongTouch)&#123;</div><div class=\"line\">CHSuper(0, className, Method);//可选</div><div class=\"line\">......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>CHOptimizedMethod(count, optimization, return_type, class_type, name1, type1, arg1)</code> 表示hook原来的方法（如果不加<code>CHSuper(0, className, Method)</code>表示复写原来的方法，CHSuper表示在当前位置调用原来的方法实现），count表示hook的方法参数个数，optimization一般填self，return_type即方法返回值类型，class_type填当前类的类名，name1是方法名，arg1是参数，如果没有参数不同填写arg，以此类推。  </p>\n<ol>\n<li>构造函数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">CHConstructor</div><div class=\"line\">&#123;</div><div class=\"line\">    @autoreleasepool</div><div class=\"line\">    &#123;</div><div class=\"line\">        CHLoadLateClass(WCContentItemViewTemplateNewSight);</div><div class=\"line\">        CHHook(0, WCContentItemViewTemplateNewSight, onLongTouch);    </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是CaptainHook的入口函数，所有被hook的类必须在这里声明加载，类里面的方法要在这里声明hook。<br>然后就可以往类和方法中写代码了，代码太长不贴了，请自行下载<br><strong><a href=\"https://github.com/gaoshilei/MMPlugin\" target=\"_blank\" rel=\"external\">MMPlugin传送门</a></strong><br><strong>这个项目中包含了小视频转发、自动抢红包、修改微信运动步数功能，自动抢红包和修改微信运动步数功能可以手动关闭。</strong></p>\n<blockquote>\n<p>   注意：如果用到了系统的类记住要导入相应的类库（比方说UIKit）和头文件否则编译的时候会报错。</p>\n</blockquote>\n<p>编译成功之后就可以在Products文件夹中找到编译好的静态库了<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-%E7%BC%96%E8%AF%91%E5%A5%BD%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93.png\" alt=\"编译好的静态库\"><br>在finder中找到它，拷贝出来待用。</p>\n<h5 id=\"2-签名-打包-安装\"><a href=\"#2-签名-打包-安装\" class=\"headerlink\" title=\"(2)    签名+打包+安装\"></a>(2)    签名+打包+安装</h5><p>进行到这里目前应该有的材料有：</p>\n<ul>\n<li>砸壳的微信app    </li>\n<li>编译好的MMPlugin.dylib</li>\n<li>安装好的iOS App Signer</li>\n<li>编译好的yololib文件  </li>\n<li>ideviceinstaller</li>\n</ul>\n<p>从原来的微信app中找到WeChat二进制文件拷贝出来待用，<strong>删除weChat.app中的Watch文件夹、PlugIns文件夹中的WeChatShareExtensionNew.appex</strong>，这步操作必须要做，不然安装的时候会报签名错误。<br>执行下面的命令将MMPlugin.dylib注入到WeChat二进制文件中，命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:WeChat gaoshilei$ ./yololib WeChat MMPlugin.dylib</div></pre></td></tr></table></figure>\n<p><strong>执行这个命令时要确保yololib、WeChat、WeChat.app处于同一目录下。</strong> </p>\n<p>完成之后将MMPlugin.dylib和WeChat拷贝到原来的WeChat.app中，覆盖掉原来的WeChat文件。<br>打开iOS App Signer按照下图选择好各项参数：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-iOSAppSigner.png\" alt=\"iOS App Signer\"><br>我这里选择的是企业级证书，个人开发者证书也是可以的，个人开发者一定要选择开发环境的并且要将需要安装的机器udid添加到prov文件里面去，选好之后点击start，稍等片刻一个经过重签名的ipa包就生成了。<br>连上你的手机执行下面的命令查看ideviceinstaller是否连接上手机：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:WeChat gaoshilei$ ideviceinfo</div></pre></td></tr></table></figure>\n<p>如果打印出一大堆手机的信息表示连接成功可以安装ipa包，如果不成功请根据错误提示进行调整。执行下面的命令进行安装：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:WeChat gaoshilei$ ideviceinstaller -i WeChat.ipa </div><div class=\"line\">WARNING: could not locate iTunesMetadata.plist in archive!</div><div class=\"line\">WARNING: could not locate Payload/WeChat.app/SC_Info/WeChat.sinf in archive!</div><div class=\"line\">Copying &apos;WeChat.ipa&apos; to device... DONE.</div><div class=\"line\">Installing &apos;com.xxxxxxxxxxxx&apos;</div><div class=\"line\"> - CreatingStagingDirectory (5%)</div><div class=\"line\"> - ExtractingPackage (15%)</div><div class=\"line\"> - InspectingPackage (20%)</div><div class=\"line\"> - TakingInstallLock (20%)</div><div class=\"line\"> - PreflightingApplication (30%)</div><div class=\"line\"> - InstallingEmbeddedProfile (30%)</div><div class=\"line\"> - VerifyingApplication (40%)</div><div class=\"line\"> - CreatingContainer (50%)</div><div class=\"line\"> - InstallingApplication (60%)</div><div class=\"line\"> - PostflightingApplication (70%)</div><div class=\"line\"> - SandboxingApplication (80%)</div><div class=\"line\"> - GeneratingApplicationMap (90%)</div><div class=\"line\"> - Complete</div></pre></td></tr></table></figure>\n<p>安装完成，在手机上打开微信试试我们添加的新功能吧！如果某个环节卡住会报错，请根据报错信息进行修改。请看效果图：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%E6%95%88%E6%9E%9C%E5%9B%BE.jpg\" alt=\"小视频转发\">  </p>\n<h4 id=\"有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。\"><a href=\"#有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。\" class=\"headerlink\" title=\"有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。\"></a>有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。</h4>","site":{"data":{}},"excerpt":"<blockquote>\n<p>   接上篇<a href=\"http://www.gaoshilei.com/2016/11/09/手把手教你逆向微信之朋友圈小视频转发（上）/\">《手把手教你逆向微信之朋友圈小视频转发（上）》</a></p>\n</blockquote>\n<h2 id=\"代码编写及重签名打包安装-（下篇）\"><a href=\"#代码编写及重签名打包安装-（下篇）\" class=\"headerlink\" title=\"代码编写及重签名打包安装 （下篇）\"></a>代码编写及重签名打包安装 （下篇）</h2><p>小视频的转发支持4个功能，转发至朋友圈、转发至好友、保存到本地相册、拷贝小视频链接到粘贴板。如果小视频没有下载长按时只会出现拷贝url链接。<br>","more":"<br>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<p><em>（非越狱机和不想利用tweak安装的越狱机<a href=\"#section_two\">点我跳到第二节</a>）</em></p>\n<h3 id=\"1-越狱机打包安装（tweak安装）\"><a href=\"#1-越狱机打包安装（tweak安装）\" class=\"headerlink\" title=\"1.越狱机打包安装（tweak安装）\"></a>1.越狱机打包安装（tweak安装）</h3><p>1&gt;    新建tweak工程<br>2&gt;    编写tweak文件</p>\n<p>这里要hook两个类，分别是WCContentItemViewTemplateNewSight和SightMomentEditViewController，在WCContentItemViewTemplateNewSight中hook住onLongTouch方法然后添加menu弹出菜单，依次添加响应的方法，具体的代码如下：  </p>\n<ul>\n<li>拷贝小视频的url链接</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">  NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</div><div class=\"line\">    UISaveVideoAtPathToSavedPhotosAlbum(localPath, nil, nil, nil);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>保存小视频到本地相册</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</div><div class=\"line\">    UISaveVideoAtPathToSavedPhotosAlbum(localPath, nil, nil, nil);</div></pre></td></tr></table></figure>\n<ul>\n<li>转发到朋友圈</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">SightMomentEditViewController *editSightVC = [[%c(SightMomentEditViewController) alloc] init];</div><div class=\"line\">   NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</div><div class=\"line\">   UIImage *image = [[self valueForKey:@&quot;_sightView&quot;] getImage];</div><div class=\"line\">   [editSightVC setRealMoviePath:localPath];</div><div class=\"line\">   [editSightVC setMoviePath:localPath];</div><div class=\"line\">   [editSightVC setRealThumbImage:image];</div><div class=\"line\">   [editSightVC setThumbImage:image];</div><div class=\"line\">   [WCTimelineVC presentViewController:editSightVC animated:YES completion:^&#123;</div><div class=\"line\"></div><div class=\"line\">   &#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>转发给好友</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self sendSightToFriend];</div></pre></td></tr></table></figure>\n<ul>\n<li>长按手势</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIMenuController *menuController = [UIMenuController sharedMenuController];</div><div class=\"line\">if (menuController.isMenuVisible) return;//防止出现menu闪屏的情况</div><div class=\"line\">[self becomeFirstResponder];</div><div class=\"line\">NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</div><div class=\"line\">BOOL isExist =[[NSFileManager defaultManager] fileExistsAtPath:localPath];</div><div class=\"line\">UIMenuItem *retweetMenuItem = [[UIMenuItem alloc] initWithTitle:@&quot;朋友圈&quot; action:@selector(SLRetweetSight)];</div><div class=\"line\">UIMenuItem *saveToDiskMenuItem = [[UIMenuItem alloc] initWithTitle:@&quot;保存到相册&quot; action:@selector(SLSightSaveToDisk)];</div><div class=\"line\">UIMenuItem *sendToFriendsMenuItem = [[UIMenuItem alloc] initWithTitle:@&quot;好友&quot; action:@selector(SLSightSendToFriends)];</div><div class=\"line\">UIMenuItem *copyURLMenuItem = [[UIMenuItem alloc] initWithTitle:@&quot;复制链接&quot; action:@selector(SLSightCopyUrl)];</div><div class=\"line\">if(isExist)&#123;</div><div class=\"line\">    [menuController setMenuItems:@[retweetMenuItem,sendToFriendsMenuItem,saveToDiskMenuItem,copyURLMenuItem]];</div><div class=\"line\">&#125;else&#123;</div><div class=\"line\">    [menuController setMenuItems:@[copyURLMenuItem]];</div><div class=\"line\">&#125;</div><div class=\"line\">[menuController setTargetRect:CGRectZero inView:self];</div><div class=\"line\">[menuController setMenuVisible:YES animated:YES];</div></pre></td></tr></table></figure>\n<p>具体的tweak文件我放在了github上，<a href=\"https://github.com/gaoshilei/WCSightRetweet\" target=\"_blank\" rel=\"external\">WCSightRetweet传送门</a></p>\n<p>3&gt;    编写WCTimelineRetweet.h头文件<br>编写这个头文件的目的是防止tweak在编译期间报错，我们可以在编写好tweak试着编译一下，然后根据报错信息来添加这个头文件的内容，在这个文件中要声明在tweak我们用到的微信的类和方法，具体请看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface WCUrl : NSObject</div><div class=\"line\">@property(retain, nonatomic) NSString *url;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCContentItem : NSObject</div><div class=\"line\">@property(retain, nonatomic) NSMutableArray *mediaList;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCDataItem : NSObject</div><div class=\"line\">@property(retain, nonatomic) WCContentItem *contentObj;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCMediaItem : NSObject</div><div class=\"line\">@property(retain, nonatomic) WCUrl *dataUrl;</div><div class=\"line\">- (id)pathForSightData;</div><div class=\"line\">@end</div><div class=\"line\">@interface MMServiceCenter : NSObject</div><div class=\"line\">+ (id)defaultCenter;</div><div class=\"line\">- (id)getService:(Class)arg1;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCFacade : NSObject</div><div class=\"line\">- (id)getTimelineDataItemOfIndex:(long long)arg1;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCSightView : UIView</div><div class=\"line\">- (id)getImage;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCContentItemViewTemplateNewSight : UIView&#123;</div><div class=\"line\">    WCSightView *_sightView;</div><div class=\"line\">&#125;</div><div class=\"line\">- (WCMediaItem *)iOSREMediaItemFromSight;</div><div class=\"line\">- (void)iOSREOnSaveToDisk;</div><div class=\"line\">- (void)iOSREOnCopyURL;</div><div class=\"line\">- (void)sendSightToFriend;</div><div class=\"line\">@end</div><div class=\"line\">@interface SightMomentEditViewController : UIViewController</div><div class=\"line\">@property(retain, nonatomic) NSString *moviePath;</div><div class=\"line\">@property(retain, nonatomic) NSString *realMoviePath;</div><div class=\"line\">@property(retain, nonatomic) UIImage *thumbImage;</div><div class=\"line\">@property(retain, nonatomic) UIImage *realThumbImage;</div><div class=\"line\">- (void)makeInputController;</div><div class=\"line\">@end</div><div class=\"line\">@interface MMWindowController : NSObject</div><div class=\"line\">- (id)initWithViewController:(id)arg1 windowLevel:(int)arg2;</div><div class=\"line\">- (void)showWindowAnimated:(_Bool)arg1;</div><div class=\"line\">@end</div><div class=\"line\">@interface WCTimeLineViewController : UIViewController</div><div class=\"line\">- (long long)calcDataItemIndex:(long long)arg1;</div><div class=\"line\">@end</div><div class=\"line\">@interface MMTableViewCell : UIView</div><div class=\"line\">@end</div><div class=\"line\">@interface MMTableView : UIView</div><div class=\"line\">- (id)indexPathForCell:(id)cell;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>4&gt;    Makefile文件修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">THEOS_DEVICE_IP = 192.168.0.115//手机所在的IP</div><div class=\"line\">include $(THEOS)/makefiles/common.mk</div><div class=\"line\">ARCHS = arm64//支持的CPU架构</div><div class=\"line\">TWEAK_NAME = WCTimelineSightRetweet</div><div class=\"line\">WCTimelineSightRetweet_FILES = Tweak.xm</div><div class=\"line\">WCTimelineSightRetweet_FRAMEWORKS = UIKit CoreGraphics//导入系统的framework</div><div class=\"line\">include $(THEOS_MAKE_PATH)/tweak.mk</div><div class=\"line\"></div><div class=\"line\">after-install::</div><div class=\"line\">\tinstall.exec &quot;killall -9 WeChat&quot;//安装完成杀掉的进程</div></pre></td></tr></table></figure>\n<p>control文件不需要做修改，然后执行命令<code>make package install</code>安装到手机，微信会被杀掉，然后再次打开微信转发小视频的功能已经加上了。  </p>\n<h3 id=\"2-微信重签名打包安装\"><a href=\"#2-微信重签名打包安装\" class=\"headerlink\" title=\"2.微信重签名打包安装 \"></a><span id=\"section_two\">2.微信重签名打包安装 </span></h3><h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><h5 id=\"（1）-安装iOSOpenDev\"><a href=\"#（1）-安装iOSOpenDev\" class=\"headerlink\" title=\"（1）    安装iOSOpenDev\"></a>（1）    安装iOSOpenDev</h5><p>1&gt;    安装 <a href=\"https://www.macports.org/install.php\" target=\"_blank\" rel=\"external\">macports</a> (安装过程需要连接VPN,否则无法安装成功)</p>\n<p>2&gt;    安装完MacPorts后打开终端，输入 <code>sudo port -v selfupdate</code> 更新MacPorts到最新版本，时间可能比较长。</p>\n<p>3&gt;    更新完MacPorts后安装DPKG文件，在终端输入<code>sudo port -f install dpkg</code></p>\n<p>4&gt;    下载安装 <a href=\"http://iosopendev.com/download\" target=\"_blank\" rel=\"external\">iOSOpendev</a> 如果安装失败，可以通过 <code>Command + L</code> 查看安装中出现的问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">PackageKit: Install Failed: Error Domain=PKInstallErrorDomain Code=112 &quot;运行软件包“iOSOpenDev-1.6-2.pkg”的脚本时出错。&quot; UserInfo=&#123;NSFilePath=./postinstall, NSURL=file://localhost/Users/ice/Downloads/iOSOpenDev-1.6-2.pkg#iodsetup.pkg, PKInstallPackageIdentifier=com.iosopendev.iosopendev162.iod-setup.pkg, NSLocalizedDescription=运行软件包“iOSOpenDev-1.6-2.pkg”的脚本时出错。&#125; &#123;</div><div class=\"line\">        NSFilePath = &quot;./postinstall&quot;;</div><div class=\"line\">        NSLocalizedDescription = &quot;\\U8fd0\\U884c\\U8f6f\\U4ef6\\U5305\\U201ciOSOpenDev-1.6-2.pkg\\U201d\\U7684\\U811a\\U672c\\U65f6\\U51fa\\U9519\\U3002&quot;;</div><div class=\"line\">        NSURL = &quot;file://localhost/Users/ice/Downloads/iOSOpenDev-1.6-2.pkg#iodsetup.pkg&quot;;</div><div class=\"line\">        PKInstallPackageIdentifier = &quot;com.iosopendev.iosopendev162.iod-setup.pkg&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里有一个解决方案：下载<a href=\"https://github.com/gaoshilei/iOSOpenDevInstallSolve\" target=\"_blank\" rel=\"external\">iOSOpenDevInstallSolve</a>中的Specifications文件夹  </p>\n<p><strong>修复安装失败问题</strong><br>打开步骤4下载的Specifications文件夹，里面应该有8个文件,如果你有安装多个xcode注意放到对应的xcode里面。  </p>\n<ol>\n<li>iPhoneOS开头的四个文件放到/应用程序/Xcode/Content/Developer/Platforms/IphoneOS.platform/Developer/Library/Xcode/Specifications文件夹下（如果没有，请自己创建一个Specifications文件夹）  </li>\n<li>iPhone Simulator 开头的另外四个文件放入/应用程序/Xcode/Content/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications文件夹下(如果没有，请同样创建一个)  </li>\n<li>在/应用程序/Xcode/Content/Developer/Platforms/iPhoneSimulator.platform/Developer/文件夹下创建usr文件夹，usr文件夹下再创建一个名为bin的文件夹。<br><strong>注意：有时候会提示安装失败，打开Xcode新建工程，如果在工程的选项菜单中有iOSOpenDev就表示安装成功了，不用管那个安装提示。</strong>  </li>\n</ol>\n<h5 id=\"（2）-安装ideviceinstaller\"><a href=\"#（2）-安装ideviceinstaller\" class=\"headerlink\" title=\"（2）    安装ideviceinstaller\"></a>（2）    安装ideviceinstaller</h5><blockquote>\n<p>   安装ipa包用的，也可以通过itool之类的工具，不过ideviceinstaller可以看到安装过程的过程，方便我们找到出错原因。</p>\n</blockquote>\n<p>执行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install ideviceinstaller</div></pre></td></tr></table></figure>\n<p>如果提示brew命令找不到，那就是你的Mac还没有安装<a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"external\">Homebrew</a><br>常见的报错信息：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR: Could not connect to lockdownd, error code -5</div></pre></td></tr></table></figure>\n<p>这个时候只要重新安装libimobiledevice就可以了（因为ideviceinstaller依赖很多其他插件）<br>执行下面的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$   brew uninstall libimobiledevice</div><div class=\"line\">$   brew install --HEAD libimobiledevice</div></pre></td></tr></table></figure>\n<p>下载<a href=\"https://github.com/DanTheMan827/ios-app-signer\" target=\"_blank\" rel=\"external\">iOS App Signer</a>重签名工具<em>（省去很多命令行操作，一键重签名！）</em>  </p>\n<p>（3）    下载砸壳的微信应用</p>\n<blockquote>\n<p>   因为AppStore的包是被加密（有壳），无法进行重签名，所以要用砸壳的，可以用dumpdecrypted自己砸壳，也可以直接利用PP助手或者itool助手下载越狱版已经砸过壳的微信应用。  </p>\n</blockquote>\n<p>（4）    安装yololib<br>yololib可以将dylib注入进WeChat二进制文件中，这样才能是你的Hook有作用，下载之后编译得到<a href=\"https://github.com/gaoshilei/yololib\" target=\"_blank\" rel=\"external\">yololib</a></p>\n<h4 id=\"代码注入以及打包安装\"><a href=\"#代码注入以及打包安装\" class=\"headerlink\" title=\"代码注入以及打包安装\"></a>代码注入以及打包安装</h4><h5 id=\"（1）生成静态库\"><a href=\"#（1）生成静态库\" class=\"headerlink\" title=\"（1）生成静态库\"></a>（1）生成静态库</h5><p>在上一步中已经安装好iOSOpendev，此时打开Xcode新建项目，在选择工程界面会出现iOSOpendev的工程，这里我们要选择CaptainHook Tweak项目<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8DiOSDev.png\" alt=\"iOSOpenDev\"><br>新建好的工程只有一个.mm文件，我们只需要把所有hook方法写在这个文件中即可。<br>因为非越狱机不能像越狱机一样可以安装tweak插件对原来的应用进行hook，CaptainHook使用的Runtime机制实现，利用宏命令封装类定义、方法替换等功能，简单介绍它的使用方法：  </p>\n<ol>\n<li>hook某个类</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CHDeclareClass(WCContentItemViewTemplateNewSight);</div></pre></td></tr></table></figure>\n<p><code>CHDeclareClass(ClassName)</code>表示要hook哪个类，一般写在对这个类操作的最前面。</p>\n<ol>\n<li>在hook的类种新建方法  </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CHDeclareMethod0(id, WCContentItemViewTemplateNewSight, SLSightDataItem)&#123;......&#125;</div></pre></td></tr></table></figure>\n<p><code>CHDeclareMethod(count, return_type, class_type, name1, arg1, ....)</code>表示新建一个方法，count表示这个方法的参数个数，return_type表示返回类型，class_type填写这个方法所在的类名，name1表示方法名，arg1表示第一个参数，如果没有参数则不填，以此类推。  </p>\n<ol>\n<li>hook原来的方法  </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">CHOptimizedMethod0(self, void, WCContentItemViewTemplateNewSight, onLongTouch)&#123;</div><div class=\"line\">CHSuper(0, className, Method);//可选</div><div class=\"line\">......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>CHOptimizedMethod(count, optimization, return_type, class_type, name1, type1, arg1)</code> 表示hook原来的方法（如果不加<code>CHSuper(0, className, Method)</code>表示复写原来的方法，CHSuper表示在当前位置调用原来的方法实现），count表示hook的方法参数个数，optimization一般填self，return_type即方法返回值类型，class_type填当前类的类名，name1是方法名，arg1是参数，如果没有参数不同填写arg，以此类推。  </p>\n<ol>\n<li>构造函数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">CHConstructor</div><div class=\"line\">&#123;</div><div class=\"line\">    @autoreleasepool</div><div class=\"line\">    &#123;</div><div class=\"line\">        CHLoadLateClass(WCContentItemViewTemplateNewSight);</div><div class=\"line\">        CHHook(0, WCContentItemViewTemplateNewSight, onLongTouch);    </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是CaptainHook的入口函数，所有被hook的类必须在这里声明加载，类里面的方法要在这里声明hook。<br>然后就可以往类和方法中写代码了，代码太长不贴了，请自行下载<br><strong><a href=\"https://github.com/gaoshilei/MMPlugin\" target=\"_blank\" rel=\"external\">MMPlugin传送门</a></strong><br><strong>这个项目中包含了小视频转发、自动抢红包、修改微信运动步数功能，自动抢红包和修改微信运动步数功能可以手动关闭。</strong></p>\n<blockquote>\n<p>   注意：如果用到了系统的类记住要导入相应的类库（比方说UIKit）和头文件否则编译的时候会报错。</p>\n</blockquote>\n<p>编译成功之后就可以在Products文件夹中找到编译好的静态库了<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-%E7%BC%96%E8%AF%91%E5%A5%BD%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93.png\" alt=\"编译好的静态库\"><br>在finder中找到它，拷贝出来待用。</p>\n<h5 id=\"2-签名-打包-安装\"><a href=\"#2-签名-打包-安装\" class=\"headerlink\" title=\"(2)    签名+打包+安装\"></a>(2)    签名+打包+安装</h5><p>进行到这里目前应该有的材料有：</p>\n<ul>\n<li>砸壳的微信app    </li>\n<li>编译好的MMPlugin.dylib</li>\n<li>安装好的iOS App Signer</li>\n<li>编译好的yololib文件  </li>\n<li>ideviceinstaller</li>\n</ul>\n<p>从原来的微信app中找到WeChat二进制文件拷贝出来待用，<strong>删除weChat.app中的Watch文件夹、PlugIns文件夹中的WeChatShareExtensionNew.appex</strong>，这步操作必须要做，不然安装的时候会报签名错误。<br>执行下面的命令将MMPlugin.dylib注入到WeChat二进制文件中，命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:WeChat gaoshilei$ ./yololib WeChat MMPlugin.dylib</div></pre></td></tr></table></figure>\n<p><strong>执行这个命令时要确保yololib、WeChat、WeChat.app处于同一目录下。</strong> </p>\n<p>完成之后将MMPlugin.dylib和WeChat拷贝到原来的WeChat.app中，覆盖掉原来的WeChat文件。<br>打开iOS App Signer按照下图选择好各项参数：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-iOSAppSigner.png\" alt=\"iOS App Signer\"><br>我这里选择的是企业级证书，个人开发者证书也是可以的，个人开发者一定要选择开发环境的并且要将需要安装的机器udid添加到prov文件里面去，选好之后点击start，稍等片刻一个经过重签名的ipa包就生成了。<br>连上你的手机执行下面的命令查看ideviceinstaller是否连接上手机：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:WeChat gaoshilei$ ideviceinfo</div></pre></td></tr></table></figure>\n<p>如果打印出一大堆手机的信息表示连接成功可以安装ipa包，如果不成功请根据错误提示进行调整。执行下面的命令进行安装：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">LeonLei-MBP:WeChat gaoshilei$ ideviceinstaller -i WeChat.ipa </div><div class=\"line\">WARNING: could not locate iTunesMetadata.plist in archive!</div><div class=\"line\">WARNING: could not locate Payload/WeChat.app/SC_Info/WeChat.sinf in archive!</div><div class=\"line\">Copying &apos;WeChat.ipa&apos; to device... DONE.</div><div class=\"line\">Installing &apos;com.xxxxxxxxxxxx&apos;</div><div class=\"line\"> - CreatingStagingDirectory (5%)</div><div class=\"line\"> - ExtractingPackage (15%)</div><div class=\"line\"> - InspectingPackage (20%)</div><div class=\"line\"> - TakingInstallLock (20%)</div><div class=\"line\"> - PreflightingApplication (30%)</div><div class=\"line\"> - InstallingEmbeddedProfile (30%)</div><div class=\"line\"> - VerifyingApplication (40%)</div><div class=\"line\"> - CreatingContainer (50%)</div><div class=\"line\"> - InstallingApplication (60%)</div><div class=\"line\"> - PostflightingApplication (70%)</div><div class=\"line\"> - SandboxingApplication (80%)</div><div class=\"line\"> - GeneratingApplicationMap (90%)</div><div class=\"line\"> - Complete</div></pre></td></tr></table></figure>\n<p>安装完成，在手机上打开微信试试我们添加的新功能吧！如果某个环节卡住会报错，请根据报错信息进行修改。请看效果图：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%E6%95%88%E6%9E%9C%E5%9B%BE.jpg\" alt=\"小视频转发\">  </p>\n<h4 id=\"有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。\"><a href=\"#有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。\" class=\"headerlink\" title=\"有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。\"></a>有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。</h4>"},{"title":"【转载】黑科技：把第三方iOS应用转成动态库","date":"2016-10-15T16:00:00.000Z","_content":"\n**文章转载自[杨君的小黑屋](http://blog.imjun.net)，对排版进行了一些调整**\n\n##\t前言  \n本文会介绍一个自己写的工具，能够把第三方iOS应用转成动态库，并加载到自己的App中，文章最后会以支付宝为例，展示如何调用其中的C函数和OC方法。  \n工具开源地址：  \n[https://github.com/tobefuturer/app2dylib](https://github.com/tobefuturer/app2dylib)  \n<!-- more -->\n##\t有什么用 \n为什么要把第三方应用转成动态库呢？与一般的注入动态库+重签名打包的手段有什么不一样呢？\n\n好处主要有下面几点：  \n1.\t可以直接调用别人的算法  \n\t逆向分析别人的应用时，可能会遇到一些私有算法，如果搞不定的话，直接拿来用就好。  \n2.\t掌控程序的控制权  \n\t程序的主体是自己的App，第三方应用的代码只是以动态库的形式加载，主要的控制权还是在我们自己手里，所以可以直接绕过应用的检测代码（文章最后有关于这部分攻防的讨论）。  \n3.\t同个进程内加载多个应用  \n\t重签名打包毕竟只能是原来的应用，但是如果是动态库的话，可以同时加载多个应用到进程内了，比如你想同时把美图秀秀和饿了么加载进来也是可以的（秀秀不饿，想想去年大众点评那个APPmixer的软广 - -! ）。  \n\n##\t应用和动态库的异同  \n我们要把应用转成动态库，首先要知道这两者之前有什么相同与不同，有相同的才存在转换的可能，而不同之处就是我们要重点关注的了。  \n\n###\t相同点：  \n\n![应用和动态库的异同](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%BA%94%E7%94%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB.jpg)  \n可执行文件和动态库都是标准的 Mach-O 文件格式，两者的文件头部结构非常类似，特别是其中的代码段（TEXT）,和数据段（DATA）结构完全一致，这也是后面转换工作的基础。  \n\n###\t不同点：\n\n不同点就是我们转换工作的重点了，主要有：  \n1.\t头部的文件类型  \n\t一个是 MH_EXECUTE 可执行文件， 一个是 MH_DYLIB 动态库， 还有各种头部的Flags，要特别留意下可执行文件中Flags部分的 MH_PIE 标志，后面再详细说。    \n![头部的文件类型不同](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%B4%E9%83%A8%E6%96%87%E4%BB%B6%E4%B8%8D%E5%90%8C.jpg)  \n2.\t动态库文件中多一个类型为 LC_ID_DYLIB 的 Load Command, 作用是动态库的标识符，一般为文件路径。路径可以随便填，但是这部分必须要有，是codesign的要求。   \n![LC_ID_DYLIB 的 Load Command](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B.jpg)  \n3.\t可执行文件会多出一个 PAGEZERO段，动态库中没有。这个段开始地址为0（NULL指针指向的位置），是一个不可读、不可写、不可执行的空间，能够在空指针访问时抛出异常。这个段的大小，32位上是0x4000，64位上是4G。这个段的处理也是转换工作的重点之一，之前有人尝试转换，不成功就是因为没有处理好 PAGEZERO.  \n![多出的PAGEZERO段](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%9A%E5%87%BA%E4%B8%80%E4%B8%AA%20PAGEZERO%E6%AE%B5.jpg)  \n\n##\t实现细节  \n###\t修改文件类型  \n第一步是修改文件的头部信息，把文件类型从可执行文件修改成动态库，同时把一些Flags修改好。\n\n这里一个比较关键的Flag是可执行文件中的 MH_PIE 标志位，（position-independent executable）。\n\n这个标志位，表明可执行文件能够在内存中任意位置正确地运行，而不受其绝对地址影响的特性，这一特性是动态库所必须的一个特性。没有这个标志位的可执行文件是没有办法转换成动态库的。iOS系统中，arm64架构下，目前这个标志位是必须的，不然程序无法运行（系统的安全性要求），但是armv7架构下，可以没有这个标志位，所以支付宝armv7版本的可执行文件是不能转成动态库的，就是这个原因。不过所有的arm64的应用都是可以转换的，后面演示时用的支付宝是arm64架构的。  \n###\t头部中添加 LC_ID_DYLIB\n直接在文件头部中按照文档格式插入一个Load Command，并填入合适的数据。这里要注意下插入内容的字节数必须是8字节对齐的。  \n###\t修改PAGEZERO段\n这部分是最重要的一部分，因为arm64上这个段的大小有4G，直接往内存中加载，会提示没有足够的连续的地址空间，所以必须要调整这个段的大小，而要调整 PAGEZERO 这个段的大小, 又会引起一连串的地址空间的变化，所以不能盲目的直接改，必须结合dyld的源码来对应修改。（注意这里不能直接把 PAGEZERO 这个段给去掉，也不能直接把大小调成0，因为涉及到dyld的rebase操作，详细看后面）  \n\n####\t1.\t所有段的地址都要重新计算  \n单纯减少 PAGEZERO 段的占用空间，作用不大，因为dyld加载动态库的时候，要求是所有的段一起进行mmap（详细可以查看dyld源码的ImageLoaderMachO::assignSegmentAddresses函数），所以必须把接下来所有的段的地址都重新计算一次。\n\n同时要保证，前后两个段没有地址空间重叠，并且每个段都是按0x4000对齐。因为 PAGEZERO 是所有段中的第一个，所以可以直接把 PAGEZERO 的大小调整到0x4000，然后后面每一个段都按顺序依次减少同样大小(0xFFFFC000 = 0x100000000 - 0x4000)，同时能保证每个段在文件内的偏移量不变。\n\n**修改前：**  \n![PAGEZERO段修改前](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-PAGEZERO%E6%AE%B5%E4%BF%AE%E6%94%B9%E5%89%8D.jpg)  \n\n**修改后：**  \n![PAGEZERO段修改后](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-PAGEZERO%E6%AE%B5%E4%BF%AE%E6%94%B9%E5%90%8E.jpg)  \n\n \n####\t2.\t对动态库进行rebase操作  \n这里的rebase是系统为了解决动态库虚拟内存地址冲突，在加载动态库时进行的基地址重定位操作。\n\n这一步操作是整个流程里最重要的，因为按照前面的操作，整个文件地址空间已经发生了变化，如果dyld依然按照原来的地址进行rebase，必然会失败。\n\n那么rebase操作需要做哪些工作呢？\n\n相关的信息储存在 Mach-O 文件的 LINKEDIT 段中, 并由 LC_DYLD_INFO_ONLY 指定 rebase info 在文件中的偏移量  \n![rebase在文件中的偏移量](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E5%81%8F%E7%A7%BB%E9%87%8F.jpg)  \n\n详细的rebase信息:\n![详细的rebase信息](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.jpg)  \n\n红框里那些Pointer的意思是说，在内存地址为 0x367C698 的地方有一个指针，这个指针需要进行rebase操作, 操作的内容就是和前面调整地址空间一样，每个指针减去 0xFFFFC000。  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E4%B8%AD%E6%8C%87%E9%92%88%E5%87%8F0xFFFFC000.jpg)  \n\n####\t3.\t为什么不能直接去掉PAGEZERO这个段  \n这个原因要涉及到文件中rebase信息的储存格式，上面的图中，可以看出rebase要处理的是一个个指针，但是实际上这些信息在文件中并不是以指针数组的形式存在，而是以一连串rebase opcode的形式存在，上面看到的一个个指针其实是 Mach O View 这个软件帮我们将opcode整理得到的。  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20opcode.jpg)  \n\n这些opcode中有一种操作比较关键，REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB。  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB.jpg)  \n\n这个opcode的意思是, 接下去需要调整文件的中的第2个段，就是图中segment(2)所表示的含义。\n\n所以说，如果把PAGEZERO这个段给去掉了，文件中各个段的序号也就都错位了，与rebase中的信息就对应不上了。\n而且把这个段大小改为0，也是不行的，因为dyld在加载的过程中，会重新自动过滤掉大小为0的段，也会导致同样的段序号错位的问题。（有兴趣的同学可以看下dyld的源码，在ImageLoaderMachO类的构造函数里）\n这就是为什么必须要保留PAGEZERO这个段，同时大小不能为0。  \n\n###\t修改符号表\n正常的线上应用是不存在符号表的，但是如果你之前用了我的另一个工具 [restore-symbol](https://github.com/tobefuturer/restore-symbol)来恢复符号表的话，这个地方自然也需要做一些处理，处理方法同rebase类似，减去0xFFFFC000.\n\n不过有一些符号需要单独过滤，比如这个：  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E4%BF%AE%E6%94%B9%E7%AC%A6%E5%8F%B7%E8%A1%A8.jpg)  \n\n这个radr://5614542是个什么神奇的符号呢，google就能发现，念茜的twitter上提过这个奇葩的符号。(女神果然是女神, 棒~ 😂)  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E5%BF%B5%E8%8C%9Ctwitter.jpg)  \n\n##\t实际效果  \n工具开源在[github](https://github.com/tobefuturer/app2dylib)上，用法：  \n###\t1.\t下载源码编译：\n\n```git\ngit clone --recursive https://github.com/tobefuturer/app2dylib.git\ncd app2dylib && make\n./app2dylib\n```\n###\t2.\t把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库  \n\n```linux\n./app2dylib /tmp/AlipayWallet -o /tmp/libAlipayApp.dylib   \n```\n###\t3.\t用 Xcode 新建工程，并把新生成的dylib拖进去，调整好各项设置.  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20Xcode%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B.jpg)  \n\nRun Script里的代码(目的是为了对dylib进行签名)  \n\n```linux\ncd ${BUILT_PRODUCTS_DIR}\ncd ${FULL_PRODUCT_NAME}\n/usr/bin/codesign --force --sign ${EXPANDED_CODE_SIGN_IDENTITY} --timestamp=none libAlipayApp.dylib\n```   \n###\t4.\t怎么调用动态库里的方法呢？  \n为方便大家尝试，这里选两个分析起来比较简单的函数调用演示给大家。\n\n一个是OC的方法 `+[aluSecurity rsaEncryptText:pubKey:]`, 可以直接用oc运行时调用。\n\n另一个是C的函数 `int base64_encode(char * output, int * output_length, char * input, int input_length)`\n这个需要先确定 base64_encode 这个C函数的函数签名和在dylib中的偏移地址（我这边的9.9.3版本是0xa798e4），可以用ida分析得到。\n\n运行结果：  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg)  \n\n```C\n#import <UIKit/UIKit.h>\n#import <dlfcn.h>\n#import <mach/mach.h>\n#import <mach-o/loader.h>\n#import <mach-o/dyld.h>\n#import <objc/runtime.h>\nint main(int argc, char * argv[]) {\n    NSLog(@\"\\n===Start===\\n\");\n    NSString * dylibName = @\"libAlipayApp\";\n    NSString * path = [[NSBundle mainBundle] pathForResource:dylibName ofType:@\"dylib\"];\n    if (dlopen(path.UTF8String, RTLD_NOW) == NULL){\n        NSLog(@\"dlopen failed ，error %s\", dlerror());\n        return 0;\n    };\n    \n    //运行时 直接调用oc方法\n    NSString * plain = @\"alipay\";\n    NSString * pubkey = @\"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDZ6i9VNEGEaZaYE7XffA9XRj15cp/ZKhHYY43EEva8LIhCWi29EREaF4JjZVMwFpUAfrL+9gpA7NMQmaMRHbrz1KHe2Ho4HpUhEac8M9zUbNvaDKSlhx0lq/15TQP+57oQbfJ9oKKd+he4Yd6jpBI3UtGmwJyN/T1S0DQ0aXR8OQIDAQAB\";\n    NSString * cipher = [NSClassFromString(@\"aluSecurity\") performSelector:NSSelectorFromString(@\"rsaEncryptText:pubKey:\") withObject:plain withObject:pubkey];\n    NSLog(@\"\\n-----------call oc method---------\\n明文：%@\\n密文： %@\\n-----------------------------------\", plain,cipher);\n    \n    //确认dylib加载在内存中的地址\n    uint64_t slide = 0;\n    for (int i = 0; i <  _dyld_image_count(); i ++)\n        if ([[NSString stringWithUTF8String:_dyld_get_image_name(i)] isEqualToString:path])\n            slide = _dyld_get_image_vmaddr_slide(i);\n    assert(slide != 0);\n    \n    \n    typedef int (*BASE64_ENCODE_FUNC_TYPE) (char * output, int * output_size , char * input, int input_length);\n    /** 根据偏移算出函数地址， 然后调用*/\n    long long base64_encode_offset_in_dylib = 0xa798e4;\n    BASE64_ENCODE_FUNC_TYPE base64_encode = (BASE64_ENCODE_FUNC_TYPE)(slide + base64_encode_offset_in_dylib);\n    char output[1000] = {0};\n    int length = 1000;\n    char * input = \"alipay\";\n    base64_encode(output, & length,  input, (int)strlen(input));\n    NSLog(@\"\\n-----------call c function---------\\nbase64: %s -> %s\\n-----------------------------------\", input,  output);\n}\n```  \n\nps：示例代码中，我刻意除掉了界面部分的代码，因为支付宝的+load函数里swizzle了UI层的一些方法，会导致crash，如果想干掉那些+load方法的话，看下面。  \n\n##\t关于绕过检测代码  \n文章开头的简介中有提到，以动态库的形式加载，能够绕过应用的检测代码，这说法不完全，因为如果把检测代码写在类的+load方法里或者mod_init_func函数（ 全局静态变量的构造函数和__attribute__((constructor))指定的函数 ）里，在dylib加载的时候也是可以得到调用的。\n\n那么也就衍生出两种配搭的对抗方案：  \n**i）越狱机**  \n+load方法的调用是在libobjc.dylib中的call_load_methods函数， mod_init_func函数的调用是在dyld中的doModInitFunctions函数，可以直接用CydiaSubstrate inline hook掉这两个函数，而且动态库是由我们自己加载的，所以可以控制hook和加载dylib的时序。\n\n**ii) 非越狱机**  \n非越狱机上，没有办法inline hook，但是可以利用_dyld_register_func_for_add_image 这个函数注册回调，这个回调是发生在动态库加载到内存后，+load方法和mod_init_func函数调用前，所以可以在这个回调里把+load方法改名，把mod_init_func段改名等等，也就可以使得各种检测函数没法调用了。\n\n总之，主要的控制权还是在我们手中。  \n测试环境：\niPhone 6Plus 、iOS 9.3.1 、arm64\n支付宝9.9.3\n\n参考链接&致谢  \n1.\tdyld的源码：[https://opensource.apple.com/source/dyld/](https://opensource.apple.com/source/dyld/)  \n2.\tiOS逆向的论坛 [http://iosre.com/](http://iosre.com/)\n\n","source":"_posts/黑科技：把第三方 iOS 应用转成动态库.md","raw":"---\ntitle: 【转载】黑科技：把第三方iOS应用转成动态库\ndate: 2016-10-16\ncategories:\n- 他山之石\ntags:\n- 黑科技\n- 动态库\npermalink: iOSAppToLibrary  \n---\n\n**文章转载自[杨君的小黑屋](http://blog.imjun.net)，对排版进行了一些调整**\n\n##\t前言  \n本文会介绍一个自己写的工具，能够把第三方iOS应用转成动态库，并加载到自己的App中，文章最后会以支付宝为例，展示如何调用其中的C函数和OC方法。  \n工具开源地址：  \n[https://github.com/tobefuturer/app2dylib](https://github.com/tobefuturer/app2dylib)  \n<!-- more -->\n##\t有什么用 \n为什么要把第三方应用转成动态库呢？与一般的注入动态库+重签名打包的手段有什么不一样呢？\n\n好处主要有下面几点：  \n1.\t可以直接调用别人的算法  \n\t逆向分析别人的应用时，可能会遇到一些私有算法，如果搞不定的话，直接拿来用就好。  \n2.\t掌控程序的控制权  \n\t程序的主体是自己的App，第三方应用的代码只是以动态库的形式加载，主要的控制权还是在我们自己手里，所以可以直接绕过应用的检测代码（文章最后有关于这部分攻防的讨论）。  \n3.\t同个进程内加载多个应用  \n\t重签名打包毕竟只能是原来的应用，但是如果是动态库的话，可以同时加载多个应用到进程内了，比如你想同时把美图秀秀和饿了么加载进来也是可以的（秀秀不饿，想想去年大众点评那个APPmixer的软广 - -! ）。  \n\n##\t应用和动态库的异同  \n我们要把应用转成动态库，首先要知道这两者之前有什么相同与不同，有相同的才存在转换的可能，而不同之处就是我们要重点关注的了。  \n\n###\t相同点：  \n\n![应用和动态库的异同](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%BA%94%E7%94%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB.jpg)  \n可执行文件和动态库都是标准的 Mach-O 文件格式，两者的文件头部结构非常类似，特别是其中的代码段（TEXT）,和数据段（DATA）结构完全一致，这也是后面转换工作的基础。  \n\n###\t不同点：\n\n不同点就是我们转换工作的重点了，主要有：  \n1.\t头部的文件类型  \n\t一个是 MH_EXECUTE 可执行文件， 一个是 MH_DYLIB 动态库， 还有各种头部的Flags，要特别留意下可执行文件中Flags部分的 MH_PIE 标志，后面再详细说。    \n![头部的文件类型不同](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%B4%E9%83%A8%E6%96%87%E4%BB%B6%E4%B8%8D%E5%90%8C.jpg)  \n2.\t动态库文件中多一个类型为 LC_ID_DYLIB 的 Load Command, 作用是动态库的标识符，一般为文件路径。路径可以随便填，但是这部分必须要有，是codesign的要求。   \n![LC_ID_DYLIB 的 Load Command](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B.jpg)  \n3.\t可执行文件会多出一个 PAGEZERO段，动态库中没有。这个段开始地址为0（NULL指针指向的位置），是一个不可读、不可写、不可执行的空间，能够在空指针访问时抛出异常。这个段的大小，32位上是0x4000，64位上是4G。这个段的处理也是转换工作的重点之一，之前有人尝试转换，不成功就是因为没有处理好 PAGEZERO.  \n![多出的PAGEZERO段](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%9A%E5%87%BA%E4%B8%80%E4%B8%AA%20PAGEZERO%E6%AE%B5.jpg)  \n\n##\t实现细节  \n###\t修改文件类型  \n第一步是修改文件的头部信息，把文件类型从可执行文件修改成动态库，同时把一些Flags修改好。\n\n这里一个比较关键的Flag是可执行文件中的 MH_PIE 标志位，（position-independent executable）。\n\n这个标志位，表明可执行文件能够在内存中任意位置正确地运行，而不受其绝对地址影响的特性，这一特性是动态库所必须的一个特性。没有这个标志位的可执行文件是没有办法转换成动态库的。iOS系统中，arm64架构下，目前这个标志位是必须的，不然程序无法运行（系统的安全性要求），但是armv7架构下，可以没有这个标志位，所以支付宝armv7版本的可执行文件是不能转成动态库的，就是这个原因。不过所有的arm64的应用都是可以转换的，后面演示时用的支付宝是arm64架构的。  \n###\t头部中添加 LC_ID_DYLIB\n直接在文件头部中按照文档格式插入一个Load Command，并填入合适的数据。这里要注意下插入内容的字节数必须是8字节对齐的。  \n###\t修改PAGEZERO段\n这部分是最重要的一部分，因为arm64上这个段的大小有4G，直接往内存中加载，会提示没有足够的连续的地址空间，所以必须要调整这个段的大小，而要调整 PAGEZERO 这个段的大小, 又会引起一连串的地址空间的变化，所以不能盲目的直接改，必须结合dyld的源码来对应修改。（注意这里不能直接把 PAGEZERO 这个段给去掉，也不能直接把大小调成0，因为涉及到dyld的rebase操作，详细看后面）  \n\n####\t1.\t所有段的地址都要重新计算  \n单纯减少 PAGEZERO 段的占用空间，作用不大，因为dyld加载动态库的时候，要求是所有的段一起进行mmap（详细可以查看dyld源码的ImageLoaderMachO::assignSegmentAddresses函数），所以必须把接下来所有的段的地址都重新计算一次。\n\n同时要保证，前后两个段没有地址空间重叠，并且每个段都是按0x4000对齐。因为 PAGEZERO 是所有段中的第一个，所以可以直接把 PAGEZERO 的大小调整到0x4000，然后后面每一个段都按顺序依次减少同样大小(0xFFFFC000 = 0x100000000 - 0x4000)，同时能保证每个段在文件内的偏移量不变。\n\n**修改前：**  \n![PAGEZERO段修改前](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-PAGEZERO%E6%AE%B5%E4%BF%AE%E6%94%B9%E5%89%8D.jpg)  \n\n**修改后：**  \n![PAGEZERO段修改后](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-PAGEZERO%E6%AE%B5%E4%BF%AE%E6%94%B9%E5%90%8E.jpg)  \n\n \n####\t2.\t对动态库进行rebase操作  \n这里的rebase是系统为了解决动态库虚拟内存地址冲突，在加载动态库时进行的基地址重定位操作。\n\n这一步操作是整个流程里最重要的，因为按照前面的操作，整个文件地址空间已经发生了变化，如果dyld依然按照原来的地址进行rebase，必然会失败。\n\n那么rebase操作需要做哪些工作呢？\n\n相关的信息储存在 Mach-O 文件的 LINKEDIT 段中, 并由 LC_DYLD_INFO_ONLY 指定 rebase info 在文件中的偏移量  \n![rebase在文件中的偏移量](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E5%81%8F%E7%A7%BB%E9%87%8F.jpg)  \n\n详细的rebase信息:\n![详细的rebase信息](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.jpg)  \n\n红框里那些Pointer的意思是说，在内存地址为 0x367C698 的地方有一个指针，这个指针需要进行rebase操作, 操作的内容就是和前面调整地址空间一样，每个指针减去 0xFFFFC000。  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E4%B8%AD%E6%8C%87%E9%92%88%E5%87%8F0xFFFFC000.jpg)  \n\n####\t3.\t为什么不能直接去掉PAGEZERO这个段  \n这个原因要涉及到文件中rebase信息的储存格式，上面的图中，可以看出rebase要处理的是一个个指针，但是实际上这些信息在文件中并不是以指针数组的形式存在，而是以一连串rebase opcode的形式存在，上面看到的一个个指针其实是 Mach O View 这个软件帮我们将opcode整理得到的。  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20opcode.jpg)  \n\n这些opcode中有一种操作比较关键，REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB。  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB.jpg)  \n\n这个opcode的意思是, 接下去需要调整文件的中的第2个段，就是图中segment(2)所表示的含义。\n\n所以说，如果把PAGEZERO这个段给去掉了，文件中各个段的序号也就都错位了，与rebase中的信息就对应不上了。\n而且把这个段大小改为0，也是不行的，因为dyld在加载的过程中，会重新自动过滤掉大小为0的段，也会导致同样的段序号错位的问题。（有兴趣的同学可以看下dyld的源码，在ImageLoaderMachO类的构造函数里）\n这就是为什么必须要保留PAGEZERO这个段，同时大小不能为0。  \n\n###\t修改符号表\n正常的线上应用是不存在符号表的，但是如果你之前用了我的另一个工具 [restore-symbol](https://github.com/tobefuturer/restore-symbol)来恢复符号表的话，这个地方自然也需要做一些处理，处理方法同rebase类似，减去0xFFFFC000.\n\n不过有一些符号需要单独过滤，比如这个：  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E4%BF%AE%E6%94%B9%E7%AC%A6%E5%8F%B7%E8%A1%A8.jpg)  \n\n这个radr://5614542是个什么神奇的符号呢，google就能发现，念茜的twitter上提过这个奇葩的符号。(女神果然是女神, 棒~ 😂)  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E5%BF%B5%E8%8C%9Ctwitter.jpg)  \n\n##\t实际效果  \n工具开源在[github](https://github.com/tobefuturer/app2dylib)上，用法：  \n###\t1.\t下载源码编译：\n\n```git\ngit clone --recursive https://github.com/tobefuturer/app2dylib.git\ncd app2dylib && make\n./app2dylib\n```\n###\t2.\t把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库  \n\n```linux\n./app2dylib /tmp/AlipayWallet -o /tmp/libAlipayApp.dylib   \n```\n###\t3.\t用 Xcode 新建工程，并把新生成的dylib拖进去，调整好各项设置.  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20Xcode%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B.jpg)  \n\nRun Script里的代码(目的是为了对dylib进行签名)  \n\n```linux\ncd ${BUILT_PRODUCTS_DIR}\ncd ${FULL_PRODUCT_NAME}\n/usr/bin/codesign --force --sign ${EXPANDED_CODE_SIGN_IDENTITY} --timestamp=none libAlipayApp.dylib\n```   \n###\t4.\t怎么调用动态库里的方法呢？  \n为方便大家尝试，这里选两个分析起来比较简单的函数调用演示给大家。\n\n一个是OC的方法 `+[aluSecurity rsaEncryptText:pubKey:]`, 可以直接用oc运行时调用。\n\n另一个是C的函数 `int base64_encode(char * output, int * output_length, char * input, int input_length)`\n这个需要先确定 base64_encode 这个C函数的函数签名和在dylib中的偏移地址（我这边的9.9.3版本是0xa798e4），可以用ida分析得到。\n\n运行结果：  \n![](http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg)  \n\n```C\n#import <UIKit/UIKit.h>\n#import <dlfcn.h>\n#import <mach/mach.h>\n#import <mach-o/loader.h>\n#import <mach-o/dyld.h>\n#import <objc/runtime.h>\nint main(int argc, char * argv[]) {\n    NSLog(@\"\\n===Start===\\n\");\n    NSString * dylibName = @\"libAlipayApp\";\n    NSString * path = [[NSBundle mainBundle] pathForResource:dylibName ofType:@\"dylib\"];\n    if (dlopen(path.UTF8String, RTLD_NOW) == NULL){\n        NSLog(@\"dlopen failed ，error %s\", dlerror());\n        return 0;\n    };\n    \n    //运行时 直接调用oc方法\n    NSString * plain = @\"alipay\";\n    NSString * pubkey = @\"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDZ6i9VNEGEaZaYE7XffA9XRj15cp/ZKhHYY43EEva8LIhCWi29EREaF4JjZVMwFpUAfrL+9gpA7NMQmaMRHbrz1KHe2Ho4HpUhEac8M9zUbNvaDKSlhx0lq/15TQP+57oQbfJ9oKKd+he4Yd6jpBI3UtGmwJyN/T1S0DQ0aXR8OQIDAQAB\";\n    NSString * cipher = [NSClassFromString(@\"aluSecurity\") performSelector:NSSelectorFromString(@\"rsaEncryptText:pubKey:\") withObject:plain withObject:pubkey];\n    NSLog(@\"\\n-----------call oc method---------\\n明文：%@\\n密文： %@\\n-----------------------------------\", plain,cipher);\n    \n    //确认dylib加载在内存中的地址\n    uint64_t slide = 0;\n    for (int i = 0; i <  _dyld_image_count(); i ++)\n        if ([[NSString stringWithUTF8String:_dyld_get_image_name(i)] isEqualToString:path])\n            slide = _dyld_get_image_vmaddr_slide(i);\n    assert(slide != 0);\n    \n    \n    typedef int (*BASE64_ENCODE_FUNC_TYPE) (char * output, int * output_size , char * input, int input_length);\n    /** 根据偏移算出函数地址， 然后调用*/\n    long long base64_encode_offset_in_dylib = 0xa798e4;\n    BASE64_ENCODE_FUNC_TYPE base64_encode = (BASE64_ENCODE_FUNC_TYPE)(slide + base64_encode_offset_in_dylib);\n    char output[1000] = {0};\n    int length = 1000;\n    char * input = \"alipay\";\n    base64_encode(output, & length,  input, (int)strlen(input));\n    NSLog(@\"\\n-----------call c function---------\\nbase64: %s -> %s\\n-----------------------------------\", input,  output);\n}\n```  \n\nps：示例代码中，我刻意除掉了界面部分的代码，因为支付宝的+load函数里swizzle了UI层的一些方法，会导致crash，如果想干掉那些+load方法的话，看下面。  \n\n##\t关于绕过检测代码  \n文章开头的简介中有提到，以动态库的形式加载，能够绕过应用的检测代码，这说法不完全，因为如果把检测代码写在类的+load方法里或者mod_init_func函数（ 全局静态变量的构造函数和__attribute__((constructor))指定的函数 ）里，在dylib加载的时候也是可以得到调用的。\n\n那么也就衍生出两种配搭的对抗方案：  \n**i）越狱机**  \n+load方法的调用是在libobjc.dylib中的call_load_methods函数， mod_init_func函数的调用是在dyld中的doModInitFunctions函数，可以直接用CydiaSubstrate inline hook掉这两个函数，而且动态库是由我们自己加载的，所以可以控制hook和加载dylib的时序。\n\n**ii) 非越狱机**  \n非越狱机上，没有办法inline hook，但是可以利用_dyld_register_func_for_add_image 这个函数注册回调，这个回调是发生在动态库加载到内存后，+load方法和mod_init_func函数调用前，所以可以在这个回调里把+load方法改名，把mod_init_func段改名等等，也就可以使得各种检测函数没法调用了。\n\n总之，主要的控制权还是在我们手中。  \n测试环境：\niPhone 6Plus 、iOS 9.3.1 、arm64\n支付宝9.9.3\n\n参考链接&致谢  \n1.\tdyld的源码：[https://opensource.apple.com/source/dyld/](https://opensource.apple.com/source/dyld/)  \n2.\tiOS逆向的论坛 [http://iosre.com/](http://iosre.com/)\n\n","slug":"iOSAppToLibrary","published":1,"updated":"2017-11-02T13:09:57.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9no6vo1002hjaen8ulf1786","content":"<p><strong>文章转载自<a href=\"http://blog.imjun.net\" target=\"_blank\" rel=\"external\">杨君的小黑屋</a>，对排版进行了一些调整</strong></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文会介绍一个自己写的工具，能够把第三方iOS应用转成动态库，并加载到自己的App中，文章最后会以支付宝为例，展示如何调用其中的C函数和OC方法。<br>工具开源地址：<br><a href=\"https://github.com/tobefuturer/app2dylib\" target=\"_blank\" rel=\"external\">https://github.com/tobefuturer/app2dylib</a><br><a id=\"more\"></a></p>\n<h2 id=\"有什么用\"><a href=\"#有什么用\" class=\"headerlink\" title=\"有什么用\"></a>有什么用</h2><p>为什么要把第三方应用转成动态库呢？与一般的注入动态库+重签名打包的手段有什么不一样呢？</p>\n<p>好处主要有下面几点：  </p>\n<ol>\n<li>可以直接调用别人的算法<br>逆向分析别人的应用时，可能会遇到一些私有算法，如果搞不定的话，直接拿来用就好。  </li>\n<li>掌控程序的控制权<br>程序的主体是自己的App，第三方应用的代码只是以动态库的形式加载，主要的控制权还是在我们自己手里，所以可以直接绕过应用的检测代码（文章最后有关于这部分攻防的讨论）。  </li>\n<li>同个进程内加载多个应用<br>重签名打包毕竟只能是原来的应用，但是如果是动态库的话，可以同时加载多个应用到进程内了，比如你想同时把美图秀秀和饿了么加载进来也是可以的（秀秀不饿，想想去年大众点评那个APPmixer的软广 - -! ）。  </li>\n</ol>\n<h2 id=\"应用和动态库的异同\"><a href=\"#应用和动态库的异同\" class=\"headerlink\" title=\"应用和动态库的异同\"></a>应用和动态库的异同</h2><p>我们要把应用转成动态库，首先要知道这两者之前有什么相同与不同，有相同的才存在转换的可能，而不同之处就是我们要重点关注的了。  </p>\n<h3 id=\"相同点：\"><a href=\"#相同点：\" class=\"headerlink\" title=\"相同点：\"></a>相同点：</h3><p><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%BA%94%E7%94%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB.jpg\" alt=\"应用和动态库的异同\"><br>可执行文件和动态库都是标准的 Mach-O 文件格式，两者的文件头部结构非常类似，特别是其中的代码段（TEXT）,和数据段（DATA）结构完全一致，这也是后面转换工作的基础。  </p>\n<h3 id=\"不同点：\"><a href=\"#不同点：\" class=\"headerlink\" title=\"不同点：\"></a>不同点：</h3><p>不同点就是我们转换工作的重点了，主要有：  </p>\n<ol>\n<li>头部的文件类型<br>一个是 MH_EXECUTE 可执行文件， 一个是 MH_DYLIB 动态库， 还有各种头部的Flags，要特别留意下可执行文件中Flags部分的 MH_PIE 标志，后面再详细说。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%B4%E9%83%A8%E6%96%87%E4%BB%B6%E4%B8%8D%E5%90%8C.jpg\" alt=\"头部的文件类型不同\">  </li>\n<li>动态库文件中多一个类型为 LC_ID_DYLIB 的 Load Command, 作用是动态库的标识符，一般为文件路径。路径可以随便填，但是这部分必须要有，是codesign的要求。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B.jpg\" alt=\"LC_ID_DYLIB 的 Load Command\">  </li>\n<li>可执行文件会多出一个 PAGEZERO段，动态库中没有。这个段开始地址为0（NULL指针指向的位置），是一个不可读、不可写、不可执行的空间，能够在空指针访问时抛出异常。这个段的大小，32位上是0x4000，64位上是4G。这个段的处理也是转换工作的重点之一，之前有人尝试转换，不成功就是因为没有处理好 PAGEZERO.<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%9A%E5%87%BA%E4%B8%80%E4%B8%AA%20PAGEZERO%E6%AE%B5.jpg\" alt=\"多出的PAGEZERO段\">  </li>\n</ol>\n<h2 id=\"实现细节\"><a href=\"#实现细节\" class=\"headerlink\" title=\"实现细节\"></a>实现细节</h2><h3 id=\"修改文件类型\"><a href=\"#修改文件类型\" class=\"headerlink\" title=\"修改文件类型\"></a>修改文件类型</h3><p>第一步是修改文件的头部信息，把文件类型从可执行文件修改成动态库，同时把一些Flags修改好。</p>\n<p>这里一个比较关键的Flag是可执行文件中的 MH_PIE 标志位，（position-independent executable）。</p>\n<p>这个标志位，表明可执行文件能够在内存中任意位置正确地运行，而不受其绝对地址影响的特性，这一特性是动态库所必须的一个特性。没有这个标志位的可执行文件是没有办法转换成动态库的。iOS系统中，arm64架构下，目前这个标志位是必须的，不然程序无法运行（系统的安全性要求），但是armv7架构下，可以没有这个标志位，所以支付宝armv7版本的可执行文件是不能转成动态库的，就是这个原因。不过所有的arm64的应用都是可以转换的，后面演示时用的支付宝是arm64架构的。  </p>\n<h3 id=\"头部中添加-LC-ID-DYLIB\"><a href=\"#头部中添加-LC-ID-DYLIB\" class=\"headerlink\" title=\"头部中添加 LC_ID_DYLIB\"></a>头部中添加 LC_ID_DYLIB</h3><p>直接在文件头部中按照文档格式插入一个Load Command，并填入合适的数据。这里要注意下插入内容的字节数必须是8字节对齐的。  </p>\n<h3 id=\"修改PAGEZERO段\"><a href=\"#修改PAGEZERO段\" class=\"headerlink\" title=\"修改PAGEZERO段\"></a>修改PAGEZERO段</h3><p>这部分是最重要的一部分，因为arm64上这个段的大小有4G，直接往内存中加载，会提示没有足够的连续的地址空间，所以必须要调整这个段的大小，而要调整 PAGEZERO 这个段的大小, 又会引起一连串的地址空间的变化，所以不能盲目的直接改，必须结合dyld的源码来对应修改。（注意这里不能直接把 PAGEZERO 这个段给去掉，也不能直接把大小调成0，因为涉及到dyld的rebase操作，详细看后面）  </p>\n<h4 id=\"1-所有段的地址都要重新计算\"><a href=\"#1-所有段的地址都要重新计算\" class=\"headerlink\" title=\"1.    所有段的地址都要重新计算\"></a>1.    所有段的地址都要重新计算</h4><p>单纯减少 PAGEZERO 段的占用空间，作用不大，因为dyld加载动态库的时候，要求是所有的段一起进行mmap（详细可以查看dyld源码的ImageLoaderMachO::assignSegmentAddresses函数），所以必须把接下来所有的段的地址都重新计算一次。</p>\n<p>同时要保证，前后两个段没有地址空间重叠，并且每个段都是按0x4000对齐。因为 PAGEZERO 是所有段中的第一个，所以可以直接把 PAGEZERO 的大小调整到0x4000，然后后面每一个段都按顺序依次减少同样大小(0xFFFFC000 = 0x100000000 - 0x4000)，同时能保证每个段在文件内的偏移量不变。</p>\n<p><strong>修改前：</strong><br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-PAGEZERO%E6%AE%B5%E4%BF%AE%E6%94%B9%E5%89%8D.jpg\" alt=\"PAGEZERO段修改前\">  </p>\n<p><strong>修改后：</strong><br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-PAGEZERO%E6%AE%B5%E4%BF%AE%E6%94%B9%E5%90%8E.jpg\" alt=\"PAGEZERO段修改后\">  </p>\n<h4 id=\"2-对动态库进行rebase操作\"><a href=\"#2-对动态库进行rebase操作\" class=\"headerlink\" title=\"2.    对动态库进行rebase操作\"></a>2.    对动态库进行rebase操作</h4><p>这里的rebase是系统为了解决动态库虚拟内存地址冲突，在加载动态库时进行的基地址重定位操作。</p>\n<p>这一步操作是整个流程里最重要的，因为按照前面的操作，整个文件地址空间已经发生了变化，如果dyld依然按照原来的地址进行rebase，必然会失败。</p>\n<p>那么rebase操作需要做哪些工作呢？</p>\n<p>相关的信息储存在 Mach-O 文件的 LINKEDIT 段中, 并由 LC_DYLD_INFO_ONLY 指定 rebase info 在文件中的偏移量<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E5%81%8F%E7%A7%BB%E9%87%8F.jpg\" alt=\"rebase在文件中的偏移量\">  </p>\n<p>详细的rebase信息:<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.jpg\" alt=\"详细的rebase信息\">  </p>\n<p>红框里那些Pointer的意思是说，在内存地址为 0x367C698 的地方有一个指针，这个指针需要进行rebase操作, 操作的内容就是和前面调整地址空间一样，每个指针减去 0xFFFFC000。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E4%B8%AD%E6%8C%87%E9%92%88%E5%87%8F0xFFFFC000.jpg\" alt=\"\">  </p>\n<h4 id=\"3-为什么不能直接去掉PAGEZERO这个段\"><a href=\"#3-为什么不能直接去掉PAGEZERO这个段\" class=\"headerlink\" title=\"3.    为什么不能直接去掉PAGEZERO这个段\"></a>3.    为什么不能直接去掉PAGEZERO这个段</h4><p>这个原因要涉及到文件中rebase信息的储存格式，上面的图中，可以看出rebase要处理的是一个个指针，但是实际上这些信息在文件中并不是以指针数组的形式存在，而是以一连串rebase opcode的形式存在，上面看到的一个个指针其实是 Mach O View 这个软件帮我们将opcode整理得到的。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20opcode.jpg\" alt=\"\">  </p>\n<p>这些opcode中有一种操作比较关键，REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB.jpg\" alt=\"\">  </p>\n<p>这个opcode的意思是, 接下去需要调整文件的中的第2个段，就是图中segment(2)所表示的含义。</p>\n<p>所以说，如果把PAGEZERO这个段给去掉了，文件中各个段的序号也就都错位了，与rebase中的信息就对应不上了。<br>而且把这个段大小改为0，也是不行的，因为dyld在加载的过程中，会重新自动过滤掉大小为0的段，也会导致同样的段序号错位的问题。（有兴趣的同学可以看下dyld的源码，在ImageLoaderMachO类的构造函数里）<br>这就是为什么必须要保留PAGEZERO这个段，同时大小不能为0。  </p>\n<h3 id=\"修改符号表\"><a href=\"#修改符号表\" class=\"headerlink\" title=\"修改符号表\"></a>修改符号表</h3><p>正常的线上应用是不存在符号表的，但是如果你之前用了我的另一个工具 <a href=\"https://github.com/tobefuturer/restore-symbol\" target=\"_blank\" rel=\"external\">restore-symbol</a>来恢复符号表的话，这个地方自然也需要做一些处理，处理方法同rebase类似，减去0xFFFFC000.</p>\n<p>不过有一些符号需要单独过滤，比如这个：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E4%BF%AE%E6%94%B9%E7%AC%A6%E5%8F%B7%E8%A1%A8.jpg\" alt=\"\">  </p>\n<p>这个radr://5614542是个什么神奇的符号呢，google就能发现，念茜的twitter上提过这个奇葩的符号。(女神果然是女神, 棒~ 😂)<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E5%BF%B5%E8%8C%9Ctwitter.jpg\" alt=\"\">  </p>\n<h2 id=\"实际效果\"><a href=\"#实际效果\" class=\"headerlink\" title=\"实际效果\"></a>实际效果</h2><p>工具开源在<a href=\"https://github.com/tobefuturer/app2dylib\" target=\"_blank\" rel=\"external\">github</a>上，用法：  </p>\n<h3 id=\"1-下载源码编译：\"><a href=\"#1-下载源码编译：\" class=\"headerlink\" title=\"1.    下载源码编译：\"></a>1.    下载源码编译：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone --recursive https://github.com/tobefuturer/app2dylib.git</div><div class=\"line\">cd app2dylib &amp;&amp; make</div><div class=\"line\">./app2dylib</div></pre></td></tr></table></figure>\n<h3 id=\"2-把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库\"><a href=\"#2-把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库\" class=\"headerlink\" title=\"2.    把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库\"></a>2.    把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./app2dylib /tmp/AlipayWallet -o /tmp/libAlipayApp.dylib</div></pre></td></tr></table></figure>\n<h3 id=\"3-用-Xcode-新建工程，并把新生成的dylib拖进去，调整好各项设置\"><a href=\"#3-用-Xcode-新建工程，并把新生成的dylib拖进去，调整好各项设置\" class=\"headerlink\" title=\"3.    用 Xcode 新建工程，并把新生成的dylib拖进去，调整好各项设置.\"></a>3.    用 Xcode 新建工程，并把新生成的dylib拖进去，调整好各项设置.</h3><p><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20Xcode%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B.jpg\" alt=\"\">  </p>\n<p>Run Script里的代码(目的是为了对dylib进行签名)  </p>\n<pre><code class=\"linux\">cd ${BUILT_PRODUCTS_DIR}\ncd ${FULL_PRODUCT_NAME}\n/usr/bin/codesign --force --sign ${EXPANDED_CODE_SIGN_IDENTITY} --timestamp=none libAlipayApp.dylib\n</code></pre>\n<h3 id=\"4-怎么调用动态库里的方法呢？\"><a href=\"#4-怎么调用动态库里的方法呢？\" class=\"headerlink\" title=\"4.    怎么调用动态库里的方法呢？\"></a>4.    怎么调用动态库里的方法呢？</h3><p>为方便大家尝试，这里选两个分析起来比较简单的函数调用演示给大家。</p>\n<p>一个是OC的方法 <code>+[aluSecurity rsaEncryptText:pubKey:]</code>, 可以直接用oc运行时调用。</p>\n<p>另一个是C的函数 <code>int base64_encode(char * output, int * output_length, char * input, int input_length)</code><br>这个需要先确定 base64_encode 这个C函数的函数签名和在dylib中的偏移地址（我这边的9.9.3版本是0xa798e4），可以用ida分析得到。</p>\n<p>运行结果：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\" alt=\"\">  </p>\n<pre><code class=\"C\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span>\n<span class=\"meta\">#import <span class=\"meta-string\">&lt;dlfcn.h&gt;</span></span>\n<span class=\"meta\">#import <span class=\"meta-string\">&lt;mach/mach.h&gt;</span></span>\n<span class=\"meta\">#import <span class=\"meta-string\">&lt;mach-o/loader.h&gt;</span></span>\n<span class=\"meta\">#import <span class=\"meta-string\">&lt;mach-o/dyld.h&gt;</span></span>\n<span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span>\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[])</span> </span>{\n    NSLog(@<span class=\"string\">\"\\n===Start===\\n\"</span>);\n    NSString * dylibName = @<span class=\"string\">\"libAlipayApp\"</span>;\n    NSString * path = [[NSBundle mainBundle] pathForResource:dylibName ofType:@<span class=\"string\">\"dylib\"</span>];\n    <span class=\"keyword\">if</span> (dlopen(path.UTF8String, RTLD_NOW) == <span class=\"literal\">NULL</span>){\n        NSLog(@<span class=\"string\">\"dlopen failed ，error %s\"</span>, dlerror());\n        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n    };\n\n    <span class=\"comment\">//运行时 直接调用oc方法</span>\n    NSString * plain = @<span class=\"string\">\"alipay\"</span>;\n    NSString * pubkey = @<span class=\"string\">\"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDZ6i9VNEGEaZaYE7XffA9XRj15cp/ZKhHYY43EEva8LIhCWi29EREaF4JjZVMwFpUAfrL+9gpA7NMQmaMRHbrz1KHe2Ho4HpUhEac8M9zUbNvaDKSlhx0lq/15TQP+57oQbfJ9oKKd+he4Yd6jpBI3UtGmwJyN/T1S0DQ0aXR8OQIDAQAB\"</span>;\n    NSString * cipher = [NSClassFromString(@<span class=\"string\">\"aluSecurity\"</span>) performSelector:NSSelectorFromString(@<span class=\"string\">\"rsaEncryptText:pubKey:\"</span>) withObject:plain withObject:pubkey];\n    NSLog(@<span class=\"string\">\"\\n-----------call oc method---------\\n明文：%@\\n密文： %@\\n-----------------------------------\"</span>, plain,cipher);\n\n    <span class=\"comment\">//确认dylib加载在内存中的地址</span>\n    <span class=\"keyword\">uint64_t</span> slide = <span class=\"number\">0</span>;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;  _dyld_image_count(); i ++)\n        <span class=\"keyword\">if</span> ([[NSString stringWithUTF8String:_dyld_get_image_name(i)] isEqualToString:path])\n            slide = _dyld_get_image_vmaddr_slide(i);\n    assert(slide != <span class=\"number\">0</span>);\n\n\n    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*BASE64_ENCODE_FUNC_TYPE)</span> <span class=\"params\">(<span class=\"keyword\">char</span> * output, <span class=\"keyword\">int</span> * output_size , <span class=\"keyword\">char</span> * input, <span class=\"keyword\">int</span> input_length)</span></span>;\n    <span class=\"comment\">/** 根据偏移算出函数地址， 然后调用*/</span>\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> base64_encode_offset_in_dylib = <span class=\"number\">0xa798e4</span>;\n    BASE64_ENCODE_FUNC_TYPE base64_encode = (BASE64_ENCODE_FUNC_TYPE)(slide + base64_encode_offset_in_dylib);\n    <span class=\"keyword\">char</span> output[<span class=\"number\">1000</span>] = {<span class=\"number\">0</span>};\n    <span class=\"keyword\">int</span> length = <span class=\"number\">1000</span>;\n    <span class=\"keyword\">char</span> * input = <span class=\"string\">\"alipay\"</span>;\n    base64_encode(output, &amp; length,  input, (<span class=\"keyword\">int</span>)<span class=\"built_in\">strlen</span>(input));\n    NSLog(@<span class=\"string\">\"\\n-----------call c function---------\\nbase64: %s -&gt; %s\\n-----------------------------------\"</span>, input,  output);\n}\n</code></pre>\n<p>ps：示例代码中，我刻意除掉了界面部分的代码，因为支付宝的+load函数里swizzle了UI层的一些方法，会导致crash，如果想干掉那些+load方法的话，看下面。  </p>\n<h2 id=\"关于绕过检测代码\"><a href=\"#关于绕过检测代码\" class=\"headerlink\" title=\"关于绕过检测代码\"></a>关于绕过检测代码</h2><p>文章开头的简介中有提到，以动态库的形式加载，能够绕过应用的检测代码，这说法不完全，因为如果把检测代码写在类的+load方法里或者mod_init_func函数（ 全局静态变量的构造函数和<strong>attribute</strong>((constructor))指定的函数 ）里，在dylib加载的时候也是可以得到调用的。</p>\n<p>那么也就衍生出两种配搭的对抗方案：<br><strong>i）越狱机</strong><br>+load方法的调用是在libobjc.dylib中的call_load_methods函数， mod_init_func函数的调用是在dyld中的doModInitFunctions函数，可以直接用CydiaSubstrate inline hook掉这两个函数，而且动态库是由我们自己加载的，所以可以控制hook和加载dylib的时序。</p>\n<p><strong>ii) 非越狱机</strong><br>非越狱机上，没有办法inline hook，但是可以利用_dyld_register_func_for_add_image 这个函数注册回调，这个回调是发生在动态库加载到内存后，+load方法和mod_init_func函数调用前，所以可以在这个回调里把+load方法改名，把mod_init_func段改名等等，也就可以使得各种检测函数没法调用了。</p>\n<p>总之，主要的控制权还是在我们手中。<br>测试环境：<br>iPhone 6Plus 、iOS 9.3.1 、arm64<br>支付宝9.9.3</p>\n<p>参考链接&amp;致谢  </p>\n<ol>\n<li>dyld的源码：<a href=\"https://opensource.apple.com/source/dyld/\" target=\"_blank\" rel=\"external\">https://opensource.apple.com/source/dyld/</a>  </li>\n<li>iOS逆向的论坛 <a href=\"http://iosre.com/\" target=\"_blank\" rel=\"external\">http://iosre.com/</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><strong>文章转载自<a href=\"http://blog.imjun.net\" target=\"_blank\" rel=\"external\">杨君的小黑屋</a>，对排版进行了一些调整</strong></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文会介绍一个自己写的工具，能够把第三方iOS应用转成动态库，并加载到自己的App中，文章最后会以支付宝为例，展示如何调用其中的C函数和OC方法。<br>工具开源地址：<br><a href=\"https://github.com/tobefuturer/app2dylib\" target=\"_blank\" rel=\"external\">https://github.com/tobefuturer/app2dylib</a><br>","more":"</p>\n<h2 id=\"有什么用\"><a href=\"#有什么用\" class=\"headerlink\" title=\"有什么用\"></a>有什么用</h2><p>为什么要把第三方应用转成动态库呢？与一般的注入动态库+重签名打包的手段有什么不一样呢？</p>\n<p>好处主要有下面几点：  </p>\n<ol>\n<li>可以直接调用别人的算法<br>逆向分析别人的应用时，可能会遇到一些私有算法，如果搞不定的话，直接拿来用就好。  </li>\n<li>掌控程序的控制权<br>程序的主体是自己的App，第三方应用的代码只是以动态库的形式加载，主要的控制权还是在我们自己手里，所以可以直接绕过应用的检测代码（文章最后有关于这部分攻防的讨论）。  </li>\n<li>同个进程内加载多个应用<br>重签名打包毕竟只能是原来的应用，但是如果是动态库的话，可以同时加载多个应用到进程内了，比如你想同时把美图秀秀和饿了么加载进来也是可以的（秀秀不饿，想想去年大众点评那个APPmixer的软广 - -! ）。  </li>\n</ol>\n<h2 id=\"应用和动态库的异同\"><a href=\"#应用和动态库的异同\" class=\"headerlink\" title=\"应用和动态库的异同\"></a>应用和动态库的异同</h2><p>我们要把应用转成动态库，首先要知道这两者之前有什么相同与不同，有相同的才存在转换的可能，而不同之处就是我们要重点关注的了。  </p>\n<h3 id=\"相同点：\"><a href=\"#相同点：\" class=\"headerlink\" title=\"相同点：\"></a>相同点：</h3><p><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%BA%94%E7%94%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB.jpg\" alt=\"应用和动态库的异同\"><br>可执行文件和动态库都是标准的 Mach-O 文件格式，两者的文件头部结构非常类似，特别是其中的代码段（TEXT）,和数据段（DATA）结构完全一致，这也是后面转换工作的基础。  </p>\n<h3 id=\"不同点：\"><a href=\"#不同点：\" class=\"headerlink\" title=\"不同点：\"></a>不同点：</h3><p>不同点就是我们转换工作的重点了，主要有：  </p>\n<ol>\n<li>头部的文件类型<br>一个是 MH_EXECUTE 可执行文件， 一个是 MH_DYLIB 动态库， 还有各种头部的Flags，要特别留意下可执行文件中Flags部分的 MH_PIE 标志，后面再详细说。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%B4%E9%83%A8%E6%96%87%E4%BB%B6%E4%B8%8D%E5%90%8C.jpg\" alt=\"头部的文件类型不同\">  </li>\n<li>动态库文件中多一个类型为 LC_ID_DYLIB 的 Load Command, 作用是动态库的标识符，一般为文件路径。路径可以随便填，但是这部分必须要有，是codesign的要求。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B.jpg\" alt=\"LC_ID_DYLIB 的 Load Command\">  </li>\n<li>可执行文件会多出一个 PAGEZERO段，动态库中没有。这个段开始地址为0（NULL指针指向的位置），是一个不可读、不可写、不可执行的空间，能够在空指针访问时抛出异常。这个段的大小，32位上是0x4000，64位上是4G。这个段的处理也是转换工作的重点之一，之前有人尝试转换，不成功就是因为没有处理好 PAGEZERO.<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%9A%E5%87%BA%E4%B8%80%E4%B8%AA%20PAGEZERO%E6%AE%B5.jpg\" alt=\"多出的PAGEZERO段\">  </li>\n</ol>\n<h2 id=\"实现细节\"><a href=\"#实现细节\" class=\"headerlink\" title=\"实现细节\"></a>实现细节</h2><h3 id=\"修改文件类型\"><a href=\"#修改文件类型\" class=\"headerlink\" title=\"修改文件类型\"></a>修改文件类型</h3><p>第一步是修改文件的头部信息，把文件类型从可执行文件修改成动态库，同时把一些Flags修改好。</p>\n<p>这里一个比较关键的Flag是可执行文件中的 MH_PIE 标志位，（position-independent executable）。</p>\n<p>这个标志位，表明可执行文件能够在内存中任意位置正确地运行，而不受其绝对地址影响的特性，这一特性是动态库所必须的一个特性。没有这个标志位的可执行文件是没有办法转换成动态库的。iOS系统中，arm64架构下，目前这个标志位是必须的，不然程序无法运行（系统的安全性要求），但是armv7架构下，可以没有这个标志位，所以支付宝armv7版本的可执行文件是不能转成动态库的，就是这个原因。不过所有的arm64的应用都是可以转换的，后面演示时用的支付宝是arm64架构的。  </p>\n<h3 id=\"头部中添加-LC-ID-DYLIB\"><a href=\"#头部中添加-LC-ID-DYLIB\" class=\"headerlink\" title=\"头部中添加 LC_ID_DYLIB\"></a>头部中添加 LC_ID_DYLIB</h3><p>直接在文件头部中按照文档格式插入一个Load Command，并填入合适的数据。这里要注意下插入内容的字节数必须是8字节对齐的。  </p>\n<h3 id=\"修改PAGEZERO段\"><a href=\"#修改PAGEZERO段\" class=\"headerlink\" title=\"修改PAGEZERO段\"></a>修改PAGEZERO段</h3><p>这部分是最重要的一部分，因为arm64上这个段的大小有4G，直接往内存中加载，会提示没有足够的连续的地址空间，所以必须要调整这个段的大小，而要调整 PAGEZERO 这个段的大小, 又会引起一连串的地址空间的变化，所以不能盲目的直接改，必须结合dyld的源码来对应修改。（注意这里不能直接把 PAGEZERO 这个段给去掉，也不能直接把大小调成0，因为涉及到dyld的rebase操作，详细看后面）  </p>\n<h4 id=\"1-所有段的地址都要重新计算\"><a href=\"#1-所有段的地址都要重新计算\" class=\"headerlink\" title=\"1.    所有段的地址都要重新计算\"></a>1.    所有段的地址都要重新计算</h4><p>单纯减少 PAGEZERO 段的占用空间，作用不大，因为dyld加载动态库的时候，要求是所有的段一起进行mmap（详细可以查看dyld源码的ImageLoaderMachO::assignSegmentAddresses函数），所以必须把接下来所有的段的地址都重新计算一次。</p>\n<p>同时要保证，前后两个段没有地址空间重叠，并且每个段都是按0x4000对齐。因为 PAGEZERO 是所有段中的第一个，所以可以直接把 PAGEZERO 的大小调整到0x4000，然后后面每一个段都按顺序依次减少同样大小(0xFFFFC000 = 0x100000000 - 0x4000)，同时能保证每个段在文件内的偏移量不变。</p>\n<p><strong>修改前：</strong><br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-PAGEZERO%E6%AE%B5%E4%BF%AE%E6%94%B9%E5%89%8D.jpg\" alt=\"PAGEZERO段修改前\">  </p>\n<p><strong>修改后：</strong><br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-PAGEZERO%E6%AE%B5%E4%BF%AE%E6%94%B9%E5%90%8E.jpg\" alt=\"PAGEZERO段修改后\">  </p>\n<h4 id=\"2-对动态库进行rebase操作\"><a href=\"#2-对动态库进行rebase操作\" class=\"headerlink\" title=\"2.    对动态库进行rebase操作\"></a>2.    对动态库进行rebase操作</h4><p>这里的rebase是系统为了解决动态库虚拟内存地址冲突，在加载动态库时进行的基地址重定位操作。</p>\n<p>这一步操作是整个流程里最重要的，因为按照前面的操作，整个文件地址空间已经发生了变化，如果dyld依然按照原来的地址进行rebase，必然会失败。</p>\n<p>那么rebase操作需要做哪些工作呢？</p>\n<p>相关的信息储存在 Mach-O 文件的 LINKEDIT 段中, 并由 LC_DYLD_INFO_ONLY 指定 rebase info 在文件中的偏移量<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E5%81%8F%E7%A7%BB%E9%87%8F.jpg\" alt=\"rebase在文件中的偏移量\">  </p>\n<p>详细的rebase信息:<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.jpg\" alt=\"详细的rebase信息\">  </p>\n<p>红框里那些Pointer的意思是说，在内存地址为 0x367C698 的地方有一个指针，这个指针需要进行rebase操作, 操作的内容就是和前面调整地址空间一样，每个指针减去 0xFFFFC000。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E4%B8%AD%E6%8C%87%E9%92%88%E5%87%8F0xFFFFC000.jpg\" alt=\"\">  </p>\n<h4 id=\"3-为什么不能直接去掉PAGEZERO这个段\"><a href=\"#3-为什么不能直接去掉PAGEZERO这个段\" class=\"headerlink\" title=\"3.    为什么不能直接去掉PAGEZERO这个段\"></a>3.    为什么不能直接去掉PAGEZERO这个段</h4><p>这个原因要涉及到文件中rebase信息的储存格式，上面的图中，可以看出rebase要处理的是一个个指针，但是实际上这些信息在文件中并不是以指针数组的形式存在，而是以一连串rebase opcode的形式存在，上面看到的一个个指针其实是 Mach O View 这个软件帮我们将opcode整理得到的。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20opcode.jpg\" alt=\"\">  </p>\n<p>这些opcode中有一种操作比较关键，REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB.jpg\" alt=\"\">  </p>\n<p>这个opcode的意思是, 接下去需要调整文件的中的第2个段，就是图中segment(2)所表示的含义。</p>\n<p>所以说，如果把PAGEZERO这个段给去掉了，文件中各个段的序号也就都错位了，与rebase中的信息就对应不上了。<br>而且把这个段大小改为0，也是不行的，因为dyld在加载的过程中，会重新自动过滤掉大小为0的段，也会导致同样的段序号错位的问题。（有兴趣的同学可以看下dyld的源码，在ImageLoaderMachO类的构造函数里）<br>这就是为什么必须要保留PAGEZERO这个段，同时大小不能为0。  </p>\n<h3 id=\"修改符号表\"><a href=\"#修改符号表\" class=\"headerlink\" title=\"修改符号表\"></a>修改符号表</h3><p>正常的线上应用是不存在符号表的，但是如果你之前用了我的另一个工具 <a href=\"https://github.com/tobefuturer/restore-symbol\" target=\"_blank\" rel=\"external\">restore-symbol</a>来恢复符号表的话，这个地方自然也需要做一些处理，处理方法同rebase类似，减去0xFFFFC000.</p>\n<p>不过有一些符号需要单独过滤，比如这个：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E4%BF%AE%E6%94%B9%E7%AC%A6%E5%8F%B7%E8%A1%A8.jpg\" alt=\"\">  </p>\n<p>这个radr://5614542是个什么神奇的符号呢，google就能发现，念茜的twitter上提过这个奇葩的符号。(女神果然是女神, 棒~ 😂)<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E5%BF%B5%E8%8C%9Ctwitter.jpg\" alt=\"\">  </p>\n<h2 id=\"实际效果\"><a href=\"#实际效果\" class=\"headerlink\" title=\"实际效果\"></a>实际效果</h2><p>工具开源在<a href=\"https://github.com/tobefuturer/app2dylib\" target=\"_blank\" rel=\"external\">github</a>上，用法：  </p>\n<h3 id=\"1-下载源码编译：\"><a href=\"#1-下载源码编译：\" class=\"headerlink\" title=\"1.    下载源码编译：\"></a>1.    下载源码编译：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone --recursive https://github.com/tobefuturer/app2dylib.git</div><div class=\"line\">cd app2dylib &amp;&amp; make</div><div class=\"line\">./app2dylib</div></pre></td></tr></table></figure>\n<h3 id=\"2-把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库\"><a href=\"#2-把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库\" class=\"headerlink\" title=\"2.    把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库\"></a>2.    把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./app2dylib /tmp/AlipayWallet -o /tmp/libAlipayApp.dylib</div></pre></td></tr></table></figure>\n<h3 id=\"3-用-Xcode-新建工程，并把新生成的dylib拖进去，调整好各项设置\"><a href=\"#3-用-Xcode-新建工程，并把新生成的dylib拖进去，调整好各项设置\" class=\"headerlink\" title=\"3.    用 Xcode 新建工程，并把新生成的dylib拖进去，调整好各项设置.\"></a>3.    用 Xcode 新建工程，并把新生成的dylib拖进去，调整好各项设置.</h3><p><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20Xcode%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B.jpg\" alt=\"\">  </p>\n<p>Run Script里的代码(目的是为了对dylib进行签名)  </p>\n<pre><code class=\"linux\">cd ${BUILT_PRODUCTS_DIR}\ncd ${FULL_PRODUCT_NAME}\n/usr/bin/codesign --force --sign ${EXPANDED_CODE_SIGN_IDENTITY} --timestamp=none libAlipayApp.dylib\n</code></pre>\n<h3 id=\"4-怎么调用动态库里的方法呢？\"><a href=\"#4-怎么调用动态库里的方法呢？\" class=\"headerlink\" title=\"4.    怎么调用动态库里的方法呢？\"></a>4.    怎么调用动态库里的方法呢？</h3><p>为方便大家尝试，这里选两个分析起来比较简单的函数调用演示给大家。</p>\n<p>一个是OC的方法 <code>+[aluSecurity rsaEncryptText:pubKey:]</code>, 可以直接用oc运行时调用。</p>\n<p>另一个是C的函数 <code>int base64_encode(char * output, int * output_length, char * input, int input_length)</code><br>这个需要先确定 base64_encode 这个C函数的函数签名和在dylib中的偏移地址（我这边的9.9.3版本是0xa798e4），可以用ida分析得到。</p>\n<p>运行结果：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\" alt=\"\">  </p>\n<pre><code class=\"C\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span>\n<span class=\"meta\">#import <span class=\"meta-string\">&lt;dlfcn.h&gt;</span></span>\n<span class=\"meta\">#import <span class=\"meta-string\">&lt;mach/mach.h&gt;</span></span>\n<span class=\"meta\">#import <span class=\"meta-string\">&lt;mach-o/loader.h&gt;</span></span>\n<span class=\"meta\">#import <span class=\"meta-string\">&lt;mach-o/dyld.h&gt;</span></span>\n<span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span>\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[])</span> </span>{\n    NSLog(@<span class=\"string\">\"\\n===Start===\\n\"</span>);\n    NSString * dylibName = @<span class=\"string\">\"libAlipayApp\"</span>;\n    NSString * path = [[NSBundle mainBundle] pathForResource:dylibName ofType:@<span class=\"string\">\"dylib\"</span>];\n    <span class=\"keyword\">if</span> (dlopen(path.UTF8String, RTLD_NOW) == <span class=\"literal\">NULL</span>){\n        NSLog(@<span class=\"string\">\"dlopen failed ，error %s\"</span>, dlerror());\n        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n    };\n\n    <span class=\"comment\">//运行时 直接调用oc方法</span>\n    NSString * plain = @<span class=\"string\">\"alipay\"</span>;\n    NSString * pubkey = @<span class=\"string\">\"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDZ6i9VNEGEaZaYE7XffA9XRj15cp/ZKhHYY43EEva8LIhCWi29EREaF4JjZVMwFpUAfrL+9gpA7NMQmaMRHbrz1KHe2Ho4HpUhEac8M9zUbNvaDKSlhx0lq/15TQP+57oQbfJ9oKKd+he4Yd6jpBI3UtGmwJyN/T1S0DQ0aXR8OQIDAQAB\"</span>;\n    NSString * cipher = [NSClassFromString(@<span class=\"string\">\"aluSecurity\"</span>) performSelector:NSSelectorFromString(@<span class=\"string\">\"rsaEncryptText:pubKey:\"</span>) withObject:plain withObject:pubkey];\n    NSLog(@<span class=\"string\">\"\\n-----------call oc method---------\\n明文：%@\\n密文： %@\\n-----------------------------------\"</span>, plain,cipher);\n\n    <span class=\"comment\">//确认dylib加载在内存中的地址</span>\n    <span class=\"keyword\">uint64_t</span> slide = <span class=\"number\">0</span>;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;  _dyld_image_count(); i ++)\n        <span class=\"keyword\">if</span> ([[NSString stringWithUTF8String:_dyld_get_image_name(i)] isEqualToString:path])\n            slide = _dyld_get_image_vmaddr_slide(i);\n    assert(slide != <span class=\"number\">0</span>);\n\n\n    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*BASE64_ENCODE_FUNC_TYPE)</span> <span class=\"params\">(<span class=\"keyword\">char</span> * output, <span class=\"keyword\">int</span> * output_size , <span class=\"keyword\">char</span> * input, <span class=\"keyword\">int</span> input_length)</span></span>;\n    <span class=\"comment\">/** 根据偏移算出函数地址， 然后调用*/</span>\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> base64_encode_offset_in_dylib = <span class=\"number\">0xa798e4</span>;\n    BASE64_ENCODE_FUNC_TYPE base64_encode = (BASE64_ENCODE_FUNC_TYPE)(slide + base64_encode_offset_in_dylib);\n    <span class=\"keyword\">char</span> output[<span class=\"number\">1000</span>] = {<span class=\"number\">0</span>};\n    <span class=\"keyword\">int</span> length = <span class=\"number\">1000</span>;\n    <span class=\"keyword\">char</span> * input = <span class=\"string\">\"alipay\"</span>;\n    base64_encode(output, &amp; length,  input, (<span class=\"keyword\">int</span>)<span class=\"built_in\">strlen</span>(input));\n    NSLog(@<span class=\"string\">\"\\n-----------call c function---------\\nbase64: %s -&gt; %s\\n-----------------------------------\"</span>, input,  output);\n}\n</code></pre>\n<p>ps：示例代码中，我刻意除掉了界面部分的代码，因为支付宝的+load函数里swizzle了UI层的一些方法，会导致crash，如果想干掉那些+load方法的话，看下面。  </p>\n<h2 id=\"关于绕过检测代码\"><a href=\"#关于绕过检测代码\" class=\"headerlink\" title=\"关于绕过检测代码\"></a>关于绕过检测代码</h2><p>文章开头的简介中有提到，以动态库的形式加载，能够绕过应用的检测代码，这说法不完全，因为如果把检测代码写在类的+load方法里或者mod_init_func函数（ 全局静态变量的构造函数和<strong>attribute</strong>((constructor))指定的函数 ）里，在dylib加载的时候也是可以得到调用的。</p>\n<p>那么也就衍生出两种配搭的对抗方案：<br><strong>i）越狱机</strong><br>+load方法的调用是在libobjc.dylib中的call_load_methods函数， mod_init_func函数的调用是在dyld中的doModInitFunctions函数，可以直接用CydiaSubstrate inline hook掉这两个函数，而且动态库是由我们自己加载的，所以可以控制hook和加载dylib的时序。</p>\n<p><strong>ii) 非越狱机</strong><br>非越狱机上，没有办法inline hook，但是可以利用_dyld_register_func_for_add_image 这个函数注册回调，这个回调是发生在动态库加载到内存后，+load方法和mod_init_func函数调用前，所以可以在这个回调里把+load方法改名，把mod_init_func段改名等等，也就可以使得各种检测函数没法调用了。</p>\n<p>总之，主要的控制权还是在我们手中。<br>测试环境：<br>iPhone 6Plus 、iOS 9.3.1 、arm64<br>支付宝9.9.3</p>\n<p>参考链接&amp;致谢  </p>\n<ol>\n<li>dyld的源码：<a href=\"https://opensource.apple.com/source/dyld/\" target=\"_blank\" rel=\"external\">https://opensource.apple.com/source/dyld/</a>  </li>\n<li>iOS逆向的论坛 <a href=\"http://iosre.com/\" target=\"_blank\" rel=\"external\">http://iosre.com/</a></li>\n</ol>"},{"title":"VPS+SSR+锐速（BBR魔改版）实现超级加速","date":"2017-11-06T16:00:00.000Z","_content":"\n谷歌2016年出了一个基于Linux内核的 BBR 拥塞控制算法，虽然咱不懂咋回事，还是大概知道它也是通过优化 TCP 底层协议来实现网速加速，跟锐速的原理一样。我是通过搬瓦工的 KiwiVM 后台安装的，用了之后感觉不咋地，网上查了一下，大部分网友都说锐速的加速效果要好于BBR。锐速已经停止新用户注册和维护了，之前虽然收费，但是现在已经有破解版。BBR不好用，有大神就开始魔改了，出了一个魔改版的BBR，据说效果比锐速还好！  \n下文对于锐速和BBR魔改版安装都有介绍，你可以尝试一下，看哪个速度更快。  \n下文的环境基于：CentOS6 X64\n\n# 1、准备 VPS\n\n[搬瓦工VPS](https://bwh1.net/aff.php?aff=10505)是我目前使用过性价比较高的 VPS，速度也比较稳定。\n**如何购买比较稳定的 VPS 可以参考我之前写的[VPS搭建高速SS服务器](https://www.gaoshilei.com/2016/05/19/VPS/)**  \n\n由于天朝的网络环境，之前的 SS 虽然营运商破解不了协议，但是通过流量监测和干扰的方式会严重影响我们的访问网络，最明显的特征就是响应慢，网络卡。所以 SS 现在已经有很大的局限性了，SSR + 加速 应该是我们最好的选择。下文会介绍如何加速，如何安装 SSR 服务。   \n\n或许有的同学会问 SS 和 SSR 有什么区别？  \n答：SSR 只是在 SS 的基础上增加了一些新的协议和混淆功能，抗检测和干扰能力更强，简单点说如果你所在的地区没有运营商干扰你访问墙外网站，那么是没有区别的，如果你所在地区的国际出口宽带流量被检测和干扰的很严重，SSR 这个时候优势就体现出来了。不过就目前的形势来看，SS 被干扰已经是很普遍的情况了，个人建议安装 SSR，然后设置好协议和混淆，干扰不严重可以不用混淆，后面会有介绍。  \n\n你购买或者配置VPS过程中遇到什么问题，可以通过邮箱 goslei1315@gmail.com 联系我，工作日一般2个小时之内回复，询问之前请描述清楚你遇到的问题。\n\n**注意：购买 VPS 要选择 KVM 虚拟的，不要选择 OpenVZ 虚拟，后面你就会知道原因。**\n\n<!-- more -->\n\n# 2、安装锐速破解版  \n## 1、执行脚本安装\n首先介绍一下锐速是干嘛的，下面的介绍来自Google\n> 锐速serverspeeder是一款TCP网络加速软件，能在Linux系统和Windows系统的服务器中安装，安装后能启到提高网络连接稳定性、带宽利用率、低访问失败率等作用，从而提高服务器网络访问速度。锐速并非实际增大服务器带宽，只是提高网络的稳定性和利用率而已。一个明显变化就是在同一VPS安装科学上网工具观看YouTube，没安装锐速前观看YouTube 720P视频非常不流畅，经常会出现缓冲现象；而安装锐速后能流畅观看YouTube 720P视频。  \n\n由于锐速只支持 KVM 虚拟化的主机，OpenVZ 主机无法使用，购买时请注意分辨。   \n\n先把一键安装的脚本下载下来：  \n\n```\n[root@California_VPS ~]# wget -N --no-check-certificate https://raw.githubusercontent.com/wn789/serverspeeder/master/serverspeeder.sh\n```\n\n如果报错 wget 命令找不到，需要安装  \n\n```\n[root@California_VPS ~]# yum -y install wget\n```\n\n脚本下载完成之后赋权执行：  \n\n```\n[root@California_VPS ~]# chmod +x serverspeeder.sh\n[root@California_VPS ~]# bash serverspeeder.sh\n```\n\n如果看到下面这个，证明当前 VPS 系统内核不支持  \n\n> This kernel is not supported. Trying fuzzy matching...\nServerspeeder is not supported on this kernel! View all supported systems and kernels here: https://www.91yun.org/serverspeeder91yun  \n\n需要手动修改内核，或者重新安装系统， 由于我的系统内核不支持，所以要手动修改。 如果很不幸你看到了上面的报错，请直接跳到`2、手动修改内核`，如果你没有看到上面内容，而是看到了   \n\n```\n[Running Status]\nServerSpeeder is running!\nversion              3.10.61.0\n\n[License Information]\nLicense              B4C10AE5B485C0CE (valid on current device)\nMaxSession           unlimited\nMaxTcpAccSession     unlimited\nMaxBandwidth(kbps)   unlimited\nExpireDate           2034-12-31\n\n[Connection Information]\nTotalFlow            1\nNumOfTcpFlows        1\nTotalAccTcpFlow      0\nTotalActiveTcpFlow   0\n\n[Running Configuration]\naccif                eth0       \nacc                  1\nadvacc               1\nadvinacc             1\nwankbps              10000000\nwaninkbps            10000000\ncsvmode              0\nsubnetAcc            0\nmaxmode              1\npcapEnable           0\n```\n\n恭喜你，锐速已经安装完成。  \n\n锐速常用的命令  \n\n```\nservice serverSpeeder start #启动\nservice serverSpeeder stop #停止\nservice serverSpeeder reload #重新加载配置\nservice serverSpeeder restart #重启\nservice serverSpeeder status #状态\nservice serverSpeeder stats #统计\nservice serverSpeeder renewLic #更新许可文件\nservice serverSpeeder update #更新\nchattr -i /serverspeeder/etc/apx* && /serverspeeder/bin/serverSpeeder.sh uninstall -f #卸载\n```\n\n\n## 2、手动修改内核（非必须）  \n\n注意在搬瓦工的后台面板（KiwiVM）查看你现在的系统类型，如后面带有 bbr 字样的，需要重新安装不带 bbr 的，否则你将无法成功修改内核   \n![](http://oeat6c2zg.bkt.clouddn.com/newOSForSSR.png)\n\n查看当前的系统内核版本：  \n\n```\n[root@California_VPS ~]# uname -r\n2.6.32-642.el6.x86_64\n```\n\n锐速支持的 CentOS6 内核版本为 2.6.32-504.3.3.el6.x86_64，下面就要开始修改内核了，准备好内核文件执行安装：  \n\n```\n[root@California_VPS ~]# rpm -ivh http://xz.wn789.com/CentOSkernel/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm\n[root@California_VPS ~]# rpm -ivh http://xz.wn789.com/CentOSkernel/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force\n```\n\n可能要等个几分钟，全部完成之后查看是否安装成功：  \n\n```\n[root@California_VPS ~]# rpm -qa | grep kernel\n\nkernel-firmware-2.6.32-642.el6.noarch\ndracut-kernel-004-409.el6.noarch\nkernel-2.6.32-504.3.3.el6.x86_64\nkernel-2.6.32-642.el6.x86_64\n```\n\n执行 `pm -qa | grep kernel` 命令之后可以看到锐速支持的 kernel-2.6.32-504.3.3.el6.x86_64 内核已经安装完成。最后一步，确认内核已经被替换。  \n重启 VPS，然后查看当前的系统内核  \n\n```\n[root@California_VPS ~]# uname -r\n2.6.32-504.3.3.el6.x86_64\n```\n\n内核已经成功被替换成锐速支持的内核，可以继续第一步的安装工作了。  \n\n# 3、安装 BBR 魔改版\n\n**注意：因为内核问题 BBR 与速锐只能二选一。**  \n\n安装魔改版BBR最好选择Debian/Ubuntu系统，因为这两个系统大佬制作了一键安装脚本，而且已经将库编译好了，如果用CentOS需要自己安装gcc4.9+，编译要很长时间，不建议在CentOS安装。下文的介绍主要还是在CentOS环境中操作，Debian/Ubuntu 有一键脚本非常傻瓜，下文也会有介绍。  \n\nBBR 也只支持 KVM 虚拟化的主机 ，所以选主机一定要选 KVM 虚拟化的。  \n\n## CentOS\n###  1、升级内核  \n\n安装魔改BBR的系统要求是4.10以上版本的kernel及对应的linux-header，gcc版本应在4.9以上，如果对应的内核版本链接失效了，可以去`http://elrepo.org`上找镜像网站，镜像网站里面有归档，可以找到对应4.12版本的内核，`http://www.jules.fm/elrepo/archive/`就是其中一个镜像网站。**BBR魔改版只能支持到4.12版本的内核，之前用4.13内核失败了**   \n\n依次执行下面的命令  \n\n```\n[root@California_VPS ~]# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\n[root@California_VPS ~]# yum install -y http://www.jules.fm/elrepo/archive/kernel/el6/x86_64/RPMS/kernel-ml-4.12.10-1.el6.elrepo.x86_64.rpm\n[root@California_VPS ~]# yum remove -y kernel-headers\n[root@California_VPS ~]# yum install -y http://www.jules.fm/elrepo/archive/kernel/el6/x86_64/RPMS/kernel-ml-headers-4.12.10-1.el6.elrepo.x86_64.rpm\n[root@California_VPS ~]# yum install -y http://www.jules.fm/elrepo/archive/kernel/el6/x86_64/RPMS/kernel-ml-devel-4.12.10-1.el6.elrepo.x86_64.rpm\n```\n\n\n###  2、修改启动引导  \n\n执行完成之后，修改启动引导，修改配置文件：  \n\n```\n[root@California_VPS ~]# vim /etc/grub.conf\n```\n\n可以看到启动项的配置文件，我们刚才添加的内核在第一个，所以要修改默认的启动内核  \n\n```\n grub.conf generated by anaconda\n#\n# Note that you do not have to rerun grub after making changes to this file\n# NOTICE:  You have a /boot partition.  This means that\n#          all kernel and initrd paths are relative to /boot/, eg.\n#          root (hd0,0)\n#          kernel /vmlinuz-version ro root=/dev/sda2\n#          initrd /initrd-[generic-]version.img\n#boot=/dev/sda\ndefault=0\ntimeout=5\nsplashimage=(hd0,0)/grub/splash.xpm.gz\nhiddenmenu\ntitle CentOS (4.12.10-1.el6.elrepo.x86_64)\n        root (hd0,0)\n        kernel /vmlinuz-4.12.10-1.el6.elrepo.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305\n        initrd /initramfs-4.12.10-1.el6.elrepo.x86_64.img\ntitle CentOS (4.13.10-1.el6.elrepo.x86_64)\n        root (hd0,0)\n        kernel /vmlinuz-4.13.10-1.el6.elrepo.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305\n        initrd /initramfs-4.13.10-1.el6.elrepo.x86_64.img\ntitle CentOS (2.6.32-642.el6.x86_64)\n        root (hd0,0)\n        kernel /vmlinuz-2.6.32-642.el6.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305\n        initrd /initramfs-2.6.32-642.el6.x86_64.img\ntitle CentOS 6 (2.6.32-642.el6.x86_64)\n        root (hd0,0)\n        kernel /vmlinuz-2.6.32-642.el6.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305\n        initrd /initramfs-2.6.32-642.el6.x86_64.img\n\n```\n\n修改 default=0 保存，重启服务器，然后查看内核是否修改成功  \n\n```\n[root@California_VPS ~]# uname -r\n4.12.10-1.el6.elrepo.x86_64\n```\n\n如果显示是刚才我们安装的内核证明已经修改成功，如果还是旧的内核，需要重新安装。\n\n###  3、编译安装  \n\n先安装基础版本的 gcc 和 gcc++\n\n```\n[root@California_VPS ~]# yum install gcc gcc++\n```\n\nLinux 默认安装的 gcc 版本是4.4.7，而编译魔改 BBR 的 gcc 版本至少要 4.9，所以要手动升级 gcc  \n\n#### 1、升级 gcc 版本 \n\n因为需要4.9以上的gcc版本，所以我们升级gcc版本到4.9.4，有人要问为什么不升级到最新版，我的原则是够用就行，你也可以到`http://ftp.gnu.org/gnu`查找最新版然后升级下载对应的包就可以了。  \n\n##### 1、 下载安装包：  \n\n```\n[root@California_VPS ~]# wget http://ftp.gnu.org/gnu/gcc/gcc-4.9.4/gcc-4.9.4.tar.bz2\n```\n\n然后解压：\n\n```\n[root@California_VPS ~]# tar -jxvf cc-4.9.4.tar.bz2\n```\n\n解压主要消耗CPU性能，搬瓦工的低配VPS都是单核的，这个包将近90MB，所以要比较久大概等个十分钟左右就好了。  \n\n##### 2、下载供编译需求的依赖库\n\n下载、配置安装依赖库，解压好的文件里面有安装脚本，依次执行下面的命令   \n\n```\n[root@California_VPS ~]# cd cc-4.9.4\n[root@California_VPS gcc-4.9.4]# ./contrib/download_prerequisites\n```\n\n##### 3、新建目录供编译存放文件\n\n首先新建一个文件夹用来存放编译的文件  \n\n```\n[root@California_VPS gcc-4.9.4]# mkdir gcc-build-4.9.4  \n[root@California_VPS gcc-4.9.4]# cd gcc-build-4.9.4/\n```\n\n#####  4、生成 Makefile 文件  \n\n```\n[root@California_VPS gcc-build-4.9.4]# ../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib\n```\n\n#####  5、编译gcc  \n\n```\n[root@California_VPS gcc-build-4.9.4]# make\n```\n\n这一步时间比较长，大概需要一个多小时（取决于你的CPU性能）。不要重复编译，因为编译期间CPU的使用率基本上都是100%，因为之前装错了内核，后面又编译了一次，于是我在KiwiVM后台看到了这样的提示  \n![](http://oeat6c2zg.bkt.clouddn.com/5272396EC1518BCC63AA0092F77C2D44.jpg)     \nCPU长时间处于满负荷状态，把我的CPU时钟限制了。    \n![](http://oeat6c2zg.bkt.clouddn.com/QQ20171109-110554@2x.png)   \n所以 CentOS 安装 BBR魔改还是要谨慎啊，gcc4.9 编译太费CPU了。\n\n\n#####  6、安装gcc\n\n```\n[root@California_VPS gcc-build-4.9.4]# make install\n```\n\n安装完成之后重启服务器，然后查看gcc版本号  \n\n```\n[root@California_VPS ~]# gcc -v\n使用内建 specs。\nCOLLECT_GCC=gcc\nCOLLECT_LTO_WRAPPER=/usr/local/libexec/gcc/x86_64-unknown-linux-gnu/4.9.4/lto-wrapper\n目标：x86_64-unknown-linux-gnu\n配置为：../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib\n线程模型：posix\ngcc 版本 4.9.4 (GCC)\n```\n\n升级成功，下面开始正式编译BBR。\n\n#### 2、编译安装 BBR\n\n```\n[root@California_VPS ~]# wget -O ./tcp_tsunami.c https://gist.github.com/anonymous/ba338038e799eafbba173215153a7f3a/raw/55ff1e45c97b46f12261e07ca07633a9922ad55d/tcp_tsunami.c\n[root@California_VPS ~]# echo \"obj-m:=tcp_tsunami.o\" > Makefile\n[root@California_VPS ~]# make -C /lib/modules/$(uname -r)/build M=`pwd` modules CC=/usr/bin/gcc\n[root@California_VPS ~]# chmod +x ./tcp_tsunami.ko\n[root@California_VPS ~]# cp -rf ./tcp_tsunami.ko /lib/modules/$(uname -r)/kernel/net/ipv4\n[root@California_VPS ~]# insmod tcp_tsunami.ko\n[root@California_VPS ~]# depmod -a\n[root@California_VPS ~]# echo \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\n[root@California_VPS ~]# echo \"net.ipv4.tcp_congestion_control=tsunami\" >> /etc/sysctl.conf\n```\n\n没有报错都顺利完成的话，重启服务器。然后查看：  \n\n```\n[root@California_VPS ~]# lsmod | grep tsunami\ntcp_tsunami            16384  5 \n```\n\n如果能看到 tcp_tsunami 证明 BBR 魔改版已安装成功。\n\n## Debian/Ubuntu\n\n### 1、开启 BBR\n\n执行下面脚本一键开启  \n \n```\nwget --no-check-certificate -qO 'BBR.sh' 'https://moeclub.org/attachment/LinuxShell/BBR.sh' && chmod a+x BBR.sh && bash BBR.sh -f\n```\n\n### 2、安装魔改版BBR  \n\n```\nwget --no-check-certificate -qO 'BBR_POWERED.sh' 'https://moeclub.org/attachment/LinuxShell/BBR_POWERED.sh' && chmod a+x BBR_POWERED.sh && bash BBR_POWERED.sh\n```\n\n完成之后执行下面的命令检查是否安装成功  \n\n```\nlsmod |grep 'bbr_powered'\n```\n\n如果结果有 `bbr_powered` 则说明加载成功！\n\n# 4、安装 SSR \n搬瓦工的后台控制面板（KiwiVM）已经提供了一键安装的功能，不过有些协议并不支持，如果想体验完整版的 SSR 的安装，还是自己动手吧！  \n还是通过一键式傻瓜脚本安装： \n\n先下载脚本   \n\n```\n[root@California_VPS ~]# wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh\n```\n\n然后赋权、安装  \n\n```\n[root@California_VPS ~]# chmod +x shadowsocksR.sh \n[root@California_VPS ~]# ./shadowsocksR.sh 2>&1 | tee shadowsocksR.log\n```\n\n执行完安装命令会看到这个：  \n\n```\n#############################################################\n# One click Install ShadowsocksR Server                     #\n# Intro: https://shadowsocks.be/9.html                      #\n# Author: Teddysun <i@teddysun.com>                         #\n# Github: https://github.com/shadowsocksr/shadowsocksr      #\n#############################################################\n\nPlease enter password for ShadowsocksR:\n...\nPlease enter a port for ShadowsocksR [1-65535]:\n...\nPlease select stream cipher for ShadowsocksR:\n...\nPlease select protocol for ShadowsocksR:\n...\nPlease select obfs for ShadowsocksR:\n...\n```\n\n需要你选择相应的参数，前两个比较好理解，一个是SSR的密码，一个是端口；后面三个就比较复杂了，关于加密方法和协议介绍请看[wiki文档](https://github.com/gaoshilei/shadowsocks_install/blob/master/shadowsocksR-wiki/ShadowsocksR%20协议插件文档.md)  \n\n如果不想看文档，可以使用推荐参数配置  \n加密：`chacha20`和`aes-256-cfb8`\n协议：`auth_chain_a`和`auth_aes128_md5`和`auth_aes128_sha1`\n混淆：`plain`,`http_simple`,`http_post`,`tls1.2_ticket_auth`  \n\n\n卸载 SSR：`./shadowsocksR.sh uninstall`\n\nSSR 一些常用的命令  \n\n```\n启动：/etc/init.d/shadowsocks start\n停止：/etc/init.d/shadowsocks stop\n重启：/etc/init.d/shadowsocks restart\n状态：/etc/init.d/shadowsocks status\n```\n\n日志路径\n\n```\n配置文件路径：/etc/shadowsocks.json\n日志文件路径：/var/log/shadowsocksr.log\n代码安装目录：/usr/local/shadowsocks\n\n```\n\n如果后面想修改 SSR 的一些配置可以直接修改 `shadowsocks.json` ，然后重启 SSR 即可。  \n\n最后配置 SSR 客户端就可以畅快的刷 YouTube 了，当然你也可以去 tumblr。【手动邪恶】    \n**奉上各个平台 SSR 的下载链接：**  \nMAC版下载地址：[ShadowsocksX-NG.1.5.1.zip](https://github.com/iMeiji/shadowsocks_install/releases/download/0.13/ShadowsocksX-NG.1.5.1.zip)  \nwindows版下载地址：[ssr-win.4.7.0-fix.7z](https://github.com/iMeiji/shadowsocks_install/releases/download/0.13/ssr-win.4.7.0-fix.7z)  \niOS版下载地址：[wingy](https://itunes.apple.com/us/app/wingy-http-s-socks5-proxy-utility/id1178584911?mt=8)（中国区已下架，换个美国账号下载）\n安卓版下载地址：[ssr-android-3.4.0.5.apk](https://github.com/iMeiji/shadowsocks_install/releases/download/0.13/ssr-android-3.4.0.5.apk)\n\n最后看看效果吧，YouTube 1080P 视频亲测截图  \n\n![YouTube 1080P视频](http://oeat6c2zg.bkt.clouddn.com/QQ20171107-174706@2x.png)\n\n\n再来一张YouTube的下载速度：  \n\n![YouTube视频下载速度](http://oeat6c2zg.bkt.clouddn.com/QQ20171107-175234@2x.png)  \n\n是不是感觉帮帮哒！","source":"_posts/VPS+SSR+锐速（BBR魔改版）实现超级加速.md","raw":"---\ntitle: VPS+SSR+锐速（BBR魔改版）实现超级加速\ndate: 2017-11-07\ncategories:\n- 实用工具\ntags:\n- VPS\n- VPN\n- Shadowsocks\npermalink: SSR\n\n---\n\n谷歌2016年出了一个基于Linux内核的 BBR 拥塞控制算法，虽然咱不懂咋回事，还是大概知道它也是通过优化 TCP 底层协议来实现网速加速，跟锐速的原理一样。我是通过搬瓦工的 KiwiVM 后台安装的，用了之后感觉不咋地，网上查了一下，大部分网友都说锐速的加速效果要好于BBR。锐速已经停止新用户注册和维护了，之前虽然收费，但是现在已经有破解版。BBR不好用，有大神就开始魔改了，出了一个魔改版的BBR，据说效果比锐速还好！  \n下文对于锐速和BBR魔改版安装都有介绍，你可以尝试一下，看哪个速度更快。  \n下文的环境基于：CentOS6 X64\n\n# 1、准备 VPS\n\n[搬瓦工VPS](https://bwh1.net/aff.php?aff=10505)是我目前使用过性价比较高的 VPS，速度也比较稳定。\n**如何购买比较稳定的 VPS 可以参考我之前写的[VPS搭建高速SS服务器](https://www.gaoshilei.com/2016/05/19/VPS/)**  \n\n由于天朝的网络环境，之前的 SS 虽然营运商破解不了协议，但是通过流量监测和干扰的方式会严重影响我们的访问网络，最明显的特征就是响应慢，网络卡。所以 SS 现在已经有很大的局限性了，SSR + 加速 应该是我们最好的选择。下文会介绍如何加速，如何安装 SSR 服务。   \n\n或许有的同学会问 SS 和 SSR 有什么区别？  \n答：SSR 只是在 SS 的基础上增加了一些新的协议和混淆功能，抗检测和干扰能力更强，简单点说如果你所在的地区没有运营商干扰你访问墙外网站，那么是没有区别的，如果你所在地区的国际出口宽带流量被检测和干扰的很严重，SSR 这个时候优势就体现出来了。不过就目前的形势来看，SS 被干扰已经是很普遍的情况了，个人建议安装 SSR，然后设置好协议和混淆，干扰不严重可以不用混淆，后面会有介绍。  \n\n你购买或者配置VPS过程中遇到什么问题，可以通过邮箱 goslei1315@gmail.com 联系我，工作日一般2个小时之内回复，询问之前请描述清楚你遇到的问题。\n\n**注意：购买 VPS 要选择 KVM 虚拟的，不要选择 OpenVZ 虚拟，后面你就会知道原因。**\n\n<!-- more -->\n\n# 2、安装锐速破解版  \n## 1、执行脚本安装\n首先介绍一下锐速是干嘛的，下面的介绍来自Google\n> 锐速serverspeeder是一款TCP网络加速软件，能在Linux系统和Windows系统的服务器中安装，安装后能启到提高网络连接稳定性、带宽利用率、低访问失败率等作用，从而提高服务器网络访问速度。锐速并非实际增大服务器带宽，只是提高网络的稳定性和利用率而已。一个明显变化就是在同一VPS安装科学上网工具观看YouTube，没安装锐速前观看YouTube 720P视频非常不流畅，经常会出现缓冲现象；而安装锐速后能流畅观看YouTube 720P视频。  \n\n由于锐速只支持 KVM 虚拟化的主机，OpenVZ 主机无法使用，购买时请注意分辨。   \n\n先把一键安装的脚本下载下来：  \n\n```\n[root@California_VPS ~]# wget -N --no-check-certificate https://raw.githubusercontent.com/wn789/serverspeeder/master/serverspeeder.sh\n```\n\n如果报错 wget 命令找不到，需要安装  \n\n```\n[root@California_VPS ~]# yum -y install wget\n```\n\n脚本下载完成之后赋权执行：  \n\n```\n[root@California_VPS ~]# chmod +x serverspeeder.sh\n[root@California_VPS ~]# bash serverspeeder.sh\n```\n\n如果看到下面这个，证明当前 VPS 系统内核不支持  \n\n> This kernel is not supported. Trying fuzzy matching...\nServerspeeder is not supported on this kernel! View all supported systems and kernels here: https://www.91yun.org/serverspeeder91yun  \n\n需要手动修改内核，或者重新安装系统， 由于我的系统内核不支持，所以要手动修改。 如果很不幸你看到了上面的报错，请直接跳到`2、手动修改内核`，如果你没有看到上面内容，而是看到了   \n\n```\n[Running Status]\nServerSpeeder is running!\nversion              3.10.61.0\n\n[License Information]\nLicense              B4C10AE5B485C0CE (valid on current device)\nMaxSession           unlimited\nMaxTcpAccSession     unlimited\nMaxBandwidth(kbps)   unlimited\nExpireDate           2034-12-31\n\n[Connection Information]\nTotalFlow            1\nNumOfTcpFlows        1\nTotalAccTcpFlow      0\nTotalActiveTcpFlow   0\n\n[Running Configuration]\naccif                eth0       \nacc                  1\nadvacc               1\nadvinacc             1\nwankbps              10000000\nwaninkbps            10000000\ncsvmode              0\nsubnetAcc            0\nmaxmode              1\npcapEnable           0\n```\n\n恭喜你，锐速已经安装完成。  \n\n锐速常用的命令  \n\n```\nservice serverSpeeder start #启动\nservice serverSpeeder stop #停止\nservice serverSpeeder reload #重新加载配置\nservice serverSpeeder restart #重启\nservice serverSpeeder status #状态\nservice serverSpeeder stats #统计\nservice serverSpeeder renewLic #更新许可文件\nservice serverSpeeder update #更新\nchattr -i /serverspeeder/etc/apx* && /serverspeeder/bin/serverSpeeder.sh uninstall -f #卸载\n```\n\n\n## 2、手动修改内核（非必须）  \n\n注意在搬瓦工的后台面板（KiwiVM）查看你现在的系统类型，如后面带有 bbr 字样的，需要重新安装不带 bbr 的，否则你将无法成功修改内核   \n![](http://oeat6c2zg.bkt.clouddn.com/newOSForSSR.png)\n\n查看当前的系统内核版本：  \n\n```\n[root@California_VPS ~]# uname -r\n2.6.32-642.el6.x86_64\n```\n\n锐速支持的 CentOS6 内核版本为 2.6.32-504.3.3.el6.x86_64，下面就要开始修改内核了，准备好内核文件执行安装：  \n\n```\n[root@California_VPS ~]# rpm -ivh http://xz.wn789.com/CentOSkernel/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm\n[root@California_VPS ~]# rpm -ivh http://xz.wn789.com/CentOSkernel/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force\n```\n\n可能要等个几分钟，全部完成之后查看是否安装成功：  \n\n```\n[root@California_VPS ~]# rpm -qa | grep kernel\n\nkernel-firmware-2.6.32-642.el6.noarch\ndracut-kernel-004-409.el6.noarch\nkernel-2.6.32-504.3.3.el6.x86_64\nkernel-2.6.32-642.el6.x86_64\n```\n\n执行 `pm -qa | grep kernel` 命令之后可以看到锐速支持的 kernel-2.6.32-504.3.3.el6.x86_64 内核已经安装完成。最后一步，确认内核已经被替换。  \n重启 VPS，然后查看当前的系统内核  \n\n```\n[root@California_VPS ~]# uname -r\n2.6.32-504.3.3.el6.x86_64\n```\n\n内核已经成功被替换成锐速支持的内核，可以继续第一步的安装工作了。  \n\n# 3、安装 BBR 魔改版\n\n**注意：因为内核问题 BBR 与速锐只能二选一。**  \n\n安装魔改版BBR最好选择Debian/Ubuntu系统，因为这两个系统大佬制作了一键安装脚本，而且已经将库编译好了，如果用CentOS需要自己安装gcc4.9+，编译要很长时间，不建议在CentOS安装。下文的介绍主要还是在CentOS环境中操作，Debian/Ubuntu 有一键脚本非常傻瓜，下文也会有介绍。  \n\nBBR 也只支持 KVM 虚拟化的主机 ，所以选主机一定要选 KVM 虚拟化的。  \n\n## CentOS\n###  1、升级内核  \n\n安装魔改BBR的系统要求是4.10以上版本的kernel及对应的linux-header，gcc版本应在4.9以上，如果对应的内核版本链接失效了，可以去`http://elrepo.org`上找镜像网站，镜像网站里面有归档，可以找到对应4.12版本的内核，`http://www.jules.fm/elrepo/archive/`就是其中一个镜像网站。**BBR魔改版只能支持到4.12版本的内核，之前用4.13内核失败了**   \n\n依次执行下面的命令  \n\n```\n[root@California_VPS ~]# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\n[root@California_VPS ~]# yum install -y http://www.jules.fm/elrepo/archive/kernel/el6/x86_64/RPMS/kernel-ml-4.12.10-1.el6.elrepo.x86_64.rpm\n[root@California_VPS ~]# yum remove -y kernel-headers\n[root@California_VPS ~]# yum install -y http://www.jules.fm/elrepo/archive/kernel/el6/x86_64/RPMS/kernel-ml-headers-4.12.10-1.el6.elrepo.x86_64.rpm\n[root@California_VPS ~]# yum install -y http://www.jules.fm/elrepo/archive/kernel/el6/x86_64/RPMS/kernel-ml-devel-4.12.10-1.el6.elrepo.x86_64.rpm\n```\n\n\n###  2、修改启动引导  \n\n执行完成之后，修改启动引导，修改配置文件：  \n\n```\n[root@California_VPS ~]# vim /etc/grub.conf\n```\n\n可以看到启动项的配置文件，我们刚才添加的内核在第一个，所以要修改默认的启动内核  \n\n```\n grub.conf generated by anaconda\n#\n# Note that you do not have to rerun grub after making changes to this file\n# NOTICE:  You have a /boot partition.  This means that\n#          all kernel and initrd paths are relative to /boot/, eg.\n#          root (hd0,0)\n#          kernel /vmlinuz-version ro root=/dev/sda2\n#          initrd /initrd-[generic-]version.img\n#boot=/dev/sda\ndefault=0\ntimeout=5\nsplashimage=(hd0,0)/grub/splash.xpm.gz\nhiddenmenu\ntitle CentOS (4.12.10-1.el6.elrepo.x86_64)\n        root (hd0,0)\n        kernel /vmlinuz-4.12.10-1.el6.elrepo.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305\n        initrd /initramfs-4.12.10-1.el6.elrepo.x86_64.img\ntitle CentOS (4.13.10-1.el6.elrepo.x86_64)\n        root (hd0,0)\n        kernel /vmlinuz-4.13.10-1.el6.elrepo.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305\n        initrd /initramfs-4.13.10-1.el6.elrepo.x86_64.img\ntitle CentOS (2.6.32-642.el6.x86_64)\n        root (hd0,0)\n        kernel /vmlinuz-2.6.32-642.el6.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305\n        initrd /initramfs-2.6.32-642.el6.x86_64.img\ntitle CentOS 6 (2.6.32-642.el6.x86_64)\n        root (hd0,0)\n        kernel /vmlinuz-2.6.32-642.el6.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305\n        initrd /initramfs-2.6.32-642.el6.x86_64.img\n\n```\n\n修改 default=0 保存，重启服务器，然后查看内核是否修改成功  \n\n```\n[root@California_VPS ~]# uname -r\n4.12.10-1.el6.elrepo.x86_64\n```\n\n如果显示是刚才我们安装的内核证明已经修改成功，如果还是旧的内核，需要重新安装。\n\n###  3、编译安装  \n\n先安装基础版本的 gcc 和 gcc++\n\n```\n[root@California_VPS ~]# yum install gcc gcc++\n```\n\nLinux 默认安装的 gcc 版本是4.4.7，而编译魔改 BBR 的 gcc 版本至少要 4.9，所以要手动升级 gcc  \n\n#### 1、升级 gcc 版本 \n\n因为需要4.9以上的gcc版本，所以我们升级gcc版本到4.9.4，有人要问为什么不升级到最新版，我的原则是够用就行，你也可以到`http://ftp.gnu.org/gnu`查找最新版然后升级下载对应的包就可以了。  \n\n##### 1、 下载安装包：  \n\n```\n[root@California_VPS ~]# wget http://ftp.gnu.org/gnu/gcc/gcc-4.9.4/gcc-4.9.4.tar.bz2\n```\n\n然后解压：\n\n```\n[root@California_VPS ~]# tar -jxvf cc-4.9.4.tar.bz2\n```\n\n解压主要消耗CPU性能，搬瓦工的低配VPS都是单核的，这个包将近90MB，所以要比较久大概等个十分钟左右就好了。  \n\n##### 2、下载供编译需求的依赖库\n\n下载、配置安装依赖库，解压好的文件里面有安装脚本，依次执行下面的命令   \n\n```\n[root@California_VPS ~]# cd cc-4.9.4\n[root@California_VPS gcc-4.9.4]# ./contrib/download_prerequisites\n```\n\n##### 3、新建目录供编译存放文件\n\n首先新建一个文件夹用来存放编译的文件  \n\n```\n[root@California_VPS gcc-4.9.4]# mkdir gcc-build-4.9.4  \n[root@California_VPS gcc-4.9.4]# cd gcc-build-4.9.4/\n```\n\n#####  4、生成 Makefile 文件  \n\n```\n[root@California_VPS gcc-build-4.9.4]# ../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib\n```\n\n#####  5、编译gcc  \n\n```\n[root@California_VPS gcc-build-4.9.4]# make\n```\n\n这一步时间比较长，大概需要一个多小时（取决于你的CPU性能）。不要重复编译，因为编译期间CPU的使用率基本上都是100%，因为之前装错了内核，后面又编译了一次，于是我在KiwiVM后台看到了这样的提示  \n![](http://oeat6c2zg.bkt.clouddn.com/5272396EC1518BCC63AA0092F77C2D44.jpg)     \nCPU长时间处于满负荷状态，把我的CPU时钟限制了。    \n![](http://oeat6c2zg.bkt.clouddn.com/QQ20171109-110554@2x.png)   \n所以 CentOS 安装 BBR魔改还是要谨慎啊，gcc4.9 编译太费CPU了。\n\n\n#####  6、安装gcc\n\n```\n[root@California_VPS gcc-build-4.9.4]# make install\n```\n\n安装完成之后重启服务器，然后查看gcc版本号  \n\n```\n[root@California_VPS ~]# gcc -v\n使用内建 specs。\nCOLLECT_GCC=gcc\nCOLLECT_LTO_WRAPPER=/usr/local/libexec/gcc/x86_64-unknown-linux-gnu/4.9.4/lto-wrapper\n目标：x86_64-unknown-linux-gnu\n配置为：../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib\n线程模型：posix\ngcc 版本 4.9.4 (GCC)\n```\n\n升级成功，下面开始正式编译BBR。\n\n#### 2、编译安装 BBR\n\n```\n[root@California_VPS ~]# wget -O ./tcp_tsunami.c https://gist.github.com/anonymous/ba338038e799eafbba173215153a7f3a/raw/55ff1e45c97b46f12261e07ca07633a9922ad55d/tcp_tsunami.c\n[root@California_VPS ~]# echo \"obj-m:=tcp_tsunami.o\" > Makefile\n[root@California_VPS ~]# make -C /lib/modules/$(uname -r)/build M=`pwd` modules CC=/usr/bin/gcc\n[root@California_VPS ~]# chmod +x ./tcp_tsunami.ko\n[root@California_VPS ~]# cp -rf ./tcp_tsunami.ko /lib/modules/$(uname -r)/kernel/net/ipv4\n[root@California_VPS ~]# insmod tcp_tsunami.ko\n[root@California_VPS ~]# depmod -a\n[root@California_VPS ~]# echo \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\n[root@California_VPS ~]# echo \"net.ipv4.tcp_congestion_control=tsunami\" >> /etc/sysctl.conf\n```\n\n没有报错都顺利完成的话，重启服务器。然后查看：  \n\n```\n[root@California_VPS ~]# lsmod | grep tsunami\ntcp_tsunami            16384  5 \n```\n\n如果能看到 tcp_tsunami 证明 BBR 魔改版已安装成功。\n\n## Debian/Ubuntu\n\n### 1、开启 BBR\n\n执行下面脚本一键开启  \n \n```\nwget --no-check-certificate -qO 'BBR.sh' 'https://moeclub.org/attachment/LinuxShell/BBR.sh' && chmod a+x BBR.sh && bash BBR.sh -f\n```\n\n### 2、安装魔改版BBR  \n\n```\nwget --no-check-certificate -qO 'BBR_POWERED.sh' 'https://moeclub.org/attachment/LinuxShell/BBR_POWERED.sh' && chmod a+x BBR_POWERED.sh && bash BBR_POWERED.sh\n```\n\n完成之后执行下面的命令检查是否安装成功  \n\n```\nlsmod |grep 'bbr_powered'\n```\n\n如果结果有 `bbr_powered` 则说明加载成功！\n\n# 4、安装 SSR \n搬瓦工的后台控制面板（KiwiVM）已经提供了一键安装的功能，不过有些协议并不支持，如果想体验完整版的 SSR 的安装，还是自己动手吧！  \n还是通过一键式傻瓜脚本安装： \n\n先下载脚本   \n\n```\n[root@California_VPS ~]# wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh\n```\n\n然后赋权、安装  \n\n```\n[root@California_VPS ~]# chmod +x shadowsocksR.sh \n[root@California_VPS ~]# ./shadowsocksR.sh 2>&1 | tee shadowsocksR.log\n```\n\n执行完安装命令会看到这个：  \n\n```\n#############################################################\n# One click Install ShadowsocksR Server                     #\n# Intro: https://shadowsocks.be/9.html                      #\n# Author: Teddysun <i@teddysun.com>                         #\n# Github: https://github.com/shadowsocksr/shadowsocksr      #\n#############################################################\n\nPlease enter password for ShadowsocksR:\n...\nPlease enter a port for ShadowsocksR [1-65535]:\n...\nPlease select stream cipher for ShadowsocksR:\n...\nPlease select protocol for ShadowsocksR:\n...\nPlease select obfs for ShadowsocksR:\n...\n```\n\n需要你选择相应的参数，前两个比较好理解，一个是SSR的密码，一个是端口；后面三个就比较复杂了，关于加密方法和协议介绍请看[wiki文档](https://github.com/gaoshilei/shadowsocks_install/blob/master/shadowsocksR-wiki/ShadowsocksR%20协议插件文档.md)  \n\n如果不想看文档，可以使用推荐参数配置  \n加密：`chacha20`和`aes-256-cfb8`\n协议：`auth_chain_a`和`auth_aes128_md5`和`auth_aes128_sha1`\n混淆：`plain`,`http_simple`,`http_post`,`tls1.2_ticket_auth`  \n\n\n卸载 SSR：`./shadowsocksR.sh uninstall`\n\nSSR 一些常用的命令  \n\n```\n启动：/etc/init.d/shadowsocks start\n停止：/etc/init.d/shadowsocks stop\n重启：/etc/init.d/shadowsocks restart\n状态：/etc/init.d/shadowsocks status\n```\n\n日志路径\n\n```\n配置文件路径：/etc/shadowsocks.json\n日志文件路径：/var/log/shadowsocksr.log\n代码安装目录：/usr/local/shadowsocks\n\n```\n\n如果后面想修改 SSR 的一些配置可以直接修改 `shadowsocks.json` ，然后重启 SSR 即可。  \n\n最后配置 SSR 客户端就可以畅快的刷 YouTube 了，当然你也可以去 tumblr。【手动邪恶】    \n**奉上各个平台 SSR 的下载链接：**  \nMAC版下载地址：[ShadowsocksX-NG.1.5.1.zip](https://github.com/iMeiji/shadowsocks_install/releases/download/0.13/ShadowsocksX-NG.1.5.1.zip)  \nwindows版下载地址：[ssr-win.4.7.0-fix.7z](https://github.com/iMeiji/shadowsocks_install/releases/download/0.13/ssr-win.4.7.0-fix.7z)  \niOS版下载地址：[wingy](https://itunes.apple.com/us/app/wingy-http-s-socks5-proxy-utility/id1178584911?mt=8)（中国区已下架，换个美国账号下载）\n安卓版下载地址：[ssr-android-3.4.0.5.apk](https://github.com/iMeiji/shadowsocks_install/releases/download/0.13/ssr-android-3.4.0.5.apk)\n\n最后看看效果吧，YouTube 1080P 视频亲测截图  \n\n![YouTube 1080P视频](http://oeat6c2zg.bkt.clouddn.com/QQ20171107-174706@2x.png)\n\n\n再来一张YouTube的下载速度：  \n\n![YouTube视频下载速度](http://oeat6c2zg.bkt.clouddn.com/QQ20171107-175234@2x.png)  \n\n是不是感觉帮帮哒！","slug":"SSR","published":1,"updated":"2017-11-21T10:27:27.021Z","_id":"cja3m8z9p0000qeenczoemygy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>谷歌2016年出了一个基于Linux内核的 BBR 拥塞控制算法，虽然咱不懂咋回事，还是大概知道它也是通过优化 TCP 底层协议来实现网速加速，跟锐速的原理一样。我是通过搬瓦工的 KiwiVM 后台安装的，用了之后感觉不咋地，网上查了一下，大部分网友都说锐速的加速效果要好于BBR。锐速已经停止新用户注册和维护了，之前虽然收费，但是现在已经有破解版。BBR不好用，有大神就开始魔改了，出了一个魔改版的BBR，据说效果比锐速还好！<br>下文对于锐速和BBR魔改版安装都有介绍，你可以尝试一下，看哪个速度更快。<br>下文的环境基于：CentOS6 X64</p>\n<h1 id=\"1、准备-VPS\"><a href=\"#1、准备-VPS\" class=\"headerlink\" title=\"1、准备 VPS\"></a>1、准备 VPS</h1><p><a href=\"https://bwh1.net/aff.php?aff=10505\" target=\"_blank\" rel=\"external\">搬瓦工VPS</a>是我目前使用过性价比较高的 VPS，速度也比较稳定。<br><strong>如何购买比较稳定的 VPS 可以参考我之前写的<a href=\"https://www.gaoshilei.com/2016/05/19/VPS/\">VPS搭建高速SS服务器</a></strong>  </p>\n<p>由于天朝的网络环境，之前的 SS 虽然营运商破解不了协议，但是通过流量监测和干扰的方式会严重影响我们的访问网络，最明显的特征就是响应慢，网络卡。所以 SS 现在已经有很大的局限性了，SSR + 加速 应该是我们最好的选择。下文会介绍如何加速，如何安装 SSR 服务。   </p>\n<p>或许有的同学会问 SS 和 SSR 有什么区别？<br>答：SSR 只是在 SS 的基础上增加了一些新的协议和混淆功能，抗检测和干扰能力更强，简单点说如果你所在的地区没有运营商干扰你访问墙外网站，那么是没有区别的，如果你所在地区的国际出口宽带流量被检测和干扰的很严重，SSR 这个时候优势就体现出来了。不过就目前的形势来看，SS 被干扰已经是很普遍的情况了，个人建议安装 SSR，然后设置好协议和混淆，干扰不严重可以不用混淆，后面会有介绍。  </p>\n<p>你购买或者配置VPS过程中遇到什么问题，可以通过邮箱 goslei1315@gmail.com 联系我，工作日一般2个小时之内回复，询问之前请描述清楚你遇到的问题。</p>\n<p><strong>注意：购买 VPS 要选择 KVM 虚拟的，不要选择 OpenVZ 虚拟，后面你就会知道原因。</strong></p>\n<a id=\"more\"></a>\n<h1 id=\"2、安装锐速破解版\"><a href=\"#2、安装锐速破解版\" class=\"headerlink\" title=\"2、安装锐速破解版\"></a>2、安装锐速破解版</h1><h2 id=\"1、执行脚本安装\"><a href=\"#1、执行脚本安装\" class=\"headerlink\" title=\"1、执行脚本安装\"></a>1、执行脚本安装</h2><p>首先介绍一下锐速是干嘛的，下面的介绍来自Google</p>\n<blockquote>\n<p>锐速serverspeeder是一款TCP网络加速软件，能在Linux系统和Windows系统的服务器中安装，安装后能启到提高网络连接稳定性、带宽利用率、低访问失败率等作用，从而提高服务器网络访问速度。锐速并非实际增大服务器带宽，只是提高网络的稳定性和利用率而已。一个明显变化就是在同一VPS安装科学上网工具观看YouTube，没安装锐速前观看YouTube 720P视频非常不流畅，经常会出现缓冲现象；而安装锐速后能流畅观看YouTube 720P视频。  </p>\n</blockquote>\n<p>由于锐速只支持 KVM 虚拟化的主机，OpenVZ 主机无法使用，购买时请注意分辨。   </p>\n<p>先把一键安装的脚本下载下来：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# wget -N --no-check-certificate https://raw.githubusercontent.com/wn789/serverspeeder/master/serverspeeder.sh</div></pre></td></tr></table></figure>\n<p>如果报错 wget 命令找不到，需要安装  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# yum -y install wget</div></pre></td></tr></table></figure>\n<p>脚本下载完成之后赋权执行：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# chmod +x serverspeeder.sh</div><div class=\"line\">[root@California_VPS ~]# bash serverspeeder.sh</div></pre></td></tr></table></figure>\n<p>如果看到下面这个，证明当前 VPS 系统内核不支持  </p>\n<blockquote>\n<p>This kernel is not supported. Trying fuzzy matching…<br>Serverspeeder is not supported on this kernel! View all supported systems and kernels here: <a href=\"https://www.91yun.org/serverspeeder91yun\" target=\"_blank\" rel=\"external\">https://www.91yun.org/serverspeeder91yun</a>  </p>\n</blockquote>\n<p>需要手动修改内核，或者重新安装系统， 由于我的系统内核不支持，所以要手动修改。 如果很不幸你看到了上面的报错，请直接跳到<code>2、手动修改内核</code>，如果你没有看到上面内容，而是看到了   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">[Running Status]</div><div class=\"line\">ServerSpeeder is running!</div><div class=\"line\">version              3.10.61.0</div><div class=\"line\"></div><div class=\"line\">[License Information]</div><div class=\"line\">License              B4C10AE5B485C0CE (valid on current device)</div><div class=\"line\">MaxSession           unlimited</div><div class=\"line\">MaxTcpAccSession     unlimited</div><div class=\"line\">MaxBandwidth(kbps)   unlimited</div><div class=\"line\">ExpireDate           2034-12-31</div><div class=\"line\"></div><div class=\"line\">[Connection Information]</div><div class=\"line\">TotalFlow            1</div><div class=\"line\">NumOfTcpFlows        1</div><div class=\"line\">TotalAccTcpFlow      0</div><div class=\"line\">TotalActiveTcpFlow   0</div><div class=\"line\"></div><div class=\"line\">[Running Configuration]</div><div class=\"line\">accif                eth0       </div><div class=\"line\">acc                  1</div><div class=\"line\">advacc               1</div><div class=\"line\">advinacc             1</div><div class=\"line\">wankbps              10000000</div><div class=\"line\">waninkbps            10000000</div><div class=\"line\">csvmode              0</div><div class=\"line\">subnetAcc            0</div><div class=\"line\">maxmode              1</div><div class=\"line\">pcapEnable           0</div></pre></td></tr></table></figure>\n<p>恭喜你，锐速已经安装完成。  </p>\n<p>锐速常用的命令  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">service serverSpeeder start #启动</div><div class=\"line\">service serverSpeeder stop #停止</div><div class=\"line\">service serverSpeeder reload #重新加载配置</div><div class=\"line\">service serverSpeeder restart #重启</div><div class=\"line\">service serverSpeeder status #状态</div><div class=\"line\">service serverSpeeder stats #统计</div><div class=\"line\">service serverSpeeder renewLic #更新许可文件</div><div class=\"line\">service serverSpeeder update #更新</div><div class=\"line\">chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f #卸载</div></pre></td></tr></table></figure>\n<h2 id=\"2、手动修改内核（非必须）\"><a href=\"#2、手动修改内核（非必须）\" class=\"headerlink\" title=\"2、手动修改内核（非必须）\"></a>2、手动修改内核（非必须）</h2><p>注意在搬瓦工的后台面板（KiwiVM）查看你现在的系统类型，如后面带有 bbr 字样的，需要重新安装不带 bbr 的，否则你将无法成功修改内核<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/newOSForSSR.png\" alt=\"\"></p>\n<p>查看当前的系统内核版本：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# uname -r</div><div class=\"line\">2.6.32-642.el6.x86_64</div></pre></td></tr></table></figure>\n<p>锐速支持的 CentOS6 内核版本为 2.6.32-504.3.3.el6.x86_64，下面就要开始修改内核了，准备好内核文件执行安装：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# rpm -ivh http://xz.wn789.com/CentOSkernel/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm</div><div class=\"line\">[root@California_VPS ~]# rpm -ivh http://xz.wn789.com/CentOSkernel/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force</div></pre></td></tr></table></figure>\n<p>可能要等个几分钟，全部完成之后查看是否安装成功：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# rpm -qa | grep kernel</div><div class=\"line\"></div><div class=\"line\">kernel-firmware-2.6.32-642.el6.noarch</div><div class=\"line\">dracut-kernel-004-409.el6.noarch</div><div class=\"line\">kernel-2.6.32-504.3.3.el6.x86_64</div><div class=\"line\">kernel-2.6.32-642.el6.x86_64</div></pre></td></tr></table></figure>\n<p>执行 <code>pm -qa | grep kernel</code> 命令之后可以看到锐速支持的 kernel-2.6.32-504.3.3.el6.x86_64 内核已经安装完成。最后一步，确认内核已经被替换。<br>重启 VPS，然后查看当前的系统内核  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# uname -r</div><div class=\"line\">2.6.32-504.3.3.el6.x86_64</div></pre></td></tr></table></figure>\n<p>内核已经成功被替换成锐速支持的内核，可以继续第一步的安装工作了。  </p>\n<h1 id=\"3、安装-BBR-魔改版\"><a href=\"#3、安装-BBR-魔改版\" class=\"headerlink\" title=\"3、安装 BBR 魔改版\"></a>3、安装 BBR 魔改版</h1><p><strong>注意：因为内核问题 BBR 与速锐只能二选一。</strong>  </p>\n<p>安装魔改版BBR最好选择Debian/Ubuntu系统，因为这两个系统大佬制作了一键安装脚本，而且已经将库编译好了，如果用CentOS需要自己安装gcc4.9+，编译要很长时间，不建议在CentOS安装。下文的介绍主要还是在CentOS环境中操作，Debian/Ubuntu 有一键脚本非常傻瓜，下文也会有介绍。  </p>\n<p>BBR 也只支持 KVM 虚拟化的主机 ，所以选主机一定要选 KVM 虚拟化的。  </p>\n<h2 id=\"CentOS\"><a href=\"#CentOS\" class=\"headerlink\" title=\"CentOS\"></a>CentOS</h2><h3 id=\"1、升级内核\"><a href=\"#1、升级内核\" class=\"headerlink\" title=\"1、升级内核\"></a>1、升级内核</h3><p>安装魔改BBR的系统要求是4.10以上版本的kernel及对应的linux-header，gcc版本应在4.9以上，如果对应的内核版本链接失效了，可以去<code>http://elrepo.org</code>上找镜像网站，镜像网站里面有归档，可以找到对应4.12版本的内核，<code>http://www.jules.fm/elrepo/archive/</code>就是其中一个镜像网站。<strong>BBR魔改版只能支持到4.12版本的内核，之前用4.13内核失败了</strong>   </p>\n<p>依次执行下面的命令  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</div><div class=\"line\">[root@California_VPS ~]# yum install -y http://www.jules.fm/elrepo/archive/kernel/el6/x86_64/RPMS/kernel-ml-4.12.10-1.el6.elrepo.x86_64.rpm</div><div class=\"line\">[root@California_VPS ~]# yum remove -y kernel-headers</div><div class=\"line\">[root@California_VPS ~]# yum install -y http://www.jules.fm/elrepo/archive/kernel/el6/x86_64/RPMS/kernel-ml-headers-4.12.10-1.el6.elrepo.x86_64.rpm</div><div class=\"line\">[root@California_VPS ~]# yum install -y http://www.jules.fm/elrepo/archive/kernel/el6/x86_64/RPMS/kernel-ml-devel-4.12.10-1.el6.elrepo.x86_64.rpm</div></pre></td></tr></table></figure>\n<h3 id=\"2、修改启动引导\"><a href=\"#2、修改启动引导\" class=\"headerlink\" title=\"2、修改启动引导\"></a>2、修改启动引导</h3><p>执行完成之后，修改启动引导，修改配置文件：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# vim /etc/grub.conf</div></pre></td></tr></table></figure>\n<p>可以看到启动项的配置文件，我们刚才添加的内核在第一个，所以要修改默认的启动内核  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"> grub.conf generated by anaconda</div><div class=\"line\">#</div><div class=\"line\"># Note that you do not have to rerun grub after making changes to this file</div><div class=\"line\"># NOTICE:  You have a /boot partition.  This means that</div><div class=\"line\">#          all kernel and initrd paths are relative to /boot/, eg.</div><div class=\"line\">#          root (hd0,0)</div><div class=\"line\">#          kernel /vmlinuz-version ro root=/dev/sda2</div><div class=\"line\">#          initrd /initrd-[generic-]version.img</div><div class=\"line\">#boot=/dev/sda</div><div class=\"line\">default=0</div><div class=\"line\">timeout=5</div><div class=\"line\">splashimage=(hd0,0)/grub/splash.xpm.gz</div><div class=\"line\">hiddenmenu</div><div class=\"line\">title CentOS (4.12.10-1.el6.elrepo.x86_64)</div><div class=\"line\">        root (hd0,0)</div><div class=\"line\">        kernel /vmlinuz-4.12.10-1.el6.elrepo.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305</div><div class=\"line\">        initrd /initramfs-4.12.10-1.el6.elrepo.x86_64.img</div><div class=\"line\">title CentOS (4.13.10-1.el6.elrepo.x86_64)</div><div class=\"line\">        root (hd0,0)</div><div class=\"line\">        kernel /vmlinuz-4.13.10-1.el6.elrepo.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305</div><div class=\"line\">        initrd /initramfs-4.13.10-1.el6.elrepo.x86_64.img</div><div class=\"line\">title CentOS (2.6.32-642.el6.x86_64)</div><div class=\"line\">        root (hd0,0)</div><div class=\"line\">        kernel /vmlinuz-2.6.32-642.el6.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305</div><div class=\"line\">        initrd /initramfs-2.6.32-642.el6.x86_64.img</div><div class=\"line\">title CentOS 6 (2.6.32-642.el6.x86_64)</div><div class=\"line\">        root (hd0,0)</div><div class=\"line\">        kernel /vmlinuz-2.6.32-642.el6.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305</div><div class=\"line\">        initrd /initramfs-2.6.32-642.el6.x86_64.img</div></pre></td></tr></table></figure>\n<p>修改 default=0 保存，重启服务器，然后查看内核是否修改成功  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# uname -r</div><div class=\"line\">4.12.10-1.el6.elrepo.x86_64</div></pre></td></tr></table></figure>\n<p>如果显示是刚才我们安装的内核证明已经修改成功，如果还是旧的内核，需要重新安装。</p>\n<h3 id=\"3、编译安装\"><a href=\"#3、编译安装\" class=\"headerlink\" title=\"3、编译安装\"></a>3、编译安装</h3><p>先安装基础版本的 gcc 和 gcc++</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# yum install gcc gcc++</div></pre></td></tr></table></figure>\n<p>Linux 默认安装的 gcc 版本是4.4.7，而编译魔改 BBR 的 gcc 版本至少要 4.9，所以要手动升级 gcc  </p>\n<h4 id=\"1、升级-gcc-版本\"><a href=\"#1、升级-gcc-版本\" class=\"headerlink\" title=\"1、升级 gcc 版本\"></a>1、升级 gcc 版本</h4><p>因为需要4.9以上的gcc版本，所以我们升级gcc版本到4.9.4，有人要问为什么不升级到最新版，我的原则是够用就行，你也可以到<code>http://ftp.gnu.org/gnu</code>查找最新版然后升级下载对应的包就可以了。  </p>\n<h5 id=\"1、-下载安装包：\"><a href=\"#1、-下载安装包：\" class=\"headerlink\" title=\"1、 下载安装包：\"></a>1、 下载安装包：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# wget http://ftp.gnu.org/gnu/gcc/gcc-4.9.4/gcc-4.9.4.tar.bz2</div></pre></td></tr></table></figure>\n<p>然后解压：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# tar -jxvf cc-4.9.4.tar.bz2</div></pre></td></tr></table></figure>\n<p>解压主要消耗CPU性能，搬瓦工的低配VPS都是单核的，这个包将近90MB，所以要比较久大概等个十分钟左右就好了。  </p>\n<h5 id=\"2、下载供编译需求的依赖库\"><a href=\"#2、下载供编译需求的依赖库\" class=\"headerlink\" title=\"2、下载供编译需求的依赖库\"></a>2、下载供编译需求的依赖库</h5><p>下载、配置安装依赖库，解压好的文件里面有安装脚本，依次执行下面的命令   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# cd cc-4.9.4</div><div class=\"line\">[root@California_VPS gcc-4.9.4]# ./contrib/download_prerequisites</div></pre></td></tr></table></figure>\n<h5 id=\"3、新建目录供编译存放文件\"><a href=\"#3、新建目录供编译存放文件\" class=\"headerlink\" title=\"3、新建目录供编译存放文件\"></a>3、新建目录供编译存放文件</h5><p>首先新建一个文件夹用来存放编译的文件  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS gcc-4.9.4]# mkdir gcc-build-4.9.4  </div><div class=\"line\">[root@California_VPS gcc-4.9.4]# cd gcc-build-4.9.4/</div></pre></td></tr></table></figure>\n<h5 id=\"4、生成-Makefile-文件\"><a href=\"#4、生成-Makefile-文件\" class=\"headerlink\" title=\"4、生成 Makefile 文件\"></a>4、生成 Makefile 文件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS gcc-build-4.9.4]# ../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib</div></pre></td></tr></table></figure>\n<h5 id=\"5、编译gcc\"><a href=\"#5、编译gcc\" class=\"headerlink\" title=\"5、编译gcc\"></a>5、编译gcc</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS gcc-build-4.9.4]# make</div></pre></td></tr></table></figure>\n<p>这一步时间比较长，大概需要一个多小时（取决于你的CPU性能）。不要重复编译，因为编译期间CPU的使用率基本上都是100%，因为之前装错了内核，后面又编译了一次，于是我在KiwiVM后台看到了这样的提示<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/5272396EC1518BCC63AA0092F77C2D44.jpg\" alt=\"\"><br>CPU长时间处于满负荷状态，把我的CPU时钟限制了。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/QQ20171109-110554@2x.png\" alt=\"\"><br>所以 CentOS 安装 BBR魔改还是要谨慎啊，gcc4.9 编译太费CPU了。</p>\n<h5 id=\"6、安装gcc\"><a href=\"#6、安装gcc\" class=\"headerlink\" title=\"6、安装gcc\"></a>6、安装gcc</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS gcc-build-4.9.4]# make install</div></pre></td></tr></table></figure>\n<p>安装完成之后重启服务器，然后查看gcc版本号  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# gcc -v</div><div class=\"line\">使用内建 specs。</div><div class=\"line\">COLLECT_GCC=gcc</div><div class=\"line\">COLLECT_LTO_WRAPPER=/usr/local/libexec/gcc/x86_64-unknown-linux-gnu/4.9.4/lto-wrapper</div><div class=\"line\">目标：x86_64-unknown-linux-gnu</div><div class=\"line\">配置为：../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib</div><div class=\"line\">线程模型：posix</div><div class=\"line\">gcc 版本 4.9.4 (GCC)</div></pre></td></tr></table></figure>\n<p>升级成功，下面开始正式编译BBR。</p>\n<h4 id=\"2、编译安装-BBR\"><a href=\"#2、编译安装-BBR\" class=\"headerlink\" title=\"2、编译安装 BBR\"></a>2、编译安装 BBR</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# wget -O ./tcp_tsunami.c https://gist.github.com/anonymous/ba338038e799eafbba173215153a7f3a/raw/55ff1e45c97b46f12261e07ca07633a9922ad55d/tcp_tsunami.c</div><div class=\"line\">[root@California_VPS ~]# echo &quot;obj-m:=tcp_tsunami.o&quot; &gt; Makefile</div><div class=\"line\">[root@California_VPS ~]# make -C /lib/modules/$(uname -r)/build M=`pwd` modules CC=/usr/bin/gcc</div><div class=\"line\">[root@California_VPS ~]# chmod +x ./tcp_tsunami.ko</div><div class=\"line\">[root@California_VPS ~]# cp -rf ./tcp_tsunami.ko /lib/modules/$(uname -r)/kernel/net/ipv4</div><div class=\"line\">[root@California_VPS ~]# insmod tcp_tsunami.ko</div><div class=\"line\">[root@California_VPS ~]# depmod -a</div><div class=\"line\">[root@California_VPS ~]# echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">[root@California_VPS ~]# echo &quot;net.ipv4.tcp_congestion_control=tsunami&quot; &gt;&gt; /etc/sysctl.conf</div></pre></td></tr></table></figure>\n<p>没有报错都顺利完成的话，重启服务器。然后查看：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# lsmod | grep tsunami</div><div class=\"line\">tcp_tsunami            16384  5</div></pre></td></tr></table></figure>\n<p>如果能看到 tcp_tsunami 证明 BBR 魔改版已安装成功。</p>\n<h2 id=\"Debian-Ubuntu\"><a href=\"#Debian-Ubuntu\" class=\"headerlink\" title=\"Debian/Ubuntu\"></a>Debian/Ubuntu</h2><h3 id=\"1、开启-BBR\"><a href=\"#1、开启-BBR\" class=\"headerlink\" title=\"1、开启 BBR\"></a>1、开启 BBR</h3><p>执行下面脚本一键开启  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget --no-check-certificate -qO &apos;BBR.sh&apos; &apos;https://moeclub.org/attachment/LinuxShell/BBR.sh&apos; &amp;&amp; chmod a+x BBR.sh &amp;&amp; bash BBR.sh -f</div></pre></td></tr></table></figure>\n<h3 id=\"2、安装魔改版BBR\"><a href=\"#2、安装魔改版BBR\" class=\"headerlink\" title=\"2、安装魔改版BBR\"></a>2、安装魔改版BBR</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget --no-check-certificate -qO &apos;BBR_POWERED.sh&apos; &apos;https://moeclub.org/attachment/LinuxShell/BBR_POWERED.sh&apos; &amp;&amp; chmod a+x BBR_POWERED.sh &amp;&amp; bash BBR_POWERED.sh</div></pre></td></tr></table></figure>\n<p>完成之后执行下面的命令检查是否安装成功  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lsmod |grep &apos;bbr_powered&apos;</div></pre></td></tr></table></figure>\n<p>如果结果有 <code>bbr_powered</code> 则说明加载成功！</p>\n<h1 id=\"4、安装-SSR\"><a href=\"#4、安装-SSR\" class=\"headerlink\" title=\"4、安装 SSR\"></a>4、安装 SSR</h1><p>搬瓦工的后台控制面板（KiwiVM）已经提供了一键安装的功能，不过有些协议并不支持，如果想体验完整版的 SSR 的安装，还是自己动手吧！<br>还是通过一键式傻瓜脚本安装： </p>\n<p>先下载脚本   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</div></pre></td></tr></table></figure>\n<p>然后赋权、安装  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# chmod +x shadowsocksR.sh </div><div class=\"line\">[root@California_VPS ~]# ./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</div></pre></td></tr></table></figure>\n<p>执行完安装命令会看到这个：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#############################################################</div><div class=\"line\"># One click Install ShadowsocksR Server                     #</div><div class=\"line\"># Intro: https://shadowsocks.be/9.html                      #</div><div class=\"line\"># Author: Teddysun &lt;i@teddysun.com&gt;                         #</div><div class=\"line\"># Github: https://github.com/shadowsocksr/shadowsocksr      #</div><div class=\"line\">#############################################################</div><div class=\"line\"></div><div class=\"line\">Please enter password for ShadowsocksR:</div><div class=\"line\">...</div><div class=\"line\">Please enter a port for ShadowsocksR [1-65535]:</div><div class=\"line\">...</div><div class=\"line\">Please select stream cipher for ShadowsocksR:</div><div class=\"line\">...</div><div class=\"line\">Please select protocol for ShadowsocksR:</div><div class=\"line\">...</div><div class=\"line\">Please select obfs for ShadowsocksR:</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>需要你选择相应的参数，前两个比较好理解，一个是SSR的密码，一个是端口；后面三个就比较复杂了，关于加密方法和协议介绍请看<a href=\"https://github.com/gaoshilei/shadowsocks_install/blob/master/shadowsocksR-wiki/ShadowsocksR%20协议插件文档.md\" target=\"_blank\" rel=\"external\">wiki文档</a>  </p>\n<p>如果不想看文档，可以使用推荐参数配置<br>加密：<code>chacha20</code>和<code>aes-256-cfb8</code><br>协议：<code>auth_chain_a</code>和<code>auth_aes128_md5</code>和<code>auth_aes128_sha1</code><br>混淆：<code>plain</code>,<code>http_simple</code>,<code>http_post</code>,<code>tls1.2_ticket_auth</code>  </p>\n<p>卸载 SSR：<code>./shadowsocksR.sh uninstall</code></p>\n<p>SSR 一些常用的命令  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">启动：/etc/init.d/shadowsocks start</div><div class=\"line\">停止：/etc/init.d/shadowsocks stop</div><div class=\"line\">重启：/etc/init.d/shadowsocks restart</div><div class=\"line\">状态：/etc/init.d/shadowsocks status</div></pre></td></tr></table></figure>\n<p>日志路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">配置文件路径：/etc/shadowsocks.json</div><div class=\"line\">日志文件路径：/var/log/shadowsocksr.log</div><div class=\"line\">代码安装目录：/usr/local/shadowsocks</div></pre></td></tr></table></figure>\n<p>如果后面想修改 SSR 的一些配置可以直接修改 <code>shadowsocks.json</code> ，然后重启 SSR 即可。  </p>\n<p>最后配置 SSR 客户端就可以畅快的刷 YouTube 了，当然你也可以去 tumblr。【手动邪恶】<br><strong>奉上各个平台 SSR 的下载链接：</strong><br>MAC版下载地址：<a href=\"https://github.com/iMeiji/shadowsocks_install/releases/download/0.13/ShadowsocksX-NG.1.5.1.zip\" target=\"_blank\" rel=\"external\">ShadowsocksX-NG.1.5.1.zip</a><br>windows版下载地址：<a href=\"https://github.com/iMeiji/shadowsocks_install/releases/download/0.13/ssr-win.4.7.0-fix.7z\" target=\"_blank\" rel=\"external\">ssr-win.4.7.0-fix.7z</a><br>iOS版下载地址：<a href=\"https://itunes.apple.com/us/app/wingy-http-s-socks5-proxy-utility/id1178584911?mt=8\" target=\"_blank\" rel=\"external\">wingy</a>（中国区已下架，换个美国账号下载）<br>安卓版下载地址：<a href=\"https://github.com/iMeiji/shadowsocks_install/releases/download/0.13/ssr-android-3.4.0.5.apk\" target=\"_blank\" rel=\"external\">ssr-android-3.4.0.5.apk</a></p>\n<p>最后看看效果吧，YouTube 1080P 视频亲测截图  </p>\n<p><img src=\"http://oeat6c2zg.bkt.clouddn.com/QQ20171107-174706@2x.png\" alt=\"YouTube 1080P视频\"></p>\n<p>再来一张YouTube的下载速度：  </p>\n<p><img src=\"http://oeat6c2zg.bkt.clouddn.com/QQ20171107-175234@2x.png\" alt=\"YouTube视频下载速度\">  </p>\n<p>是不是感觉帮帮哒！</p>\n","site":{"data":{}},"excerpt":"<p>谷歌2016年出了一个基于Linux内核的 BBR 拥塞控制算法，虽然咱不懂咋回事，还是大概知道它也是通过优化 TCP 底层协议来实现网速加速，跟锐速的原理一样。我是通过搬瓦工的 KiwiVM 后台安装的，用了之后感觉不咋地，网上查了一下，大部分网友都说锐速的加速效果要好于BBR。锐速已经停止新用户注册和维护了，之前虽然收费，但是现在已经有破解版。BBR不好用，有大神就开始魔改了，出了一个魔改版的BBR，据说效果比锐速还好！<br>下文对于锐速和BBR魔改版安装都有介绍，你可以尝试一下，看哪个速度更快。<br>下文的环境基于：CentOS6 X64</p>\n<h1 id=\"1、准备-VPS\"><a href=\"#1、准备-VPS\" class=\"headerlink\" title=\"1、准备 VPS\"></a>1、准备 VPS</h1><p><a href=\"https://bwh1.net/aff.php?aff=10505\" target=\"_blank\" rel=\"external\">搬瓦工VPS</a>是我目前使用过性价比较高的 VPS，速度也比较稳定。<br><strong>如何购买比较稳定的 VPS 可以参考我之前写的<a href=\"https://www.gaoshilei.com/2016/05/19/VPS/\">VPS搭建高速SS服务器</a></strong>  </p>\n<p>由于天朝的网络环境，之前的 SS 虽然营运商破解不了协议，但是通过流量监测和干扰的方式会严重影响我们的访问网络，最明显的特征就是响应慢，网络卡。所以 SS 现在已经有很大的局限性了，SSR + 加速 应该是我们最好的选择。下文会介绍如何加速，如何安装 SSR 服务。   </p>\n<p>或许有的同学会问 SS 和 SSR 有什么区别？<br>答：SSR 只是在 SS 的基础上增加了一些新的协议和混淆功能，抗检测和干扰能力更强，简单点说如果你所在的地区没有运营商干扰你访问墙外网站，那么是没有区别的，如果你所在地区的国际出口宽带流量被检测和干扰的很严重，SSR 这个时候优势就体现出来了。不过就目前的形势来看，SS 被干扰已经是很普遍的情况了，个人建议安装 SSR，然后设置好协议和混淆，干扰不严重可以不用混淆，后面会有介绍。  </p>\n<p>你购买或者配置VPS过程中遇到什么问题，可以通过邮箱 goslei1315@gmail.com 联系我，工作日一般2个小时之内回复，询问之前请描述清楚你遇到的问题。</p>\n<p><strong>注意：购买 VPS 要选择 KVM 虚拟的，不要选择 OpenVZ 虚拟，后面你就会知道原因。</strong></p>","more":"<h1 id=\"2、安装锐速破解版\"><a href=\"#2、安装锐速破解版\" class=\"headerlink\" title=\"2、安装锐速破解版\"></a>2、安装锐速破解版</h1><h2 id=\"1、执行脚本安装\"><a href=\"#1、执行脚本安装\" class=\"headerlink\" title=\"1、执行脚本安装\"></a>1、执行脚本安装</h2><p>首先介绍一下锐速是干嘛的，下面的介绍来自Google</p>\n<blockquote>\n<p>锐速serverspeeder是一款TCP网络加速软件，能在Linux系统和Windows系统的服务器中安装，安装后能启到提高网络连接稳定性、带宽利用率、低访问失败率等作用，从而提高服务器网络访问速度。锐速并非实际增大服务器带宽，只是提高网络的稳定性和利用率而已。一个明显变化就是在同一VPS安装科学上网工具观看YouTube，没安装锐速前观看YouTube 720P视频非常不流畅，经常会出现缓冲现象；而安装锐速后能流畅观看YouTube 720P视频。  </p>\n</blockquote>\n<p>由于锐速只支持 KVM 虚拟化的主机，OpenVZ 主机无法使用，购买时请注意分辨。   </p>\n<p>先把一键安装的脚本下载下来：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# wget -N --no-check-certificate https://raw.githubusercontent.com/wn789/serverspeeder/master/serverspeeder.sh</div></pre></td></tr></table></figure>\n<p>如果报错 wget 命令找不到，需要安装  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# yum -y install wget</div></pre></td></tr></table></figure>\n<p>脚本下载完成之后赋权执行：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# chmod +x serverspeeder.sh</div><div class=\"line\">[root@California_VPS ~]# bash serverspeeder.sh</div></pre></td></tr></table></figure>\n<p>如果看到下面这个，证明当前 VPS 系统内核不支持  </p>\n<blockquote>\n<p>This kernel is not supported. Trying fuzzy matching…<br>Serverspeeder is not supported on this kernel! View all supported systems and kernels here: <a href=\"https://www.91yun.org/serverspeeder91yun\" target=\"_blank\" rel=\"external\">https://www.91yun.org/serverspeeder91yun</a>  </p>\n</blockquote>\n<p>需要手动修改内核，或者重新安装系统， 由于我的系统内核不支持，所以要手动修改。 如果很不幸你看到了上面的报错，请直接跳到<code>2、手动修改内核</code>，如果你没有看到上面内容，而是看到了   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">[Running Status]</div><div class=\"line\">ServerSpeeder is running!</div><div class=\"line\">version              3.10.61.0</div><div class=\"line\"></div><div class=\"line\">[License Information]</div><div class=\"line\">License              B4C10AE5B485C0CE (valid on current device)</div><div class=\"line\">MaxSession           unlimited</div><div class=\"line\">MaxTcpAccSession     unlimited</div><div class=\"line\">MaxBandwidth(kbps)   unlimited</div><div class=\"line\">ExpireDate           2034-12-31</div><div class=\"line\"></div><div class=\"line\">[Connection Information]</div><div class=\"line\">TotalFlow            1</div><div class=\"line\">NumOfTcpFlows        1</div><div class=\"line\">TotalAccTcpFlow      0</div><div class=\"line\">TotalActiveTcpFlow   0</div><div class=\"line\"></div><div class=\"line\">[Running Configuration]</div><div class=\"line\">accif                eth0       </div><div class=\"line\">acc                  1</div><div class=\"line\">advacc               1</div><div class=\"line\">advinacc             1</div><div class=\"line\">wankbps              10000000</div><div class=\"line\">waninkbps            10000000</div><div class=\"line\">csvmode              0</div><div class=\"line\">subnetAcc            0</div><div class=\"line\">maxmode              1</div><div class=\"line\">pcapEnable           0</div></pre></td></tr></table></figure>\n<p>恭喜你，锐速已经安装完成。  </p>\n<p>锐速常用的命令  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">service serverSpeeder start #启动</div><div class=\"line\">service serverSpeeder stop #停止</div><div class=\"line\">service serverSpeeder reload #重新加载配置</div><div class=\"line\">service serverSpeeder restart #重启</div><div class=\"line\">service serverSpeeder status #状态</div><div class=\"line\">service serverSpeeder stats #统计</div><div class=\"line\">service serverSpeeder renewLic #更新许可文件</div><div class=\"line\">service serverSpeeder update #更新</div><div class=\"line\">chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f #卸载</div></pre></td></tr></table></figure>\n<h2 id=\"2、手动修改内核（非必须）\"><a href=\"#2、手动修改内核（非必须）\" class=\"headerlink\" title=\"2、手动修改内核（非必须）\"></a>2、手动修改内核（非必须）</h2><p>注意在搬瓦工的后台面板（KiwiVM）查看你现在的系统类型，如后面带有 bbr 字样的，需要重新安装不带 bbr 的，否则你将无法成功修改内核<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/newOSForSSR.png\" alt=\"\"></p>\n<p>查看当前的系统内核版本：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# uname -r</div><div class=\"line\">2.6.32-642.el6.x86_64</div></pre></td></tr></table></figure>\n<p>锐速支持的 CentOS6 内核版本为 2.6.32-504.3.3.el6.x86_64，下面就要开始修改内核了，准备好内核文件执行安装：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# rpm -ivh http://xz.wn789.com/CentOSkernel/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm</div><div class=\"line\">[root@California_VPS ~]# rpm -ivh http://xz.wn789.com/CentOSkernel/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force</div></pre></td></tr></table></figure>\n<p>可能要等个几分钟，全部完成之后查看是否安装成功：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# rpm -qa | grep kernel</div><div class=\"line\"></div><div class=\"line\">kernel-firmware-2.6.32-642.el6.noarch</div><div class=\"line\">dracut-kernel-004-409.el6.noarch</div><div class=\"line\">kernel-2.6.32-504.3.3.el6.x86_64</div><div class=\"line\">kernel-2.6.32-642.el6.x86_64</div></pre></td></tr></table></figure>\n<p>执行 <code>pm -qa | grep kernel</code> 命令之后可以看到锐速支持的 kernel-2.6.32-504.3.3.el6.x86_64 内核已经安装完成。最后一步，确认内核已经被替换。<br>重启 VPS，然后查看当前的系统内核  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# uname -r</div><div class=\"line\">2.6.32-504.3.3.el6.x86_64</div></pre></td></tr></table></figure>\n<p>内核已经成功被替换成锐速支持的内核，可以继续第一步的安装工作了。  </p>\n<h1 id=\"3、安装-BBR-魔改版\"><a href=\"#3、安装-BBR-魔改版\" class=\"headerlink\" title=\"3、安装 BBR 魔改版\"></a>3、安装 BBR 魔改版</h1><p><strong>注意：因为内核问题 BBR 与速锐只能二选一。</strong>  </p>\n<p>安装魔改版BBR最好选择Debian/Ubuntu系统，因为这两个系统大佬制作了一键安装脚本，而且已经将库编译好了，如果用CentOS需要自己安装gcc4.9+，编译要很长时间，不建议在CentOS安装。下文的介绍主要还是在CentOS环境中操作，Debian/Ubuntu 有一键脚本非常傻瓜，下文也会有介绍。  </p>\n<p>BBR 也只支持 KVM 虚拟化的主机 ，所以选主机一定要选 KVM 虚拟化的。  </p>\n<h2 id=\"CentOS\"><a href=\"#CentOS\" class=\"headerlink\" title=\"CentOS\"></a>CentOS</h2><h3 id=\"1、升级内核\"><a href=\"#1、升级内核\" class=\"headerlink\" title=\"1、升级内核\"></a>1、升级内核</h3><p>安装魔改BBR的系统要求是4.10以上版本的kernel及对应的linux-header，gcc版本应在4.9以上，如果对应的内核版本链接失效了，可以去<code>http://elrepo.org</code>上找镜像网站，镜像网站里面有归档，可以找到对应4.12版本的内核，<code>http://www.jules.fm/elrepo/archive/</code>就是其中一个镜像网站。<strong>BBR魔改版只能支持到4.12版本的内核，之前用4.13内核失败了</strong>   </p>\n<p>依次执行下面的命令  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</div><div class=\"line\">[root@California_VPS ~]# yum install -y http://www.jules.fm/elrepo/archive/kernel/el6/x86_64/RPMS/kernel-ml-4.12.10-1.el6.elrepo.x86_64.rpm</div><div class=\"line\">[root@California_VPS ~]# yum remove -y kernel-headers</div><div class=\"line\">[root@California_VPS ~]# yum install -y http://www.jules.fm/elrepo/archive/kernel/el6/x86_64/RPMS/kernel-ml-headers-4.12.10-1.el6.elrepo.x86_64.rpm</div><div class=\"line\">[root@California_VPS ~]# yum install -y http://www.jules.fm/elrepo/archive/kernel/el6/x86_64/RPMS/kernel-ml-devel-4.12.10-1.el6.elrepo.x86_64.rpm</div></pre></td></tr></table></figure>\n<h3 id=\"2、修改启动引导\"><a href=\"#2、修改启动引导\" class=\"headerlink\" title=\"2、修改启动引导\"></a>2、修改启动引导</h3><p>执行完成之后，修改启动引导，修改配置文件：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# vim /etc/grub.conf</div></pre></td></tr></table></figure>\n<p>可以看到启动项的配置文件，我们刚才添加的内核在第一个，所以要修改默认的启动内核  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"> grub.conf generated by anaconda</div><div class=\"line\">#</div><div class=\"line\"># Note that you do not have to rerun grub after making changes to this file</div><div class=\"line\"># NOTICE:  You have a /boot partition.  This means that</div><div class=\"line\">#          all kernel and initrd paths are relative to /boot/, eg.</div><div class=\"line\">#          root (hd0,0)</div><div class=\"line\">#          kernel /vmlinuz-version ro root=/dev/sda2</div><div class=\"line\">#          initrd /initrd-[generic-]version.img</div><div class=\"line\">#boot=/dev/sda</div><div class=\"line\">default=0</div><div class=\"line\">timeout=5</div><div class=\"line\">splashimage=(hd0,0)/grub/splash.xpm.gz</div><div class=\"line\">hiddenmenu</div><div class=\"line\">title CentOS (4.12.10-1.el6.elrepo.x86_64)</div><div class=\"line\">        root (hd0,0)</div><div class=\"line\">        kernel /vmlinuz-4.12.10-1.el6.elrepo.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305</div><div class=\"line\">        initrd /initramfs-4.12.10-1.el6.elrepo.x86_64.img</div><div class=\"line\">title CentOS (4.13.10-1.el6.elrepo.x86_64)</div><div class=\"line\">        root (hd0,0)</div><div class=\"line\">        kernel /vmlinuz-4.13.10-1.el6.elrepo.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305</div><div class=\"line\">        initrd /initramfs-4.13.10-1.el6.elrepo.x86_64.img</div><div class=\"line\">title CentOS (2.6.32-642.el6.x86_64)</div><div class=\"line\">        root (hd0,0)</div><div class=\"line\">        kernel /vmlinuz-2.6.32-642.el6.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305</div><div class=\"line\">        initrd /initramfs-2.6.32-642.el6.x86_64.img</div><div class=\"line\">title CentOS 6 (2.6.32-642.el6.x86_64)</div><div class=\"line\">        root (hd0,0)</div><div class=\"line\">        kernel /vmlinuz-2.6.32-642.el6.x86_64 ro root=UUID=971ffe7e-0c71-40c1-97a9-bdb6b167d4b7 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM consoleblank=0 vga=0x305</div><div class=\"line\">        initrd /initramfs-2.6.32-642.el6.x86_64.img</div></pre></td></tr></table></figure>\n<p>修改 default=0 保存，重启服务器，然后查看内核是否修改成功  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# uname -r</div><div class=\"line\">4.12.10-1.el6.elrepo.x86_64</div></pre></td></tr></table></figure>\n<p>如果显示是刚才我们安装的内核证明已经修改成功，如果还是旧的内核，需要重新安装。</p>\n<h3 id=\"3、编译安装\"><a href=\"#3、编译安装\" class=\"headerlink\" title=\"3、编译安装\"></a>3、编译安装</h3><p>先安装基础版本的 gcc 和 gcc++</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# yum install gcc gcc++</div></pre></td></tr></table></figure>\n<p>Linux 默认安装的 gcc 版本是4.4.7，而编译魔改 BBR 的 gcc 版本至少要 4.9，所以要手动升级 gcc  </p>\n<h4 id=\"1、升级-gcc-版本\"><a href=\"#1、升级-gcc-版本\" class=\"headerlink\" title=\"1、升级 gcc 版本\"></a>1、升级 gcc 版本</h4><p>因为需要4.9以上的gcc版本，所以我们升级gcc版本到4.9.4，有人要问为什么不升级到最新版，我的原则是够用就行，你也可以到<code>http://ftp.gnu.org/gnu</code>查找最新版然后升级下载对应的包就可以了。  </p>\n<h5 id=\"1、-下载安装包：\"><a href=\"#1、-下载安装包：\" class=\"headerlink\" title=\"1、 下载安装包：\"></a>1、 下载安装包：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# wget http://ftp.gnu.org/gnu/gcc/gcc-4.9.4/gcc-4.9.4.tar.bz2</div></pre></td></tr></table></figure>\n<p>然后解压：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# tar -jxvf cc-4.9.4.tar.bz2</div></pre></td></tr></table></figure>\n<p>解压主要消耗CPU性能，搬瓦工的低配VPS都是单核的，这个包将近90MB，所以要比较久大概等个十分钟左右就好了。  </p>\n<h5 id=\"2、下载供编译需求的依赖库\"><a href=\"#2、下载供编译需求的依赖库\" class=\"headerlink\" title=\"2、下载供编译需求的依赖库\"></a>2、下载供编译需求的依赖库</h5><p>下载、配置安装依赖库，解压好的文件里面有安装脚本，依次执行下面的命令   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# cd cc-4.9.4</div><div class=\"line\">[root@California_VPS gcc-4.9.4]# ./contrib/download_prerequisites</div></pre></td></tr></table></figure>\n<h5 id=\"3、新建目录供编译存放文件\"><a href=\"#3、新建目录供编译存放文件\" class=\"headerlink\" title=\"3、新建目录供编译存放文件\"></a>3、新建目录供编译存放文件</h5><p>首先新建一个文件夹用来存放编译的文件  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS gcc-4.9.4]# mkdir gcc-build-4.9.4  </div><div class=\"line\">[root@California_VPS gcc-4.9.4]# cd gcc-build-4.9.4/</div></pre></td></tr></table></figure>\n<h5 id=\"4、生成-Makefile-文件\"><a href=\"#4、生成-Makefile-文件\" class=\"headerlink\" title=\"4、生成 Makefile 文件\"></a>4、生成 Makefile 文件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS gcc-build-4.9.4]# ../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib</div></pre></td></tr></table></figure>\n<h5 id=\"5、编译gcc\"><a href=\"#5、编译gcc\" class=\"headerlink\" title=\"5、编译gcc\"></a>5、编译gcc</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS gcc-build-4.9.4]# make</div></pre></td></tr></table></figure>\n<p>这一步时间比较长，大概需要一个多小时（取决于你的CPU性能）。不要重复编译，因为编译期间CPU的使用率基本上都是100%，因为之前装错了内核，后面又编译了一次，于是我在KiwiVM后台看到了这样的提示<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/5272396EC1518BCC63AA0092F77C2D44.jpg\" alt=\"\"><br>CPU长时间处于满负荷状态，把我的CPU时钟限制了。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/QQ20171109-110554@2x.png\" alt=\"\"><br>所以 CentOS 安装 BBR魔改还是要谨慎啊，gcc4.9 编译太费CPU了。</p>\n<h5 id=\"6、安装gcc\"><a href=\"#6、安装gcc\" class=\"headerlink\" title=\"6、安装gcc\"></a>6、安装gcc</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS gcc-build-4.9.4]# make install</div></pre></td></tr></table></figure>\n<p>安装完成之后重启服务器，然后查看gcc版本号  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# gcc -v</div><div class=\"line\">使用内建 specs。</div><div class=\"line\">COLLECT_GCC=gcc</div><div class=\"line\">COLLECT_LTO_WRAPPER=/usr/local/libexec/gcc/x86_64-unknown-linux-gnu/4.9.4/lto-wrapper</div><div class=\"line\">目标：x86_64-unknown-linux-gnu</div><div class=\"line\">配置为：../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib</div><div class=\"line\">线程模型：posix</div><div class=\"line\">gcc 版本 4.9.4 (GCC)</div></pre></td></tr></table></figure>\n<p>升级成功，下面开始正式编译BBR。</p>\n<h4 id=\"2、编译安装-BBR\"><a href=\"#2、编译安装-BBR\" class=\"headerlink\" title=\"2、编译安装 BBR\"></a>2、编译安装 BBR</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# wget -O ./tcp_tsunami.c https://gist.github.com/anonymous/ba338038e799eafbba173215153a7f3a/raw/55ff1e45c97b46f12261e07ca07633a9922ad55d/tcp_tsunami.c</div><div class=\"line\">[root@California_VPS ~]# echo &quot;obj-m:=tcp_tsunami.o&quot; &gt; Makefile</div><div class=\"line\">[root@California_VPS ~]# make -C /lib/modules/$(uname -r)/build M=`pwd` modules CC=/usr/bin/gcc</div><div class=\"line\">[root@California_VPS ~]# chmod +x ./tcp_tsunami.ko</div><div class=\"line\">[root@California_VPS ~]# cp -rf ./tcp_tsunami.ko /lib/modules/$(uname -r)/kernel/net/ipv4</div><div class=\"line\">[root@California_VPS ~]# insmod tcp_tsunami.ko</div><div class=\"line\">[root@California_VPS ~]# depmod -a</div><div class=\"line\">[root@California_VPS ~]# echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">[root@California_VPS ~]# echo &quot;net.ipv4.tcp_congestion_control=tsunami&quot; &gt;&gt; /etc/sysctl.conf</div></pre></td></tr></table></figure>\n<p>没有报错都顺利完成的话，重启服务器。然后查看：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# lsmod | grep tsunami</div><div class=\"line\">tcp_tsunami            16384  5</div></pre></td></tr></table></figure>\n<p>如果能看到 tcp_tsunami 证明 BBR 魔改版已安装成功。</p>\n<h2 id=\"Debian-Ubuntu\"><a href=\"#Debian-Ubuntu\" class=\"headerlink\" title=\"Debian/Ubuntu\"></a>Debian/Ubuntu</h2><h3 id=\"1、开启-BBR\"><a href=\"#1、开启-BBR\" class=\"headerlink\" title=\"1、开启 BBR\"></a>1、开启 BBR</h3><p>执行下面脚本一键开启  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget --no-check-certificate -qO &apos;BBR.sh&apos; &apos;https://moeclub.org/attachment/LinuxShell/BBR.sh&apos; &amp;&amp; chmod a+x BBR.sh &amp;&amp; bash BBR.sh -f</div></pre></td></tr></table></figure>\n<h3 id=\"2、安装魔改版BBR\"><a href=\"#2、安装魔改版BBR\" class=\"headerlink\" title=\"2、安装魔改版BBR\"></a>2、安装魔改版BBR</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget --no-check-certificate -qO &apos;BBR_POWERED.sh&apos; &apos;https://moeclub.org/attachment/LinuxShell/BBR_POWERED.sh&apos; &amp;&amp; chmod a+x BBR_POWERED.sh &amp;&amp; bash BBR_POWERED.sh</div></pre></td></tr></table></figure>\n<p>完成之后执行下面的命令检查是否安装成功  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lsmod |grep &apos;bbr_powered&apos;</div></pre></td></tr></table></figure>\n<p>如果结果有 <code>bbr_powered</code> 则说明加载成功！</p>\n<h1 id=\"4、安装-SSR\"><a href=\"#4、安装-SSR\" class=\"headerlink\" title=\"4、安装 SSR\"></a>4、安装 SSR</h1><p>搬瓦工的后台控制面板（KiwiVM）已经提供了一键安装的功能，不过有些协议并不支持，如果想体验完整版的 SSR 的安装，还是自己动手吧！<br>还是通过一键式傻瓜脚本安装： </p>\n<p>先下载脚本   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</div></pre></td></tr></table></figure>\n<p>然后赋权、安装  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# chmod +x shadowsocksR.sh </div><div class=\"line\">[root@California_VPS ~]# ./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</div></pre></td></tr></table></figure>\n<p>执行完安装命令会看到这个：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#############################################################</div><div class=\"line\"># One click Install ShadowsocksR Server                     #</div><div class=\"line\"># Intro: https://shadowsocks.be/9.html                      #</div><div class=\"line\"># Author: Teddysun &lt;i@teddysun.com&gt;                         #</div><div class=\"line\"># Github: https://github.com/shadowsocksr/shadowsocksr      #</div><div class=\"line\">#############################################################</div><div class=\"line\"></div><div class=\"line\">Please enter password for ShadowsocksR:</div><div class=\"line\">...</div><div class=\"line\">Please enter a port for ShadowsocksR [1-65535]:</div><div class=\"line\">...</div><div class=\"line\">Please select stream cipher for ShadowsocksR:</div><div class=\"line\">...</div><div class=\"line\">Please select protocol for ShadowsocksR:</div><div class=\"line\">...</div><div class=\"line\">Please select obfs for ShadowsocksR:</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>需要你选择相应的参数，前两个比较好理解，一个是SSR的密码，一个是端口；后面三个就比较复杂了，关于加密方法和协议介绍请看<a href=\"https://github.com/gaoshilei/shadowsocks_install/blob/master/shadowsocksR-wiki/ShadowsocksR%20协议插件文档.md\" target=\"_blank\" rel=\"external\">wiki文档</a>  </p>\n<p>如果不想看文档，可以使用推荐参数配置<br>加密：<code>chacha20</code>和<code>aes-256-cfb8</code><br>协议：<code>auth_chain_a</code>和<code>auth_aes128_md5</code>和<code>auth_aes128_sha1</code><br>混淆：<code>plain</code>,<code>http_simple</code>,<code>http_post</code>,<code>tls1.2_ticket_auth</code>  </p>\n<p>卸载 SSR：<code>./shadowsocksR.sh uninstall</code></p>\n<p>SSR 一些常用的命令  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">启动：/etc/init.d/shadowsocks start</div><div class=\"line\">停止：/etc/init.d/shadowsocks stop</div><div class=\"line\">重启：/etc/init.d/shadowsocks restart</div><div class=\"line\">状态：/etc/init.d/shadowsocks status</div></pre></td></tr></table></figure>\n<p>日志路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">配置文件路径：/etc/shadowsocks.json</div><div class=\"line\">日志文件路径：/var/log/shadowsocksr.log</div><div class=\"line\">代码安装目录：/usr/local/shadowsocks</div></pre></td></tr></table></figure>\n<p>如果后面想修改 SSR 的一些配置可以直接修改 <code>shadowsocks.json</code> ，然后重启 SSR 即可。  </p>\n<p>最后配置 SSR 客户端就可以畅快的刷 YouTube 了，当然你也可以去 tumblr。【手动邪恶】<br><strong>奉上各个平台 SSR 的下载链接：</strong><br>MAC版下载地址：<a href=\"https://github.com/iMeiji/shadowsocks_install/releases/download/0.13/ShadowsocksX-NG.1.5.1.zip\" target=\"_blank\" rel=\"external\">ShadowsocksX-NG.1.5.1.zip</a><br>windows版下载地址：<a href=\"https://github.com/iMeiji/shadowsocks_install/releases/download/0.13/ssr-win.4.7.0-fix.7z\" target=\"_blank\" rel=\"external\">ssr-win.4.7.0-fix.7z</a><br>iOS版下载地址：<a href=\"https://itunes.apple.com/us/app/wingy-http-s-socks5-proxy-utility/id1178584911?mt=8\" target=\"_blank\" rel=\"external\">wingy</a>（中国区已下架，换个美国账号下载）<br>安卓版下载地址：<a href=\"https://github.com/iMeiji/shadowsocks_install/releases/download/0.13/ssr-android-3.4.0.5.apk\" target=\"_blank\" rel=\"external\">ssr-android-3.4.0.5.apk</a></p>\n<p>最后看看效果吧，YouTube 1080P 视频亲测截图  </p>\n<p><img src=\"http://oeat6c2zg.bkt.clouddn.com/QQ20171107-174706@2x.png\" alt=\"YouTube 1080P视频\"></p>\n<p>再来一张YouTube的下载速度：  </p>\n<p><img src=\"http://oeat6c2zg.bkt.clouddn.com/QQ20171107-175234@2x.png\" alt=\"YouTube视频下载速度\">  </p>\n<p>是不是感觉帮帮哒！</p>"},{"title":"VPS搭建高速SS服务器","date":"2016-05-19T16:00:00.000Z","_content":"\n##\t\t前言：(废话较多，不想看的略过直接看后面的教程)  \n*\t作为一名有着远大理想和抱负的codeMonkey，平时查资料必须Google，百度一下会真的死啊！不是黑百度，确实百度出来的资料内容看一下大致是相同的，搜到的内容就是copy+paste，花了很多时间结果找不到我们想要的东西，最最重要的是搜索结果有一半是广告，这个时候只能求助于Google，无奈天朝的GFW，一直追求自由明主的Google早在10年就被GCD轰出了墙外，所以VPN成了连接我们和整个世界的桥梁。\n<!-- more -->\n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)\n\n*\t现在市面上的VPN产品满天飞，有不少是开张几个月就卷款跑路，然后重新弄个网站换个名字继续骗钱，市面上常见的VPN还有一个很大的缺点就是速度不稳定，只能够全局加速（至少在Mac上是这样），访问国内网站都很卡，因为这些VPN都是共享一条线路，用户少速度会快一点，人一多就卡成了龟速。当然也有部分VPN推出了专线套餐，便宜的一个月也要100大洋左右，我等屌丝“何德何能”能消费得起这样的产品啊（鬼魅的微笑）。  \n*\t在用了几年这种VPN产品之后，我终于发现了一块新大陆，自己购买主机搭建SS服务器，不论是速度还是用户体验，不要太爽的好伐，关键是价格很亲民，最便宜的一年20刀，折合人民币才100多大洋。接下来就给大家分享我搭建SS的过程，搭建完成之后观看YouTube高清720P毫无压力（当然还要取决于运营商给你的带宽）。我购买的是VPS界享有“盛誉”的搬瓦工，价格亲民、速度快，有智能后台一键搭建VPN省去很多繁琐的命令行输入，大家可以在官网首页看到机型配置和价格，最便宜的2.99刀一个月，一年20刀。\n\n##\t教程  \n###\t一.\t购买VPS  \n> VPS有点像VirtualBox、Parallels创建出来的主机，可以理解成一台独立的主机。我们需要购买的就是这样一台独立的主机，不过一定要购买海外的，否则搭建了SS也无法访问海外的网站。  \n   \n因为我用的是搬瓦工，速度和稳定性感觉都不错，推荐给大家，还有其他的海外VPS提供商也都是可以的。\n**搬瓦工官网链接：[https://bandwagonhost.com](https://bandwagonhost.com/aff.php?aff=10505)**    \n这个链接貌似被墙了，如果访问不了的话请走大陆**镜像链接：[https://bwh1.net](https://bwh1.net/aff.php?aff=10505)**   \n\n进入之后要注册，之后就可以购买主机了，根据你自己的需求来选择。（*其实不同主机的带宽都是一样的，只不过在配置上有差别，如果不是搭建大型的网站对配置有要求，只是想有个专线VPN或翻墙工具的话，$19.99 或者 $39.99一年就足够用了。*）  \n\n> **我在购买主机的时候有一个小坑要提一下，~~搬瓦工的支付方式只支持PayPal，国内强大的支付宝居然不能支付！所以又去注册一个PayPal，~~坑来了：** \nPayPal分国内版和国际版，国内版是不支持美元支付的，而且两者的账户是不通的，所以你注册了国内版是无法支付的，国际版的地址是：[https://www.paypal.com](https://www.paypal.com/c2/webapps/mpp/home)，虽然是中文，但是货币是USD美元，绑定一张银联的卡就可以购物了。\n<img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNPayPal.png\" width=\"500\"/>   \n \n**这里做个修正：搬瓦工已经推出支付宝支付了，check out的时候选择alipay就可以了**\n\n###\t二.\t配置服务器  \n####\t1.\t进入控制面板，修改当前的root密码  \n进入账户之后我们可以在MyServices中看到服务器列表：\n![服务器列表](http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPN%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%97%E8%A1%A8.png)  \n进入KiwiVM管理后台，我们可以看到左侧有个菜单栏，点击Root Shell-interactive，此时会以H5的形式打开一个terminal窗口，执行`passwd`命令修改root密码  \n（*如果你不嫌系统分配的root密码不好记、每次ssh进主机都要复制粘贴密码，那么略过这步，***如果你忘记了root密码也可以直接通过这里修改，什么？！你忘记搬瓦工的账号密码无法进入后台面板？用你注册填写的邮箱或者手机号找回吧！**）\n![修改root密码](http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPN%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81.png)\n\n####\t2.\t安装一个你喜欢的Linux OS  \n左侧菜单栏找到Install New OS，选一个你喜欢的系统吧（*系统默认安装的是32位CentOS6，如果你不想换其他系统这步也可以略过，***需要注意每次安装系统，主机所有数据都会丢失**）  \n<img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPN%E5%AE%89%E8%A3%85%E6%96%B0%E7%B3%BB%E7%BB%9F.png\" width=\"500\"/>    \n这里推荐安装64位系统，后面装插件支持都好一点。\n####\t3.\t安装Shadowsocks Server  \n> 搬瓦工也提供了openVPN一键安装，个人感觉Shadowsocks更好用，有两种加速模式，访问会更快速。  \n  \n**2017.11.16更新：** \n现在搬瓦工的后台也可以一键安装 ShadowsocksR Server（SSR）了，操作流程基本一致。\n\n左侧菜单栏找到Shadowsocks Server，点进去安装就好了（**注意：搬瓦工提供的一键安装功能只支持CentOS6**，你也可以通过命令行的方式安装），安装好的Shadowsocks Server界面是这样的：  \n<img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNShadowsocks%20Server.png\" width=\"500\"/>  \n此时SS已经可以用了，不过还差一个客户端，Windows版本的客户端在后台面板就有链接，Mac用户请[点击这里下载](https://sourceforge.net/projects/shadowsocksgui/)如果无法访问，我已经下载好放到我的网盘了[ShadowsocksX-2.6.3.dmg](https://pan.baidu.com/s/1boXspQJ)，安装好打开Shadowsocks Server，在Mac的工具栏会有一个小飞机的图标  \n<img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNShadowsocks%20Server%E4%BD%BF%E7%94%A8%E7%95%8C%E9%9D%A2.png\" width=\"300\" height=\"400\" />  \n\n**2017.11.16更新：**  \n由于SS服务在部分地区受到运营商的流量干扰，出现网速慢甚至断网的现象，有类似情况的朋友请安装SSR，抗干扰效果更好。请参考我近期写的一篇文章[VPS+SSR+锐速（BBR魔改版）实现超级加速](https://gaoshilei.com/2017/11/06/SSR/)  \n你购买或者配置VPS过程中遇到什么问题，可以通过邮箱 goslei1315@gmail.com 联系我，工作日一般2个小时之内回复。询问之前请描述清楚你遇到的问题。\n\n>  2016.11.25更新：由于iPhone的Shadowsocks Server只在英国地区销售，国内的AppStore是下载不到的，大家可以在AppStore搜wingy，配置过程跟mac差不多，主要是IP、 Port和密码，加密协议都用默认的aes-256-cfb就行，然后手机也可以愉快的上网了。\n\n点开服务器，配置IP和密码，只需要修改地址和密码，其他不用改就OK了。\n<img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNShadowsocks%20Server%E8%AE%BE%E7%BD%AE.png\" width=\"500\" height=\"300\"/>  \n上两张图显示Shadowsocks Server有两种加速模式 ，**一般情况下勾选自动代理模式就可以了，这个这个模式下会自动判断你当前访问的域名是否在GFW名单里面，如果是就启用代理，如果不是就正常访问，这样我们在访问墙内网站的时候也不会受到任何影响** ，如果你遇到网站无法访问，有可能是这个网站近期被墙了，你没有更新本地的GFW名单，如果你确定这个网站是可以打开的，切换到全局模式就可以访问了 \n> Shadowsocks Server自动代理模式原理是根据GFWList配置了一个PAC文件，名单中的域名全部走代理，你可以手动修改这个配置文件，添加你要访问的被墙的网站，它就是一个js文件，你点击编辑自动模式的PAC文件便会跳转到这个js所在的位置，那个GFWList自动更新功能坏掉了，作者一直也没更新，不过不影响平时使用。  \n  \n**2017.11.16更新：**\n**请注意：下面的内容已经过时，更稳定更便捷更快速的翻墙姿势请查看我近期写的一篇文章。**  \n传送门：[VPS+SSR+锐速（BBR魔改版）实现超级加速](https://gaoshilei.com/2017/11/06/SSR/)\n\n###\t三.\t加速SS（很重要！很重要！很重要！）\n完成上面的步骤，你确实是可以访问墙外网站了，但是下载速度一般只有100多KB，YouTube视频240P都感觉不流畅，此时就要用到Net-Speeder给VPN加速了，具体步骤请看：  \n#####\t1.\t先连上远程主机\n`ssh -l root -p 12830 192.243.112.242`  \n把端口和IP换成你自己主机的，然后需要输入root密码，输入在第一步我们设置的密码就可以了。  \n#####\t2.\t安装Net-Speeder  \n输入下面的命令进行安装：  \n`wget https://coding.net/u/njzhenghao/p/download/git/raw/master/net_speeder-installer.sh`\n这里我用的是别人git上的sh脚本，有现成的为何不用呢，是吧？！\n#####\t3.\t编译并安装  \n输入下面的命令编译Net-Speeder：  \n`bash net_speeder-installer.sh`   \n命令执行成功之后，执行reboot重启主机，或者在后台面板重启主机也行。（**此时远程主机的连接会断开，需要重新连接**） \n#####\t4.\t端口加速  \n最后一步，加速端口：  \n`nohup /usr/local/net_speeder/net_speeder venet0 \"ip\" >/dev/null 2>&1 &`  \n执行完这个命令应该会有一个端口号打印出来，证明加速成功了！别着急还有最后一步，点开Shadowsocks Server菜单点击退出，*不要点退出Shadowsocks Server*，然后再次打开App，现在打开YouTube看个视频试试吧！现在墙外网站下载速度一般都在500KB左右，当然这个速度也受到你所在运营商的网络环境影响。（**注意：加速端口这个命令每次重启主机都需要执行一次，因为这个脚本没有加到开机自启动，反正我们没事也不重启主机，我懒得弄了，大家自己Google吧，哈哈！**）  \n\n**2016.11.25更新**  \n\n有些网友反应速度有时候很慢，我今天也遇到了这种情况，解决方案如下：  \n先通过命令连上VPS  \n\n```\nssh -l root -p port IP\n```\n\n然后重启主机  \n\n```\nreboot\n```\n\n此时连接断开，不用管，去看一下此时的SS是否正常使用，确定可以访问之后，再连上VPS开启端口加速  \n\n```\nnohup /usr/local/net_speeder/net_speeder venet0 \"ip\" >/dev/null 2>&1 &\n```  \n\n这种情况应该是主机的SS服务挂掉了，这种情况很少遇到，我使用了这么久今天第一次遇到，这么操作之后SS又恢复到原来丝滑般的享受 。\n","source":"_posts/VPS搭建高速SS服务器.md","raw":"---\ntitle: VPS搭建高速SS服务器\ndate: 2016-05-20\ncategories:\n- 实用工具\ntags:\n- VPS\n- VPN\n- Shadowsocks\npermalink: VPS\n\n---\n\n##\t\t前言：(废话较多，不想看的略过直接看后面的教程)  \n*\t作为一名有着远大理想和抱负的codeMonkey，平时查资料必须Google，百度一下会真的死啊！不是黑百度，确实百度出来的资料内容看一下大致是相同的，搜到的内容就是copy+paste，花了很多时间结果找不到我们想要的东西，最最重要的是搜索结果有一半是广告，这个时候只能求助于Google，无奈天朝的GFW，一直追求自由明主的Google早在10年就被GCD轰出了墙外，所以VPN成了连接我们和整个世界的桥梁。\n<!-- more -->\n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)\n\n*\t现在市面上的VPN产品满天飞，有不少是开张几个月就卷款跑路，然后重新弄个网站换个名字继续骗钱，市面上常见的VPN还有一个很大的缺点就是速度不稳定，只能够全局加速（至少在Mac上是这样），访问国内网站都很卡，因为这些VPN都是共享一条线路，用户少速度会快一点，人一多就卡成了龟速。当然也有部分VPN推出了专线套餐，便宜的一个月也要100大洋左右，我等屌丝“何德何能”能消费得起这样的产品啊（鬼魅的微笑）。  \n*\t在用了几年这种VPN产品之后，我终于发现了一块新大陆，自己购买主机搭建SS服务器，不论是速度还是用户体验，不要太爽的好伐，关键是价格很亲民，最便宜的一年20刀，折合人民币才100多大洋。接下来就给大家分享我搭建SS的过程，搭建完成之后观看YouTube高清720P毫无压力（当然还要取决于运营商给你的带宽）。我购买的是VPS界享有“盛誉”的搬瓦工，价格亲民、速度快，有智能后台一键搭建VPN省去很多繁琐的命令行输入，大家可以在官网首页看到机型配置和价格，最便宜的2.99刀一个月，一年20刀。\n\n##\t教程  \n###\t一.\t购买VPS  \n> VPS有点像VirtualBox、Parallels创建出来的主机，可以理解成一台独立的主机。我们需要购买的就是这样一台独立的主机，不过一定要购买海外的，否则搭建了SS也无法访问海外的网站。  \n   \n因为我用的是搬瓦工，速度和稳定性感觉都不错，推荐给大家，还有其他的海外VPS提供商也都是可以的。\n**搬瓦工官网链接：[https://bandwagonhost.com](https://bandwagonhost.com/aff.php?aff=10505)**    \n这个链接貌似被墙了，如果访问不了的话请走大陆**镜像链接：[https://bwh1.net](https://bwh1.net/aff.php?aff=10505)**   \n\n进入之后要注册，之后就可以购买主机了，根据你自己的需求来选择。（*其实不同主机的带宽都是一样的，只不过在配置上有差别，如果不是搭建大型的网站对配置有要求，只是想有个专线VPN或翻墙工具的话，$19.99 或者 $39.99一年就足够用了。*）  \n\n> **我在购买主机的时候有一个小坑要提一下，~~搬瓦工的支付方式只支持PayPal，国内强大的支付宝居然不能支付！所以又去注册一个PayPal，~~坑来了：** \nPayPal分国内版和国际版，国内版是不支持美元支付的，而且两者的账户是不通的，所以你注册了国内版是无法支付的，国际版的地址是：[https://www.paypal.com](https://www.paypal.com/c2/webapps/mpp/home)，虽然是中文，但是货币是USD美元，绑定一张银联的卡就可以购物了。\n<img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNPayPal.png\" width=\"500\"/>   \n \n**这里做个修正：搬瓦工已经推出支付宝支付了，check out的时候选择alipay就可以了**\n\n###\t二.\t配置服务器  \n####\t1.\t进入控制面板，修改当前的root密码  \n进入账户之后我们可以在MyServices中看到服务器列表：\n![服务器列表](http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPN%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%97%E8%A1%A8.png)  \n进入KiwiVM管理后台，我们可以看到左侧有个菜单栏，点击Root Shell-interactive，此时会以H5的形式打开一个terminal窗口，执行`passwd`命令修改root密码  \n（*如果你不嫌系统分配的root密码不好记、每次ssh进主机都要复制粘贴密码，那么略过这步，***如果你忘记了root密码也可以直接通过这里修改，什么？！你忘记搬瓦工的账号密码无法进入后台面板？用你注册填写的邮箱或者手机号找回吧！**）\n![修改root密码](http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPN%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81.png)\n\n####\t2.\t安装一个你喜欢的Linux OS  \n左侧菜单栏找到Install New OS，选一个你喜欢的系统吧（*系统默认安装的是32位CentOS6，如果你不想换其他系统这步也可以略过，***需要注意每次安装系统，主机所有数据都会丢失**）  \n<img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPN%E5%AE%89%E8%A3%85%E6%96%B0%E7%B3%BB%E7%BB%9F.png\" width=\"500\"/>    \n这里推荐安装64位系统，后面装插件支持都好一点。\n####\t3.\t安装Shadowsocks Server  \n> 搬瓦工也提供了openVPN一键安装，个人感觉Shadowsocks更好用，有两种加速模式，访问会更快速。  \n  \n**2017.11.16更新：** \n现在搬瓦工的后台也可以一键安装 ShadowsocksR Server（SSR）了，操作流程基本一致。\n\n左侧菜单栏找到Shadowsocks Server，点进去安装就好了（**注意：搬瓦工提供的一键安装功能只支持CentOS6**，你也可以通过命令行的方式安装），安装好的Shadowsocks Server界面是这样的：  \n<img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNShadowsocks%20Server.png\" width=\"500\"/>  \n此时SS已经可以用了，不过还差一个客户端，Windows版本的客户端在后台面板就有链接，Mac用户请[点击这里下载](https://sourceforge.net/projects/shadowsocksgui/)如果无法访问，我已经下载好放到我的网盘了[ShadowsocksX-2.6.3.dmg](https://pan.baidu.com/s/1boXspQJ)，安装好打开Shadowsocks Server，在Mac的工具栏会有一个小飞机的图标  \n<img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNShadowsocks%20Server%E4%BD%BF%E7%94%A8%E7%95%8C%E9%9D%A2.png\" width=\"300\" height=\"400\" />  \n\n**2017.11.16更新：**  \n由于SS服务在部分地区受到运营商的流量干扰，出现网速慢甚至断网的现象，有类似情况的朋友请安装SSR，抗干扰效果更好。请参考我近期写的一篇文章[VPS+SSR+锐速（BBR魔改版）实现超级加速](https://gaoshilei.com/2017/11/06/SSR/)  \n你购买或者配置VPS过程中遇到什么问题，可以通过邮箱 goslei1315@gmail.com 联系我，工作日一般2个小时之内回复。询问之前请描述清楚你遇到的问题。\n\n>  2016.11.25更新：由于iPhone的Shadowsocks Server只在英国地区销售，国内的AppStore是下载不到的，大家可以在AppStore搜wingy，配置过程跟mac差不多，主要是IP、 Port和密码，加密协议都用默认的aes-256-cfb就行，然后手机也可以愉快的上网了。\n\n点开服务器，配置IP和密码，只需要修改地址和密码，其他不用改就OK了。\n<img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNShadowsocks%20Server%E8%AE%BE%E7%BD%AE.png\" width=\"500\" height=\"300\"/>  \n上两张图显示Shadowsocks Server有两种加速模式 ，**一般情况下勾选自动代理模式就可以了，这个这个模式下会自动判断你当前访问的域名是否在GFW名单里面，如果是就启用代理，如果不是就正常访问，这样我们在访问墙内网站的时候也不会受到任何影响** ，如果你遇到网站无法访问，有可能是这个网站近期被墙了，你没有更新本地的GFW名单，如果你确定这个网站是可以打开的，切换到全局模式就可以访问了 \n> Shadowsocks Server自动代理模式原理是根据GFWList配置了一个PAC文件，名单中的域名全部走代理，你可以手动修改这个配置文件，添加你要访问的被墙的网站，它就是一个js文件，你点击编辑自动模式的PAC文件便会跳转到这个js所在的位置，那个GFWList自动更新功能坏掉了，作者一直也没更新，不过不影响平时使用。  \n  \n**2017.11.16更新：**\n**请注意：下面的内容已经过时，更稳定更便捷更快速的翻墙姿势请查看我近期写的一篇文章。**  \n传送门：[VPS+SSR+锐速（BBR魔改版）实现超级加速](https://gaoshilei.com/2017/11/06/SSR/)\n\n###\t三.\t加速SS（很重要！很重要！很重要！）\n完成上面的步骤，你确实是可以访问墙外网站了，但是下载速度一般只有100多KB，YouTube视频240P都感觉不流畅，此时就要用到Net-Speeder给VPN加速了，具体步骤请看：  \n#####\t1.\t先连上远程主机\n`ssh -l root -p 12830 192.243.112.242`  \n把端口和IP换成你自己主机的，然后需要输入root密码，输入在第一步我们设置的密码就可以了。  \n#####\t2.\t安装Net-Speeder  \n输入下面的命令进行安装：  \n`wget https://coding.net/u/njzhenghao/p/download/git/raw/master/net_speeder-installer.sh`\n这里我用的是别人git上的sh脚本，有现成的为何不用呢，是吧？！\n#####\t3.\t编译并安装  \n输入下面的命令编译Net-Speeder：  \n`bash net_speeder-installer.sh`   \n命令执行成功之后，执行reboot重启主机，或者在后台面板重启主机也行。（**此时远程主机的连接会断开，需要重新连接**） \n#####\t4.\t端口加速  \n最后一步，加速端口：  \n`nohup /usr/local/net_speeder/net_speeder venet0 \"ip\" >/dev/null 2>&1 &`  \n执行完这个命令应该会有一个端口号打印出来，证明加速成功了！别着急还有最后一步，点开Shadowsocks Server菜单点击退出，*不要点退出Shadowsocks Server*，然后再次打开App，现在打开YouTube看个视频试试吧！现在墙外网站下载速度一般都在500KB左右，当然这个速度也受到你所在运营商的网络环境影响。（**注意：加速端口这个命令每次重启主机都需要执行一次，因为这个脚本没有加到开机自启动，反正我们没事也不重启主机，我懒得弄了，大家自己Google吧，哈哈！**）  \n\n**2016.11.25更新**  \n\n有些网友反应速度有时候很慢，我今天也遇到了这种情况，解决方案如下：  \n先通过命令连上VPS  \n\n```\nssh -l root -p port IP\n```\n\n然后重启主机  \n\n```\nreboot\n```\n\n此时连接断开，不用管，去看一下此时的SS是否正常使用，确定可以访问之后，再连上VPS开启端口加速  \n\n```\nnohup /usr/local/net_speeder/net_speeder venet0 \"ip\" >/dev/null 2>&1 &\n```  \n\n这种情况应该是主机的SS服务挂掉了，这种情况很少遇到，我使用了这么久今天第一次遇到，这么操作之后SS又恢复到原来丝滑般的享受 。\n","slug":"VPS","published":1,"updated":"2017-11-20T09:40:55.440Z","_id":"cja3m8za00001qeen0adv2zqb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言：-废话较多，不想看的略过直接看后面的教程\"><a href=\"#前言：-废话较多，不想看的略过直接看后面的教程\" class=\"headerlink\" title=\"前言：(废话较多，不想看的略过直接看后面的教程)\"></a>前言：(废话较多，不想看的略过直接看后面的教程)</h2><ul>\n<li>作为一名有着远大理想和抱负的codeMonkey，平时查资料必须Google，百度一下会真的死啊！不是黑百度，确实百度出来的资料内容看一下大致是相同的，搜到的内容就是copy+paste，花了很多时间结果找不到我们想要的东西，最最重要的是搜索结果有一半是广告，这个时候只能求助于Google，无奈天朝的GFW，一直追求自由明主的Google早在10年就被GCD轰出了墙外，所以VPN成了连接我们和整个世界的桥梁。<a id=\"more\"></a>\n</li>\n</ul>\n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a></p>\n<ul>\n<li>现在市面上的VPN产品满天飞，有不少是开张几个月就卷款跑路，然后重新弄个网站换个名字继续骗钱，市面上常见的VPN还有一个很大的缺点就是速度不稳定，只能够全局加速（至少在Mac上是这样），访问国内网站都很卡，因为这些VPN都是共享一条线路，用户少速度会快一点，人一多就卡成了龟速。当然也有部分VPN推出了专线套餐，便宜的一个月也要100大洋左右，我等屌丝“何德何能”能消费得起这样的产品啊（鬼魅的微笑）。  </li>\n<li>在用了几年这种VPN产品之后，我终于发现了一块新大陆，自己购买主机搭建SS服务器，不论是速度还是用户体验，不要太爽的好伐，关键是价格很亲民，最便宜的一年20刀，折合人民币才100多大洋。接下来就给大家分享我搭建SS的过程，搭建完成之后观看YouTube高清720P毫无压力（当然还要取决于运营商给你的带宽）。我购买的是VPS界享有“盛誉”的搬瓦工，价格亲民、速度快，有智能后台一键搭建VPN省去很多繁琐的命令行输入，大家可以在官网首页看到机型配置和价格，最便宜的2.99刀一个月，一年20刀。</li>\n</ul>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><h3 id=\"一-购买VPS\"><a href=\"#一-购买VPS\" class=\"headerlink\" title=\"一.    购买VPS\"></a>一.    购买VPS</h3><blockquote>\n<p>VPS有点像VirtualBox、Parallels创建出来的主机，可以理解成一台独立的主机。我们需要购买的就是这样一台独立的主机，不过一定要购买海外的，否则搭建了SS也无法访问海外的网站。  </p>\n</blockquote>\n<p>因为我用的是搬瓦工，速度和稳定性感觉都不错，推荐给大家，还有其他的海外VPS提供商也都是可以的。<br><strong>搬瓦工官网链接：<a href=\"https://bandwagonhost.com/aff.php?aff=10505\" target=\"_blank\" rel=\"external\">https://bandwagonhost.com</a></strong><br>这个链接貌似被墙了，如果访问不了的话请走大陆<strong>镜像链接：<a href=\"https://bwh1.net/aff.php?aff=10505\" target=\"_blank\" rel=\"external\">https://bwh1.net</a></strong>   </p>\n<p>进入之后要注册，之后就可以购买主机了，根据你自己的需求来选择。（<em>其实不同主机的带宽都是一样的，只不过在配置上有差别，如果不是搭建大型的网站对配置有要求，只是想有个专线VPN或翻墙工具的话，$19.99 或者 $39.99一年就足够用了。</em>）  </p>\n<blockquote>\n<p><strong>我在购买主机的时候有一个小坑要提一下，<del>搬瓦工的支付方式只支持PayPal，国内强大的支付宝居然不能支付！所以又去注册一个PayPal，</del>坑来了：</strong><br>PayPal分国内版和国际版，国内版是不支持美元支付的，而且两者的账户是不通的，所以你注册了国内版是无法支付的，国际版的地址是：<a href=\"https://www.paypal.com/c2/webapps/mpp/home\" target=\"_blank\" rel=\"external\">https://www.paypal.com</a>，虽然是中文，但是货币是USD美元，绑定一张银联的卡就可以购物了。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNPayPal.png\" width=\"500\">   </p>\n</blockquote>\n<p><strong>这里做个修正：搬瓦工已经推出支付宝支付了，check out的时候选择alipay就可以了</strong></p>\n<h3 id=\"二-配置服务器\"><a href=\"#二-配置服务器\" class=\"headerlink\" title=\"二.    配置服务器\"></a>二.    配置服务器</h3><h4 id=\"1-进入控制面板，修改当前的root密码\"><a href=\"#1-进入控制面板，修改当前的root密码\" class=\"headerlink\" title=\"1.    进入控制面板，修改当前的root密码\"></a>1.    进入控制面板，修改当前的root密码</h4><p>进入账户之后我们可以在MyServices中看到服务器列表：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPN%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%97%E8%A1%A8.png\" alt=\"服务器列表\"><br>进入KiwiVM管理后台，我们可以看到左侧有个菜单栏，点击Root Shell-interactive，此时会以H5的形式打开一个terminal窗口，执行<code>passwd</code>命令修改root密码<br>（<em>如果你不嫌系统分配的root密码不好记、每次ssh进主机都要复制粘贴密码，那么略过这步，**</em>如果你忘记了root密码也可以直接通过这里修改，什么？！你忘记搬瓦工的账号密码无法进入后台面板？用你注册填写的邮箱或者手机号找回吧！**）<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPN%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81.png\" alt=\"修改root密码\"></p>\n<h4 id=\"2-安装一个你喜欢的Linux-OS\"><a href=\"#2-安装一个你喜欢的Linux-OS\" class=\"headerlink\" title=\"2.    安装一个你喜欢的Linux OS\"></a>2.    安装一个你喜欢的Linux OS</h4><p>左侧菜单栏找到Install New OS，选一个你喜欢的系统吧（<em>系统默认安装的是32位CentOS6，如果你不想换其他系统这步也可以略过，**</em>需要注意每次安装系统，主机所有数据都会丢失**）<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPN%E5%AE%89%E8%A3%85%E6%96%B0%E7%B3%BB%E7%BB%9F.png\" width=\"500\"><br>这里推荐安装64位系统，后面装插件支持都好一点。</p>\n<h4 id=\"3-安装Shadowsocks-Server\"><a href=\"#3-安装Shadowsocks-Server\" class=\"headerlink\" title=\"3.    安装Shadowsocks Server\"></a>3.    安装Shadowsocks Server</h4><blockquote>\n<p>搬瓦工也提供了openVPN一键安装，个人感觉Shadowsocks更好用，有两种加速模式，访问会更快速。  </p>\n</blockquote>\n<p><strong>2017.11.16更新：</strong><br>现在搬瓦工的后台也可以一键安装 ShadowsocksR Server（SSR）了，操作流程基本一致。</p>\n<p>左侧菜单栏找到Shadowsocks Server，点进去安装就好了（<strong>注意：搬瓦工提供的一键安装功能只支持CentOS6</strong>，你也可以通过命令行的方式安装），安装好的Shadowsocks Server界面是这样的：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNShadowsocks%20Server.png\" width=\"500\"><br>此时SS已经可以用了，不过还差一个客户端，Windows版本的客户端在后台面板就有链接，Mac用户请<a href=\"https://sourceforge.net/projects/shadowsocksgui/\" target=\"_blank\" rel=\"external\">点击这里下载</a>如果无法访问，我已经下载好放到我的网盘了<a href=\"https://pan.baidu.com/s/1boXspQJ\" target=\"_blank\" rel=\"external\">ShadowsocksX-2.6.3.dmg</a>，安装好打开Shadowsocks Server，在Mac的工具栏会有一个小飞机的图标<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNShadowsocks%20Server%E4%BD%BF%E7%94%A8%E7%95%8C%E9%9D%A2.png\" width=\"300\" height=\"400\">  </p>\n<p><strong>2017.11.16更新：</strong><br>由于SS服务在部分地区受到运营商的流量干扰，出现网速慢甚至断网的现象，有类似情况的朋友请安装SSR，抗干扰效果更好。请参考我近期写的一篇文章<a href=\"https://gaoshilei.com/2017/11/06/SSR/\" target=\"_blank\" rel=\"external\">VPS+SSR+锐速（BBR魔改版）实现超级加速</a><br>你购买或者配置VPS过程中遇到什么问题，可以通过邮箱 goslei1315@gmail.com 联系我，工作日一般2个小时之内回复。询问之前请描述清楚你遇到的问题。</p>\n<blockquote>\n<p> 2016.11.25更新：由于iPhone的Shadowsocks Server只在英国地区销售，国内的AppStore是下载不到的，大家可以在AppStore搜wingy，配置过程跟mac差不多，主要是IP、 Port和密码，加密协议都用默认的aes-256-cfb就行，然后手机也可以愉快的上网了。</p>\n</blockquote>\n<p>点开服务器，配置IP和密码，只需要修改地址和密码，其他不用改就OK了。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNShadowsocks%20Server%E8%AE%BE%E7%BD%AE.png\" width=\"500\" height=\"300\"><br>上两张图显示Shadowsocks Server有两种加速模式 ，<strong>一般情况下勾选自动代理模式就可以了，这个这个模式下会自动判断你当前访问的域名是否在GFW名单里面，如果是就启用代理，如果不是就正常访问，这样我们在访问墙内网站的时候也不会受到任何影响</strong> ，如果你遇到网站无法访问，有可能是这个网站近期被墙了，你没有更新本地的GFW名单，如果你确定这个网站是可以打开的，切换到全局模式就可以访问了 </p>\n<blockquote>\n<p>Shadowsocks Server自动代理模式原理是根据GFWList配置了一个PAC文件，名单中的域名全部走代理，你可以手动修改这个配置文件，添加你要访问的被墙的网站，它就是一个js文件，你点击编辑自动模式的PAC文件便会跳转到这个js所在的位置，那个GFWList自动更新功能坏掉了，作者一直也没更新，不过不影响平时使用。  </p>\n</blockquote>\n<p><strong>2017.11.16更新：</strong><br><strong>请注意：下面的内容已经过时，更稳定更便捷更快速的翻墙姿势请查看我近期写的一篇文章。</strong><br>传送门：<a href=\"https://gaoshilei.com/2017/11/06/SSR/\" target=\"_blank\" rel=\"external\">VPS+SSR+锐速（BBR魔改版）实现超级加速</a></p>\n<h3 id=\"三-加速SS（很重要！很重要！很重要！）\"><a href=\"#三-加速SS（很重要！很重要！很重要！）\" class=\"headerlink\" title=\"三.    加速SS（很重要！很重要！很重要！）\"></a>三.    加速SS（很重要！很重要！很重要！）</h3><p>完成上面的步骤，你确实是可以访问墙外网站了，但是下载速度一般只有100多KB，YouTube视频240P都感觉不流畅，此时就要用到Net-Speeder给VPN加速了，具体步骤请看：  </p>\n<h5 id=\"1-先连上远程主机\"><a href=\"#1-先连上远程主机\" class=\"headerlink\" title=\"1.    先连上远程主机\"></a>1.    先连上远程主机</h5><p><code>ssh -l root -p 12830 192.243.112.242</code><br>把端口和IP换成你自己主机的，然后需要输入root密码，输入在第一步我们设置的密码就可以了。  </p>\n<h5 id=\"2-安装Net-Speeder\"><a href=\"#2-安装Net-Speeder\" class=\"headerlink\" title=\"2.    安装Net-Speeder\"></a>2.    安装Net-Speeder</h5><p>输入下面的命令进行安装：<br><code>wget https://coding.net/u/njzhenghao/p/download/git/raw/master/net_speeder-installer.sh</code><br>这里我用的是别人git上的sh脚本，有现成的为何不用呢，是吧？！</p>\n<h5 id=\"3-编译并安装\"><a href=\"#3-编译并安装\" class=\"headerlink\" title=\"3.    编译并安装\"></a>3.    编译并安装</h5><p>输入下面的命令编译Net-Speeder：<br><code>bash net_speeder-installer.sh</code><br>命令执行成功之后，执行reboot重启主机，或者在后台面板重启主机也行。（<strong>此时远程主机的连接会断开，需要重新连接</strong>） </p>\n<h5 id=\"4-端口加速\"><a href=\"#4-端口加速\" class=\"headerlink\" title=\"4.    端口加速\"></a>4.    端口加速</h5><p>最后一步，加速端口：<br><code>nohup /usr/local/net_speeder/net_speeder venet0 &quot;ip&quot; &gt;/dev/null 2&gt;&amp;1 &amp;</code><br>执行完这个命令应该会有一个端口号打印出来，证明加速成功了！别着急还有最后一步，点开Shadowsocks Server菜单点击退出，<em>不要点退出Shadowsocks Server</em>，然后再次打开App，现在打开YouTube看个视频试试吧！现在墙外网站下载速度一般都在500KB左右，当然这个速度也受到你所在运营商的网络环境影响。（<strong>注意：加速端口这个命令每次重启主机都需要执行一次，因为这个脚本没有加到开机自启动，反正我们没事也不重启主机，我懒得弄了，大家自己Google吧，哈哈！</strong>）  </p>\n<p><strong>2016.11.25更新</strong>  </p>\n<p>有些网友反应速度有时候很慢，我今天也遇到了这种情况，解决方案如下：<br>先通过命令连上VPS  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh -l root -p port IP</div></pre></td></tr></table></figure>\n<p>然后重启主机  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reboot</div></pre></td></tr></table></figure>\n<p>此时连接断开，不用管，去看一下此时的SS是否正常使用，确定可以访问之后，再连上VPS开启端口加速  </p>\n<pre><code>nohup /usr/local/net_speeder/net_speeder venet0 &quot;ip&quot; &gt;/dev/null 2&gt;&amp;1 &amp;\n</code></pre><p>这种情况应该是主机的SS服务挂掉了，这种情况很少遇到，我使用了这么久今天第一次遇到，这么操作之后SS又恢复到原来丝滑般的享受 。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言：-废话较多，不想看的略过直接看后面的教程\"><a href=\"#前言：-废话较多，不想看的略过直接看后面的教程\" class=\"headerlink\" title=\"前言：(废话较多，不想看的略过直接看后面的教程)\"></a>前言：(废话较多，不想看的略过直接看后面的教程)</h2><ul>\n<li>作为一名有着远大理想和抱负的codeMonkey，平时查资料必须Google，百度一下会真的死啊！不是黑百度，确实百度出来的资料内容看一下大致是相同的，搜到的内容就是copy+paste，花了很多时间结果找不到我们想要的东西，最最重要的是搜索结果有一半是广告，这个时候只能求助于Google，无奈天朝的GFW，一直追求自由明主的Google早在10年就被GCD轰出了墙外，所以VPN成了连接我们和整个世界的桥梁。","more":"</li>\n</ul>\n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a></p>\n<ul>\n<li>现在市面上的VPN产品满天飞，有不少是开张几个月就卷款跑路，然后重新弄个网站换个名字继续骗钱，市面上常见的VPN还有一个很大的缺点就是速度不稳定，只能够全局加速（至少在Mac上是这样），访问国内网站都很卡，因为这些VPN都是共享一条线路，用户少速度会快一点，人一多就卡成了龟速。当然也有部分VPN推出了专线套餐，便宜的一个月也要100大洋左右，我等屌丝“何德何能”能消费得起这样的产品啊（鬼魅的微笑）。  </li>\n<li>在用了几年这种VPN产品之后，我终于发现了一块新大陆，自己购买主机搭建SS服务器，不论是速度还是用户体验，不要太爽的好伐，关键是价格很亲民，最便宜的一年20刀，折合人民币才100多大洋。接下来就给大家分享我搭建SS的过程，搭建完成之后观看YouTube高清720P毫无压力（当然还要取决于运营商给你的带宽）。我购买的是VPS界享有“盛誉”的搬瓦工，价格亲民、速度快，有智能后台一键搭建VPN省去很多繁琐的命令行输入，大家可以在官网首页看到机型配置和价格，最便宜的2.99刀一个月，一年20刀。</li>\n</ul>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><h3 id=\"一-购买VPS\"><a href=\"#一-购买VPS\" class=\"headerlink\" title=\"一.    购买VPS\"></a>一.    购买VPS</h3><blockquote>\n<p>VPS有点像VirtualBox、Parallels创建出来的主机，可以理解成一台独立的主机。我们需要购买的就是这样一台独立的主机，不过一定要购买海外的，否则搭建了SS也无法访问海外的网站。  </p>\n</blockquote>\n<p>因为我用的是搬瓦工，速度和稳定性感觉都不错，推荐给大家，还有其他的海外VPS提供商也都是可以的。<br><strong>搬瓦工官网链接：<a href=\"https://bandwagonhost.com/aff.php?aff=10505\" target=\"_blank\" rel=\"external\">https://bandwagonhost.com</a></strong><br>这个链接貌似被墙了，如果访问不了的话请走大陆<strong>镜像链接：<a href=\"https://bwh1.net/aff.php?aff=10505\" target=\"_blank\" rel=\"external\">https://bwh1.net</a></strong>   </p>\n<p>进入之后要注册，之后就可以购买主机了，根据你自己的需求来选择。（<em>其实不同主机的带宽都是一样的，只不过在配置上有差别，如果不是搭建大型的网站对配置有要求，只是想有个专线VPN或翻墙工具的话，$19.99 或者 $39.99一年就足够用了。</em>）  </p>\n<blockquote>\n<p><strong>我在购买主机的时候有一个小坑要提一下，<del>搬瓦工的支付方式只支持PayPal，国内强大的支付宝居然不能支付！所以又去注册一个PayPal，</del>坑来了：</strong><br>PayPal分国内版和国际版，国内版是不支持美元支付的，而且两者的账户是不通的，所以你注册了国内版是无法支付的，国际版的地址是：<a href=\"https://www.paypal.com/c2/webapps/mpp/home\" target=\"_blank\" rel=\"external\">https://www.paypal.com</a>，虽然是中文，但是货币是USD美元，绑定一张银联的卡就可以购物了。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNPayPal.png\" width=\"500\">   </p>\n</blockquote>\n<p><strong>这里做个修正：搬瓦工已经推出支付宝支付了，check out的时候选择alipay就可以了</strong></p>\n<h3 id=\"二-配置服务器\"><a href=\"#二-配置服务器\" class=\"headerlink\" title=\"二.    配置服务器\"></a>二.    配置服务器</h3><h4 id=\"1-进入控制面板，修改当前的root密码\"><a href=\"#1-进入控制面板，修改当前的root密码\" class=\"headerlink\" title=\"1.    进入控制面板，修改当前的root密码\"></a>1.    进入控制面板，修改当前的root密码</h4><p>进入账户之后我们可以在MyServices中看到服务器列表：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPN%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%97%E8%A1%A8.png\" alt=\"服务器列表\"><br>进入KiwiVM管理后台，我们可以看到左侧有个菜单栏，点击Root Shell-interactive，此时会以H5的形式打开一个terminal窗口，执行<code>passwd</code>命令修改root密码<br>（<em>如果你不嫌系统分配的root密码不好记、每次ssh进主机都要复制粘贴密码，那么略过这步，**</em>如果你忘记了root密码也可以直接通过这里修改，什么？！你忘记搬瓦工的账号密码无法进入后台面板？用你注册填写的邮箱或者手机号找回吧！**）<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPN%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81.png\" alt=\"修改root密码\"></p>\n<h4 id=\"2-安装一个你喜欢的Linux-OS\"><a href=\"#2-安装一个你喜欢的Linux-OS\" class=\"headerlink\" title=\"2.    安装一个你喜欢的Linux OS\"></a>2.    安装一个你喜欢的Linux OS</h4><p>左侧菜单栏找到Install New OS，选一个你喜欢的系统吧（<em>系统默认安装的是32位CentOS6，如果你不想换其他系统这步也可以略过，**</em>需要注意每次安装系统，主机所有数据都会丢失**）<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPN%E5%AE%89%E8%A3%85%E6%96%B0%E7%B3%BB%E7%BB%9F.png\" width=\"500\"><br>这里推荐安装64位系统，后面装插件支持都好一点。</p>\n<h4 id=\"3-安装Shadowsocks-Server\"><a href=\"#3-安装Shadowsocks-Server\" class=\"headerlink\" title=\"3.    安装Shadowsocks Server\"></a>3.    安装Shadowsocks Server</h4><blockquote>\n<p>搬瓦工也提供了openVPN一键安装，个人感觉Shadowsocks更好用，有两种加速模式，访问会更快速。  </p>\n</blockquote>\n<p><strong>2017.11.16更新：</strong><br>现在搬瓦工的后台也可以一键安装 ShadowsocksR Server（SSR）了，操作流程基本一致。</p>\n<p>左侧菜单栏找到Shadowsocks Server，点进去安装就好了（<strong>注意：搬瓦工提供的一键安装功能只支持CentOS6</strong>，你也可以通过命令行的方式安装），安装好的Shadowsocks Server界面是这样的：<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNShadowsocks%20Server.png\" width=\"500\"><br>此时SS已经可以用了，不过还差一个客户端，Windows版本的客户端在后台面板就有链接，Mac用户请<a href=\"https://sourceforge.net/projects/shadowsocksgui/\" target=\"_blank\" rel=\"external\">点击这里下载</a>如果无法访问，我已经下载好放到我的网盘了<a href=\"https://pan.baidu.com/s/1boXspQJ\" target=\"_blank\" rel=\"external\">ShadowsocksX-2.6.3.dmg</a>，安装好打开Shadowsocks Server，在Mac的工具栏会有一个小飞机的图标<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNShadowsocks%20Server%E4%BD%BF%E7%94%A8%E7%95%8C%E9%9D%A2.png\" width=\"300\" height=\"400\">  </p>\n<p><strong>2017.11.16更新：</strong><br>由于SS服务在部分地区受到运营商的流量干扰，出现网速慢甚至断网的现象，有类似情况的朋友请安装SSR，抗干扰效果更好。请参考我近期写的一篇文章<a href=\"https://gaoshilei.com/2017/11/06/SSR/\" target=\"_blank\" rel=\"external\">VPS+SSR+锐速（BBR魔改版）实现超级加速</a><br>你购买或者配置VPS过程中遇到什么问题，可以通过邮箱 goslei1315@gmail.com 联系我，工作日一般2个小时之内回复。询问之前请描述清楚你遇到的问题。</p>\n<blockquote>\n<p> 2016.11.25更新：由于iPhone的Shadowsocks Server只在英国地区销售，国内的AppStore是下载不到的，大家可以在AppStore搜wingy，配置过程跟mac差不多，主要是IP、 Port和密码，加密协议都用默认的aes-256-cfb就行，然后手机也可以愉快的上网了。</p>\n</blockquote>\n<p>点开服务器，配置IP和密码，只需要修改地址和密码，其他不用改就OK了。<br><img src=\"http://oeat6c2zg.bkt.clouddn.com/%E6%90%AD%E5%BB%BAVPNShadowsocks%20Server%E8%AE%BE%E7%BD%AE.png\" width=\"500\" height=\"300\"><br>上两张图显示Shadowsocks Server有两种加速模式 ，<strong>一般情况下勾选自动代理模式就可以了，这个这个模式下会自动判断你当前访问的域名是否在GFW名单里面，如果是就启用代理，如果不是就正常访问，这样我们在访问墙内网站的时候也不会受到任何影响</strong> ，如果你遇到网站无法访问，有可能是这个网站近期被墙了，你没有更新本地的GFW名单，如果你确定这个网站是可以打开的，切换到全局模式就可以访问了 </p>\n<blockquote>\n<p>Shadowsocks Server自动代理模式原理是根据GFWList配置了一个PAC文件，名单中的域名全部走代理，你可以手动修改这个配置文件，添加你要访问的被墙的网站，它就是一个js文件，你点击编辑自动模式的PAC文件便会跳转到这个js所在的位置，那个GFWList自动更新功能坏掉了，作者一直也没更新，不过不影响平时使用。  </p>\n</blockquote>\n<p><strong>2017.11.16更新：</strong><br><strong>请注意：下面的内容已经过时，更稳定更便捷更快速的翻墙姿势请查看我近期写的一篇文章。</strong><br>传送门：<a href=\"https://gaoshilei.com/2017/11/06/SSR/\" target=\"_blank\" rel=\"external\">VPS+SSR+锐速（BBR魔改版）实现超级加速</a></p>\n<h3 id=\"三-加速SS（很重要！很重要！很重要！）\"><a href=\"#三-加速SS（很重要！很重要！很重要！）\" class=\"headerlink\" title=\"三.    加速SS（很重要！很重要！很重要！）\"></a>三.    加速SS（很重要！很重要！很重要！）</h3><p>完成上面的步骤，你确实是可以访问墙外网站了，但是下载速度一般只有100多KB，YouTube视频240P都感觉不流畅，此时就要用到Net-Speeder给VPN加速了，具体步骤请看：  </p>\n<h5 id=\"1-先连上远程主机\"><a href=\"#1-先连上远程主机\" class=\"headerlink\" title=\"1.    先连上远程主机\"></a>1.    先连上远程主机</h5><p><code>ssh -l root -p 12830 192.243.112.242</code><br>把端口和IP换成你自己主机的，然后需要输入root密码，输入在第一步我们设置的密码就可以了。  </p>\n<h5 id=\"2-安装Net-Speeder\"><a href=\"#2-安装Net-Speeder\" class=\"headerlink\" title=\"2.    安装Net-Speeder\"></a>2.    安装Net-Speeder</h5><p>输入下面的命令进行安装：<br><code>wget https://coding.net/u/njzhenghao/p/download/git/raw/master/net_speeder-installer.sh</code><br>这里我用的是别人git上的sh脚本，有现成的为何不用呢，是吧？！</p>\n<h5 id=\"3-编译并安装\"><a href=\"#3-编译并安装\" class=\"headerlink\" title=\"3.    编译并安装\"></a>3.    编译并安装</h5><p>输入下面的命令编译Net-Speeder：<br><code>bash net_speeder-installer.sh</code><br>命令执行成功之后，执行reboot重启主机，或者在后台面板重启主机也行。（<strong>此时远程主机的连接会断开，需要重新连接</strong>） </p>\n<h5 id=\"4-端口加速\"><a href=\"#4-端口加速\" class=\"headerlink\" title=\"4.    端口加速\"></a>4.    端口加速</h5><p>最后一步，加速端口：<br><code>nohup /usr/local/net_speeder/net_speeder venet0 &quot;ip&quot; &gt;/dev/null 2&gt;&amp;1 &amp;</code><br>执行完这个命令应该会有一个端口号打印出来，证明加速成功了！别着急还有最后一步，点开Shadowsocks Server菜单点击退出，<em>不要点退出Shadowsocks Server</em>，然后再次打开App，现在打开YouTube看个视频试试吧！现在墙外网站下载速度一般都在500KB左右，当然这个速度也受到你所在运营商的网络环境影响。（<strong>注意：加速端口这个命令每次重启主机都需要执行一次，因为这个脚本没有加到开机自启动，反正我们没事也不重启主机，我懒得弄了，大家自己Google吧，哈哈！</strong>）  </p>\n<p><strong>2016.11.25更新</strong>  </p>\n<p>有些网友反应速度有时候很慢，我今天也遇到了这种情况，解决方案如下：<br>先通过命令连上VPS  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh -l root -p port IP</div></pre></td></tr></table></figure>\n<p>然后重启主机  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reboot</div></pre></td></tr></table></figure>\n<p>此时连接断开，不用管，去看一下此时的SS是否正常使用，确定可以访问之后，再连上VPS开启端口加速  </p>\n<pre><code>nohup /usr/local/net_speeder/net_speeder venet0 &quot;ip&quot; &gt;/dev/null 2&gt;&amp;1 &amp;\n</code></pre><p>这种情况应该是主机的SS服务挂掉了，这种情况很少遇到，我使用了这么久今天第一次遇到，这么操作之后SS又恢复到原来丝滑般的享受 。</p>"},{"title":"快速搭建Hexo博客+webhook自动部署+全站HTTPS","date":"2017-10-30T11:09:00.000Z","_content":"\n本文档主要用来记录自己借助[Hexo](https://hexo.io)搭建博客的一些步骤和命令，方便以后重装；新人也可以通过此篇文章快速搭建自己的个人博客。\n下文的环境为:  \nVPS： CentOS6.9\n本地： MacOS  \n\n## 搭建博客\n### 1、安装 NodeJS 和 NPM  \n\n```shell  \n[root@California_VPS ~]# curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -  \n```\n\n执行完这个命令之后就可以安装NodeJS  \n\n```shell  \n[root@California_VPS ~]# yum install -y nodejs\n```\n\n<!-- more -->\n\n这里安装的是8.X版本，如果安装其他版本将`setup_8.x`中的8改成对应的版本就可以了。  \n安装完成之后执行命令检查安装结果：  \n\n```shell  \n[root@California_VPS ~]# node -v\nv8.8.1\n[root@California_VPS ~]# npm -v\n5.4.2\n```\n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n### 2、安装 Nginx  \n通过 yum方式安装比较麻烦，还需要安装epel依赖库，下面介绍一种最简单的安装方法 \n\n```shell  \n[root@California_VPS ~]# vim /etc/yum.repos.d/nginx.repo \n```\n先在 yum.repos.d 文件下新建一个`nginx.repo`，然后将下面的内容拷贝进去，`:wq`保存退出\n\n```shell  \n[nginx]\nname=nginx repo\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\ngpgcheck=0\nenabled=1 \n```\n\n执行下面的命令直接从配置文件安装 nginx\n\n```shell  \n[root@California_VPS ~]# yum install nginx -y\n```\n\n然后启动nginx  \n\n```\n[root@c_vps ~]# nginx\n```\n\n然后打开服务器所在的IP测试nginx是否安装完成。\n\n### 3、安装 Hexo\n按照官网的文档执行命令  \n\n```shell  \n[root@California_VPS ~]# npm install -g hexo-cli\n```\n\n顺利的话一会就安装好了，有时候会遇到 npm 权限问题  \n\n  \n> /usr/bin/hexo -> /usr/lib/node_modules/hexo-cli/bin/hexo\nhexo-util@0.6.1 postinstall /usr/lib/node_modules/hexo-cli/node_modules/hexo-util\nnpm run build:highlight\nhexo-util@0.6.1 build:highlight /usr/lib/node_modules/hexo-cli/node_modules/hexo-util\nnode scripts/build_highlight_alias.js > highlight_alias.json\nsh: highlight_alias.json: 权限不够\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! hexo-util@0.6.1 build:highlight: `node scripts/build_highlight_alias.js > highlight_alias.json`\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the hexo-util@0.6.1 build:highlight script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.  \n\n\n这个时候需要开启 npm 的 unsafe-perm 模式  \n\n```shell  \n[root@California_VPS ~]# npm config set unsafe-perm \"true\"  \n```\n\n查看是否设置成功  \n\n```shell  \n[root@California_VPS ~]# npm config get unsafe-perm\ntrue\n```\n\n如果为 `true` 则设置成功，再次执行 hexo 的安装命令即可顺利安装成功。  \n\n因为需要把之前在 github 的博客备份重新拷贝新的服务器上，所以要配置 ssh 公钥方便 git 操作。\n\n先生成公钥\n\n```shell \n[root@California_VPS ~]# ssh-keygen -t rsa -b 4096 -C \"xxxxx@xxx.com\"  \n```\n\n这一步会生成ssh公钥，也就是 public key，生成之后可以通过下面的命令查看  \n\n```shell  \nls -al ~/.ssh\n```\n\n如果有 `id_rsa` `id_rsa.pub` 证明生成成功，然后通过下面的命令查看 ssh 公钥\n\n```shell  \ncat ~/.ssh/id_rsa.pub\n```\n再将这个公钥拷贝到 github 的账户配置中即可。   \n\n**注意：  为了方便在本地修改博客、实时预览、自动部署，以上（除了Nginx安装）所有步骤在本地机器上也需要重新操作一遍，以后在本地直接修改之后推送github，配合下文的webhook，服务器会自动更新**  \n\n### 4、配置博客  \n\n新安装：参照 [Hexo官方教程](https://hexo.io/zh-cn/docs/setup.html) \n重装：从 github 上把之前的博客 clone 下来，放到 root 目录下：  \n\n```shell  \ngit clone git@github.com:gaoshilei/hexo-blog.git  \n```\n\n进入博客目录，一次执行下面的命令\n\n```\n[root@c_vps hexo-blog]# npm install hexo\n[root@c_vps hexo-blog]# npm install\n```\n\n然后配置 nginx，让 80 端口指向博客静态页面首页，在 nginx 配置文件目中新建一个`hexo.conf`文件 \n\n```shell  \n[root@California_VPS ~]# vim /etc/nginx/conf.d/hexo.conf  \n```\n\n写入相应的配置  \n\n```shell  \nserver {\n    listen          80;\n    server_name     gaoshilei.com www.gaoshilei.com;\n    location / {\n        root        /root/hexo-blog/public;\n        index       index.html;\n    }\n}\n```\n\n重启 nginx 使服务生效  \n\n```shell  \n[root@California_VPS ~]# nginx -s reload\n```\n\n此时去访问博客得到的是一个 404 或者 403 报错，因为 nginx 是以 nginx 用户运行的，他没有博客目录的读写权限，有两个方法可以解决：  \n1. 给博客目录赋权，让 nginx 用户拥有读写权限\n2. 让 nginx 以 root 用户运行 \n\n我采用第二种方式，修改 nginx 的配置文件  \n\n```shell  \n[root@California_VPS ~]# vim /etc/nginx/nginx.conf  \n```\n\n将 `user  nginx;` 改成 `user  root;` 即可。然后重启 nginx。  \n\n再去访问发现报错没了，但是页面是一片空白，找了半天原因，之前用到的主题并没有上传到 github 上，将主题拷贝到 `themes` 文件夹下，然后部署 hexo 就可以正常访问了。  \n\n**hexo 常用的命令**  \n生成静态文件并部署网站:  \n\n安装 hexo 服务（本地可以通过这个服务实现预览，不需要安装nginx）\n\n```  \n# npm install hexo-server --save  \n```\n\n启动 hexo 服务，默认端口为 4000\n\n``` \n# hexo server\n```\n\n用指定端口(port)启动启动 hexo 服务\n\n```\n# hexo server -p port\n```\n\n生成静态文件\n\n```  \n# hexo g\n```\n\n清除缓存文件 (db.json) 和已生成的静态文件 (public)  \n\n```  \n# hexo clean  \n```\n\n生成站点map  \n\n```  \n# npm install hexo-generator-sitemap --save\n# npm install hexo-generator-baidu-sitemap --save  \n```\n\n\n## 配置 webhooks 自动更新博客  \n每次在本地更新了博客，push 到 github 上，还要去 VPS 再 git pull 一下，确实很麻烦，配置好 webhooks 就可以在 github 有 push 操作时自动更新并部署博客。  \n\nwebhooks 在 github 对应仓库直接设置就行，重点是服务器的接收和相应的操作。  \n有 Python、PHP、NodeJS 多种方式可以接收 webhooks , 由于 hexo 是基于 NodeJS 的，所以这里用 NodeJS 来接收 github 的 push 事件。 \n\n安装依赖库 `github-webhook-handler`：  \n\n```shell  \n[root@California_VPS ~]# npm install -g github-webhook-handler\n```\n\n安装完成之后配置 `webhooks.js`  \n\n```shell  \n[root@California_VPS hexo-blog]# vim webhooks.js \n```\n\n然后将下面代码的拷贝进去  \n\n```js   \nvar http = require('http')\nvar createHandler = require('github-webhook-handler')\nvar handler = createHandler({ path: '/webhooks_push', secret: 'leonlei1226' })\n// 上面的 secret 保持和 GitHub 后台设置的一致\n\nfunction run_cmd(cmd, args, callback) {\n  var spawn = require('child_process').spawn;\n  var child = spawn(cmd, args);\n  var resp = \"\";\n\n  child.stdout.on('data', function(buffer) { resp += buffer.toString(); });\n  child.stdout.on('end', function() { callback (resp) });\n}\n\nhandler.on('error', function (err) {\n  console.error('Error:', err.message)\n})\n\nhandler.on('push', function (event) {\n  console.log('Received a push event for %s to %s',\n    event.payload.repository.name,\n    event.payload.ref);\n    run_cmd('sh', ['./deploy.sh'], function(text){ console.log(text) });\n})\n\ntry {\n  http.createServer(function (req, res) {\n    handler(req, res, function (err) {\n      res.statusCode = 404\n      res.end('no such location')\n    })\n  }).listen(6666)\n}catch(err){\n  console.error('Error:', err.message)\n}\n```\n\n其中 **secret** 要和 github 仓库中 webhooks 设置的一致，**6666** 是监听端口可以随便改，不要冲突就行，**./deploy.sh** 是接收到 push 事件时需要执行的shell脚本，与 `webhooks.js` 都存放在博客目录下；**path: '/webhooks_push** 是 github 通知服务器的地址，完整的地址是这样的`http://www.gaoshilei.com:6666/webhooks_push`  \n\n> 用 https 会报错，github 设置页面会 deliver error，所以把地址改成了 http\n\n\n配置`./deploy.sh`  \n\n```shell  \n[root@California_VPS hexo-blog]# vim deploy.sh\n```\n\n将下面代码拷贝进去\n\n```shell  \ngit pull origin master\nhexo g\n```\n\n然后运行  \n\n```shell  \n[root@California_VPS hexo-blog]# node webhooks.js \n```\n\n就可以实现本地更新 push 到 github ，服务器会自动更新部署博客。  \n最后要将进程加入守护，通过 pm2 来实现  \n\n```shell  \n[root@California_VPS ~]# npm install pm2 --global\n```\n\n然后通过 pm2 启动 `webhooks.js`  \n\n```shell  \n[root@California_VPS hexo-blog]# pm2 start /root/hexo-blog/webhooks.js \n[PM2] Starting /root/hexo-blog/webhooks.js in fork_mode (1 instance)\n[PM2] Done.\n┌──────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐\n│ App name │ id │ mode │ pid   │ status │ restart │ uptime │ cpu │ mem       │ user │ watching │\n├──────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤\n│ webhooks │ 0  │ fork │ 10010 │ online │ 0       │ 0s     │ 14% │ 24.2 MB   │ root │ disabled │\n└──────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘\n Use `pm2 show <id|name>` to get more details about an app  \n```\n\n如果服务器重启，我们还要手动开启webhooks服务，所以我们将上面的命令加入开机启动就可以了，将命令加入`/etc/rc.d/rc.local`中，即可实现开机自启  \n先将命令写到脚本`/root/webhooks_auto.sh`中：  \n\n```  \n/sbin/runuser -l root -c \"/usr/bin/pm2 start /root/hexo-blog/webhooks.js\"\n```\n\n\n然后在`/etc/rc.d/rc.local`中添加刚才的脚本：  \n\n```\n/root/webhooks_auto.sh 2>&1 > /dev/null &\n```\n\n\n重启VPS，然后用命令`pm2 show webhooks`查看 webhooks 是否已经启动。\n\n## 全站 HTTPS \n\n使用 Let’s Encrypt 的免费证书，不过每三个月要续签一次。安装可以通过 Certbot 的傻瓜式操作  \n\n```shell  \n[root@California_VPS www]# wget https://dl.eff.org/certbot-auto\n[root@California_VPS www]# chmod a+x certbot-auto  \n```\n\n下载脚本，然后赋权  \n\n```shell  \n[root@California_VPS www]# sudo ./certbot-auto --nginx\n```\n\n执行脚本，获取证书，Certbot 会自动帮我们配置 nginx 的一些配置。走到最后可能遇到这种情况  \n\n>  \nCannot find a VirtualHost matching domain www.gaoshilei.com. In order for Certbot to correctly perform the challenge please add a corresponding server_name directive to your nginx configuration: https://nginx.org/en/docs/http/server_names.html\n\n之前在配置 nginx.conf 文件的时候忘记加域名了，把 server_name 补全就行了，然后重新执行一次脚本。你还可能遇到这样的问题  \n\n```\nCreating virtual environment...\n[root@California_VPS www]# ./certbot-auto: line 864: virtualenv: command not found\n```\n\n缺少`virtualenv`环境，依次执行下面的命令下面进行安装：  \n\n```\n[root@California_VPS www]# curl https://bootstrap.pypa.io/get-pip.py | python -\n[root@California_VPS www]# pip install virtualenv\n```\n\n然后执行上面的命令`sudo ./certbot-auto --nginx`继续安装证书，中间需要我们输入邮箱，域名等等，按照步骤操作就可以，最后顺利申请了证书，而且 Certbot 都帮我配置好了，nice！  \n不过这个证书有效期只有三个月，所以需要续签，可以手动续签，证书快过期的时候执行  \n\n```shell  \n# sudo /root/www/certbot-auto renew\n```\n\n或者将上面的命令加入 `crontab` 定时任务  \n\n```shell  \n[root@California_VPS etc]# ps -ef | grep cron\nroot      1164     1  0 Oct30 ?        00:00:00 crond\nroot      8507  8222  0 07:31 pts/0    00:00:00 grep cron  \n[root@California_VPS etc]# service crond status\ncrond (pid  1164) is running...\n```\n\n先检查一下有没有安装 crontab，并且查看 crontab 的运行状态。最后配置  \n\n```shell  \n[root@California_VPS etc]# crontab -e\n```\n\n添加下面这条命令到配置文件中\n\n```shell  \n0 0 * * 0 /root/www/certbot-auto renew  \n```\n\n这条命令的意思是每周日的0点0分执行`/root/www/certbot-auto renew`这条命令。执行下面这条命令查看定时任务列表中是否有刚才添加的任务\n\n```shell  \n[root@California_VPS etc]# crontab -l \n0 0 * * 0 /root/www/certbot-auto renew\n```\n\n大功告成！\n\n","source":"_posts/快速搭建Hexo博客+webhook自动部署+全站HTTPS.md","raw":"---\ntitle: 快速搭建Hexo博客+webhook自动部署+全站HTTPS  \ndate: 2017-10-30 19:09:00  \ncategories:  \n- 备忘录  \ntags:  \n- 个人博客  \npermalink: hexo-init  \n---\n\n本文档主要用来记录自己借助[Hexo](https://hexo.io)搭建博客的一些步骤和命令，方便以后重装；新人也可以通过此篇文章快速搭建自己的个人博客。\n下文的环境为:  \nVPS： CentOS6.9\n本地： MacOS  \n\n## 搭建博客\n### 1、安装 NodeJS 和 NPM  \n\n```shell  \n[root@California_VPS ~]# curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -  \n```\n\n执行完这个命令之后就可以安装NodeJS  \n\n```shell  \n[root@California_VPS ~]# yum install -y nodejs\n```\n\n<!-- more -->\n\n这里安装的是8.X版本，如果安装其他版本将`setup_8.x`中的8改成对应的版本就可以了。  \n安装完成之后执行命令检查安装结果：  \n\n```shell  \n[root@California_VPS ~]# node -v\nv8.8.1\n[root@California_VPS ~]# npm -v\n5.4.2\n```\n\n转载请注明出处：[来自LeonLei的博客http://www.gaoshilei.com](http://www.gaoshilei.com)  \n\n### 2、安装 Nginx  \n通过 yum方式安装比较麻烦，还需要安装epel依赖库，下面介绍一种最简单的安装方法 \n\n```shell  \n[root@California_VPS ~]# vim /etc/yum.repos.d/nginx.repo \n```\n先在 yum.repos.d 文件下新建一个`nginx.repo`，然后将下面的内容拷贝进去，`:wq`保存退出\n\n```shell  \n[nginx]\nname=nginx repo\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\ngpgcheck=0\nenabled=1 \n```\n\n执行下面的命令直接从配置文件安装 nginx\n\n```shell  \n[root@California_VPS ~]# yum install nginx -y\n```\n\n然后启动nginx  \n\n```\n[root@c_vps ~]# nginx\n```\n\n然后打开服务器所在的IP测试nginx是否安装完成。\n\n### 3、安装 Hexo\n按照官网的文档执行命令  \n\n```shell  \n[root@California_VPS ~]# npm install -g hexo-cli\n```\n\n顺利的话一会就安装好了，有时候会遇到 npm 权限问题  \n\n  \n> /usr/bin/hexo -> /usr/lib/node_modules/hexo-cli/bin/hexo\nhexo-util@0.6.1 postinstall /usr/lib/node_modules/hexo-cli/node_modules/hexo-util\nnpm run build:highlight\nhexo-util@0.6.1 build:highlight /usr/lib/node_modules/hexo-cli/node_modules/hexo-util\nnode scripts/build_highlight_alias.js > highlight_alias.json\nsh: highlight_alias.json: 权限不够\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! hexo-util@0.6.1 build:highlight: `node scripts/build_highlight_alias.js > highlight_alias.json`\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the hexo-util@0.6.1 build:highlight script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.  \n\n\n这个时候需要开启 npm 的 unsafe-perm 模式  \n\n```shell  \n[root@California_VPS ~]# npm config set unsafe-perm \"true\"  \n```\n\n查看是否设置成功  \n\n```shell  \n[root@California_VPS ~]# npm config get unsafe-perm\ntrue\n```\n\n如果为 `true` 则设置成功，再次执行 hexo 的安装命令即可顺利安装成功。  \n\n因为需要把之前在 github 的博客备份重新拷贝新的服务器上，所以要配置 ssh 公钥方便 git 操作。\n\n先生成公钥\n\n```shell \n[root@California_VPS ~]# ssh-keygen -t rsa -b 4096 -C \"xxxxx@xxx.com\"  \n```\n\n这一步会生成ssh公钥，也就是 public key，生成之后可以通过下面的命令查看  \n\n```shell  \nls -al ~/.ssh\n```\n\n如果有 `id_rsa` `id_rsa.pub` 证明生成成功，然后通过下面的命令查看 ssh 公钥\n\n```shell  \ncat ~/.ssh/id_rsa.pub\n```\n再将这个公钥拷贝到 github 的账户配置中即可。   \n\n**注意：  为了方便在本地修改博客、实时预览、自动部署，以上（除了Nginx安装）所有步骤在本地机器上也需要重新操作一遍，以后在本地直接修改之后推送github，配合下文的webhook，服务器会自动更新**  \n\n### 4、配置博客  \n\n新安装：参照 [Hexo官方教程](https://hexo.io/zh-cn/docs/setup.html) \n重装：从 github 上把之前的博客 clone 下来，放到 root 目录下：  \n\n```shell  \ngit clone git@github.com:gaoshilei/hexo-blog.git  \n```\n\n进入博客目录，一次执行下面的命令\n\n```\n[root@c_vps hexo-blog]# npm install hexo\n[root@c_vps hexo-blog]# npm install\n```\n\n然后配置 nginx，让 80 端口指向博客静态页面首页，在 nginx 配置文件目中新建一个`hexo.conf`文件 \n\n```shell  \n[root@California_VPS ~]# vim /etc/nginx/conf.d/hexo.conf  \n```\n\n写入相应的配置  \n\n```shell  \nserver {\n    listen          80;\n    server_name     gaoshilei.com www.gaoshilei.com;\n    location / {\n        root        /root/hexo-blog/public;\n        index       index.html;\n    }\n}\n```\n\n重启 nginx 使服务生效  \n\n```shell  \n[root@California_VPS ~]# nginx -s reload\n```\n\n此时去访问博客得到的是一个 404 或者 403 报错，因为 nginx 是以 nginx 用户运行的，他没有博客目录的读写权限，有两个方法可以解决：  \n1. 给博客目录赋权，让 nginx 用户拥有读写权限\n2. 让 nginx 以 root 用户运行 \n\n我采用第二种方式，修改 nginx 的配置文件  \n\n```shell  \n[root@California_VPS ~]# vim /etc/nginx/nginx.conf  \n```\n\n将 `user  nginx;` 改成 `user  root;` 即可。然后重启 nginx。  \n\n再去访问发现报错没了，但是页面是一片空白，找了半天原因，之前用到的主题并没有上传到 github 上，将主题拷贝到 `themes` 文件夹下，然后部署 hexo 就可以正常访问了。  \n\n**hexo 常用的命令**  \n生成静态文件并部署网站:  \n\n安装 hexo 服务（本地可以通过这个服务实现预览，不需要安装nginx）\n\n```  \n# npm install hexo-server --save  \n```\n\n启动 hexo 服务，默认端口为 4000\n\n``` \n# hexo server\n```\n\n用指定端口(port)启动启动 hexo 服务\n\n```\n# hexo server -p port\n```\n\n生成静态文件\n\n```  \n# hexo g\n```\n\n清除缓存文件 (db.json) 和已生成的静态文件 (public)  \n\n```  \n# hexo clean  \n```\n\n生成站点map  \n\n```  \n# npm install hexo-generator-sitemap --save\n# npm install hexo-generator-baidu-sitemap --save  \n```\n\n\n## 配置 webhooks 自动更新博客  \n每次在本地更新了博客，push 到 github 上，还要去 VPS 再 git pull 一下，确实很麻烦，配置好 webhooks 就可以在 github 有 push 操作时自动更新并部署博客。  \n\nwebhooks 在 github 对应仓库直接设置就行，重点是服务器的接收和相应的操作。  \n有 Python、PHP、NodeJS 多种方式可以接收 webhooks , 由于 hexo 是基于 NodeJS 的，所以这里用 NodeJS 来接收 github 的 push 事件。 \n\n安装依赖库 `github-webhook-handler`：  \n\n```shell  \n[root@California_VPS ~]# npm install -g github-webhook-handler\n```\n\n安装完成之后配置 `webhooks.js`  \n\n```shell  \n[root@California_VPS hexo-blog]# vim webhooks.js \n```\n\n然后将下面代码的拷贝进去  \n\n```js   \nvar http = require('http')\nvar createHandler = require('github-webhook-handler')\nvar handler = createHandler({ path: '/webhooks_push', secret: 'leonlei1226' })\n// 上面的 secret 保持和 GitHub 后台设置的一致\n\nfunction run_cmd(cmd, args, callback) {\n  var spawn = require('child_process').spawn;\n  var child = spawn(cmd, args);\n  var resp = \"\";\n\n  child.stdout.on('data', function(buffer) { resp += buffer.toString(); });\n  child.stdout.on('end', function() { callback (resp) });\n}\n\nhandler.on('error', function (err) {\n  console.error('Error:', err.message)\n})\n\nhandler.on('push', function (event) {\n  console.log('Received a push event for %s to %s',\n    event.payload.repository.name,\n    event.payload.ref);\n    run_cmd('sh', ['./deploy.sh'], function(text){ console.log(text) });\n})\n\ntry {\n  http.createServer(function (req, res) {\n    handler(req, res, function (err) {\n      res.statusCode = 404\n      res.end('no such location')\n    })\n  }).listen(6666)\n}catch(err){\n  console.error('Error:', err.message)\n}\n```\n\n其中 **secret** 要和 github 仓库中 webhooks 设置的一致，**6666** 是监听端口可以随便改，不要冲突就行，**./deploy.sh** 是接收到 push 事件时需要执行的shell脚本，与 `webhooks.js` 都存放在博客目录下；**path: '/webhooks_push** 是 github 通知服务器的地址，完整的地址是这样的`http://www.gaoshilei.com:6666/webhooks_push`  \n\n> 用 https 会报错，github 设置页面会 deliver error，所以把地址改成了 http\n\n\n配置`./deploy.sh`  \n\n```shell  \n[root@California_VPS hexo-blog]# vim deploy.sh\n```\n\n将下面代码拷贝进去\n\n```shell  \ngit pull origin master\nhexo g\n```\n\n然后运行  \n\n```shell  \n[root@California_VPS hexo-blog]# node webhooks.js \n```\n\n就可以实现本地更新 push 到 github ，服务器会自动更新部署博客。  \n最后要将进程加入守护，通过 pm2 来实现  \n\n```shell  \n[root@California_VPS ~]# npm install pm2 --global\n```\n\n然后通过 pm2 启动 `webhooks.js`  \n\n```shell  \n[root@California_VPS hexo-blog]# pm2 start /root/hexo-blog/webhooks.js \n[PM2] Starting /root/hexo-blog/webhooks.js in fork_mode (1 instance)\n[PM2] Done.\n┌──────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐\n│ App name │ id │ mode │ pid   │ status │ restart │ uptime │ cpu │ mem       │ user │ watching │\n├──────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤\n│ webhooks │ 0  │ fork │ 10010 │ online │ 0       │ 0s     │ 14% │ 24.2 MB   │ root │ disabled │\n└──────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘\n Use `pm2 show <id|name>` to get more details about an app  \n```\n\n如果服务器重启，我们还要手动开启webhooks服务，所以我们将上面的命令加入开机启动就可以了，将命令加入`/etc/rc.d/rc.local`中，即可实现开机自启  \n先将命令写到脚本`/root/webhooks_auto.sh`中：  \n\n```  \n/sbin/runuser -l root -c \"/usr/bin/pm2 start /root/hexo-blog/webhooks.js\"\n```\n\n\n然后在`/etc/rc.d/rc.local`中添加刚才的脚本：  \n\n```\n/root/webhooks_auto.sh 2>&1 > /dev/null &\n```\n\n\n重启VPS，然后用命令`pm2 show webhooks`查看 webhooks 是否已经启动。\n\n## 全站 HTTPS \n\n使用 Let’s Encrypt 的免费证书，不过每三个月要续签一次。安装可以通过 Certbot 的傻瓜式操作  \n\n```shell  \n[root@California_VPS www]# wget https://dl.eff.org/certbot-auto\n[root@California_VPS www]# chmod a+x certbot-auto  \n```\n\n下载脚本，然后赋权  \n\n```shell  \n[root@California_VPS www]# sudo ./certbot-auto --nginx\n```\n\n执行脚本，获取证书，Certbot 会自动帮我们配置 nginx 的一些配置。走到最后可能遇到这种情况  \n\n>  \nCannot find a VirtualHost matching domain www.gaoshilei.com. In order for Certbot to correctly perform the challenge please add a corresponding server_name directive to your nginx configuration: https://nginx.org/en/docs/http/server_names.html\n\n之前在配置 nginx.conf 文件的时候忘记加域名了，把 server_name 补全就行了，然后重新执行一次脚本。你还可能遇到这样的问题  \n\n```\nCreating virtual environment...\n[root@California_VPS www]# ./certbot-auto: line 864: virtualenv: command not found\n```\n\n缺少`virtualenv`环境，依次执行下面的命令下面进行安装：  \n\n```\n[root@California_VPS www]# curl https://bootstrap.pypa.io/get-pip.py | python -\n[root@California_VPS www]# pip install virtualenv\n```\n\n然后执行上面的命令`sudo ./certbot-auto --nginx`继续安装证书，中间需要我们输入邮箱，域名等等，按照步骤操作就可以，最后顺利申请了证书，而且 Certbot 都帮我配置好了，nice！  \n不过这个证书有效期只有三个月，所以需要续签，可以手动续签，证书快过期的时候执行  \n\n```shell  \n# sudo /root/www/certbot-auto renew\n```\n\n或者将上面的命令加入 `crontab` 定时任务  \n\n```shell  \n[root@California_VPS etc]# ps -ef | grep cron\nroot      1164     1  0 Oct30 ?        00:00:00 crond\nroot      8507  8222  0 07:31 pts/0    00:00:00 grep cron  \n[root@California_VPS etc]# service crond status\ncrond (pid  1164) is running...\n```\n\n先检查一下有没有安装 crontab，并且查看 crontab 的运行状态。最后配置  \n\n```shell  \n[root@California_VPS etc]# crontab -e\n```\n\n添加下面这条命令到配置文件中\n\n```shell  \n0 0 * * 0 /root/www/certbot-auto renew  \n```\n\n这条命令的意思是每周日的0点0分执行`/root/www/certbot-auto renew`这条命令。执行下面这条命令查看定时任务列表中是否有刚才添加的任务\n\n```shell  \n[root@California_VPS etc]# crontab -l \n0 0 * * 0 /root/www/certbot-auto renew\n```\n\n大功告成！\n\n","slug":"hexo-init","published":1,"updated":"2017-11-20T09:40:50.961Z","_id":"cja3nqn0u0000qqendt66oqmz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文档主要用来记录自己借助<a href=\"https://hexo.io\" target=\"_blank\" rel=\"external\">Hexo</a>搭建博客的一些步骤和命令，方便以后重装；新人也可以通过此篇文章快速搭建自己的个人博客。<br>下文的环境为:<br>VPS： CentOS6.9<br>本地： MacOS  </p>\n<h2 id=\"搭建博客\"><a href=\"#搭建博客\" class=\"headerlink\" title=\"搭建博客\"></a>搭建博客</h2><h3 id=\"1、安装-NodeJS-和-NPM\"><a href=\"#1、安装-NodeJS-和-NPM\" class=\"headerlink\" title=\"1、安装 NodeJS 和 NPM\"></a>1、安装 NodeJS 和 NPM</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -</div></pre></td></tr></table></figure>\n<p>执行完这个命令之后就可以安装NodeJS  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# yum install -y nodejs</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>这里安装的是8.X版本，如果安装其他版本将<code>setup_8.x</code>中的8改成对应的版本就可以了。<br>安装完成之后执行命令检查安装结果：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# node -v</div><div class=\"line\">v8.8.1</div><div class=\"line\">[root@California_VPS ~]# npm -v</div><div class=\"line\">5.4.2</div></pre></td></tr></table></figure>\n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<h3 id=\"2、安装-Nginx\"><a href=\"#2、安装-Nginx\" class=\"headerlink\" title=\"2、安装 Nginx\"></a>2、安装 Nginx</h3><p>通过 yum方式安装比较麻烦，还需要安装epel依赖库，下面介绍一种最简单的安装方法 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# vim /etc/yum.repos.d/nginx.repo</div></pre></td></tr></table></figure>\n<p>先在 yum.repos.d 文件下新建一个<code>nginx.repo</code>，然后将下面的内容拷贝进去，<code>:wq</code>保存退出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[nginx]</div><div class=\"line\">name=nginx repo</div><div class=\"line\">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</div><div class=\"line\">gpgcheck=0</div><div class=\"line\">enabled=1</div></pre></td></tr></table></figure>\n<p>执行下面的命令直接从配置文件安装 nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# yum install nginx -y</div></pre></td></tr></table></figure>\n<p>然后启动nginx  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@c_vps ~]# nginx</div></pre></td></tr></table></figure>\n<p>然后打开服务器所在的IP测试nginx是否安装完成。</p>\n<h3 id=\"3、安装-Hexo\"><a href=\"#3、安装-Hexo\" class=\"headerlink\" title=\"3、安装 Hexo\"></a>3、安装 Hexo</h3><p>按照官网的文档执行命令  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<p>顺利的话一会就安装好了，有时候会遇到 npm 权限问题  </p>\n<blockquote>\n<p>/usr/bin/hexo -&gt; /usr/lib/node_modules/hexo-cli/bin/hexo<br>hexo-util@0.6.1 postinstall /usr/lib/node_modules/hexo-cli/node_modules/hexo-util<br>npm run build:highlight<br>hexo-util@0.6.1 build:highlight /usr/lib/node_modules/hexo-cli/node_modules/hexo-util<br>node scripts/build_highlight_alias.js &gt; highlight_alias.json<br>sh: highlight_alias.json: 权限不够<br>npm ERR! code ELIFECYCLE<br>npm ERR! errno 1<br>npm ERR! hexo-util@0.6.1 build:highlight: <code>node scripts/build_highlight_alias.js &gt; highlight_alias.json</code><br>npm ERR! Exit status 1<br>npm ERR!<br>npm ERR! Failed at the hexo-util@0.6.1 build:highlight script.<br>npm ERR! This is probably not a problem with npm. There is likely additional logging output above.  </p>\n</blockquote>\n<p>这个时候需要开启 npm 的 unsafe-perm 模式  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# npm config set unsafe-perm &quot;true&quot;</div></pre></td></tr></table></figure>\n<p>查看是否设置成功  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# npm config get unsafe-perm</div><div class=\"line\">true</div></pre></td></tr></table></figure>\n<p>如果为 <code>true</code> 则设置成功，再次执行 hexo 的安装命令即可顺利安装成功。  </p>\n<p>因为需要把之前在 github 的博客备份重新拷贝新的服务器上，所以要配置 ssh 公钥方便 git 操作。</p>\n<p>先生成公钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# ssh-keygen -t rsa -b 4096 -C &quot;xxxxx@xxx.com&quot;</div></pre></td></tr></table></figure>\n<p>这一步会生成ssh公钥，也就是 public key，生成之后可以通过下面的命令查看  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ls -al ~/.ssh</div></pre></td></tr></table></figure>\n<p>如果有 <code>id_rsa</code> <code>id_rsa.pub</code> 证明生成成功，然后通过下面的命令查看 ssh 公钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure>\n<p>再将这个公钥拷贝到 github 的账户配置中即可。   </p>\n<p><strong>注意：  为了方便在本地修改博客、实时预览、自动部署，以上（除了Nginx安装）所有步骤在本地机器上也需要重新操作一遍，以后在本地直接修改之后推送github，配合下文的webhook，服务器会自动更新</strong>  </p>\n<h3 id=\"4、配置博客\"><a href=\"#4、配置博客\" class=\"headerlink\" title=\"4、配置博客\"></a>4、配置博客</h3><p>新安装：参照 <a href=\"https://hexo.io/zh-cn/docs/setup.html\" target=\"_blank\" rel=\"external\">Hexo官方教程</a><br>重装：从 github 上把之前的博客 clone 下来，放到 root 目录下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone git@github.com:gaoshilei/hexo-blog.git</div></pre></td></tr></table></figure>\n<p>进入博客目录，一次执行下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@c_vps hexo-blog]# npm install hexo</div><div class=\"line\">[root@c_vps hexo-blog]# npm install</div></pre></td></tr></table></figure>\n<p>然后配置 nginx，让 80 端口指向博客静态页面首页，在 nginx 配置文件目中新建一个<code>hexo.conf</code>文件 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# vim /etc/nginx/conf.d/hexo.conf</div></pre></td></tr></table></figure>\n<p>写入相应的配置  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">    listen          80;</div><div class=\"line\">    server_name     gaoshilei.com www.gaoshilei.com;</div><div class=\"line\">    location / &#123;</div><div class=\"line\">        root        /root/hexo-blog/public;</div><div class=\"line\">        index       index.html;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重启 nginx 使服务生效  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# nginx -s reload</div></pre></td></tr></table></figure>\n<p>此时去访问博客得到的是一个 404 或者 403 报错，因为 nginx 是以 nginx 用户运行的，他没有博客目录的读写权限，有两个方法可以解决：  </p>\n<ol>\n<li>给博客目录赋权，让 nginx 用户拥有读写权限</li>\n<li>让 nginx 以 root 用户运行 </li>\n</ol>\n<p>我采用第二种方式，修改 nginx 的配置文件  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# vim /etc/nginx/nginx.conf</div></pre></td></tr></table></figure>\n<p>将 <code>user  nginx;</code> 改成 <code>user  root;</code> 即可。然后重启 nginx。  </p>\n<p>再去访问发现报错没了，但是页面是一片空白，找了半天原因，之前用到的主题并没有上传到 github 上，将主题拷贝到 <code>themes</code> 文件夹下，然后部署 hexo 就可以正常访问了。  </p>\n<p><strong>hexo 常用的命令</strong><br>生成静态文件并部署网站:  </p>\n<p>安装 hexo 服务（本地可以通过这个服务实现预览，不需要安装nginx）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># npm install hexo-server --save</div></pre></td></tr></table></figure>\n<p>启动 hexo 服务，默认端口为 4000</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># hexo server</div></pre></td></tr></table></figure>\n<p>用指定端口(port)启动启动 hexo 服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># hexo server -p port</div></pre></td></tr></table></figure>\n<p>生成静态文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># hexo g</div></pre></td></tr></table></figure>\n<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># hexo clean</div></pre></td></tr></table></figure>\n<p>生成站点map  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># npm install hexo-generator-sitemap --save</div><div class=\"line\"># npm install hexo-generator-baidu-sitemap --save</div></pre></td></tr></table></figure>\n<h2 id=\"配置-webhooks-自动更新博客\"><a href=\"#配置-webhooks-自动更新博客\" class=\"headerlink\" title=\"配置 webhooks 自动更新博客\"></a>配置 webhooks 自动更新博客</h2><p>每次在本地更新了博客，push 到 github 上，还要去 VPS 再 git pull 一下，确实很麻烦，配置好 webhooks 就可以在 github 有 push 操作时自动更新并部署博客。  </p>\n<p>webhooks 在 github 对应仓库直接设置就行，重点是服务器的接收和相应的操作。<br>有 Python、PHP、NodeJS 多种方式可以接收 webhooks , 由于 hexo 是基于 NodeJS 的，所以这里用 NodeJS 来接收 github 的 push 事件。 </p>\n<p>安装依赖库 <code>github-webhook-handler</code>：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# npm install -g github-webhook-handler</div></pre></td></tr></table></figure>\n<p>安装完成之后配置 <code>webhooks.js</code>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS hexo-blog]# vim webhooks.js</div></pre></td></tr></table></figure>\n<p>然后将下面代码的拷贝进去  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> createHandler = <span class=\"built_in\">require</span>(<span class=\"string\">'github-webhook-handler'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> handler = createHandler(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'/webhooks_push'</span>, <span class=\"attr\">secret</span>: <span class=\"string\">'leonlei1226'</span> &#125;)</div><div class=\"line\"><span class=\"comment\">// 上面的 secret 保持和 GitHub 后台设置的一致</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run_cmd</span>(<span class=\"params\">cmd, args, callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> spawn = <span class=\"built_in\">require</span>(<span class=\"string\">'child_process'</span>).spawn;</div><div class=\"line\">  <span class=\"keyword\">var</span> child = spawn(cmd, args);</div><div class=\"line\">  <span class=\"keyword\">var</span> resp = <span class=\"string\">\"\"</span>;</div><div class=\"line\"></div><div class=\"line\">  child.stdout.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">buffer</span>) </span>&#123; resp += buffer.toString(); &#125;);</div><div class=\"line\">  child.stdout.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; callback (resp) &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">handler.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">'Error:'</span>, err.message)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">handler.on(<span class=\"string\">'push'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Received a push event for %s to %s'</span>,</div><div class=\"line\">    event.payload.repository.name,</div><div class=\"line\">    event.payload.ref);</div><div class=\"line\">    run_cmd(<span class=\"string\">'sh'</span>, [<span class=\"string\">'./deploy.sh'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">text</span>)</span>&#123; <span class=\"built_in\">console</span>.log(text) &#125;);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">  http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    handler(req, res, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">      res.statusCode = <span class=\"number\">404</span></div><div class=\"line\">      res.end(<span class=\"string\">'no such location'</span>)</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;).listen(<span class=\"number\">6666</span>)</div><div class=\"line\">&#125;<span class=\"keyword\">catch</span>(err)&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">'Error:'</span>, err.message)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中 <strong>secret</strong> 要和 github 仓库中 webhooks 设置的一致，<strong>6666</strong> 是监听端口可以随便改，不要冲突就行，<strong>./deploy.sh</strong> 是接收到 push 事件时需要执行的shell脚本，与 <code>webhooks.js</code> 都存放在博客目录下；<strong>path: ‘/webhooks_push</strong> 是 github 通知服务器的地址，完整的地址是这样的<code>http://www.gaoshilei.com:6666/webhooks_push</code>  </p>\n<blockquote>\n<p>用 https 会报错，github 设置页面会 deliver error，所以把地址改成了 http</p>\n</blockquote>\n<p>配置<code>./deploy.sh</code>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS hexo-blog]# vim deploy.sh</div></pre></td></tr></table></figure>\n<p>将下面代码拷贝进去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull origin master</div><div class=\"line\">hexo g</div></pre></td></tr></table></figure>\n<p>然后运行  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS hexo-blog]# node webhooks.js</div></pre></td></tr></table></figure>\n<p>就可以实现本地更新 push 到 github ，服务器会自动更新部署博客。<br>最后要将进程加入守护，通过 pm2 来实现  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# npm install pm2 --global</div></pre></td></tr></table></figure>\n<p>然后通过 pm2 启动 <code>webhooks.js</code>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS hexo-blog]# pm2 start /root/hexo-blog/webhooks.js </div><div class=\"line\">[PM2] Starting /root/hexo-blog/webhooks.js in fork_mode (1 instance)</div><div class=\"line\">[PM2] Done.</div><div class=\"line\">┌──────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐</div><div class=\"line\">│ App name │ id │ mode │ pid   │ status │ restart │ uptime │ cpu │ mem       │ user │ watching │</div><div class=\"line\">├──────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤</div><div class=\"line\">│ webhooks │ 0  │ fork │ 10010 │ online │ 0       │ 0s     │ 14% │ 24.2 MB   │ root │ disabled │</div><div class=\"line\">└──────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘</div><div class=\"line\"> Use `pm2 show &lt;id|name&gt;` to get more details about an app</div></pre></td></tr></table></figure>\n<p>如果服务器重启，我们还要手动开启webhooks服务，所以我们将上面的命令加入开机启动就可以了，将命令加入<code>/etc/rc.d/rc.local</code>中，即可实现开机自启<br>先将命令写到脚本<code>/root/webhooks_auto.sh</code>中：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/sbin/runuser -l root -c &quot;/usr/bin/pm2 start /root/hexo-blog/webhooks.js&quot;</div></pre></td></tr></table></figure>\n<p>然后在<code>/etc/rc.d/rc.local</code>中添加刚才的脚本：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/root/webhooks_auto.sh 2&gt;&amp;1 &gt; /dev/null &amp;</div></pre></td></tr></table></figure>\n<p>重启VPS，然后用命令<code>pm2 show webhooks</code>查看 webhooks 是否已经启动。</p>\n<h2 id=\"全站-HTTPS\"><a href=\"#全站-HTTPS\" class=\"headerlink\" title=\"全站 HTTPS\"></a>全站 HTTPS</h2><p>使用 Let’s Encrypt 的免费证书，不过每三个月要续签一次。安装可以通过 Certbot 的傻瓜式操作  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS www]# wget https://dl.eff.org/certbot-auto</div><div class=\"line\">[root@California_VPS www]# chmod a+x certbot-auto</div></pre></td></tr></table></figure>\n<p>下载脚本，然后赋权  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS www]# sudo ./certbot-auto --nginx</div></pre></td></tr></table></figure>\n<p>执行脚本，获取证书，Certbot 会自动帮我们配置 nginx 的一些配置。走到最后可能遇到这种情况  </p>\n<blockquote>\n<p>Cannot find a VirtualHost matching domain www.gaoshilei.com. In order for Certbot to correctly perform the challenge please add a corresponding server_name directive to your nginx configuration: <a href=\"https://nginx.org/en/docs/http/server_names.html\" target=\"_blank\" rel=\"external\">https://nginx.org/en/docs/http/server_names.html</a></p>\n</blockquote>\n<p>之前在配置 nginx.conf 文件的时候忘记加域名了，把 server_name 补全就行了，然后重新执行一次脚本。你还可能遇到这样的问题  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Creating virtual environment...</div><div class=\"line\">[root@California_VPS www]# ./certbot-auto: line 864: virtualenv: command not found</div></pre></td></tr></table></figure>\n<p>缺少<code>virtualenv</code>环境，依次执行下面的命令下面进行安装：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS www]# curl https://bootstrap.pypa.io/get-pip.py | python -</div><div class=\"line\">[root@California_VPS www]# pip install virtualenv</div></pre></td></tr></table></figure>\n<p>然后执行上面的命令<code>sudo ./certbot-auto --nginx</code>继续安装证书，中间需要我们输入邮箱，域名等等，按照步骤操作就可以，最后顺利申请了证书，而且 Certbot 都帮我配置好了，nice！<br>不过这个证书有效期只有三个月，所以需要续签，可以手动续签，证书快过期的时候执行  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># sudo /root/www/certbot-auto renew</div></pre></td></tr></table></figure>\n<p>或者将上面的命令加入 <code>crontab</code> 定时任务  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS etc]# ps -ef | grep cron</div><div class=\"line\">root      1164     1  0 Oct30 ?        00:00:00 crond</div><div class=\"line\">root      8507  8222  0 07:31 pts/0    00:00:00 grep cron  </div><div class=\"line\">[root@California_VPS etc]# service crond status</div><div class=\"line\">crond (pid  1164) is running...</div></pre></td></tr></table></figure>\n<p>先检查一下有没有安装 crontab，并且查看 crontab 的运行状态。最后配置  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS etc]# crontab -e</div></pre></td></tr></table></figure>\n<p>添加下面这条命令到配置文件中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">0 0 * * 0 /root/www/certbot-auto renew</div></pre></td></tr></table></figure>\n<p>这条命令的意思是每周日的0点0分执行<code>/root/www/certbot-auto renew</code>这条命令。执行下面这条命令查看定时任务列表中是否有刚才添加的任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS etc]# crontab -l </div><div class=\"line\">0 0 * * 0 /root/www/certbot-auto renew</div></pre></td></tr></table></figure>\n<p>大功告成！</p>\n","site":{"data":{}},"excerpt":"<p>本文档主要用来记录自己借助<a href=\"https://hexo.io\" target=\"_blank\" rel=\"external\">Hexo</a>搭建博客的一些步骤和命令，方便以后重装；新人也可以通过此篇文章快速搭建自己的个人博客。<br>下文的环境为:<br>VPS： CentOS6.9<br>本地： MacOS  </p>\n<h2 id=\"搭建博客\"><a href=\"#搭建博客\" class=\"headerlink\" title=\"搭建博客\"></a>搭建博客</h2><h3 id=\"1、安装-NodeJS-和-NPM\"><a href=\"#1、安装-NodeJS-和-NPM\" class=\"headerlink\" title=\"1、安装 NodeJS 和 NPM\"></a>1、安装 NodeJS 和 NPM</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -</div></pre></td></tr></table></figure>\n<p>执行完这个命令之后就可以安装NodeJS  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# yum install -y nodejs</div></pre></td></tr></table></figure>","more":"<p>这里安装的是8.X版本，如果安装其他版本将<code>setup_8.x</code>中的8改成对应的版本就可以了。<br>安装完成之后执行命令检查安装结果：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# node -v</div><div class=\"line\">v8.8.1</div><div class=\"line\">[root@California_VPS ~]# npm -v</div><div class=\"line\">5.4.2</div></pre></td></tr></table></figure>\n<p>转载请注明出处：<a href=\"http://www.gaoshilei.com\">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>\n<h3 id=\"2、安装-Nginx\"><a href=\"#2、安装-Nginx\" class=\"headerlink\" title=\"2、安装 Nginx\"></a>2、安装 Nginx</h3><p>通过 yum方式安装比较麻烦，还需要安装epel依赖库，下面介绍一种最简单的安装方法 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# vim /etc/yum.repos.d/nginx.repo</div></pre></td></tr></table></figure>\n<p>先在 yum.repos.d 文件下新建一个<code>nginx.repo</code>，然后将下面的内容拷贝进去，<code>:wq</code>保存退出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[nginx]</div><div class=\"line\">name=nginx repo</div><div class=\"line\">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</div><div class=\"line\">gpgcheck=0</div><div class=\"line\">enabled=1</div></pre></td></tr></table></figure>\n<p>执行下面的命令直接从配置文件安装 nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# yum install nginx -y</div></pre></td></tr></table></figure>\n<p>然后启动nginx  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@c_vps ~]# nginx</div></pre></td></tr></table></figure>\n<p>然后打开服务器所在的IP测试nginx是否安装完成。</p>\n<h3 id=\"3、安装-Hexo\"><a href=\"#3、安装-Hexo\" class=\"headerlink\" title=\"3、安装 Hexo\"></a>3、安装 Hexo</h3><p>按照官网的文档执行命令  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<p>顺利的话一会就安装好了，有时候会遇到 npm 权限问题  </p>\n<blockquote>\n<p>/usr/bin/hexo -&gt; /usr/lib/node_modules/hexo-cli/bin/hexo<br>hexo-util@0.6.1 postinstall /usr/lib/node_modules/hexo-cli/node_modules/hexo-util<br>npm run build:highlight<br>hexo-util@0.6.1 build:highlight /usr/lib/node_modules/hexo-cli/node_modules/hexo-util<br>node scripts/build_highlight_alias.js &gt; highlight_alias.json<br>sh: highlight_alias.json: 权限不够<br>npm ERR! code ELIFECYCLE<br>npm ERR! errno 1<br>npm ERR! hexo-util@0.6.1 build:highlight: <code>node scripts/build_highlight_alias.js &gt; highlight_alias.json</code><br>npm ERR! Exit status 1<br>npm ERR!<br>npm ERR! Failed at the hexo-util@0.6.1 build:highlight script.<br>npm ERR! This is probably not a problem with npm. There is likely additional logging output above.  </p>\n</blockquote>\n<p>这个时候需要开启 npm 的 unsafe-perm 模式  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# npm config set unsafe-perm &quot;true&quot;</div></pre></td></tr></table></figure>\n<p>查看是否设置成功  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# npm config get unsafe-perm</div><div class=\"line\">true</div></pre></td></tr></table></figure>\n<p>如果为 <code>true</code> 则设置成功，再次执行 hexo 的安装命令即可顺利安装成功。  </p>\n<p>因为需要把之前在 github 的博客备份重新拷贝新的服务器上，所以要配置 ssh 公钥方便 git 操作。</p>\n<p>先生成公钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# ssh-keygen -t rsa -b 4096 -C &quot;xxxxx@xxx.com&quot;</div></pre></td></tr></table></figure>\n<p>这一步会生成ssh公钥，也就是 public key，生成之后可以通过下面的命令查看  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ls -al ~/.ssh</div></pre></td></tr></table></figure>\n<p>如果有 <code>id_rsa</code> <code>id_rsa.pub</code> 证明生成成功，然后通过下面的命令查看 ssh 公钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure>\n<p>再将这个公钥拷贝到 github 的账户配置中即可。   </p>\n<p><strong>注意：  为了方便在本地修改博客、实时预览、自动部署，以上（除了Nginx安装）所有步骤在本地机器上也需要重新操作一遍，以后在本地直接修改之后推送github，配合下文的webhook，服务器会自动更新</strong>  </p>\n<h3 id=\"4、配置博客\"><a href=\"#4、配置博客\" class=\"headerlink\" title=\"4、配置博客\"></a>4、配置博客</h3><p>新安装：参照 <a href=\"https://hexo.io/zh-cn/docs/setup.html\" target=\"_blank\" rel=\"external\">Hexo官方教程</a><br>重装：从 github 上把之前的博客 clone 下来，放到 root 目录下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone git@github.com:gaoshilei/hexo-blog.git</div></pre></td></tr></table></figure>\n<p>进入博客目录，一次执行下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@c_vps hexo-blog]# npm install hexo</div><div class=\"line\">[root@c_vps hexo-blog]# npm install</div></pre></td></tr></table></figure>\n<p>然后配置 nginx，让 80 端口指向博客静态页面首页，在 nginx 配置文件目中新建一个<code>hexo.conf</code>文件 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# vim /etc/nginx/conf.d/hexo.conf</div></pre></td></tr></table></figure>\n<p>写入相应的配置  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">    listen          80;</div><div class=\"line\">    server_name     gaoshilei.com www.gaoshilei.com;</div><div class=\"line\">    location / &#123;</div><div class=\"line\">        root        /root/hexo-blog/public;</div><div class=\"line\">        index       index.html;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重启 nginx 使服务生效  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# nginx -s reload</div></pre></td></tr></table></figure>\n<p>此时去访问博客得到的是一个 404 或者 403 报错，因为 nginx 是以 nginx 用户运行的，他没有博客目录的读写权限，有两个方法可以解决：  </p>\n<ol>\n<li>给博客目录赋权，让 nginx 用户拥有读写权限</li>\n<li>让 nginx 以 root 用户运行 </li>\n</ol>\n<p>我采用第二种方式，修改 nginx 的配置文件  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# vim /etc/nginx/nginx.conf</div></pre></td></tr></table></figure>\n<p>将 <code>user  nginx;</code> 改成 <code>user  root;</code> 即可。然后重启 nginx。  </p>\n<p>再去访问发现报错没了，但是页面是一片空白，找了半天原因，之前用到的主题并没有上传到 github 上，将主题拷贝到 <code>themes</code> 文件夹下，然后部署 hexo 就可以正常访问了。  </p>\n<p><strong>hexo 常用的命令</strong><br>生成静态文件并部署网站:  </p>\n<p>安装 hexo 服务（本地可以通过这个服务实现预览，不需要安装nginx）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># npm install hexo-server --save</div></pre></td></tr></table></figure>\n<p>启动 hexo 服务，默认端口为 4000</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># hexo server</div></pre></td></tr></table></figure>\n<p>用指定端口(port)启动启动 hexo 服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># hexo server -p port</div></pre></td></tr></table></figure>\n<p>生成静态文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># hexo g</div></pre></td></tr></table></figure>\n<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># hexo clean</div></pre></td></tr></table></figure>\n<p>生成站点map  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># npm install hexo-generator-sitemap --save</div><div class=\"line\"># npm install hexo-generator-baidu-sitemap --save</div></pre></td></tr></table></figure>\n<h2 id=\"配置-webhooks-自动更新博客\"><a href=\"#配置-webhooks-自动更新博客\" class=\"headerlink\" title=\"配置 webhooks 自动更新博客\"></a>配置 webhooks 自动更新博客</h2><p>每次在本地更新了博客，push 到 github 上，还要去 VPS 再 git pull 一下，确实很麻烦，配置好 webhooks 就可以在 github 有 push 操作时自动更新并部署博客。  </p>\n<p>webhooks 在 github 对应仓库直接设置就行，重点是服务器的接收和相应的操作。<br>有 Python、PHP、NodeJS 多种方式可以接收 webhooks , 由于 hexo 是基于 NodeJS 的，所以这里用 NodeJS 来接收 github 的 push 事件。 </p>\n<p>安装依赖库 <code>github-webhook-handler</code>：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# npm install -g github-webhook-handler</div></pre></td></tr></table></figure>\n<p>安装完成之后配置 <code>webhooks.js</code>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS hexo-blog]# vim webhooks.js</div></pre></td></tr></table></figure>\n<p>然后将下面代码的拷贝进去  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> createHandler = <span class=\"built_in\">require</span>(<span class=\"string\">'github-webhook-handler'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> handler = createHandler(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'/webhooks_push'</span>, <span class=\"attr\">secret</span>: <span class=\"string\">'leonlei1226'</span> &#125;)</div><div class=\"line\"><span class=\"comment\">// 上面的 secret 保持和 GitHub 后台设置的一致</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run_cmd</span>(<span class=\"params\">cmd, args, callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> spawn = <span class=\"built_in\">require</span>(<span class=\"string\">'child_process'</span>).spawn;</div><div class=\"line\">  <span class=\"keyword\">var</span> child = spawn(cmd, args);</div><div class=\"line\">  <span class=\"keyword\">var</span> resp = <span class=\"string\">\"\"</span>;</div><div class=\"line\"></div><div class=\"line\">  child.stdout.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">buffer</span>) </span>&#123; resp += buffer.toString(); &#125;);</div><div class=\"line\">  child.stdout.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; callback (resp) &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">handler.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">'Error:'</span>, err.message)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">handler.on(<span class=\"string\">'push'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Received a push event for %s to %s'</span>,</div><div class=\"line\">    event.payload.repository.name,</div><div class=\"line\">    event.payload.ref);</div><div class=\"line\">    run_cmd(<span class=\"string\">'sh'</span>, [<span class=\"string\">'./deploy.sh'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">text</span>)</span>&#123; <span class=\"built_in\">console</span>.log(text) &#125;);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">  http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    handler(req, res, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">      res.statusCode = <span class=\"number\">404</span></div><div class=\"line\">      res.end(<span class=\"string\">'no such location'</span>)</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;).listen(<span class=\"number\">6666</span>)</div><div class=\"line\">&#125;<span class=\"keyword\">catch</span>(err)&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">'Error:'</span>, err.message)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中 <strong>secret</strong> 要和 github 仓库中 webhooks 设置的一致，<strong>6666</strong> 是监听端口可以随便改，不要冲突就行，<strong>./deploy.sh</strong> 是接收到 push 事件时需要执行的shell脚本，与 <code>webhooks.js</code> 都存放在博客目录下；<strong>path: ‘/webhooks_push</strong> 是 github 通知服务器的地址，完整的地址是这样的<code>http://www.gaoshilei.com:6666/webhooks_push</code>  </p>\n<blockquote>\n<p>用 https 会报错，github 设置页面会 deliver error，所以把地址改成了 http</p>\n</blockquote>\n<p>配置<code>./deploy.sh</code>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS hexo-blog]# vim deploy.sh</div></pre></td></tr></table></figure>\n<p>将下面代码拷贝进去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull origin master</div><div class=\"line\">hexo g</div></pre></td></tr></table></figure>\n<p>然后运行  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS hexo-blog]# node webhooks.js</div></pre></td></tr></table></figure>\n<p>就可以实现本地更新 push 到 github ，服务器会自动更新部署博客。<br>最后要将进程加入守护，通过 pm2 来实现  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS ~]# npm install pm2 --global</div></pre></td></tr></table></figure>\n<p>然后通过 pm2 启动 <code>webhooks.js</code>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS hexo-blog]# pm2 start /root/hexo-blog/webhooks.js </div><div class=\"line\">[PM2] Starting /root/hexo-blog/webhooks.js in fork_mode (1 instance)</div><div class=\"line\">[PM2] Done.</div><div class=\"line\">┌──────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐</div><div class=\"line\">│ App name │ id │ mode │ pid   │ status │ restart │ uptime │ cpu │ mem       │ user │ watching │</div><div class=\"line\">├──────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤</div><div class=\"line\">│ webhooks │ 0  │ fork │ 10010 │ online │ 0       │ 0s     │ 14% │ 24.2 MB   │ root │ disabled │</div><div class=\"line\">└──────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘</div><div class=\"line\"> Use `pm2 show &lt;id|name&gt;` to get more details about an app</div></pre></td></tr></table></figure>\n<p>如果服务器重启，我们还要手动开启webhooks服务，所以我们将上面的命令加入开机启动就可以了，将命令加入<code>/etc/rc.d/rc.local</code>中，即可实现开机自启<br>先将命令写到脚本<code>/root/webhooks_auto.sh</code>中：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/sbin/runuser -l root -c &quot;/usr/bin/pm2 start /root/hexo-blog/webhooks.js&quot;</div></pre></td></tr></table></figure>\n<p>然后在<code>/etc/rc.d/rc.local</code>中添加刚才的脚本：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/root/webhooks_auto.sh 2&gt;&amp;1 &gt; /dev/null &amp;</div></pre></td></tr></table></figure>\n<p>重启VPS，然后用命令<code>pm2 show webhooks</code>查看 webhooks 是否已经启动。</p>\n<h2 id=\"全站-HTTPS\"><a href=\"#全站-HTTPS\" class=\"headerlink\" title=\"全站 HTTPS\"></a>全站 HTTPS</h2><p>使用 Let’s Encrypt 的免费证书，不过每三个月要续签一次。安装可以通过 Certbot 的傻瓜式操作  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS www]# wget https://dl.eff.org/certbot-auto</div><div class=\"line\">[root@California_VPS www]# chmod a+x certbot-auto</div></pre></td></tr></table></figure>\n<p>下载脚本，然后赋权  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS www]# sudo ./certbot-auto --nginx</div></pre></td></tr></table></figure>\n<p>执行脚本，获取证书，Certbot 会自动帮我们配置 nginx 的一些配置。走到最后可能遇到这种情况  </p>\n<blockquote>\n<p>Cannot find a VirtualHost matching domain www.gaoshilei.com. In order for Certbot to correctly perform the challenge please add a corresponding server_name directive to your nginx configuration: <a href=\"https://nginx.org/en/docs/http/server_names.html\" target=\"_blank\" rel=\"external\">https://nginx.org/en/docs/http/server_names.html</a></p>\n</blockquote>\n<p>之前在配置 nginx.conf 文件的时候忘记加域名了，把 server_name 补全就行了，然后重新执行一次脚本。你还可能遇到这样的问题  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Creating virtual environment...</div><div class=\"line\">[root@California_VPS www]# ./certbot-auto: line 864: virtualenv: command not found</div></pre></td></tr></table></figure>\n<p>缺少<code>virtualenv</code>环境，依次执行下面的命令下面进行安装：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS www]# curl https://bootstrap.pypa.io/get-pip.py | python -</div><div class=\"line\">[root@California_VPS www]# pip install virtualenv</div></pre></td></tr></table></figure>\n<p>然后执行上面的命令<code>sudo ./certbot-auto --nginx</code>继续安装证书，中间需要我们输入邮箱，域名等等，按照步骤操作就可以，最后顺利申请了证书，而且 Certbot 都帮我配置好了，nice！<br>不过这个证书有效期只有三个月，所以需要续签，可以手动续签，证书快过期的时候执行  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># sudo /root/www/certbot-auto renew</div></pre></td></tr></table></figure>\n<p>或者将上面的命令加入 <code>crontab</code> 定时任务  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS etc]# ps -ef | grep cron</div><div class=\"line\">root      1164     1  0 Oct30 ?        00:00:00 crond</div><div class=\"line\">root      8507  8222  0 07:31 pts/0    00:00:00 grep cron  </div><div class=\"line\">[root@California_VPS etc]# service crond status</div><div class=\"line\">crond (pid  1164) is running...</div></pre></td></tr></table></figure>\n<p>先检查一下有没有安装 crontab，并且查看 crontab 的运行状态。最后配置  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS etc]# crontab -e</div></pre></td></tr></table></figure>\n<p>添加下面这条命令到配置文件中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">0 0 * * 0 /root/www/certbot-auto renew</div></pre></td></tr></table></figure>\n<p>这条命令的意思是每周日的0点0分执行<code>/root/www/certbot-auto renew</code>这条命令。执行下面这条命令查看定时任务列表中是否有刚才添加的任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@California_VPS etc]# crontab -l </div><div class=\"line\">0 0 * * 0 /root/www/certbot-auto renew</div></pre></td></tr></table></figure>\n<p>大功告成！</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj9no6vma000ajaenaapqem8p","category_id":"cj9no6vm90008jaeni4pyiyb2","_id":"cj9no6vms000hjaeny8m2p6p8"},{"post_id":"cj9no6vlw0002jaen87mu7nu5","category_id":"cj9no6vm90008jaeni4pyiyb2","_id":"cj9no6vmu000ljaen4onmg3qf"},{"post_id":"cj9no6vmf000bjaen5ive6f1k","category_id":"cj9no6vm90008jaeni4pyiyb2","_id":"cj9no6vmv000njaenbbvwh7iz"},{"post_id":"cj9no6vmn000fjaen5cn518s8","category_id":"cj9no6vm90008jaeni4pyiyb2","_id":"cj9no6vmw000rjaenk9bprg8h"},{"post_id":"cj9no6vm20005jaens0ytdj0c","category_id":"cj9no6vm90008jaeni4pyiyb2","_id":"cj9no6vmw000tjaenhfd1suzy"},{"post_id":"cj9no6vm50006jaengg25tbbj","category_id":"cj9no6vms000ijaentisnxwan","_id":"cj9no6vmw000vjaen0ba00fu2"},{"post_id":"cj9no6vm80007jaen6ahy2418","category_id":"cj9no6vmv000pjaentvk5eg1e","_id":"cj9no6vmx000yjaenm2vhdvqi"},{"post_id":"cj9no6vmq000gjaenm90zjodj","category_id":"cj9no6vmv000pjaentvk5eg1e","_id":"cj9no6vmy0010jaenbvpedtcu"},{"post_id":"cj9no6vnu002cjaeny56df995","category_id":"cj9no6vmv000pjaentvk5eg1e","_id":"cj9no6vo4002ijaen2l7niboc"},{"post_id":"cj9no6vnx002ejaen0xdg4moq","category_id":"cj9no6vmv000pjaentvk5eg1e","_id":"cj9no6vo5002kjaen1wx743zd"},{"post_id":"cj9no6vo1002hjaen8ulf1786","category_id":"cj9no6vo5002jjaencgblcj5n","_id":"cj9no6vo6002njaen6h1aazsr"},{"post_id":"cja3m8z9p0000qeenczoemygy","category_id":"cj9no6vlz0003jaenw88zhzpq","_id":"cja3m8za80004qeen9wj4dfuo"},{"post_id":"cja3m8za00001qeen0adv2zqb","category_id":"cj9no6vlz0003jaenw88zhzpq","_id":"cja3m8za90006qeeniwt7t4xs"},{"post_id":"cja3nqn0u0000qqendt66oqmz","category_id":"cj9no6vmx000xjaenue3sd7dw","_id":"cja3nqn0x0002qqennt6a6ark"}],"PostTag":[{"post_id":"cj9no6vlw0002jaen87mu7nu5","tag_id":"cj9no6vmt000jjaenkqivuinv","_id":"cj9no6vmy0012jaen0cmr10ws"},{"post_id":"cj9no6vlw0002jaen87mu7nu5","tag_id":"cj9no6vmv000qjaenpsrmkr6p","_id":"cj9no6vmy0014jaendbq5d1ob"},{"post_id":"cj9no6vlw0002jaen87mu7nu5","tag_id":"cj9no6vmw000wjaenxhhrcb0k","_id":"cj9no6vmz0016jaenykymnuwa"},{"post_id":"cj9no6vlw0002jaen87mu7nu5","tag_id":"cj9no6vmx000zjaens0j8vs5y","_id":"cj9no6vmz0017jaenbdwwdhd4"},{"post_id":"cj9no6vm20005jaens0ytdj0c","tag_id":"cj9no6vmy0011jaenlrw8q9at","_id":"cj9no6vn2001bjaenq948wzpo"},{"post_id":"cj9no6vm20005jaens0ytdj0c","tag_id":"cj9no6vmz0015jaenfk016itx","_id":"cj9no6vn2001cjaen6q9fkfx4"},{"post_id":"cj9no6vm20005jaens0ytdj0c","tag_id":"cj9no6vmz0018jaens1sd0rec","_id":"cj9no6vn2001ejaenk4ob6fg1"},{"post_id":"cj9no6vm20005jaens0ytdj0c","tag_id":"cj9no6vn00019jaenjszattwr","_id":"cj9no6vn2001fjaen75feunbs"},{"post_id":"cj9no6vm50006jaengg25tbbj","tag_id":"cj9no6vn0001ajaenhxsjgehw","_id":"cj9no6vn4001hjaenxqfcbyvn"},{"post_id":"cj9no6vm50006jaengg25tbbj","tag_id":"cj9no6vn2001djaena5m6bqsc","_id":"cj9no6vn4001ijaenf7oz0og6"},{"post_id":"cj9no6vm80007jaen6ahy2418","tag_id":"cj9no6vn2001gjaene045vxup","_id":"cj9no6vn6001ljaenrxjp7q6g"},{"post_id":"cj9no6vm80007jaen6ahy2418","tag_id":"cj9no6vn4001jjaenvw4dm8ah","_id":"cj9no6vn6001mjaenm448v3nr"},{"post_id":"cj9no6vma000ajaenaapqem8p","tag_id":"cj9no6vmy0011jaenlrw8q9at","_id":"cj9no6vn8001rjaenxejuigd5"},{"post_id":"cj9no6vma000ajaenaapqem8p","tag_id":"cj9no6vmz0015jaenfk016itx","_id":"cj9no6vn8001sjaen2axm2e2k"},{"post_id":"cj9no6vma000ajaenaapqem8p","tag_id":"cj9no6vmz0018jaens1sd0rec","_id":"cj9no6vn9001ujaen70pk7cvl"},{"post_id":"cj9no6vma000ajaenaapqem8p","tag_id":"cj9no6vn00019jaenjszattwr","_id":"cj9no6vn9001vjaen6vyblo0f"},{"post_id":"cj9no6vmf000bjaen5ive6f1k","tag_id":"cj9no6vn8001qjaenn0nj1tue","_id":"cj9no6vn9001xjaeng6zw65y9"},{"post_id":"cj9no6vmf000bjaen5ive6f1k","tag_id":"cj9no6vn8001tjaenntn0pkyb","_id":"cj9no6vn9001yjaengfs5e212"},{"post_id":"cj9no6vmn000fjaen5cn518s8","tag_id":"cj9no6vn9001wjaeny2w5jlqg","_id":"cj9no6vnc0023jaen2li3zgxm"},{"post_id":"cj9no6vmn000fjaen5cn518s8","tag_id":"cj9no6vn9001zjaeng2psrn3k","_id":"cj9no6vnc0024jaen9w7myeye"},{"post_id":"cj9no6vmn000fjaen5cn518s8","tag_id":"cj9no6vnb0020jaenzssn1035","_id":"cj9no6vnc0026jaen5nujsz9u"},{"post_id":"cj9no6vmn000fjaen5cn518s8","tag_id":"cj9no6vnb0021jaen6zx4l45q","_id":"cj9no6vnc0027jaenswtaawda"},{"post_id":"cj9no6vmq000gjaenm90zjodj","tag_id":"cj9no6vnb0022jaenroh58nc1","_id":"cj9no6vne0029jaenx7ur1wap"},{"post_id":"cj9no6vmq000gjaenm90zjodj","tag_id":"cj9no6vnc0025jaen0u7uei8f","_id":"cj9no6vne002ajaenkfg438s7"},{"post_id":"cj9no6vnu002cjaeny56df995","tag_id":"cj9no6vo1002gjaen67jusao6","_id":"cj9no6vo7002qjaen8gac4dz2"},{"post_id":"cj9no6vnu002cjaeny56df995","tag_id":"cj9no6vo5002ljaen5q1sr2b7","_id":"cj9no6vo7002rjaenjap27qg9"},{"post_id":"cj9no6vnu002cjaeny56df995","tag_id":"cj9no6vo6002mjaen7ztbdna5","_id":"cj9no6vo8002tjaenct9vz6qh"},{"post_id":"cj9no6vnu002cjaeny56df995","tag_id":"cj9no6vo6002ojaen9yft62y5","_id":"cj9no6vo8002ujaen90ugrpcf"},{"post_id":"cj9no6vnx002ejaen0xdg4moq","tag_id":"cj9no6vo1002gjaen67jusao6","_id":"cj9no6vob002yjaen7hpa97ea"},{"post_id":"cj9no6vnx002ejaen0xdg4moq","tag_id":"cj9no6vo5002ljaen5q1sr2b7","_id":"cj9no6vob002zjaenhtuka36n"},{"post_id":"cj9no6vnx002ejaen0xdg4moq","tag_id":"cj9no6vo6002mjaen7ztbdna5","_id":"cj9no6voc0030jaenz0kuw8ld"},{"post_id":"cj9no6vnx002ejaen0xdg4moq","tag_id":"cj9no6vo6002ojaen9yft62y5","_id":"cj9no6voc0031jaenlrh2u60s"},{"post_id":"cj9no6vo1002hjaen8ulf1786","tag_id":"cj9no6voa002xjaen02cfjzhq","_id":"cj9no6voc0032jaen8r7tfnni"},{"post_id":"cj9no6vo1002hjaen8ulf1786","tag_id":"cj9no6vn9001zjaeng2psrn3k","_id":"cj9no6voc0033jaendsuixy4y"},{"post_id":"cja3m8z9p0000qeenczoemygy","tag_id":"cj9no6vm10004jaenlqnhts6a","_id":"cja3m8za50002qeencvaz5n4q"},{"post_id":"cja3m8z9p0000qeenczoemygy","tag_id":"cj9no6vm90009jaenmhqf5yrj","_id":"cja3m8za80003qeen42xygmxm"},{"post_id":"cja3m8z9p0000qeenczoemygy","tag_id":"cj9no6vmj000ejaenx7s9sdfw","_id":"cja3m8za90005qeen96rabo4o"},{"post_id":"cja3m8za00001qeen0adv2zqb","tag_id":"cj9no6vm10004jaenlqnhts6a","_id":"cja3m8zaa0007qeenfmippzje"},{"post_id":"cja3m8za00001qeen0adv2zqb","tag_id":"cj9no6vm90009jaenmhqf5yrj","_id":"cja3m8zaa0008qeent8jghvy3"},{"post_id":"cja3m8za00001qeen0adv2zqb","tag_id":"cj9no6vmj000ejaenx7s9sdfw","_id":"cja3m8zab0009qeenw7vngchp"},{"post_id":"cja3nqn0u0000qqendt66oqmz","tag_id":"cj9no6vnd0028jaenxtolqkjs","_id":"cja3nqn0w0001qqen2s4ogo1n"}],"Tag":[{"name":"VPS","_id":"cj9no6vm10004jaenlqnhts6a"},{"name":"VPN","_id":"cj9no6vm90009jaenmhqf5yrj"},{"name":"Shadowsocks","_id":"cj9no6vmj000ejaenx7s9sdfw"},{"name":"RunLoop","_id":"cj9no6vmt000jjaenkqivuinv"},{"name":"NSTimer","_id":"cj9no6vmv000qjaenpsrmkr6p"},{"name":"AutoreleasePool","_id":"cj9no6vmw000wjaenxhhrcb0k"},{"name":"AFNetworking","_id":"cj9no6vmx000zjaens0j8vs5y"},{"name":"Weex","_id":"cj9no6vmy0011jaenlrw8q9at"},{"name":"Vue","_id":"cj9no6vmz0015jaenfk016itx"},{"name":"JS","_id":"cj9no6vmz0018jaens1sd0rec"},{"name":"前端","_id":"cj9no6vn00019jaenjszattwr"},{"name":"Xcode","_id":"cj9no6vn0001ajaenhxsjgehw"},{"name":"Cocopods","_id":"cj9no6vn2001djaena5m6bqsc"},{"name":"dumpdecrypted","_id":"cj9no6vn2001gjaene045vxup"},{"name":"砸壳","_id":"cj9no6vn4001jjaenvw4dm8ah"},{"name":"block","_id":"cj9no6vn8001qjaenn0nj1tue"},{"name":"retain cycle","_id":"cj9no6vn8001tjaenntn0pkyb"},{"name":"静态库","_id":"cj9no6vn9001wjaeny2w5jlqg"},{"name":"动态库","_id":"cj9no6vn9001zjaeng2psrn3k"},{"name":"framework","_id":"cj9no6vnb0020jaenzssn1035"},{"name":"SDK","_id":"cj9no6vnb0021jaen6zx4l45q"},{"name":"serial Number","_id":"cj9no6vnb0022jaenroh58nc1"},{"name":"UDID","_id":"cj9no6vnc0025jaen0u7uei8f"},{"name":"个人博客","_id":"cj9no6vnd0028jaenxtolqkjs"},{"name":"微信","_id":"cj9no6vo1002gjaen67jusao6"},{"name":"汇编语言","_id":"cj9no6vo5002ljaen5q1sr2b7"},{"name":"IDA","_id":"cj9no6vo6002mjaen7ztbdna5"},{"name":"重签名","_id":"cj9no6vo6002ojaen9yft62y5"},{"name":"黑科技","_id":"cj9no6voa002xjaen02cfjzhq"}]}}