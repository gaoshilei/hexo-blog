<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>路是月的痕</title>
  
  <subtitle>代码略懂，精通LOL</subtitle>
  <link href="http://www.gaoshilei.com/atom.xml" rel="self"/>
  
  <link href="http://www.gaoshilei.com/"/>
  <updated>2023-10-20T08:44:35.699Z</updated>
  <id>http://www.gaoshilei.com/</id>
  
  <author>
    <name>LeonLei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS计算误差小谈</title>
    <link href="http://www.gaoshilei.com/js_double/"/>
    <id>http://www.gaoshilei.com/js_double/</id>
    <published>2019-01-07T16:00:01.000Z</published>
    <updated>2023-10-20T08:44:35.699Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>平时在写js代码时会用到一些简单的计算，比方说系统中我们数据库储存的金额是分，前端展示的是元，所以在用户输入元之后要转成分传给后台，这个公式小学一年级就学过了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.11*100 = 111</span><br></pre></td></tr></table></figure><p>一般来说这个计算结果是没问题的，但是在js里面却有这样的尴尬</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.11*100 = 111.00000000000001</span><br></pre></td></tr></table></figure><p>结果不是我们想要的111，类似的情况还有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.1+0.2 = 0.30000000000000004   //加法</span><br><span class="line">0.27-0.11 = 0.16000000000000003 //减法</span><br><span class="line">19.9*100 = 1989.9999999999998   //乘法</span><br><span class="line">0.3/0.1 = 2.9999999999999996    //除法</span><br></pre></td></tr></table></figure><p>一般遇到这种问题，我们都有成熟的解决方案解决</p><ul><li><a href="https://github.com/josdejong/mathjs">Math.js</a></li><li><a href="https://github.com/MikeMcl/decimal.js">decimal.js</a></li></ul><p>用着用着就习惯了，一直没有搞清楚为什么会有这样的误差。这两天正好有空，看了一些博客终于搞清楚了。</p><span id="more"></span><h2 id="双精度浮点数"><a href="#双精度浮点数" class="headerlink" title="双精度浮点数"></a>双精度浮点数</h2><p>JS 的数据类型比较特别，和<code>C、Java</code> 等语言的的数据类型不一样，不管是 <code>int、double、float</code> 在 JS 里面都是<code>Number</code>类型。<br>要搞清楚为什么有这个误差，就要先介绍一下<strong>双精度浮点</strong>(double)</p><p>双精度浮点数(double)使用 64 位（8字节） 来储存一个浮点数。 它可以表示十进位制的15或16位有效数字，其可以表示的数字的绝对值范围大约是 <code>[2.23*10^(-308),1.79*10^(308)]</code>。</p><p>这其中的64位bit又可以分为下面的格式</p><ul><li>sign bit(符号位)：0代表正数，1代表负数</li><li>exponent(指数)：中间的11位用来表示次方数</li><li>mantissa(尾数)：最后的52位用来表示精确度</li></ul><p><img src="http://img.gaoshilei.com/687474703a2f2f617461322d696d672e636e2d68616e677a686f752e696d672d7075622e616c6979756e2d696e632e636f6d2f37323637613538623239383932633362373233653364366333663733393035612e706e67.png" loading="lazy"></p><p>上面的格式可以转换成这个这个公式<br><img src="http://img.gaoshilei.com/Xnip2019-01-22_18-33-33.png" loading="lazy"></p><p>在十进制中，整数部分可以是0<del>9，在二进制中整数部分只能是0</del>1，所以可以看到上面公式对应的整数部分只能是1，这样就可以不用管整数部分直接保留后面的小数部分就可以了。指数 exponent(E) 是一个无符号整型 (unsigned int) ，那么问题就来了，我们怎么保留小数呢？按照科学计数法，如果E小于0才可以表示成小数，因为E是11位的，最大可以表示为2047，所以取一个中间值1023（十六进制为ox3FF），0<del>1022表示为负，1023</del>2047表示为正，这样就解决了小数的表示问题。  </p><p>我们来看看数字 1 是怎么储存的</p><p><img src="http://img.gaoshilei.com/Xnip2019-01-22_19-18-53.png" loading="lazy"></p><p>用上面的公式表示就是：<code>(-1)^0 * 2^(1024-1023) * 1.0 = 1</code>，再看一下 0.5 的储存形式</p><p><img src="http://img.gaoshilei.com/Xnip2019-01-24_11-09-30.png" loading="lazy"></p><p><code>(-1)^0 * 2^(1022-1023) * 1.0 = 0.5</code>，搞清楚这个，我们再看看上面提到的 <code>1.11*100 = 111.00000000000001</code> 这个问题。  </p><p>将 1.11 转换成二进制是这样的<code>1.0001110000101000111101011100001010001111010111000011...</code>(11100001010001111010循环)（<a href="https://www.sojson.com/hexconvert.html">十进制小数转二进制方法</a>)，换成64位浮点来表示，S为0，E为1023，mantissa(M)为0001110000101000111101011100001010001111010111000011，因为位数只有52位，后面循环的部分就被舍弃了，转成64位浮点数是这样的<br><img src="http://img.gaoshilei.com/Xnip2019-01-22_19-37-10.png" loading="lazy"><br>然后转成10进制的就变成了 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.11000000000000009769962616701</span><br></pre></td></tr></table></figure><p>所以这里出现了问题，误差就有了，究其根本还是精度的问题。</p><h2 id="还有一个问题？"><a href="#还有一个问题？" class="headerlink" title="还有一个问题？"></a>还有一个问题？</h2><blockquote><p>为什么我直接输入 1.11 得到的结果是 1.11，而不是1.11000000000000009769962616701 呢？</p></blockquote><p>这个还是<strong>精度</strong>问题，64位浮点的尾数是52位，因为整数部分只能是1所以可以省略一位，比方说  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11.101 * 2^1001 可以格式化为 1.1101 * 2^1010，尾数部分M直接储存1101即可；</span><br><span class="line">0.0011101 * 2^-1001 可以格式化为 1.1101 * 2^-1100，尾数部分M储存1101即可。  </span><br></pre></td></tr></table></figure><p>所以他可以表示的最大长度是53，即2^53 &#x3D; 9007199254740992，所以<strong>双精度浮点</strong>能表示的最大精度是 16 位的，JS 会调用 toPrecision(16) 来做运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.11.toPrecision(16) = 1.110000000000000 //自动取整之后就是1.11</span><br></pre></td></tr></table></figure><p>如果精度调整一下，结果就不一样了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.11.toPrecision(17) = 1.1100000000000001</span><br><span class="line">1.11.toPrecision(20) = 1.1100000000000000977</span><br></pre></td></tr></table></figure><p>到这里终于真相大白了！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;平时在写js代码时会用到一些简单的计算，比方说系统中我们数据库储存的金额是分，前端展示的是元，所以在用户输入元之后要转成分传给后台，这个公式小学一年级就学过了&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.11*100 = 111&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一般来说这个计算结果是没问题的，但是在js里面却有这样的尴尬&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.11*100 = 111.00000000000001&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结果不是我们想要的111，类似的情况还有&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0.1+0.2 = 0.30000000000000004   //加法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0.27-0.11 = 0.16000000000000003 //减法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19.9*100 = 1989.9999999999998   //乘法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0.3/0.1 = 2.9999999999999996    //除法&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一般遇到这种问题，我们都有成熟的解决方案解决&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/josdejong/mathjs&quot;&gt;Math.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/MikeMcl/decimal.js&quot;&gt;decimal.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用着用着就习惯了，一直没有搞清楚为什么会有这样的误差。这两天正好有空，看了一些博客终于搞清楚了。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="http://www.gaoshilei.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JS" scheme="http://www.gaoshilei.com/tags/JS/"/>
    
    <category term="双精度浮点" scheme="http://www.gaoshilei.com/tags/%E5%8F%8C%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9/"/>
    
    <category term="数据误差" scheme="http://www.gaoshilei.com/tags/%E6%95%B0%E6%8D%AE%E8%AF%AF%E5%B7%AE/"/>
    
  </entry>
  
  <entry>
    <title>如何使用CocoaPods管理第三方SDK</title>
    <link href="http://www.gaoshilei.com/cocopods_private_sdk_repo/"/>
    <id>http://www.gaoshilei.com/cocopods_private_sdk_repo/</id>
    <published>2018-01-18T16:00:00.000Z</published>
    <updated>2023-10-20T12:27:24.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近整理项目，发现用到了很多第三方的SDK，这些SDK都是直接拖到项目里面的比较乱，打算把这些乱七八糟的第三方SDK全都交给 CocoaPods 来管理。</p><h1 id="什么是CocoaPods？"><a href="#什么是CocoaPods？" class="headerlink" title="什么是CocoaPods？"></a>什么是CocoaPods？</h1><p> <img src="http://img.gaoshilei.com/whats_cocoapods.jpg" alt="一脸懵逼" loading="lazy"><br> 你不知道 CocoaPods 是什么？给你个传送门 <a href="https://cocoapods.org/">https://cocoapods.org</a></p><h1 id="CocoaPods-新建本地仓库"><a href="#CocoaPods-新建本地仓库" class="headerlink" title="CocoaPods 新建本地仓库"></a>CocoaPods 新建本地仓库</h1><p>这里我用微信 SDK 来举个栗子，从微信开发者中心下载对应的 SDK。</p><span id="more"></span> <img src="http://img.gaoshilei.com/cocopods_example.jpeg?imageMogr2/thumbnail/!45p" alt="举个栗子" align=center / loading="lazy">  <p> 我们得到一个 WechatSDK 文件夹，里面的内容也比较简单</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">└── <span class="title class_">WechatSDK</span>  </span><br><span class="line">    ├── libWeChatSDK.<span class="property">a</span> </span><br><span class="line">    ├── <span class="variable constant_">README</span>.<span class="property">txt</span></span><br><span class="line">    ├── <span class="title class_">WechatAuthSDK</span>.<span class="property">h</span></span><br><span class="line">    ├── <span class="title class_">WXApi</span>.<span class="property">h</span></span><br><span class="line">    └── <span class="title class_">WXApiObject</span>.<span class="property">h</span>  </span><br></pre></td></tr></table></figure><p>要让 CocoaPods 来管理第三方 SDK，我们需要将第三方 SDK 制作成一个仓库，跟平时我们使用 Podfile 一样。 下面我们要在  WechatSDK 目录下新建一个 <code>.podspec</code> 格式的文件，这个文件主要是用来描述当前仓库的一些信息，它的格式官网有介绍，不赘述。<a href="http://guides.cocoapods.org/syntax/podspec.html">http://guides.cocoapods.org/syntax/podspec.html</a>  </p><p>转载请注明出处：<a href="http://www.gaoshilei.com/">来自LeonLei的博客http://www.gaoshilei.com</a>   </p><p>按照他要求的格式，新建 WechatSDK.podspec 并填入下面这些信息：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="title class_">Pod::Spec</span>.new <span class="keyword">do</span> |<span class="params">s</span>|</span><br><span class="line">  s.name         = <span class="string">&quot;WechatSDK&quot;</span> <span class="comment">#必填，仓库的名称，Podfile中会用到，类似于 AFNetworking</span></span><br><span class="line"></span><br><span class="line">  s.version      = <span class="string">&quot;1.8.2&quot;</span> <span class="comment">#必填，版本号</span></span><br><span class="line"></span><br><span class="line">  s.summary      = <span class="string">&quot;微信SDK&quot;</span> <span class="comment"># 随便写写吧</span></span><br><span class="line"></span><br><span class="line">  s.description  = <span class="string">&lt;&lt;-DESC # 随便写写吧</span></span><br><span class="line"><span class="string">                    WechatSDK repo</span></span><br><span class="line"><span class="string">                     DESC</span></span><br><span class="line"></span><br><span class="line">  s.homepage     = <span class="string">&quot;http://git.internal.weyao.com/gaoshilei/WechatSDK&quot;</span> <span class="comment"># 随便写写吧</span></span><br><span class="line">  s.license    =  <span class="string">&#x27;MIT&#x27;</span> <span class="comment"># 随便写写吧</span></span><br><span class="line">  s.authors      = &#123; <span class="string">&quot;gaoshilei&quot;</span> =&gt; <span class="string">&quot;goslei@163.com&quot;</span> &#125; <span class="comment"># 随便写写吧</span></span><br><span class="line">  s.platform     = <span class="symbol">:ios</span> <span class="comment"># 必填</span></span><br><span class="line">  s.ios.deployment_target = <span class="string">&#x27;8.0&#x27;</span> <span class="comment"># 必填</span></span><br><span class="line">  s.source =  &#123; <span class="symbol">:git</span> =&gt; <span class="string">&#x27;./Vendors/WechatSDK&#x27;</span>, <span class="symbol">:tag</span> =&gt; <span class="string">&quot;1.8.2&quot;</span> &#125; <span class="comment"># 必填，这是你的仓库相对于 Podfile 的路径（我试过写绝对路径，最后报错了）</span></span><br><span class="line">  s.source_files = <span class="string">&#x27;*.&#123;h,m,mm,c&#125;&#x27;</span> <span class="comment"># 必填，代码文件。如果你还有二级目录，要包含所有二级目录中的代码文件，用**表示。上面给的链接中也有介绍</span></span><br><span class="line">  <span class="comment"># s.frameworks = &#x27;QuartzCore&#x27;, &#x27;CoreData&#x27; #这里是第三方 SDK 使用到的一些系统 Framework</span></span><br><span class="line">  s.vendored_libraries = <span class="string">&#x27;libWeChatSDK.a&#x27;</span> <span class="comment"># 如果第三方 SDK 有lib包，这个是必填的（注意路径）</span></span><br><span class="line">  <span class="comment"># s.vendored_frameworks = &#x27;ThirdPartyFramework.framework&#x27; #第三方SDK如果有 Framework，需要在这里加上（注意路径）</span></span><br><span class="line">  s.requires_arc = <span class="literal">true</span> <span class="comment"># 加上就行，除非你还在写MRC的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <code>s.source</code> 这个键需要详细讲解一下。这是 CocoaPods 需要读取的 git 仓库地址，这里直接写成本地的仓库路径就可以了，不过要在 WechatSDK 文件夹中新建 git 仓库。然后 tag 能对应上就可以了。在当前目录下执行下面的命令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br><span class="line">git add.</span><br><span class="line">git commit -m &quot;commit&quot;</span><br><span class="line">git tag 1.8.2</span><br></pre></td></tr></table></figure><p>注意 git 仓库地址的路径要填相对于你项目 Podfile 的路径，我的项目 Podfile 跟 文件夹 Vendors 是同级的，所以我应该这么写 <code>./Vendors/WechatSDK</code> 。<br>到这里工作已经完成一大半了，下面就是要在项目 Podfile 文件中正确配置  </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">&#x27;AFNetworking&#x27;</span></span><br><span class="line">......</span><br><span class="line">pod <span class="string">&#x27;WechatSDK&#x27;</span>, <span class="symbol">:podspec</span> =&gt; <span class="string">&#x27;./Vendors/WechatSDK/WechatSDK.podspec&#x27;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>后面指定仓库配置文件的路径就可以了，这里也要注意是相对于 Podfile 文件的路径。然后在项目中执行 <code>pod install --no-repo-update</code> 安装，一般可能会有以下的问题（我在制作过程中遇到的）  </p><p>第一种情况： </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[!] <span class="title class_">Failed</span> to load <span class="string">&#x27;WechatSDK&#x27;</span> <span class="symbol">podspec:</span></span><br><span class="line">[!] <span class="title class_">Invalid</span> <span class="string">`WechatSDK.podspec`</span> <span class="symbol">file:</span> undefined local variable <span class="keyword">or</span> method <span class="string">`tag`</span> <span class="keyword">for</span> <span class="title class_">Pod</span><span class="symbol">:Module</span></span><br></pre></td></tr></table></figure><p>这种情况是 CocoaPods 没有找到仓库的 podspec 配置文件，原因是 Podfile 中的路径写错了，改成仓库相对于 Podfile 的路径就可以了。</p><p>第二种情况：  </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[!] <span class="title class_">Error</span> installing <span class="title class_">Wechat</span>SDK</span><br><span class="line">[!] /usr/bin/git clone <span class="variable">$HOME</span>/<span class="title class_">Desktop</span>/<span class="title class_">LittleBee</span>/<span class="title class_">LittleBee</span>_iOS/<span class="title class_">Vendors</span>/<span class="title class_">Wechat</span>SDK /var/folders/6y/w9bcrs915g17gt732n84x6p40000gn/T/d20180119-<span class="number">75062</span>-1jdxrw8 --template= --single-branch --depth <span class="number">1</span> --branch <span class="number">1.8</span>.<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">fatal:</span> repository <span class="string">&#x27;$HOME/Desktop/LittleBee/LittleBee_iOS/Vendors/WechatSDK&#x27;</span> does <span class="keyword">not</span> exist</span><br></pre></td></tr></table></figure><p>这就很明显了，仓库找不到，因为 <code>WechatSDK.podspec</code> 中<code>s.source</code>路径写的是绝对路径，解决方法就是改成相对路径。  </p><p>第三种情况：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[!] <span class="title class_">The</span> <span class="string">`WechatSDK`</span> pod failed to validate due to <span class="number">1</span> <span class="symbol">error:</span></span><br><span class="line">    - <span class="variable constant_">ERROR</span> |<span class="params"> [iOS] File Patterns: File patterns must be relative <span class="keyword">and</span> cannot start with a slash (source_files).</span></span><br></pre></td></tr></table></figure><p>这种情况就是 podspec 配置文件格式不对，对照官网的文档修改一下就行。   </p><p><strong>上面是将第三方 SDK 制作成了 CocoaPods 库，你也可以将你自己的代码制作成库，将 s.source 改成 github 上的地址，就制作了一个线上可以共享的 CocoaPods 库，类似于 AFNetworking，这个要多一个步骤，将自己的开源库配置文件推送到 CocoaPods 的 podspec 仓库中（我还没有制作过，具体步骤自行百度或者谷歌吧）</strong></p><h1 id="创建私有中心仓库"><a href="#创建私有中心仓库" class="headerlink" title="创建私有中心仓库"></a>创建私有中心仓库</h1><p>上面都完成，貌似是挺完美，但还是有缺陷的。明显跟我们平时使用的 pod 格式不一样，后面还要配置路径太麻烦了，如果能这样用：  </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">&#x27;AFNetworking&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;WechatSDK&#x27;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这样岂不就完美了！CocoaPods 其实是通过 podspec 来管理所有的仓库的，在我们的本地有一个目录 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.cocoapods/repos</span><br></pre></td></tr></table></figure><p>CocoaPods 把中心仓库放在了这个位置，所以平时我们执行 <code>pod install</code> 都会去这个中心仓库查看是否有对应的目标开源组件，然后<code>git clone</code>下来，所以有时候明明有这个开源组件，但是我们执行 <code>pod install</code> 总提示安装失败，没有这个目录。那是因为本地的 repos 太旧了，这个时候执行 <code>pod repo update</code> 一下就可以了。基于 CocoaPods 这个原理，我们就可以实现上面提到的方式了。</p><p>先看下 CocoaPods 的中心仓库是怎么管理这些开源插件的</p><p><img src="http://img.gaoshilei.com/cocopods_central_repo.png" alt="AFNetworking" loading="lazy">  </p><p>路径是这个样子的  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LeonLeiMBP15-145:AFNetworking gaoshilei$ pwd</span><br><span class="line">/Users/gaoshilei/.cocoapods/repos/master/Specs/a/7/5/AFNetworking</span><br><span class="line">LeonLeiMBP15-145:AFNetworking gaoshilei$ cd 3.1.0/</span><br><span class="line">LeonLeiMBP15-145:3.1.0 gaoshilei$ ls -o</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r--  1 gaoshilei  2889 12 19  2016 AFNetworking.podspec.json</span><br></pre></td></tr></table></figure><p>AFNetworking 下面有很多版本号的文件夹，每个版本号下面对应的是仓库的配置文件.podspec格式化的json文件。照葫芦画瓢我们就可以创建自己的私有中心仓库。找个目录建立自己的私有中心仓库  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LeonLeiMBP15-145:~ gaoshilei$ cd Desktop/</span><br><span class="line">LeonLeiMBP15-145:Desktop gaoshilei$ mkdir CocopodsPrivate</span><br><span class="line">LeonLeiMBP15-145:Desktop gaoshilei$ cd CocopodsPrivate/</span><br><span class="line">LeonLeiMBP15-145:CocopodsPrivate gaoshilei$ mkdir WechatSDK</span><br><span class="line">LeonLeiMBP15-145:CocopodsPrivate gaoshilei$ cd WechatSDK/</span><br><span class="line">LeonLeiMBP15-145:WechatSDK gaoshilei$ mkdir 1.8.2</span><br><span class="line">LeonLeiMBP15-145:WechatSDK gaoshilei$ cd 1.8.2/</span><br><span class="line">LeonLeiMBP15-145:1.8.2 gaoshilei$ cp ~/Desktop/LittleBee/LittleBee_iOS/Vendors/WechatSDK/WechatSDK.podspec .</span><br></pre></td></tr></table></figure><p>此时私有中心仓库已经建好了，下面就是要让 CocoaPods 知道这个仓库的存在，为了方便团队开发时直接使用，这个中心仓库需要放到公司 git 上共享：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LeonLeiMBP15-145:CocopodsPrivate gaoshilei$ git init</span><br><span class="line">Initialized empty Git repository in /Users/gaoshilei/Desktop/CocopodsPrivate/.git/</span><br><span class="line">LeonLeiMBP15-145:CocopodsPrivate gaoshilei$ git add .</span><br><span class="line">LeonLeiMBP15-145:CocopodsPrivate gaoshilei$ git commit -m &quot;first commit&quot;</span><br><span class="line">[master (root-commit) aa27f56] first commit</span><br><span class="line"> 1 file changed, 25 insertions(+)</span><br><span class="line"> create mode 100644 WechatSDK/1.8.2/WechatSDK.podspec</span><br><span class="line">LeonLeiMBP15-145:CocopodsPrivate gaoshilei$ git remote add origin git@git.internal.weyao.com:gaoshilei/CocoapodsPrivate.git</span><br><span class="line">LeonLeiMBP15-145:CocopodsPrivate gaoshilei$ git push origin master</span><br></pre></td></tr></table></figure><p>然后再将这个私有中心仓库添加到 CocoaPods 中  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LeonLeiMBP15-145:CocopodsPrivate gaoshilei$ pod repo add CocoapodsPrivate git@git.internal.weyao.com:gaoshilei/CocoapodsPrivate.git</span><br></pre></td></tr></table></figure><p>添加成功之后，执行 <code>pod search WechatSDK</code> 可以看到，刚才添加的已经可以搜到了，并且版本号后面显示来自仓库<code>CocoapodsPrivate</code>  </p><p><img src="http://img.gaoshilei.com/pod_search_wechatsdk_CocoapodsPrivate.png" alt="私有仓库搜索结果" loading="lazy">  </p><p>让团队其他成员执行 <code>pod repo add CocoapodsPrivate git@git.internal.weyao.com:gaoshilei/CocoapodsPrivate.git</code> 之后，就可以使用这个私有中心仓库了。  </p><p>PS：当你可以搜到 <code>WechatSDK</code> 时却无法正常执行 <code>pod install</code>，会报这样的错：<code>[!] Unable to find a specification for &#39;WechatSDK&#39;</code> ，那是因为项目的 Podfile 中需要添加相应的仓库地址才行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#x27;8.0&#x27;</span><br><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="line">source &#x27;git@git.internal.weyao.com:gaoshilei/CocoapodsPrivate.git&#x27;</span><br><span class="line">......</span><br><span class="line">  pod &#x27;WechatSDK&#x27;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>把这两条添加进去，然后再执行 <code>pod install</code> 就没问题了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近整理项目，发现用到了很多第三方的SDK，这些SDK都是直接拖到项目里面的比较乱，打算把这些乱七八糟的第三方SDK全都交给 CocoaPods 来管理。&lt;/p&gt;
&lt;h1 id=&quot;什么是CocoaPods？&quot;&gt;&lt;a href=&quot;#什么是CocoaPods？&quot; class=&quot;headerlink&quot; title=&quot;什么是CocoaPods？&quot;&gt;&lt;/a&gt;什么是CocoaPods？&lt;/h1&gt;&lt;p&gt; &lt;img src=&quot;http://img.gaoshilei.com/whats_cocoapods.jpg&quot; alt=&quot;一脸懵逼&quot;&gt;&lt;br&gt; 你不知道 CocoaPods 是什么？给你个传送门 &lt;a href=&quot;https://cocoapods.org/&quot;&gt;https://cocoapods.org&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;CocoaPods-新建本地仓库&quot;&gt;&lt;a href=&quot;#CocoaPods-新建本地仓库&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods 新建本地仓库&quot;&gt;&lt;/a&gt;CocoaPods 新建本地仓库&lt;/h1&gt;&lt;p&gt;这里我用微信 SDK 来举个栗子，从微信开发者中心下载对应的 SDK。&lt;/p&gt;</summary>
    
    
    
    <category term="小技巧" scheme="http://www.gaoshilei.com/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="CocoaPods" scheme="http://www.gaoshilei.com/tags/CocoaPods/"/>
    
    <category term="SDK" scheme="http://www.gaoshilei.com/tags/SDK/"/>
    
  </entry>
  
  <entry>
    <title>搭建微信小程序服务</title>
    <link href="http://www.gaoshilei.com/wechatproservice/"/>
    <id>http://www.gaoshilei.com/wechatproservice/</id>
    <published>2017-11-27T03:58:00.000Z</published>
    <updated>2023-10-20T08:42:15.421Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p> 1、域名<br> 2、注册开发者账号<br> 3、开发者后台配置服务器信息  </p><h1 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h1><h2 id="搭建HTTP服务"><a href="#搭建HTTP服务" class="headerlink" title="搭建HTTP服务"></a>搭建HTTP服务</h2><h3 id="安装NodeJS和NPM"><a href="#安装NodeJS和NPM" class="headerlink" title="安装NodeJS和NPM"></a>安装NodeJS和NPM</h3><p>执行下面的命令安装：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -</span><br><span class="line">yum install nodejs -y</span><br></pre></td></tr></table></figure> <span id="more"></span><h3 id="编写-HTTP-Server-源码"><a href="#编写-HTTP-Server-源码" class="headerlink" title="编写 HTTP Server 源码"></a>编写 HTTP Server 源码</h3><p>先创建一个工作目录  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@172.17.0.9:~</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> -p /data/release/weapp</span></span><br></pre></td></tr></table></figure><p>然后进入这个目录  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@172.17.0.9:~</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> /data/release/weapp/</span></span><br></pre></td></tr></table></figure><p>创建<code>package.json</code>文件  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@172.17.0.9:/data/release/weapp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vi package.json</span></span><br></pre></td></tr></table></figure><p>拷贝下面的内容进去  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;weapp&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来创建<code>app.js</code>文件，拷贝下面内容  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用 express 来支持 HTTP Server 的实现</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 express 实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现唯一的一个中间件，对于所有请求，都输出 &quot;Response from express&quot;</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">    response.<span class="title function_">write</span>(<span class="string">&#x27;Response from express&#x27;</span>);</span><br><span class="line">    response.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口，等待连接</span></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8765</span>;</span><br><span class="line">app.<span class="title function_">listen</span>(port);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出服务器启动日志</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server listening at http://127.0.0.1:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>这里调用了<code>Express.js</code>监听8765端口。  </p><h3 id="运行HTTP服务"><a href="#运行HTTP服务" class="headerlink" title="运行HTTP服务"></a>运行HTTP服务</h3><p>这里我们用pm2来守护HTTP服务，首先安装pm2  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@172.17.0.9:/data/release/weapp</span><br><span class="line"># npm install pm2 --global</span><br></pre></td></tr></table></figure><p>上一步配置HTTP服务的时候，用到了<code>Express.js</code>，我们要安装相应的依赖  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@172.17.0.9:/data/release/weapp</span><br><span class="line"># npm install express --save</span><br></pre></td></tr></table></figure><p>然后用pm2来启动HTTP服务  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@172.17.0.9:/data/release/weapp</span><br><span class="line"># pm2 start app.js --watch</span><br></pre></td></tr></table></figure><p>查看当前服务信息可通过  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@172.17.0.9:/data/release/weapp</span><br><span class="line"># pm2 show app</span><br></pre></td></tr></table></figure><h2 id="搭建HTTPS服务"><a href="#搭建HTTPS服务" class="headerlink" title="搭建HTTPS服务"></a>搭建HTTPS服务</h2><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>可以直接通过yum来安装  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@172.17.0.9:/data/release/weapp</span><br><span class="line"># yum install nginx -y</span><br></pre></td></tr></table></figure><p>如果这里报错没有nginx包，需要新建配置文件    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><p>将下面的内容粘贴到配置文件中  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=<span class="attr">http</span>:<span class="comment">//nginx.org/packages/centos/$releasever/$basearch/</span></span><br><span class="line">gpgcheck=<span class="number">0</span></span><br><span class="line">enabled=<span class="number">1</span> </span><br></pre></td></tr></table></figure><p>然后再执行第一步的安装命令即可。</p><h3 id="配置HTTPS反向代理"><a href="#配置HTTPS反向代理" class="headerlink" title="配置HTTPS反向代理"></a>配置HTTPS反向代理</h3><p>首先配置nginx的配置文件  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@172.17.0.9:/etc/nginx/conf.d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim ssl.conf</span></span><br></pre></td></tr></table></figure><p>把下面的内容拷进去  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443;</span><br><span class="line">        server_name www.leonlei.top; # 改为绑定证书的域名</span><br><span class="line">        # ssl 配置</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate 1_www.leonlei.top_bundle.crt; # 改为自己申请得到的 crt 文件的名称</span><br><span class="line">        ssl_certificate_key 2_www.leonlei.top.key; # 改为自己申请得到的 key 文件的名称</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:8765;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后将再腾讯云申请的免费SSL证书上传到<code>/etc/nginx</code>目录下  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LeonLeiMBP15-110:gaoshilei$ scp -p /Users/gaoshilei/Downloads/www/Nginx/1_www.leonlei.top_bundle.crt root@115.159.87.164:/etc/nginx/1_www.leonlei.top_bundle.crt </span><br><span class="line">LeonLeiMBP15-110:gaoshilei$ scp -p /Users/gaoshilei/Downloads/www/Nginx/2_www.leonlei.top.key root@115.159.87.164:/etc/nginx/2_www.leonlei.top.key</span><br></pre></td></tr></table></figure><p>然后重启nginx  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@172.17.0.9:/etc/nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nginx -s reload</span></span><br></pre></td></tr></table></figure><h2 id="配置小程序会话"><a href="#配置小程序会话" class="headerlink" title="配置小程序会话"></a>配置小程序会话</h2><p>由于小程序不支持cookies和浏览器的缓存机制，需要创建独立的会话层，这里我们用另外一台服务器用来做会话</p><h3 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_13_centos ~]# yum install mongodb-server mongodb -y</span><br></pre></td></tr></table></figure><p>安装完成之后查看是否安装成功  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_13_centos ~]# mongod --version</span><br><span class="line">db version v2.6.12</span><br><span class="line">2017-11-27T18:11:21.773+0800 git version: nogitversion</span><br><span class="line">2017-11-27T18:11:21.773+0800 OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013</span><br><span class="line">[root@VM_0_13_centos ~]# mongo --version</span><br><span class="line">MongoDB shell version: 2.6.12</span><br></pre></td></tr></table></figure><h3 id="启动MongoDB"><a href="#启动MongoDB" class="headerlink" title="启动MongoDB"></a>启动MongoDB</h3><p>创建数据储存和日志的储存目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_13_centos ~]# mkdir -p /data/mongodb</span><br><span class="line">[root@VM_0_13_centos ~]# mkdir -p /data/logs/mongodb</span><br></pre></td></tr></table></figure><p>然后使用命令启动MongoDB   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_13_centos ~]# mongod --fork --dbpath /data/mongodb --logpath /data/logs/mongodb/weapp.log</span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 6660</span><br><span class="line">child process started successfully, parent exiting  </span><br></pre></td></tr></table></figure><p>使用命令查看是否启动成功  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_13_centos ~]# netstat -ltp | grep 27017</span><br><span class="line">tcp        0      0 0.0.0.0:27017           0.0.0.0:*               LISTEN      6660/mongod</span><br></pre></td></tr></table></figure><h3 id="添加-MongoDB-用户"><a href="#添加-MongoDB-用户" class="headerlink" title="添加 MongoDB 用户"></a>添加 MongoDB 用户</h3><p>登录数据库  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_13_centos ~]# mongo</span><br><span class="line">MongoDB shell version: 2.6.12</span><br><span class="line">connecting to: test</span><br><span class="line">Welcome to the MongoDB shell.</span><br><span class="line">For interactive help, type &quot;help&quot;.</span><br><span class="line">For more comprehensive documentation, see</span><br><span class="line">        http://docs.mongodb.org/</span><br><span class="line">Questions? Try the support group</span><br><span class="line">        http://groups.google.com/group/mongodb-user</span><br><span class="line">Server has startup warnings:</span><br><span class="line">2017-11-27T18:13:28.129+0800 [initandlisten]</span><br><span class="line">2017-11-27T18:13:28.129+0800 [initandlisten] ** WARNING: Readahead for /data/mongodb is set to 4096KB</span><br><span class="line">2017-11-27T18:13:28.129+0800 [initandlisten] **          We suggest setting it to 256KB (512 sectors) or less</span><br><span class="line">2017-11-27T18:13:28.129+0800 [initandlisten] **          http://dochub.mongodb.org/core/readahead</span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure><p>然后创建一个用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; use weapp</span><br><span class="line">switched to db weapp</span><br><span class="line">&gt; db.createUser(&#123; user: &#x27;weapp&#x27;, pwd: &#x27;weapp-dev&#x27;, roles: [&#x27;dbAdmin&#x27;, &#x27;readWrite&#x27;]&#125;);</span><br><span class="line">Successfully added user: &#123; &quot;user&quot; : &quot;wechatapp&quot;, &quot;roles&quot; : [ &quot;dbAdmin&quot;, &quot;readWrite&quot; ] &#125;</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure><h3 id="安装Node模块"><a href="#安装Node模块" class="headerlink" title="安装Node模块"></a>安装Node模块</h3><p>实现小程序的会话功能，需要安装 connect-mongo 和 wafer-node-session，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_13_centos ~]# cd /data/release/weapp</span><br><span class="line"></span><br><span class="line">[root@VM_0_13_centos /data/release/weapp]# npm install connect-mongo wafer-node-session --save</span><br></pre></td></tr></table></figure><h3 id="实现小程序会话"><a href="#实现小程序会话" class="headerlink" title="实现小程序会话"></a>实现小程序会话</h3><p>在目录<code>/data/release/weapp</code>中新建文件<code>config.js</code>，然后将下面的代码拷入（注意appID和appSecret）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; </span><br><span class="line">    <span class="attr">serverPort</span>: <span class="string">&#x27;8765&#x27;</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小程序 appId 和 appSecret </span></span><br><span class="line">    <span class="comment">// 请到 https://mp.weixin.qq.com 获取 AppID 和 AppSecret</span></span><br><span class="line">    <span class="attr">appId</span>: <span class="string">&#x27;wx9fd292461a087d38&#x27;</span>, </span><br><span class="line">    <span class="attr">appSecret</span>: <span class="string">&#x27;b05144b0d40a08337bb2c476dc543f8a&#x27;</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">// mongodb 连接配置，生产环境请使用更复杂的用户名密码</span></span><br><span class="line">    <span class="attr">mongoHost</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, </span><br><span class="line">    <span class="attr">mongoPort</span>: <span class="string">&#x27;27017&#x27;</span>, </span><br><span class="line">    <span class="attr">mongoUser</span>: <span class="string">&#x27;weapp&#x27;</span>, </span><br><span class="line">    <span class="attr">mongoPass</span>: <span class="string">&#x27;weapp-dev&#x27;</span>, </span><br><span class="line">    <span class="attr">mongoDb</span>: <span class="string">&#x27;weapp&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改<code>app.js</code>，添加会话逻辑  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用 express 来支持 HTTP Server 的实现</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 引用 wafer-session 支持小程序会话</span></span><br><span class="line"><span class="keyword">const</span> waferSession = <span class="built_in">require</span>(<span class="string">&#x27;wafer-node-session&#x27;</span>); </span><br><span class="line"><span class="comment">// 使用 MongoDB 作为会话的存储</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MongoStore</span> = <span class="built_in">require</span>(<span class="string">&#x27;connect-mongo&#x27;</span>)(waferSession); </span><br><span class="line"><span class="comment">// 引入配置文件</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./config&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 express 实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加会话中间件，登录地址是 /login</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">waferSession</span>(&#123; </span><br><span class="line">    <span class="attr">appId</span>: config.<span class="property">appId</span>, </span><br><span class="line">    <span class="attr">appSecret</span>: config.<span class="property">appSecret</span>, </span><br><span class="line">    <span class="attr">loginPath</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">    <span class="attr">store</span>: <span class="keyword">new</span> <span class="title class_">MongoStore</span>(&#123; </span><br><span class="line">        <span class="attr">url</span>: <span class="string">`mongodb://<span class="subst">$&#123;config.mongoUser&#125;</span>:<span class="subst">$&#123;config.mongoPass&#125;</span>@<span class="subst">$&#123;config.mongoHost&#125;</span>:<span class="subst">$&#123;config.mongoPort&#125;</span>/<span class="subst">$&#123;config.mongoDb&#125;</span>`</span> </span><br><span class="line">    &#125;) </span><br><span class="line">&#125;)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在路由 /me 下，输出会话里包含的用户信息</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/me&#x27;</span>, <span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123; </span><br><span class="line">    response.<span class="title function_">json</span>(request.<span class="property">session</span> ? request.<span class="property">session</span>.<span class="property">userInfo</span> : &#123; <span class="attr">noBody</span>: <span class="literal">true</span> &#125;); </span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">session</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Wafer session success with openId=<span class="subst">$&#123;request.session.userInfo.openId&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个中间件，对于未处理的请求，都输出 &quot;Response from express&quot;</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">    response.<span class="title function_">write</span>(<span class="string">&#x27;Response from express&#x27;</span>);</span><br><span class="line">    response.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口，等待连接</span></span><br><span class="line">app.<span class="title function_">listen</span>(config.<span class="property">serverPort</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出服务器启动日志</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server listening at http://127.0.0.1:<span class="subst">$&#123;config.serverPort&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>添加完成重启服务  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@172.17.0.9:/data/release/weapp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pm2 restart app</span></span><br><span class="line">Use --update-env to update environment variables</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt; In-memory PM2 is out-of-date, <span class="keyword">do</span>:</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt; $ pm2 update</span></span><br><span class="line">In memory PM2 version: 2.0.18</span><br><span class="line">Local PM2 version: 2.8.0</span><br><span class="line"></span><br><span class="line">[PM2] Applying action restartProcessId on app [app](ids: 1)</span><br><span class="line">[PM2] [app](1) ✓</span><br><span class="line">┌──────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐</span><br><span class="line">│ App name │ id │ mode │ pid   │ status │ restart │ uptime │ cpu │ mem       │ user │ watching │</span><br><span class="line">├──────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤</span><br><span class="line">│ app      │ 1  │ fork │ 10193 │ online │ 7       │ 0s     │ 0%  │ 10.2 MB   │ root │ enabled  │</span><br><span class="line">│ weapp    │ 0  │ fork │ 2067  │ online │ 0       │ 19h    │ 0%  │ 45.5 MB   │ root │ disabled │</span><br><span class="line">└──────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘</span><br></pre></td></tr></table></figure><h2 id="WebSocket-服务"><a href="#WebSocket-服务" class="headerlink" title="WebSocket 服务"></a>WebSocket 服务</h2><h3 id="安装Node模块-1"><a href="#安装Node模块-1" class="headerlink" title="安装Node模块"></a>安装Node模块</h3><p>小程序使用<code>ws</code>模块与服务器实现WebSocket通信，所以先安装node依赖  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@172.17.0.9:/data/release/weapp</span><br><span class="line"># npm install ws --save</span><br></pre></td></tr></table></figure><h3 id="实现WebSocket服务"><a href="#实现WebSocket服务" class="headerlink" title="实现WebSocket服务"></a>实现WebSocket服务</h3><p>创建<code>websocket.js</code>，写入一下内容  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 ws 支持 WebSocket 的实现</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出处理方法</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">listen</span> = listen;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 HTTP Server 上处理 WebSocket 请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">http.Server</span>&#125; <span class="variable">server</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">wafer.SessionMiddleware</span>&#125; <span class="variable">sessionMiddleware</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listen</span>(<span class="params">server, sessionMiddleware</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用 HTTP Server 创建 WebSocket 服务，使用 path 参数指定需要升级为 WebSocket 的路径</span></span><br><span class="line">    <span class="keyword">const</span> wss = <span class="keyword">new</span> ws.<span class="title class_">Server</span>(&#123; server, <span class="attr">path</span>: <span class="string">&#x27;/ws&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 WebSocket 连接建立</span></span><br><span class="line">    wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">ws,request</span>) =&gt;</span> &#123;<span class="comment">// 要升级到 WebSocket 协议的 HTTP 连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被升级到 WebSocket 的请求不会被 express 处理，</span></span><br><span class="line">        <span class="comment">// 需要使用会话中间节获取会话</span></span><br><span class="line">        <span class="title function_">sessionMiddleware</span>(request, <span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> session = request.<span class="property">session</span>;</span><br><span class="line">            <span class="keyword">if</span> (!session) &#123;</span><br><span class="line">                <span class="comment">// 没有获取到会话，强制断开 WebSocket 连接</span></span><br><span class="line">                ws.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(request.<span class="property">sessionError</span>) || <span class="string">&quot;No session avaliable&quot;</span>);</span><br><span class="line">                ws.<span class="title function_">close</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保留这个日志的输出可让实验室能检查到当前步骤是否完成</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`WebSocket client connected with openId=<span class="subst">$&#123;session.userInfo.openId&#125;</span>`</span>);</span><br><span class="line">            <span class="title function_">serveMessage</span>(ws, session.<span class="property">userInfo</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 WebSocket 服务的错误</span></span><br><span class="line">    wss.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行简单的 WebSocket 服务，对于客户端发来的所有消息都回复回去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">serveMessage</span>(<span class="params">ws, userInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 监听客户端发来的消息</span></span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`WebSocket received: <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">        ws.<span class="title function_">send</span>(<span class="string">`Server: Received(<span class="subst">$&#123;message&#125;</span>)`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听关闭事件</span></span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">(<span class="params">code, message</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`WebSocket client closed (code: <span class="subst">$&#123;code&#125;</span>, message: <span class="subst">$&#123;message || <span class="string">&#x27;none&#x27;</span>&#125;</span>)`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接后马上发送 hello 消息给会话对应的用户</span></span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">`Server: 恭喜，<span class="subst">$&#123;userInfo.nickName&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>app.js</code>调用WebSocket服务 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTTP 模块同时支持 Express 和 WebSocket</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>); </span><br><span class="line"><span class="comment">// 引用 express 来支持 HTTP Server 的实现</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 引用 wafer-session 支持小程序会话</span></span><br><span class="line"><span class="keyword">const</span> waferSession = <span class="built_in">require</span>(<span class="string">&#x27;wafer-node-session&#x27;</span>); </span><br><span class="line"><span class="comment">// 使用 MongoDB 作为会话的存储</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MongoStore</span> = <span class="built_in">require</span>(<span class="string">&#x27;connect-mongo&#x27;</span>)(waferSession); </span><br><span class="line"><span class="comment">// 引入配置文件</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./config&#x27;</span>); </span><br><span class="line"><span class="comment">// 引入 WebSocket 服务实现</span></span><br><span class="line"><span class="keyword">const</span> websocket = <span class="built_in">require</span>(<span class="string">&#x27;./websocket&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 express 实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 独立出会话中间件给 express 和 ws 使用</span></span><br><span class="line"><span class="keyword">const</span> sessionMiddleware = <span class="title function_">waferSession</span>(&#123;</span><br><span class="line">    <span class="attr">appId</span>: config.<span class="property">appId</span>,</span><br><span class="line">    <span class="attr">appSecret</span>: config.<span class="property">appSecret</span>,</span><br><span class="line">    <span class="attr">loginPath</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">    <span class="attr">store</span>: <span class="keyword">new</span> <span class="title class_">MongoStore</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">`mongodb://<span class="subst">$&#123;config.mongoUser&#125;</span>:<span class="subst">$&#123;config.mongoPass&#125;</span>@<span class="subst">$&#123;config.mongoHost&#125;</span>:<span class="subst">$&#123;config.mongoPort&#125;</span>/<span class="subst">$&#123;config.mongoDb&#125;</span>`</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">use</span>(sessionMiddleware);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在路由 /me 下，输出会话里包含的用户信息</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/me&#x27;</span>, <span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123; </span><br><span class="line">    response.<span class="title function_">json</span>(request.<span class="property">session</span> ? request.<span class="property">session</span>.<span class="property">userInfo</span> : &#123; <span class="attr">noBody</span>: <span class="literal">true</span> &#125;); </span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">session</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Wafer session success with openId=<span class="subst">$&#123;request.session.userInfo.openId&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个中间件，对于未处理的请求，都输出 &quot;Response from express&quot;</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">    response.<span class="title function_">write</span>(<span class="string">&#x27;Response from express&#x27;</span>);</span><br><span class="line">    response.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 HTTP Server 而不是直接使用 express 监听</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(app);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 WebSocket 服务在创建的 HTTP 服务器上监听</span></span><br><span class="line">websocket.<span class="title function_">listen</span>(server, sessionMiddleware);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 HTTP 服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(config.<span class="property">serverPort</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出服务器启动日志</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server listening at http://127.0.0.1:<span class="subst">$&#123;config.serverPort&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>完成之后用&#96;pm2重启服务。</p><h3 id="更新Nginx代理"><a href="#更新Nginx代理" class="headerlink" title="更新Nginx代理"></a>更新Nginx代理</h3><p>需要向配置文件中添加WebSocket支持，修改之前配置好的<code>/etc/nginx/conf.d/ssl.conf</code>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># WebSocket 配置</span><br><span class="line">map $http_upgrade $connection_upgrade &#123;</span><br><span class="line">    default upgrade;</span><br><span class="line">    &#x27;&#x27;      close;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 443;</span><br><span class="line">        server_name www.leonlei.top; # 改为绑定证书的域名</span><br><span class="line">        # ssl 配置</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate 1_www.leonlei.top.crt; # 改为自己申请得到的 crt 文件的名称</span><br><span class="line">        ssl_certificate_key 2_www.leonlei.top.key; # 改为自己申请得到的 key 文件的名称</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        # WebSocket 配置</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection $connection_upgrade;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:8765;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>配置完成重启nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@172.17.0.9:/etc/nginx/conf.d</span><br><span class="line"># nginx -s reload</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;p&gt; 1、域名&lt;br&gt; 2、注册开发者账号&lt;br&gt; 3、开发者后台配置服务器信息  &lt;/p&gt;
&lt;h1 id=&quot;配置服务&quot;&gt;&lt;a href=&quot;#配置服务&quot; class=&quot;headerlink&quot; title=&quot;配置服务&quot;&gt;&lt;/a&gt;配置服务&lt;/h1&gt;&lt;h2 id=&quot;搭建HTTP服务&quot;&gt;&lt;a href=&quot;#搭建HTTP服务&quot; class=&quot;headerlink&quot; title=&quot;搭建HTTP服务&quot;&gt;&lt;/a&gt;搭建HTTP服务&lt;/h2&gt;&lt;h3 id=&quot;安装NodeJS和NPM&quot;&gt;&lt;a href=&quot;#安装NodeJS和NPM&quot; class=&quot;headerlink&quot; title=&quot;安装NodeJS和NPM&quot;&gt;&lt;/a&gt;安装NodeJS和NPM&lt;/h3&gt;&lt;p&gt;执行下面的命令安装：  &lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install nodejs -y&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="备忘录" scheme="http://www.gaoshilei.com/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
    <category term="个人博客" scheme="http://www.gaoshilei.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>快速搭建Hexo博客+webhook自动部署+全站HTTPS</title>
    <link href="http://www.gaoshilei.com/hexo-init/"/>
    <id>http://www.gaoshilei.com/hexo-init/</id>
    <published>2017-10-30T11:09:00.000Z</published>
    <updated>2023-10-20T08:42:24.462Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文档主要用来记录自己借助<a href="https://hexo.io/">Hexo</a>搭建博客的一些步骤和命令，方便以后重装；新人也可以通过此篇文章快速搭建自己的个人博客。<br>下文的环境为:<br>VPS： CentOS6.9<br>本地： MacOS  </p><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><h3 id="1、安装-NodeJS-和-NPM"><a href="#1、安装-NodeJS-和-NPM" class="headerlink" title="1、安装 NodeJS 和 NPM"></a>1、安装 NodeJS 和 NPM</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -  </span><br></pre></td></tr></table></figure><p>执行完这个命令之后就可以安装NodeJS  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# yum install -y nodejs</span><br></pre></td></tr></table></figure><span id="more"></span><p>这里安装的是8.X版本，如果安装其他版本将<code>setup_8.x</code>中的8改成对应的版本就可以了。<br>安装完成之后执行命令检查安装结果：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# node -v</span><br><span class="line">v8.8.1</span><br><span class="line">[root@California_VPS ~]# npm -v</span><br><span class="line">5.4.2</span><br></pre></td></tr></table></figure><p>转载请注明出处：<a href="http://www.gaoshilei.com/">来自LeonLei的博客http://www.gaoshilei.com</a>  </p><h3 id="2、安装-Nginx"><a href="#2、安装-Nginx" class="headerlink" title="2、安装 Nginx"></a>2、安装 Nginx</h3><p>通过 yum方式安装比较麻烦，还需要安装epel依赖库，下面介绍一种最简单的安装方法 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# vim /etc/yum.repos.d/nginx.repo </span><br></pre></td></tr></table></figure><p>先在 yum.repos.d 文件下新建一个<code>nginx.repo</code>，然后将下面的内容拷贝进去，<code>:wq</code>保存退出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1 </span><br></pre></td></tr></table></figure><p>执行下面的命令直接从配置文件安装 nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# yum install nginx -y</span><br></pre></td></tr></table></figure><p>然后启动nginx  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@c_vps ~]# nginx</span><br></pre></td></tr></table></figure><p>然后打开服务器所在的IP测试nginx是否安装完成。</p><h3 id="3、安装-Hexo"><a href="#3、安装-Hexo" class="headerlink" title="3、安装 Hexo"></a>3、安装 Hexo</h3><p>按照官网的文档执行命令  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>顺利的话一会就安装好了，有时候会遇到 npm 权限问题  </p><blockquote><p>&#x2F;usr&#x2F;bin&#x2F;hexo -&gt; &#x2F;usr&#x2F;lib&#x2F;node_modules&#x2F;hexo-cli&#x2F;bin&#x2F;hexo<br><a href="mailto:&#x68;&#x65;&#120;&#x6f;&#45;&#117;&#x74;&#x69;&#108;&#x40;&#48;&#46;&#54;&#46;&#x31;">&#x68;&#x65;&#120;&#x6f;&#45;&#117;&#x74;&#x69;&#108;&#x40;&#48;&#46;&#54;&#46;&#x31;</a> postinstall &#x2F;usr&#x2F;lib&#x2F;node_modules&#x2F;hexo-cli&#x2F;node_modules&#x2F;hexo-util<br>npm run build:highlight<br><a href="mailto:&#104;&#101;&#x78;&#111;&#x2d;&#117;&#x74;&#x69;&#108;&#x40;&#48;&#46;&#x36;&#x2e;&#49;">&#104;&#101;&#x78;&#111;&#x2d;&#117;&#x74;&#x69;&#108;&#x40;&#48;&#46;&#x36;&#x2e;&#49;</a> build:highlight &#x2F;usr&#x2F;lib&#x2F;node_modules&#x2F;hexo-cli&#x2F;node_modules&#x2F;hexo-util<br>node scripts&#x2F;build_highlight_alias.js &gt; highlight_alias.json<br>sh: highlight_alias.json: 权限不够<br>npm ERR! code ELIFECYCLE<br>npm ERR! errno 1<br>npm ERR! <a href="mailto:&#104;&#101;&#x78;&#x6f;&#45;&#x75;&#x74;&#105;&#108;&#64;&#x30;&#46;&#54;&#x2e;&#49;">&#104;&#101;&#x78;&#x6f;&#45;&#x75;&#x74;&#105;&#108;&#64;&#x30;&#46;&#54;&#x2e;&#49;</a> build:highlight: <code>node scripts/build_highlight_alias.js &gt; highlight_alias.json</code><br>npm ERR! Exit status 1<br>npm ERR!<br>npm ERR! Failed at the <a href="mailto:&#x68;&#x65;&#x78;&#111;&#x2d;&#x75;&#x74;&#x69;&#108;&#x40;&#x30;&#x2e;&#54;&#x2e;&#49;">&#x68;&#x65;&#x78;&#111;&#x2d;&#x75;&#x74;&#x69;&#108;&#x40;&#x30;&#x2e;&#54;&#x2e;&#49;</a> build:highlight script.<br>npm ERR! This is probably not a problem with npm. There is likely additional logging output above.  </p></blockquote><p>这个时候需要开启 npm 的 unsafe-perm 模式  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# npm config set unsafe-perm &quot;true&quot;  </span><br></pre></td></tr></table></figure><p>查看是否设置成功  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# npm config get unsafe-perm</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>如果为 <code>true</code> 则设置成功，再次执行 hexo 的安装命令即可顺利安装成功。  </p><p>因为需要把之前在 github 的博客备份重新拷贝新的服务器上，所以要配置 ssh 公钥方便 git 操作。</p><p>先生成公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# ssh-keygen -t rsa -b 4096 -C &quot;xxxxx@xxx.com&quot;  </span><br></pre></td></tr></table></figure><p>一直回车全部使用默认设置就行，这一步会生成ssh公钥，也就是 public key，生成之后可以通过下面的命令查看  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~/.ssh</span><br></pre></td></tr></table></figure><p>如果有 <code>id_rsa</code> <code>id_rsa.pub</code> 证明生成成功，然后通过下面的命令查看 ssh 公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>再将这个公钥拷贝到 github 的账户配置中即可。   </p><p><strong>注意：  为了方便在本地修改博客、实时预览、自动部署，以上（除了Nginx安装）所有步骤在本地机器上也需要重新操作一遍，以后在本地直接修改之后推送github，配合下文的webhook，服务器会自动更新</strong>  </p><h3 id="4、配置博客"><a href="#4、配置博客" class="headerlink" title="4、配置博客"></a>4、配置博客</h3><p>新安装：参照 <a href="https://hexo.io/zh-cn/docs/setup.html">Hexo官方教程</a><br>重装：从 github 上把之前的博客 clone 下来，放到 root 目录下：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:gaoshilei/hexo-blog.git  </span><br></pre></td></tr></table></figure><p>进入博客目录，一次执行下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@c_vps hexo-blog]# npm install hexo</span><br><span class="line">[root@c_vps hexo-blog]# npm install</span><br></pre></td></tr></table></figure><p>然后配置 nginx，让 80 端口指向博客静态页面首页，在 nginx 配置文件目中新建一个<code>hexo.conf</code>文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# vim /etc/nginx/conf.d/hexo.conf  </span><br></pre></td></tr></table></figure><p>写入相应的配置  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     gaoshilei.com www.gaoshilei.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root        /root/hexo-blog/public;</span><br><span class="line">        index       index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 nginx 使服务生效  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# nginx -s reload</span><br></pre></td></tr></table></figure><p>此时去访问博客得到的是一个 404 或者 403 报错，因为 nginx 是以 nginx 用户运行的，他没有博客目录的读写权限，有两个方法可以解决：  </p><ol><li>给博客目录赋权，让 nginx 用户拥有读写权限</li><li>让 nginx 以 root 用户运行</li></ol><p>我采用第二种方式，修改 nginx 的配置文件  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# vim /etc/nginx/nginx.conf  </span><br></pre></td></tr></table></figure><p>将 <code>user  nginx;</code> 改成 <code>user  root;</code> 即可。然后重启 nginx。  </p><p>再去访问发现报错没了，但是页面是一片空白，找了半天原因，之前用到的主题并没有上传到 github 上，将主题拷贝到 <code>themes</code> 文件夹下，然后部署 hexo 就可以正常访问了。  </p><p><strong>hexo 常用的命令</strong><br>生成静态文件并部署网站:  </p><p>安装 hexo 服务（本地可以通过这个服务实现预览，不需要安装nginx）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># npm install hexo-server --save  </span><br></pre></td></tr></table></figure><p>启动 hexo 服务，默认端口为 4000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hexo server</span><br></pre></td></tr></table></figure><p>用指定端口(port)启动启动 hexo 服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hexo server -p port</span><br></pre></td></tr></table></figure><p>生成静态文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hexo g</span><br></pre></td></tr></table></figure><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hexo clean  </span><br></pre></td></tr></table></figure><p>生成站点map  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># npm install hexo-generator-sitemap --save</span><br><span class="line"># npm install hexo-generator-baidu-sitemap --save  </span><br></pre></td></tr></table></figure><h2 id="配置-webhooks-自动更新博客"><a href="#配置-webhooks-自动更新博客" class="headerlink" title="配置 webhooks 自动更新博客"></a>配置 webhooks 自动更新博客</h2><p>每次在本地更新了博客，push 到 github 上，还要去 VPS 再 git pull 一下，确实很麻烦，配置好 webhooks 就可以在 github 有 push 操作时自动更新并部署博客。  </p><p>webhooks 在 github 对应仓库直接设置就行，重点是服务器的接收和相应的操作。<br>有 Python、PHP、NodeJS 多种方式可以接收 webhooks , 由于 hexo 是基于 NodeJS 的，所以这里用 NodeJS 来接收 github 的 push 事件。 </p><p>安装依赖库 <code>github-webhook-handler</code>：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# npm install -g github-webhook-handler</span><br></pre></td></tr></table></figure><p>安装完成之后配置 <code>webhooks.js</code>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS hexo-blog]# vim webhooks.js </span><br></pre></td></tr></table></figure><p>然后将下面代码的拷贝进去  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> createHandler = <span class="built_in">require</span>(<span class="string">&#x27;github-webhook-handler&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> handler = <span class="title function_">createHandler</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/webhooks_push&#x27;</span>, <span class="attr">secret</span>: <span class="string">&#x27;leonlei1226&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// 上面的 secret 保持和 GitHub 后台设置的一致</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run_cmd</span>(<span class="params">cmd, args, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">spawn</span>;</span><br><span class="line">  <span class="keyword">var</span> child = <span class="title function_">spawn</span>(cmd, args);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  child.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">buffer</span>) &#123; resp += buffer.<span class="title function_">toString</span>(); &#125;);</span><br><span class="line">  child.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; callback (resp) &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handler.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, err.<span class="property">message</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">handler.<span class="title function_">on</span>(<span class="string">&#x27;push&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received a push event for %s to %s&#x27;</span>,</span><br><span class="line">    event.<span class="property">payload</span>.<span class="property">repository</span>.<span class="property">name</span>,</span><br><span class="line">    event.<span class="property">payload</span>.<span class="property">ref</span>);</span><br><span class="line">    <span class="title function_">run_cmd</span>(<span class="string">&#x27;sh&#x27;</span>, [<span class="string">&#x27;./deploy.sh&#x27;</span>], <span class="keyword">function</span>(<span class="params">text</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(text) &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="title function_">handler</span>(req, res, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">      res.<span class="property">statusCode</span> = <span class="number">404</span></span><br><span class="line">      res.<span class="title function_">end</span>(<span class="string">&#x27;no such location&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).<span class="title function_">listen</span>(<span class="number">6666</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, err.<span class="property">message</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <strong>secret</strong> 要和 github 仓库中 webhooks 设置的一致，<strong>6666</strong> 是监听端口可以随便改，不要冲突就行，**.&#x2F;deploy.sh** 是接收到 push 事件时需要执行的shell脚本，与 <code>webhooks.js</code> 都存放在博客目录下；<strong>path: ‘&#x2F;webhooks_push</strong> 是 github 通知服务器的地址，完整的地址是这样的<code>http://www.gaoshilei.com:6666/webhooks_push</code>  </p><blockquote><p>用 https 会报错，github 设置页面会 deliver error，所以把地址改成了 http</p></blockquote><p>配置<code>./deploy.sh</code>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS hexo-blog]# vim deploy.sh</span><br></pre></td></tr></table></figure><p>将下面代码拷贝进去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /root/hexo-blog/</span><br><span class="line">git reset --hard</span><br><span class="line">git pull origin master  </span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>然后运行  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS hexo-blog]# node webhooks.js </span><br></pre></td></tr></table></figure><p>就可以实现本地更新 push 到 github ，服务器会自动更新部署博客。<br>最后要将进程加入守护，通过 pm2 来实现  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS ~]# npm install pm2 --global</span><br></pre></td></tr></table></figure><p>然后通过 pm2 启动 <code>webhooks.js</code>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS hexo-blog]# pm2 start /root/hexo-blog/webhooks.js </span><br><span class="line">[PM2] Starting /root/hexo-blog/webhooks.js in fork_mode (1 instance)</span><br><span class="line">[PM2] Done.</span><br><span class="line">┌──────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐</span><br><span class="line">│ App name │ id │ mode │ pid   │ status │ restart │ uptime │ cpu │ mem       │ user │ watching │</span><br><span class="line">├──────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤</span><br><span class="line">│ webhooks │ 0  │ fork │ 10010 │ online │ 0       │ 0s     │ 14% │ 24.2 MB   │ root │ disabled │</span><br><span class="line">└──────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘</span><br><span class="line"> Use `pm2 show &lt;id|name&gt;` to get more details about an app  </span><br></pre></td></tr></table></figure><p>如果服务器重启，我们还要手动开启webhooks服务，所以我们将上面的命令加入开机启动就可以了，将命令加入<code>/etc/rc.d/rc.local</code>中，即可实现开机自启<br>先将命令写到脚本<code>/root/webhooks_auto.sh</code>中：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/runuser -l root -c &quot;/usr/bin/pm2 start /root/hexo-blog/webhooks.js&quot;</span><br></pre></td></tr></table></figure><p>然后在<code>/etc/rc.d/rc.local</code>中添加刚才的脚本：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/root/webhooks_auto.sh 2&gt;&amp;1 &gt; /dev/null &amp;</span><br></pre></td></tr></table></figure><p>重启VPS，然后用命令<code>pm2 show webhooks</code>查看 webhooks 是否已经启动。</p><h2 id="全站-HTTPS"><a href="#全站-HTTPS" class="headerlink" title="全站 HTTPS"></a>全站 HTTPS</h2><p>使用 Let’s Encrypt 的免费证书，不过每三个月要续签一次。安装可以通过 Certbot 的傻瓜式操作  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS www]# wget https://dl.eff.org/certbot-auto</span><br><span class="line">[root@California_VPS www]# chmod a+x certbot-auto  </span><br></pre></td></tr></table></figure><p>下载脚本，然后赋权  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS www]# sudo ./certbot-auto --nginx</span><br></pre></td></tr></table></figure><p>执行脚本，获取证书，Certbot 会自动帮我们配置 nginx 的一些配置。走到最后可能遇到这种情况  </p><blockquote><p>Cannot find a VirtualHost matching domain <a href="http://www.gaoshilei.com/">www.gaoshilei.com</a>. In order for Certbot to correctly perform the challenge please add a corresponding server_name directive to your nginx configuration: <a href="https://nginx.org/en/docs/http/server_names.html">https://nginx.org/en/docs/http/server_names.html</a></p></blockquote><p>之前在配置 nginx.conf 文件的时候忘记加域名了，把 server_name 补全就行了，然后重新执行一次脚本。你还可能遇到这样的问题  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Creating virtual environment...</span><br><span class="line">[root@California_VPS www]# ./certbot-auto: line 864: virtualenv: command not found</span><br></pre></td></tr></table></figure><p>缺少<code>virtualenv</code>环境，依次执行下面的命令下面进行安装：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS www]# curl https://bootstrap.pypa.io/get-pip.py | python -</span><br><span class="line">[root@California_VPS www]# pip install virtualenv</span><br></pre></td></tr></table></figure><p>然后执行上面的命令<code>sudo ./certbot-auto --nginx</code>继续安装证书，中间需要我们输入邮箱，域名等等，按照步骤操作就可以，最后顺利申请了证书，而且 Certbot 都帮我配置好了，nice！<br>不过这个证书有效期只有三个月，所以需要续签，可以手动续签，证书快过期的时候执行  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo /root/www/certbot-auto renew</span></span><br></pre></td></tr></table></figure><p>或者将上面的命令加入 <code>crontab</code> 定时任务  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS etc]# ps -ef | grep cron</span><br><span class="line">root      1164     1  0 Oct30 ?        00:00:00 crond</span><br><span class="line">root      8507  8222  0 07:31 pts/0    00:00:00 grep cron  </span><br><span class="line">[root@California_VPS etc]# service crond status</span><br><span class="line">crond (pid  1164) is running...</span><br></pre></td></tr></table></figure><p>先检查一下有没有安装 crontab，并且查看 crontab 的运行状态。最后配置  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS etc]# crontab -e</span><br></pre></td></tr></table></figure><p>添加下面这条命令到配置文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * 0 /root/www/certbot-auto renew  </span><br></pre></td></tr></table></figure><p>这条命令的意思是每周日的0点0分执行<code>/root/www/certbot-auto renew</code>这条命令。执行下面这条命令查看定时任务列表中是否有刚才添加的任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@California_VPS etc]# crontab -l </span><br><span class="line">0 0 * * 0 /root/www/certbot-auto renew</span><br></pre></td></tr></table></figure><p>大功告成！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文档主要用来记录自己借助&lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;搭建博客的一些步骤和命令，方便以后重装；新人也可以通过此篇文章快速搭建自己的个人博客。&lt;br&gt;下文的环境为:&lt;br&gt;VPS： CentOS6.9&lt;br&gt;本地： MacOS  &lt;/p&gt;
&lt;h2 id=&quot;搭建博客&quot;&gt;&lt;a href=&quot;#搭建博客&quot; class=&quot;headerlink&quot; title=&quot;搭建博客&quot;&gt;&lt;/a&gt;搭建博客&lt;/h2&gt;&lt;h3 id=&quot;1、安装-NodeJS-和-NPM&quot;&gt;&lt;a href=&quot;#1、安装-NodeJS-和-NPM&quot; class=&quot;headerlink&quot; title=&quot;1、安装 NodeJS 和 NPM&quot;&gt;&lt;/a&gt;1、安装 NodeJS 和 NPM&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@California_VPS ~]# curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -  &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;执行完这个命令之后就可以安装NodeJS  &lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@California_VPS ~]# yum install -y nodejs&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="备忘录" scheme="http://www.gaoshilei.com/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
    <category term="个人博客" scheme="http://www.gaoshilei.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Weex从入门到超神（二）</title>
    <link href="http://www.gaoshilei.com/weex-2/"/>
    <id>http://www.gaoshilei.com/weex-2/</id>
    <published>2017-09-26T10:10:21.000Z</published>
    <updated>2023-10-20T08:43:45.411Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>距离我写的上一篇文章 <a href="https://gaoshilei.com/2017/05/26/weex-1/">Weex从入门到超神（一）</a> 已经过了挺久了（惭愧而不失礼貌的微笑），起初写那篇文章的初衷是因为项目中使用到了 Weex ,所以准备对 Weex 做一个心得式的笔记，后来无意间发现<a href="http://www.jianshu.com/u/12201cdd5d7a">简书“霜神”</a>已经对 Weex 写过几篇剖析比较深刻的文章，还有其他一些原因（懒），所以就没有继续写下去。<br>最近由于Facebook的 <a href="https://github.com/facebook/react/blob/master/LICENSE">BSD license</a>，React 被前端社区的同学们推到了风口浪尖，React&amp;RN、Vue&amp;Weex 又成为了大家码前码后讨论的话题。Apache 社区还因为 Facebook 的 BSD license，全面封杀使用了 BSD license 的开源项目，貌似一切都很精彩，迫于前端同(da)学(lao)的淫威还有社区的强烈谴责，上周 Facebook 终于认怂了，承诺这周将 React 以及 gayhub 上面的其他几个项目的开源协议从 BSD 改成 MIT，下图是我脑补的场景：<br><img src="http://img.gaoshilei.com/FA269E01D9C3794449AA6748EA6280C6.png" loading="lazy"><br>鉴于对于项目中使用 Weex 的一些经验和心得，还是希望写出来和大家一起分享。  </p><span id="more"></span><h2 id="应用层核心组件"><a href="#应用层核心组件" class="headerlink" title="应用层核心组件"></a>应用层核心组件</h2><p>Weex 运行时会先注入一段位于 <code>pre-build</code> 下的 <code>native-bundle-main.js</code> 代码。不过在注入这段代码之前会先注册一些默认的 <code>Component</code>、<code>Module</code>和<code>Handler</code>，<strong>这就是 Weex 与 Native 应用层交互最核心的部分</strong>，可以理解为“组件”。其中 Component 是为了映射 Html 的一些标签，Module 中是提供一些 Native 的一些方法供 Weex 调用，Handler 是一些协议的实现。  </p><p><img src="http://img.gaoshilei.com/weex-component.png" loading="lazy">  </p><p>注册完 Weex 默认的“组件” 之后，注入刚才那段 JS，这个时候 Vue 的标签和动作才能被 Weex 所识别和转换。<br><strong>为了便于下文的描述和理解，我把 Native 这边的 SDK 称作 Weex，前端的 Vue 和 Weex 库以及 Vue 编译后的 js 统称为 Vue</strong></p><h3 id="1-组件：Component"><a href="#1-组件：Component" class="headerlink" title="1. 组件：Component"></a>1. 组件：Component</h3><p>目前 Weex 一共提供了26种 Component，比较常见的有 <code>div</code>、<code>image</code>、<code>scroller</code>… ，有些跟 html 标签重名，有些是 Weex 自定义的。Weex 注册的 Component 有两种类型，一类是有<br><code>&#123;@&quot;append&quot;:@&quot;tree&quot;&#125;</code>属性的标签，另一类是没有<code>&#123;@&quot;append&quot;:@&quot;tree&quot;&#125;</code>属性的标签。要搞清楚这两类标签有什么不同，我们就要看一下 Component 的注册的源码实现。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[WXComponentFactory registerComponent:name withClass:clazz withPros:properties];</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *dict = [WXComponentFactory componentMethodMapsWithName:name];</span><br><span class="line">dict[<span class="string">@&quot;type&quot;</span>] = name;</span><br><span class="line"><span class="keyword">if</span> (properties) &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *props = [properties mutableCopy];</span><br><span class="line">    <span class="keyword">if</span> ([dict[<span class="string">@&quot;methods&quot;</span>] count]) &#123;</span><br><span class="line">        [props addEntriesFromDictionary:dict];</span><br><span class="line">    &#125;</span><br><span class="line">    [[WXSDKManager bridgeMgr] registerComponents:@[props]];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [[WXSDKManager bridgeMgr] registerComponents:@[dict]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过一个工厂类<code>WXComponentFactory</code>注册 Component，  </p><blockquote><p> 这个工厂类（单例）中管理了所有的 Component ，注册的每一个 Component 都会用一个对应的 <code>WXComponentConfig</code>来保存标签name、对应的class和属性，最后由<code>WXComponentFactory</code>来统一管理这些<code>WXComponentConfig </code>   </p></blockquote><p>这一步同时注册了 Component 中的 methods，关于 method 也有两类，一类是包含<code>wx_export_method_sync_</code>前缀的同步方法，另一类是包含<code>wx_export_method_</code>前缀的异步方法（<em>这两种方法有什么不同，后面会有介绍</em>）。在<code>WXComponentConfig</code>的父类<code>WXInvocationConfig</code>储存了 Component 的方法map:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *asyncMethods;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *syncMethods;</span><br></pre></td></tr></table></figure><p>然后再从<code>WXComponentFactory</code>拿到对应 Component 的方法列表字典，需要注意的是这里拿到的方法列表只是<strong>异步方法</strong>，得到的是这样的字典：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    methods =     (</span><br><span class="line">        resetLoadmore</span><br><span class="line">    );</span><br><span class="line">    type = scroller;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>不过大部分 Component 并没有<code>wx_export</code>前缀的 method，所以很多这里拿到的方法都为空。<br>最后也是最关键的一步，要将 Component 注册到<code>WXBridgeContext</code>中。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.frameworkLoadFinished) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.jsBridge callJSMethod:method args:args];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [_methodQueue addObject:@&#123;<span class="string">@&quot;method&quot;</span>:method, <span class="string">@&quot;args&quot;</span>:args&#125;];</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>最后将 Component 注册到了<code>JSContext</code>中，</p><blockquote><p> 还记得文章开头介绍的<code>native-bundle-main.js</code>吗？这里的注册调用了js中的<code>registerComponents</code>方法，这个 Component 与 Vue 就联系起来了，在 Vue 就可以使用这个 Component。</p></blockquote><p>并且从上面的这段代码可以看出来，Component 的注册操作是在 JSFramework 加载完成才会进行，如果<code>native-bundle-main.js</code>没有加载完成，所有的 Component 的方法注册操作都会被加到队列中等待。其中的第二个参数<code>args</code>就是上面我们拿到的字典。不过有属性的 和没属性的有点区别，有属性的会将属性添加到之前拿到的字典中作为<code>args</code>再去注册。<br>要搞清楚这个属性干嘛的，我们先看一下<code>WXComponentManager</code>中的相关源码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)_recursivelyAddComponent:(<span class="built_in">NSDictionary</span> *)componentData toSupercomponent:(WXComponent *)supercomponent atIndex:(<span class="built_in">NSInteger</span>)index appendingInTree:(<span class="type">BOOL</span>)appendingInTree &#123;</span><br><span class="line">...    </span><br><span class="line">    <span class="type">BOOL</span> appendTree = !appendingInTree &amp;&amp; [component.attributes[<span class="string">@&quot;append&quot;</span>] isEqualToString:<span class="string">@&quot;tree&quot;</span>];</span><br><span class="line">    <span class="comment">// if ancestor is appending tree, child should not be laid out again even it is appending tree.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">NSDictionary</span> *subcomponentData <span class="keyword">in</span> subcomponentsData)&#123;</span><br><span class="line">        [<span class="keyword">self</span> _recursivelyAddComponent:subcomponentData toSupercomponent:component atIndex:<span class="number">-1</span> appendingInTree:appendTree || appendingInTree];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (appendTree) &#123;</span><br><span class="line">        <span class="comment">// If appending tree，force layout in case of too much tasks piling up in syncQueue</span></span><br><span class="line">        [<span class="keyword">self</span> _layoutAndSyncUI];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是 Vue 页面渲染时所调用的方法，这个方法会递归添加 Component，同时会向视图中添加与 Component 相对应的 UIView。从代码的后半部分可以看到，如果当前 Component 有<code>&#123;@&quot;append&quot;:@&quot;tree&quot;&#125;</code>属性并且它的父 Component 没有这个属性将会强制对页面进行重新布局。可以看到这样做是为了防止UI绘制任务太多堆积在一起影响同步队列任务的执行。    </p><p>搞清楚了 Component 的注册机制，下面重点扒一下 Component 的运行原理：Vue 标签是如何加载以及渲染到视图上的。<br>从刚才的注册过程中发现，最后一步是通过<code>_jsBridge</code>调用<code>callJSMethod</code>这个方法来注册的，而且从<code>WXBridgeContext</code>中可以看到，这个<code>_jsBridge</code>就是<code>WXJSCoreBridge</code>的实例。<code>WXJSCoreBridge</code>可以认为是 Weex 与 Vue 进行通信的最底层的部分。在调用<code>callJSMethod</code>方法之前，<code>_jsBridge</code>向 JavaScriptCore 中注册了很多全局 function，因为<code>jsBridge</code>是懒加载的，所以这些操作只会执行一次，具体请看精简后的源码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  [_jsBridge registerCallNative:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instance, <span class="built_in">NSArray</span> *tasks, <span class="built_in">NSString</span> *callback) &#123;</span><br><span class="line">...    </span><br><span class="line">&#125;];</span><br><span class="line">  [_jsBridge registerCallAddElement:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *parentRef, <span class="built_in">NSDictionary</span> *elementData, <span class="built_in">NSInteger</span> index) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [_jsBridge registerCallCreateBody:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSDictionary</span> *bodyData) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [_jsBridge registerCallRemoveElement:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *ref) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [_jsBridge registerCallMoveElement:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId,<span class="built_in">NSString</span> *ref,<span class="built_in">NSString</span> *parentRef,<span class="built_in">NSInteger</span> index) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [_jsBridge registerCallUpdateAttrs:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId,<span class="built_in">NSString</span> *ref,<span class="built_in">NSDictionary</span> *attrsData) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [_jsBridge registerCallUpdateStyle:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId,<span class="built_in">NSString</span> *ref,<span class="built_in">NSDictionary</span> *stylesData) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [_jsBridge registerCallAddEvent:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId,<span class="built_in">NSString</span> *ref,<span class="built_in">NSString</span> *event) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [_jsBridge registerCallRemoveEvent:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId,<span class="built_in">NSString</span> *ref,<span class="built_in">NSString</span> *event) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [_jsBridge registerCallCreateFinish:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [_jsBridge registerCallNativeModule:^<span class="built_in">NSInvocation</span>*(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *moduleName, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *arguments, <span class="built_in">NSDictionary</span> *options) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [_jsBridge registerCallNativeComponent:^<span class="type">void</span>(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *componentRef, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *args, <span class="built_in">NSDictionary</span> *options) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><p>从这些方法名看，大多数都是一些与 Dom 更新相关的方法，我们在<code>WXJSCoreBridge</code>中更细致的看一下是怎么实现的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)registerCallAddElement:(WXJSCallAddElement)callAddElement</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> callAddElementBlock = ^(JSValue *instanceId, JSValue *ref, JSValue *element, JSValue *index, JSValue *ifCallback) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *instanceIdString = [instanceId toString];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *componentData = [element toDictionary];</span><br><span class="line">        <span class="built_in">NSString</span> *parentRef = [ref toString];</span><br><span class="line">        <span class="built_in">NSInteger</span> insertIndex = [[index toNumber] integerValue];</span><br><span class="line">        [WXTracingManager startTracingWithInstanceId:instanceIdString ref:componentData[<span class="string">@&quot;ref&quot;</span>] className:<span class="literal">nil</span> name:WXTJSCall phase:WXTracingBegin functionName:<span class="string">@&quot;addElement&quot;</span> options:<span class="literal">nil</span>];</span><br><span class="line">         WXLogDebug(<span class="string">@&quot;callAddElement...%@, %@, %@, %ld&quot;</span>, instanceIdString, parentRef, componentData, (<span class="type">long</span>)insertIndex);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [JSValue valueWithInt32:(int32_t)callAddElement(instanceIdString, parentRef, componentData, insertIndex) inContext:[JSContext currentContext]];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    _jsContext[<span class="string">@&quot;callAddElement&quot;</span>] = callAddElementBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个更新 Dom 添加 UIView 的方法，这里需要把 Native 的方法暴露给 JS 调用。但是有一个问题：  </p><blockquote><p> OC 的方法参数格式和 JS 的不一样，不能直接提供给 JS 调用。  </p></blockquote><p>所以这里用了两个 Block 嵌套的方式，在 JS 中调用方法时会先 invoke 里层的 callAddElementBlock，这层 Block 将 JS 传进来的参数转换成 OC 的参数格式，再执行 callAddElement 并返回一个 JSValue 给 JS，callAddElement Block中是在<code>WXComponentManager</code>中完成的关于 Component 的一些操作，这在上面介绍 Component 包含 <code>tree</code>属性问题时已经介绍过了。<br>至此，简单来说就是：Weex 的页面渲染是通过先向 JSCore 注入方法，Vue 加载完成就可以调用这些方法并传入相应的参数完成 Component 的渲染和视图的更新。<br>要注意，每一个 <code>WXSDKInstance</code> 对应一个 Vue 页面，Vue 加载之前就会创建对应的 WXSDKInstance，所有的 Component 都继承自<code>WXComponent</code>，他们的初始化方法都是</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">instancetype</span>)initWithRef:(<span class="built_in">NSString</span> *)ref</span><br><span class="line">                      type:(<span class="built_in">NSString</span> *)type</span><br><span class="line">                    styles:(<span class="built_in">NSDictionary</span> *)styles</span><br><span class="line">                attributes:(<span class="built_in">NSDictionary</span> *)attributes</span><br><span class="line">                    events:(<span class="built_in">NSArray</span> *)events</span><br><span class="line">              weexInstance:(WXSDKInstance *)weexInstance</span><br></pre></td></tr></table></figure><p>这个方法会在 JS 调用<code>callCreateBody</code>时被 invoke。 </p><h3 id="2-组件：Module"><a href="#2-组件：Module" class="headerlink" title="2. 组件：Module"></a>2. 组件：Module</h3><p>Module 注册流程和 Component 基本一致，首先通过<code>WXModuleFactory</code>注册 Module</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)_registerModule:(<span class="built_in">NSString</span> *)name withClass:(Class)clazz</span><br><span class="line">&#123;</span><br><span class="line">    WXAssert(name &amp;&amp; clazz, <span class="string">@&quot;Fail to register the module, please check if the parameters are correct ！&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    [_moduleLock lock];</span><br><span class="line">    <span class="comment">//allow to register module with the same name;</span></span><br><span class="line">    WXModuleConfig *config = [[WXModuleConfig alloc] init];</span><br><span class="line">    config.name = name;</span><br><span class="line">    config.clazz = <span class="built_in">NSStringFromClass</span>(clazz);</span><br><span class="line">    [config registerMethods];</span><br><span class="line">    [_moduleMap setValue:config forKey:name];</span><br><span class="line">    [_moduleLock unlock];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册 Moudle 的<code>registerMethods</code>方法与注册 Component 是一样的，都是将方法注册到<code>WXInvocationConfig</code>中，<code>wx_export_method_sync_</code>前缀的同步方法注册到 syncMethods 中，<code>wx_export_method_</code>前缀的异步方法注册到 asyncMethods 中。再将 Moudle 的同步和异步方法取出来调用<code>registerComponents</code>注入到<code>JSContext</code>中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    dom =     (</span><br><span class="line">        addEventListener,</span><br><span class="line">        removeAllEventListeners,</span><br><span class="line">        addEvent,</span><br><span class="line">        removeElement,</span><br><span class="line">        getComponentRect,</span><br><span class="line">        updateFinish,</span><br><span class="line">        scrollToElement,</span><br><span class="line">        addRule,</span><br><span class="line">        updateAttrs,</span><br><span class="line">        addElement,</span><br><span class="line">        createFinish,</span><br><span class="line">        createBody,</span><br><span class="line">        updateStyle,</span><br><span class="line">        removeEvent,</span><br><span class="line">        refreshFinish,</span><br><span class="line">        moveElement</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是<code>WXDomModule</code>中所有的方法，<em>Moudle 中的方法注册比 Component 更有意义，因为 Moudle 中基本上都是暴露给 Vue 调用的 Native 方法。</em><br><strong>接下来我们来看一下 Moudle 的方法如何被调用以及 syncMethods 和 asyncMethods 有什么不同。</strong><br>在前面的<code>jsBridge</code>懒加载中，有一个注册方法是跟 Moudle 中方法有关的，Moudle 中的方法会在这个注册方法的回调中被 invoke，换言之，Vue 调用 Moudle 中的方法会在这个回调中被唤起  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[_jsBridge registerCallNativeModule:^<span class="built_in">NSInvocation</span>*(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *moduleName, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *arguments, <span class="built_in">NSDictionary</span> *options) &#123;</span><br><span class="line">    </span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        WXLogInfo(<span class="string">@&quot;instance not found for callNativeModule:%@.%@, maybe already destroyed&quot;</span>, moduleName, methodName);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance];</span><br><span class="line">    <span class="keyword">if</span>(![moduleName isEqualToString:<span class="string">@&quot;dom&quot;</span>] &amp;&amp; instance.needPrerender)&#123;</span><br><span class="line">        [WXPrerenderManager storePrerenderModuleTasks:method forUrl:instance.scriptURL.absoluteString];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [method invoke];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>在<code>WXModuleMethod</code>中可以看到<code>-(NSInvocation *)invoke</code>这个方法，Moudle 中的方法将会通过这个方法被 invoke</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  </span><br><span class="line">  Class moduleClass =  [WXModuleFactory classWithModuleName:_moduleName];</span><br><span class="line">  <span class="keyword">if</span> (!moduleClass) &#123;</span><br><span class="line">      <span class="built_in">NSString</span> *errorMessage = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Module：%@ doesn&#x27;t exist, maybe it has not been registered&quot;</span>, _moduleName];</span><br><span class="line">      WX_MONITOR_FAIL(WXMTJSBridge, WX_ERR_INVOKE_NATIVE, errorMessage);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">id</span>&lt;WXModuleProtocol&gt; moduleInstance = [<span class="keyword">self</span>.instance moduleForClass:moduleClass];</span><br><span class="line">  WXAssert(moduleInstance, <span class="string">@&quot;No instance found for module name:%@, class:%@&quot;</span>, _moduleName, moduleClass);</span><br><span class="line">  <span class="type">BOOL</span> isSync = <span class="literal">NO</span>;</span><br><span class="line">  SEL selector = [WXModuleFactory selectorWithModuleName:<span class="keyword">self</span>.moduleName methodName:<span class="keyword">self</span>.methodName isSync:&amp;isSync];</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (![moduleInstance respondsToSelector:selector]) &#123;</span><br><span class="line">      <span class="comment">// if not implement the selector, then dispatch default module method</span></span><br><span class="line">      <span class="keyword">if</span> ([<span class="keyword">self</span>.methodName isEqualToString:<span class="string">@&quot;addEventListener&quot;</span>]) &#123;</span><br><span class="line">          [<span class="keyword">self</span>.instance _addModuleEventObserversWithModuleMethod:<span class="keyword">self</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.methodName isEqualToString:<span class="string">@&quot;removeAllEventListeners&quot;</span>]) &#123;</span><br><span class="line">          [<span class="keyword">self</span>.instance _removeModuleEventObserverWithModuleMethod:<span class="keyword">self</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">NSString</span> *errorMessage = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;method：%@ for module:%@ doesn&#x27;t exist, maybe it has not been registered&quot;</span>, <span class="keyword">self</span>.methodName, _moduleName];</span><br><span class="line">          WX_MONITOR_FAIL(WXMTJSBridge, WX_ERR_INVOKE_NATIVE, errorMessage);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> commitModuleInvoke];</span><br><span class="line">  <span class="built_in">NSInvocation</span> *invocation = [<span class="keyword">self</span> invocationWithTarget:moduleInstance selector:selector];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isSync) &#123;</span><br><span class="line">      [invocation invoke];</span><br><span class="line">      <span class="keyword">return</span> invocation;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      [<span class="keyword">self</span> _dispatchInvocation:invocation moduleInstance:moduleInstance];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>先通过 <code>WXModuleFactory</code> 拿到对应的方法 Selector，然后再拿到这个方法对应的 NSInvocation ，最后 invoke 这个 NSInvocation。对于 syncMethods 和 asyncMethods 有两种 invoke 方式。如果是 syncMethod 会直接 invoke ，如果是 asyncMethod，会将它派发到某个指定的线程中进行 invoke，这样做的好处是不会阻塞当前线程。到这里 Moudle 的大概的运行原理都清除了，不过还有一个问题，Moudle 的方法是怎么暴露给 Vue 的呢？<br>在 Moudle 中我们通过 Weex 提供的宏可以将方法暴露出来：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WX_EXPORT_METHOD(method) WX_EXPORT_METHOD_INTERNAL(method,wx_export_method_)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WX_EXPORT_METHOD_SYNC(method) WX_EXPORT_METHOD_INTERNAL(method,wx_export_method_sync_)</span></span><br></pre></td></tr></table></figure><p>分别提供了 syncMethod 和 asyncMethod 的宏，展开其实是这样的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WX_EXPORT_METHOD_INTERNAL(method, token) \</span></span><br><span class="line"><span class="meta">+ (NSString *)WX_CONCAT_WRAPPER(token, __LINE__) &#123; \</span></span><br><span class="line"><span class="meta">    return NSStringFromSelector(method); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line">```  </span><br><span class="line">这里会自动将方法名和当前的行数拼成一个新的方法名，这样做的好处是可以保证方法的唯一性，例如 `WXDomModule` 中的 `createBody:` 方法利用宏暴露出来，最终展开形式是这样的  </span><br><span class="line"></span><br><span class="line">```ObjC  </span><br><span class="line">+ (<span class="built_in">NSString</span> *)wx_export_method_40 &#123; \</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSStringFromSelector</span>(createBody:); \</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">在`WXInvocationConfig`中调用`- (<span class="type">void</span>)registerMethods`注册方法的时候，首先拿到当前 <span class="keyword">class</span> 中所有的类方法**（宏包装成的方法，并不是实际要注册的方法）**，然后通过判断有无`wx_export_method_sync_`前缀和`wx_export_method_`前缀来判断是否为暴露的方法，然后再调用该类方法，获得最终的实例方法字符串</span><br><span class="line"></span><br><span class="line">```ObjC  </span><br><span class="line">method = ((<span class="built_in">NSString</span>* (*)(<span class="type">id</span>, SEL))[currentClass methodForSelector:selector])(currentClass, selector);</span><br></pre></td></tr></table></figure><p>拿到需要注册的实例方法字符串，再将方法字符串注册到<code>WXInvocationConfig</code>的对应方法 map 中。  </p><h3 id="3-组件：Handlers"><a href="#3-组件：Handlers" class="headerlink" title="3. 组件：Handlers"></a>3. 组件：Handlers</h3><p>Handlers 的注册和使用非常简单，直接将对应的 class 注册到 <code>WXHandlerFactory</code> map中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[WXHandlerFactory sharedInstance].handlers setObject:handler forKey:<span class="built_in">NSStringFromProtocol</span>(protocol)];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要使用的时候也非常简单粗暴，通过<code>WXHandlerFactory</code>的方法和相应的 protocol</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">id</span>)handlerForProtocol:(Protocol *)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> handler = [[WXHandlerFactory sharedInstance].handlers objectForKey:<span class="built_in">NSStringFromProtocol</span>(protocol)];</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接拿出即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;距离我写的上一篇文章 &lt;a href=&quot;https://gaoshilei.com/2017/05/26/weex-1/&quot;&gt;Weex从入门到超神（一）&lt;/a&gt; 已经过了挺久了（惭愧而不失礼貌的微笑），起初写那篇文章的初衷是因为项目中使用到了 Weex ,所以准备对 Weex 做一个心得式的笔记，后来无意间发现&lt;a href=&quot;http://www.jianshu.com/u/12201cdd5d7a&quot;&gt;简书“霜神”&lt;/a&gt;已经对 Weex 写过几篇剖析比较深刻的文章，还有其他一些原因（懒），所以就没有继续写下去。&lt;br&gt;最近由于Facebook的 &lt;a href=&quot;https://github.com/facebook/react/blob/master/LICENSE&quot;&gt;BSD license&lt;/a&gt;，React 被前端社区的同学们推到了风口浪尖，React&amp;amp;RN、Vue&amp;amp;Weex 又成为了大家码前码后讨论的话题。Apache 社区还因为 Facebook 的 BSD license，全面封杀使用了 BSD license 的开源项目，貌似一切都很精彩，迫于前端同(da)学(lao)的淫威还有社区的强烈谴责，上周 Facebook 终于认怂了，承诺这周将 React 以及 gayhub 上面的其他几个项目的开源协议从 BSD 改成 MIT，下图是我脑补的场景：&lt;br&gt;&lt;img src=&quot;http://img.gaoshilei.com/FA269E01D9C3794449AA6748EA6280C6.png&quot;&gt;&lt;br&gt;鉴于对于项目中使用 Weex 的一些经验和心得，还是希望写出来和大家一起分享。  &lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="http://www.gaoshilei.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JS" scheme="http://www.gaoshilei.com/tags/JS/"/>
    
    <category term="Weex" scheme="http://www.gaoshilei.com/tags/Weex/"/>
    
    <category term="Vue" scheme="http://www.gaoshilei.com/tags/Vue/"/>
    
    <category term="前端" scheme="http://www.gaoshilei.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Weex从入门到超神（一）</title>
    <link href="http://www.gaoshilei.com/weex-1/"/>
    <id>http://www.gaoshilei.com/weex-1/</id>
    <published>2017-05-26T06:23:11.000Z</published>
    <updated>2023-10-20T08:43:48.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://img.gaoshilei.com/Weex_logo.png" loading="lazy"></p><p>随着移动端发展进入白热化阶段，很多中小型公司越来越注重于APP的更新迭代速度。加上去年微信小程序的问世，前端同学似乎迎来了“第二春”，越来越多的 Native 开发者感受到了前所未有的压力，人家已经打到家门口了，难道就这样两眼旁观吗？  </p><p>两年前 Facebook 团队发布了一个全新的移动端和前端无缝衔接的框架 React Native，很明显是用 React 开发的，支持在 Native 上运行的这么一个玩意，这相对于苹果漫长的审核机制的确是一个福音。可是 React 的学习曲线比较陡，网上大部分教程的性质都是 <strong>“React Native 从入门到放弃”</strong>，RN虽好，但是对于大多数移动开发者来说学习成本过高。   </p><span id="more"></span><p>去年阿里巴巴开源了一个类似 RN 的框架 <strong><a href="http://weex.apache.org/cn/">Weex</a></strong> ，虽然面世才一年多，已经收获了广泛的关注，今年 Weex 已经被纳入 Apache 基金会的孵化项目。<br><img src="http://img.gaoshilei.com/Weex_Apache.png" loading="lazy"></p><h2 id="为什么选择-Weex"><a href="#为什么选择-Weex" class="headerlink" title="为什么选择 Weex"></a>为什么选择 Weex</h2><p>转载请注明出处：<a href="http://www.gaoshilei.com/">来自LeonLei的博客http://www.gaoshilei.com</a>  </p><p>作为 Native 开发者，我们很清楚 Native 走到今天所面临的困境，相较于前端比较呆板不够灵活，任何改动都需要重新打包提交审核然后发布版本，这个周期最短也要1~2天的时间，一直有人在说要用 H5 替代 Native ,这不是危言耸听，移动端市场正在遭受着冲击。  </p><p>大部分中小型的互联网公司都是小步快走的模式进行版本迭代，版本发布的灵活性就显得尤为重要，可能产品早上想的功能点晚上就要上线，Native 肯定是办不到的，H5 这个时候就显示出它的优势了；但是 H5 有一个致命的缺点就是性能太差，用户体验远达不到 Native 带来的那种丝滑流畅般的享受。所以这两年，RN 和 Weex 悄然崛起就是为了解决这种矛盾。</p><p>不管是 RN 还是 Weex 都能做到实时修改页面不需要 Native 发版，他们的原理都是一样的，通过 js 来渲染 Native 界面。<br>Weex 在很大程度上借鉴了 RN 的思想和方式，对比一下 RN 和 Weex 的差异和优缺点：  </p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>由于 Weex 采用了 Vue 作为上层框架，相较于 React 更加轻量，Vue 的官网宣传就是非常轻量，体积小巧，语法简单。</li><li>Vue 的学习成本相较于 React 更加小，大部分 Native 开发者更容易上手。</li><li>Weex 吸收了 RN 的精华，可以说 Weex 是站在巨人的肩膀上问世。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>   Weex 相较于 RN 起步比较晚，社区没有 RN 活跃。</li><li><pre><code>从问世的时间上来看，RN 具有更大的优势，Weex 的学习资料比较少。</code></pre></li><li><pre><code>Weex 现在存在的 BUG 相较于 RN 还比较多，对于使用来说会有一些影响。</code></pre></li></ul><p>不管选择 RN 还是 Weex ，我们的目的都是一样：通过 js 语法渲染成  Native 的页面，至于该选择哪个，这就要结合自己公司的实际情况来选，没有绝对的好与坏。<br>由于我们公司的 H5 项目是用 Vue 开发的，所以我们也就毫不犹豫的选择了 Weex。  </p><p><img src="http://img.gaoshilei.com/weex&vue.png" loading="lazy">  </p><p>可能大部分 Native 开发者看到这里就要说一句：<em>球都麻袋！Weex 都还搞明白怎么又提到 Vue ，这是什么鬼</em>；Vue 是国人开发的一个 JS 框架，大家可以去官网看看，文档都是中文比较方便，这里就不再赘述，有一点 H5 基础都可以很快上手。**<a href="https://cn.vuejs.org/">Vue官网</a>**</p><h2 id="Weex-项目结构"><a href="#Weex-项目结构" class="headerlink" title="Weex 项目结构"></a>Weex 项目结构</h2><p>想必大多数 Native 开发者对于前端的知识还是匮乏的，虽然 Weex 官网有教程会教你怎么安装怎么运行，大部分同学任然会卡在某一个步骤走不下去，所以基础工作还是要做好，后面的路才会顺畅。  </p><p>首先给大家介绍 Node.js 和 npm ，刚开始接触这个我也是懵逼的，这两者之间有什么关系？为什么要安装 Node.js ？ 搞懂这个关系后面对 weex 中结构理解会有很好的帮助，npm 是 Node.js 默认的包管理器，从 Node.js 0.6.3 开始，npm 集成到了 Node.js 的安装包里面，所以我们安装 Node.js 的目的是使用 npm 来管理 weex 所用到的一些依赖库。</p><p>至于怎么安装，可以参考 Weex 的<a href="http://weex.apache.org/cn/guide/">官方教程</a></p><blockquote><p> 前端同学用到的 npm 有点类似我们用的 Cocopods 来管理第三方依赖库，安装 Cocopods 之前你必须安装 ruby ，因为 Cocopods 依赖 ruby 才能运行， npm 也是一样的道理，npm 依赖 Node.js 才能运行。</p></blockquote><p>Weex 的文件格式有两种，分别是 <code>.we</code> 、<code>.vue</code>，可以很明显的发现用 Vue 可以直接写 Weex 页面。笔者开始接触 Weex 的时候也是直接学 Vue ,不仅可以用来写 Weex 还可以写写其他 H5 页面。 <strong>所以我建议学 Weex 直接看 Vue 就可以了。</strong></p><h3 id="Weex-的目录结构"><a href="#Weex-的目录结构" class="headerlink" title="Weex 的目录结构"></a>Weex 的目录结构</h3> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">├── src  </span><br><span class="line">├── node_modules </span><br><span class="line">├── dist</span><br><span class="line">├── build</span><br><span class="line">├── bin</span><br><span class="line">├── package.<span class="property">json</span></span><br><span class="line">├── webpack.<span class="property">config</span>.<span class="property">js</span>    </span><br><span class="line">└── config.<span class="property">js</span>   </span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><strong>src</strong>  </p><blockquote><p>源码存放的位置，如<code>.we</code> <code>.vue</code>  </p></blockquote><p><strong>node_modules</strong> </p><blockquote><p>依赖库的存放位置，类似于Xcode项目中的 Pods 文件夹。在 package.json 所在目录执行 npm install 就会自动安装好所有的依赖，有点像 pod install。</p></blockquote><p><strong>dist</strong>  </p><blockquote><p>存放编译好的js文件 </p></blockquote><p><strong>build</strong></p><blockquote><p>存放npm build 时的 js 文件，可在 package.json 文件中配置</p></blockquote><p><strong>bin</strong>  </p><blockquote><p>存放一些 shell 脚本，一般用不到</p></blockquote><p><strong>package.json</strong>  </p><blockquote><p>项目的配置和依赖库文件，有点类似 podfile 文件</p></blockquote><p><strong>webpack.config.js</strong></p><blockquote><p>webpack 的配置文件</p></blockquote><p><strong>config.js</strong>  </p><blockquote><p>项目的相关配置文件，你可以在这个文件中配置切换不同的环境</p></blockquote><p>提到 webpack ，这个比较复杂，我们只需要知道 Weex 用 webpack 进行打包编译就行了，当然也可以用其他工具来打包；感兴趣的同学可以看一下 webpack 的<a href="http://webpack.github.io/">官网</a>。<br>当你运行 <code>npm bulid</code> 时，对应的是运行 package.json 中配置的 <code>scripts: build</code> 命令，src 文件夹中的文件都会被编译好并存放到 dist 文件夹中，这个路径在 webpack.config.js 文件中可以进行配置。<code>npm run</code> 后面跟的命令都是在 package.json 的 <code>scripts</code> 配置的。  </p><p>转载请注明出处：<a href="http://www.gaoshilei.com/">来自LeonLei的博客http://www.gaoshilei.com</a>   </p><p>Weex 前端的项目目录大概就是这样，Weex 前端的源码不在这次的讨论范围之类，如果大家感兴趣想看 Weex 前端的源码，在 node_modules 文件夹中就可以找到。<strong>关于 Weex SDK源码在后续文章中会进行深度解析。</strong><br>##Weex 运行原理<br>官方也给出了 Weex 的运行原理图，顺手牵羊拿了过来：</p><p><img src="http://img.gaoshilei.com/Weex_theroy.png" loading="lazy">  </p><p>不难发现，Weex 其实就是将 <code>.vue</code> 、<code>.we</code> 文件编译成 js 文件，打包成所谓的 JS Bundle 放到 dist 文件夹中，然后将编译好的 JS Bundle 部署到服务器上，我们的 iOS、安卓、浏览器就可以访问对应的 JS 然后由 SDK 渲染成 Native 的页面，或者浏览器的内核渲染成 DOM 节点显示。<strong>这里有个坑要提一下：虽然说是三端统一的，实际开发中还是要做兼容处理的。</strong>  </p><blockquote><p>本篇文章浅显的介绍了 Weex 的应用背景和工作原理，下篇文章将深入分析 Weex 的实现原理。 </p></blockquote><p><a href="https://www.gaoshilei.com/2017/09/26/weex-2/">Weex从入门到超神（二）</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://img.gaoshilei.com/Weex_logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着移动端发展进入白热化阶段，很多中小型公司越来越注重于APP的更新迭代速度。加上去年微信小程序的问世，前端同学似乎迎来了“第二春”，越来越多的 Native 开发者感受到了前所未有的压力，人家已经打到家门口了，难道就这样两眼旁观吗？  &lt;/p&gt;
&lt;p&gt;两年前 Facebook 团队发布了一个全新的移动端和前端无缝衔接的框架 React Native，很明显是用 React 开发的，支持在 Native 上运行的这么一个玩意，这相对于苹果漫长的审核机制的确是一个福音。可是 React 的学习曲线比较陡，网上大部分教程的性质都是 &lt;strong&gt;“React Native 从入门到放弃”&lt;/strong&gt;，RN虽好，但是对于大多数移动开发者来说学习成本过高。   &lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="http://www.gaoshilei.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JS" scheme="http://www.gaoshilei.com/tags/JS/"/>
    
    <category term="Weex" scheme="http://www.gaoshilei.com/tags/Weex/"/>
    
    <category term="Vue" scheme="http://www.gaoshilei.com/tags/Vue/"/>
    
    <category term="前端" scheme="http://www.gaoshilei.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>你真的会用strong-weak dance吗？</title>
    <link href="http://www.gaoshilei.com/strong-weak_dance/"/>
    <id>http://www.gaoshilei.com/strong-weak_dance/</id>
    <published>2017-01-16T07:34:45.000Z</published>
    <updated>2023-10-20T08:44:24.895Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>下文的讨论基于ARC  </p></blockquote><p>平时开发中我们遇到block里面引用self的情况，大部分都是这样处理的  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.myBlock =  ^&#123;</span><br><span class="line">__<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">    [strongSelf doSomething]; </span><br><span class="line">    [strongSelf doSomethingElse]; </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>转载请注明出处：<a href="http://www.gaoshilei.com/">来自LeonLei的博客http://www.gaoshilei.com</a>   </p><p>我们习惯了这样用，<strong>貌似这样用了之后可以解决循环引用的问题，而且可以保证block执行之前self不会被释放掉？真相总是残酷的，然而事实并非如此！</strong>下面将会对block中引用self的三种方式进行讨论，并给出原因和另外一种解决方案。</p><span id="more"></span><h2 id="1-block中直接引用self"><a href="#1-block中直接引用self" class="headerlink" title="1.  block中直接引用self"></a>1.  block中直接引用self</h2><p>这种情况使用是block被没有被self强引用，因此这样不会导致retain cycle。  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t completionHandler = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="2-在block外部创建weakself变量，在block中引用weakself"><a href="#2-在block外部创建weakself变量，在block中引用weakself" class="headerlink" title="2.在block外部创建weakself变量，在block中引用weakself"></a>2.在block外部创建weakself变量，在block中引用weakself</h2><p>当block被self强引用，此时如果在block内强引用self将会导致retain cycle。所以我们就想到了在block外部创建一个weakself，然后block在创建的时候捕获到的是weakself，这样就不会导致retain cycle。  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">dispatch_block_t block =  ^&#123;</span><br><span class="line">    [weakSelf doSomething]; </span><br><span class="line">    [weakSelf doSomethingElse]; </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>但是要注意的是block捕获的是weakself变量，如果在执行doSomething的过程中self被释放掉，由于是弱引用，weakself也将置空，下面的doSomethingElse是无法得到执行的，看一个例子：</p><p>下面的例子展示的是，在block调用之后的1秒后释放self，在block中调用doSomething，2秒之后再调用doAnotherThing，意味着调用doAnotherThing之前self已经被释放了  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//viewController.m</span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.sself = [strongweakself new];</span><br><span class="line">    [<span class="keyword">self</span>.sself test];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;self.block被释放!&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.sself = <span class="literal">nil</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//strongweakself.m</span></span><br><span class="line">-(<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.myobject = [TestObject new];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) __weakself = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.myobject setWeakblock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;调用block!&quot;</span>);</span><br><span class="line">        [__weakself doSomething];</span><br><span class="line">            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [__weakself doAnotherThing];</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">self</span>.myobject.weakblock();</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)doSomething</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)doAnotherThing</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)dealloc&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从打印日志可以看出，block执行大约1秒之后self被dealloc，doAnotherThing并没有得到调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-16</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">13.834</span> <span class="keyword">strong</span>-<span class="keyword">weak</span> dance[<span class="number">11366</span>:<span class="number">4727954</span>] 调用block!</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-16</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">13.836</span> <span class="keyword">strong</span>-<span class="keyword">weak</span> dance[<span class="number">11366</span>:<span class="number">4727954</span>] -[strongweakself doSomething]</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-16</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">14.893</span> <span class="keyword">strong</span>-<span class="keyword">weak</span> dance[<span class="number">11366</span>:<span class="number">4727954</span>] <span class="keyword">self</span>.block被释放!</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-16</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">14.893</span> <span class="keyword">strong</span>-<span class="keyword">weak</span> dance[<span class="number">11366</span>:<span class="number">4727954</span>] -[strongweakself dealloc]</span><br></pre></td></tr></table></figure><p>所以只使用weakself，在self被释放之后，weakself由于self的释放已经为空，后面的self都将失效，所以在block中这样引用self是非常危险的，下面就要谈谈我们最熟悉的strong-weak dance了。</p><h2 id="3-strong-weak-dance"><a href="#3-strong-weak-dance" class="headerlink" title="3.strong-weak dance"></a>3.strong-weak dance</h2><p>对比第二种方案我们看一下doAnotherThing是否可以得到调用，稍微改一下代码，还是在block执行1秒后释放self，我们看看后面的self引用是否有效</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.myobject = [TestObject new];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) __weakself = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.myobject setWeakblock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;调用block!&quot;</span>);</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) __strongself= __weakself;</span><br><span class="line">        [__strongself doSomething];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [__strongself doAnotherThing];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">self</span>.myobject.weakblock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时看打印日志：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-16</span> <span class="number">14</span>:<span class="number">36</span>:<span class="number">39.039</span> <span class="keyword">strong</span>-<span class="keyword">weak</span> dance[<span class="number">11374</span>:<span class="number">4728878</span>] 调用block!</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-16</span> <span class="number">14</span>:<span class="number">36</span>:<span class="number">39.039</span> <span class="keyword">strong</span>-<span class="keyword">weak</span> dance[<span class="number">11374</span>:<span class="number">4728878</span>] -[strongweakself doSomething]</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-16</span> <span class="number">14</span>:<span class="number">36</span>:<span class="number">40.110</span> <span class="keyword">strong</span>-<span class="keyword">weak</span> dance[<span class="number">11374</span>:<span class="number">4728878</span>] <span class="keyword">self</span>.block被释放!</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-16</span> <span class="number">14</span>:<span class="number">36</span>:<span class="number">41.213</span> <span class="keyword">strong</span>-<span class="keyword">weak</span> dance[<span class="number">11374</span>:<span class="number">4728878</span>] -[strongweakself doAnotherThing]</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-16</span> <span class="number">14</span>:<span class="number">36</span>:<span class="number">41.213</span> <span class="keyword">strong</span>-<span class="keyword">weak</span> dance[<span class="number">11374</span>:<span class="number">4728878</span>] -[strongweakself dealloc]</span><br></pre></td></tr></table></figure><p>虽然self被释放掉了，但是并没有dealloc，因为block内部的strongself对他进行了一次retain，当doAnotherThing执行完毕，strongself对他的引用计数减一，self被dealloc彻底销毁。</p><p><strong>那么问题来了！strong-weak dance能不能解决block执行前，self被释放的问题？</strong>下面继续验证<br>我们改一下代码，在1秒之后释放self，在2秒之后执行block（<em>注意延时block中对于self的处理是weakself，防止延时block对self进行retain影响验证结果</em>）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//viewController.m</span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.sself = [strongweakself new];</span><br><span class="line">    [<span class="keyword">self</span>.sself test];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;self.block被释放!&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.sself = <span class="literal">nil</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//strongweakself.m</span></span><br><span class="line">-(<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.myobject = [TestObject new];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) __weakself = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.myobject setWeakblock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;调用block!&quot;</span>);</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) __strongself= __weakself;</span><br><span class="line">    [__strongself doSomething];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [__strongself doAnotherThing];</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,__weakself);</span><br><span class="line">        __weakself.myobject.weakblock();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看一下日志：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-16</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">26.314</span> <span class="keyword">strong</span>-<span class="keyword">weak</span> dance[<span class="number">11395</span>:<span class="number">4730727</span>] <span class="keyword">self</span>.block被释放!</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-16</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">26.314</span> <span class="keyword">strong</span>-<span class="keyword">weak</span> dance[<span class="number">11395</span>:<span class="number">4730727</span>] -[strongweakself dealloc]</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-16</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">27.372</span> <span class="keyword">strong</span>-<span class="keyword">weak</span> dance[<span class="number">11395</span>:<span class="number">4730727</span>] (null)</span><br></pre></td></tr></table></figure><p>当开始调用block的时候报错了，self这时已经被dealloc掉。strong-weak dance并没有解决这种问题。看到这心是不是凉了半截？真相就是如此，我们平时一直使用的strong-weak dance也只能解决block得到调用之后self不被释放的问题。  </p><p>这是我们最常用的是一种方案，因为block创建时捕获的是weakself，所以block执行之前不能够控制self的生命周期，所以这样不会导致整个block对self进行强引用。之后在block内部创建一个对self进行retain的变量strongself，<strong>strongself 作为局部变量强引用了 self 并且会在block执行完毕的时候被自动销毁，这样既可以保证在block执行期间 self 不会被外界干掉，同时也解决了retain cycle的问题。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面几个小栗子可以看出来：strong-weak dance确实是比较好的解决方案，但是也不是万能的，他不能解决block调用之前self被释放的问题，下面将block中引用self分为4中场景：</p><h4 id="1-使用self"><a href="#1-使用self" class="headerlink" title="1.使用self"></a>1.使用self</h4><p>当self不持有、不间接持有block时，可以在block内部直接引用self。</p><h4 id="2-使用weakself"><a href="#2-使用weakself" class="headerlink" title="2.使用weakself"></a>2.使用weakself</h4><p>当self持有或间接持有block，可以通过在外部创建self的弱引用weakself然后捕获到block内部进行使用，但是这样使用存在一定风险，一般也不推荐使用。</p><h4 id="3-使用strong-weak-dance"><a href="#3-使用strong-weak-dance" class="headerlink" title="3.使用strong-weak dance"></a>3.使用strong-weak dance</h4><p>当self持有或间接持有block，此时要使用strong-weak dance。<br>这种方法也不是万能的，在block被执行前，block对self依然只是弱引用，进入block里面才会retain一次，保证在block执行期间self都不会被释放掉。</p><h4 id="4-block中强引用self并且打破retain-cycle"><a href="#4-block中强引用self并且打破retain-cycle" class="headerlink" title="4.block中强引用self并且打破retain cycle"></a>4.block中强引用self并且打破retain cycle</h4><p><strong>不管是weakself还是strong-weak dance，目的都是避免retain cycle，strong-weak dance的本质也是在block中搞了一个局部变量来打破这种循环引用的；</strong><br>如果我们在block中直接使用self，并且在适当的时机打破这种循环（比如说在block执行完成将这个block销毁）也可以避免retain cycle，并且这种在block创建时就强引用的方式，在block被调用前 self 不会被释放掉，可以弥补strong-weak dance的不足。</p><p>关于本文的内容可能存在不足的地方，欢迎大家指正！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>   <a href="http://albertodebortoli.com/blog/2013/08/03/objective-c-blocks-caveat">http://albertodebortoli.com/blog/2013/08/03/objective-c-blocks-caveat</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;下文的讨论基于ARC  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;平时开发中我们遇到block里面引用self的情况，大部分都是这样处理的  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) weakSelf = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.myBlock =  ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) strongSelf = weakSelf;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [strongSelf doSomething]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [strongSelf doSomethingElse]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;  &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;转载请注明出处：&lt;a href=&quot;http://www.gaoshilei.com/&quot;&gt;来自LeonLei的博客http://www.gaoshilei.com&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;我们习惯了这样用，&lt;strong&gt;貌似这样用了之后可以解决循环引用的问题，而且可以保证block执行之前self不会被释放掉？真相总是残酷的，然而事实并非如此！&lt;/strong&gt;下面将会对block中引用self的三种方式进行讨论，并给出原因和另外一种解决方案。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="http://www.gaoshilei.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="block" scheme="http://www.gaoshilei.com/tags/block/"/>
    
    <category term="retain cycle" scheme="http://www.gaoshilei.com/tags/retain-cycle/"/>
    
  </entry>
  
  <entry>
    <title>RunLoop的前世今生</title>
    <link href="http://www.gaoshilei.com/RunLoop/"/>
    <id>http://www.gaoshilei.com/RunLoop/</id>
    <published>2016-11-20T06:23:11.000Z</published>
    <updated>2023-10-20T08:44:31.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、RunLoop初识"><a href="#一、RunLoop初识" class="headerlink" title="一、RunLoop初识"></a>一、RunLoop初识</h1><p>日常的开发工作中，我们几乎很少注意RunLoop，因为我们基本上“用不到”RunLoop。包括我在内应该有很多人都不了解这个东西，只是听说过。最近有空查了不少资料终于把RunLoop运行原理搞清楚了。<br>本文会对RunLoop的原理进行深入探讨，但是不涉及底层的实现。<br>我们平时开发中的很多东西都和RunLoop相关，比如：  </p><span id="more"></span><ul><li>   AutoreleasePool   </li><li>   NSTimer  </li><li>   消息通知</li><li>   perform函数</li><li>   网络请求</li><li>   dispatch调用</li><li>   block回调</li><li>   KVO</li><li>   触摸事件以及各种硬件传感器</li></ul><p>RunLoop机制贯穿整个App的生命周期的，这里提前剧透个彩蛋：  </p><blockquote><p>我们都知道：如果主线程的RunLoop挂掉了，App也就挂掉了  </p></blockquote><p><strong>BUT：</strong>  <br>我们通过RunLoop机制可以让崩溃的App继续保持运行，非常英吹思婷！后面会有介绍。 </p><p>转载请注明出处：<a href="http://www.gaoshilei.com/">来自LeonLei的博客http://www.gaoshilei.com</a>   </p><h1 id="二、RunLoop详解"><a href="#二、RunLoop详解" class="headerlink" title="二、RunLoop详解"></a>二、RunLoop详解</h1><p>计算机处理任务有进程和线程的概念，安卓中一个应用可以开启多个进程，而在iOS中一个App只能开启一个进程，但是线程可以开启多个。线程是用来处理事务的，多个线程处理事务是为了防止线程堵塞；一般来说一个线程一次只能执行一个任务，任务执行完成这个线程就会退出。<br>某些情况下我们需要这个线程一直运行着，不管有没有任务执行（<em>比方说App的主线程</em>），所以需要一种机制来维持线程的生命周期，iOS中叫做RunLoop，安卓里面的Looper机制和此类似。<br>为了让线程不退出随时候命处理事件而不退出，可以将逻辑简化为下面的代码  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    var message = getNewmessages();<span class="comment">//接收来自外部的消息</span></span><br><span class="line">    exec(message);<span class="comment">//处理消息任务</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>==isQuit)</span><br></pre></td></tr></table></figure><p>RunLoop实际上也是一个对象，这个对象管理了线程内部需要处理的事件和消息，存在RunLoop的线程一直处于“消息接收-&gt;等待-&gt;处理”的循环中，直到这个循环结束（RunLoop被释放）。  </p><h2 id="1-进程、线程、RunLoop之间的关系"><a href="#1-进程、线程、RunLoop之间的关系" class="headerlink" title="1.进程、线程、RunLoop之间的关系"></a>1.进程、线程、RunLoop之间的关系</h2><p><strong>这里举一个比较通俗易懂的例子：</strong> </p><ul><li>   进程：工厂  </li><li>   线程：流水线  </li><li>   RunLoop：生产线上面的主管</li></ul><p>当工厂接到商家的订单时，会将订单生产的消息（外界的event消息）发送给对应流水线上的主管（RunLoop），主管接收到消息之后启动这个流水线（唤醒线程）进行生产（线程处理事务）。如果这个流水线没有主管，流水线将会被工厂销毁。  </p><p>需要注意的是，线程与RunLoop是一一对应的关系（对应关系保存在一个全局的Dictionary里），线程创建之后是没有RunLoop的（主线程除外），RunLoop的创建是发生在第一次获取时。  </p><blockquote><p>苹果不允许直接创建RunLoop，但是可以通过[NSRunLoop currentRunLoop]或者CFRunLoopGetCurrent()来获取（如果没有就会自动创建一个）。</p></blockquote><p>一般开发中使用的RunLoop就是NSRunLoop和CFRunLoopRef，CFRunLoopRef属于Core Foundation框架，提供的是C函数的API，<strong>是线程安全的</strong>，NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，<strong>这些API不是线程安全的</strong>。  </p><p>由于NSRunLoop是基于CFRunLoop封装的，下文关于RunLoop的原理讨论都会基于CFRunLoop来进行。NSRunLoop和CFRunLoop所有类都是一一对应的关系。</p><h2 id="2-RunLoop主要组成"><a href="#2-RunLoop主要组成" class="headerlink" title="2.RunLoop主要组成"></a>2.RunLoop主要组成</h2><blockquote><p>CFRunLoop对象可以检测某个task或者dispatch的输入事件，当检测到有输入源事件，CFRunLoop将会将其加入到线程中进行处理。比方说用户输入事件、网络连接事件、周期性或者延时事件、异步的回调等。  </p><p>RunLoop可以检测的事件类型一共有3种，分别是CFRunLoopSource、CFRunLoopTimer、CFRunLoopObserver。可以通过CFRunLoopAddSource, CFRunLoopAddTimer或者CFRunLoopAddObserver添加相应的事件类型。  </p><p>要让一个RunLoop跑起来还需要run loop modes，每一个source, timer和observer添加到RunLoop中时必须要与一个模式（CFRunLoopMode）相关联才可以运行。</p></blockquote><p>上面是对于CFRunLoop官方文档的解释，大致说明了RunLoop的工作原理。<br>RunLoop的主要组成部分如下：  </p><ul><li>   Run Loop （CFRunLoopRef）</li><li>   Run Loop Source（CFRunLoopSourceRef）</li><li>   Run Loop Timer（CFRunLoopTimerRef）</li><li>   Run Loop Observer（CFRunLoopObserverRef）</li><li>   Run Loop Modes（CFRunLoopModeRef）</li></ul><p>RunLoop共包含5个类，但公开的只有Source、Timer、Observer相关的三个类。<br>这5个类之间的关系关系：<br><img src="http://img.gaoshilei.com/RunLoop.png" loading="lazy"></p><p>下面对这几个部分作详细的讲解。  </p><h3 id="1-RunLoop-Modes"><a href="#1-RunLoop-Modes" class="headerlink" title="1.RunLoop Modes"></a>1.RunLoop Modes</h3><blockquote><p>Run Loop Mode就是流水线上能够生产的产品类型，流水线在一个时刻只能在一种模式下运行，生产某一类型的产品。消息事件就是订单。  </p></blockquote><p>CFRunLoopMode 和 CFRunLoop的结构大致如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个RunLoop包含了多个Mode，每个Mode又包含了若干个Source&#x2F;Timer&#x2F;Observer。每次调用 RunLoop的主函数时，只能指定其中一个Mode，这个Mode被称作CurrentMode。如果需要切换 Mode，只能退出Loop，再重新指定一个Mode进入。这样做主要是为了分隔开不同Mode中的Source&#x2F;Timer&#x2F;Observer，让其互不影响。下面是5种Mode  </p><ul><li>   <strong>kCFDefaultRunLoopMode</strong>App的默认Mode，通常主线程是在这个Mode下运行</li><li>   <strong>UITrackingRunLoopMode</strong>界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li><li>   <strong>UIInitializationRunLoopMode</strong> 在刚启动App时第进入的第一个Mode，启动完成后就不再使用</li><li>   <strong>GSEventReceiveRunLoopMode</strong>接受系统事件的内部Mode，通常用不到</li><li>   <strong>kCFRunLoopCommonModes</strong>这是一个占位用的Mode，不是一种真正的Mode</li></ul><p>其中kCFDefaultRunLoopMode、UITrackingRunLoopMode是苹果公开的，其余的mode都是无法添加的。既然没有CommonModes这个模式，那我们平时用的这行代码怎么解释呢？  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; </span><br></pre></td></tr></table></figure><p><strong>什么是CommonModes？</strong>   </p><p>一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source&#x2F;Observer&#x2F;Timer 同步到具有 “Common” 标记的所有Mode里<br>主线程的 RunLoop 里有 kCFRunLoopDefaultMode 和 UITrackingRunLoopMode，这两个Mode都已经被标记为”Common”属性。当你创建一个Timer并加到DefaultMode时，Timer会得到重复回调，但此时滑动一个 scrollView 时，RunLoop 会将 mode 切换为TrackingRunLoopMode，这时Timer就不会被回调，并且也不会影响到滑动操作。<br>如果想让scrollView滑动时Timer可以正常调用，一种办法就是手动将这个 Timer 分别加入这两个 Mode。另一种方法就是将 Timer 加入到CommonMode 中。</p><p><strong>怎么将事件加入到CommonMode？</strong><br>我们调用上面的代码将 Timer 加入到CommonMode 时，但实际并没有 CommonMode，其实系统将这个 Timer 加入到顶层的 RunLoop 的 commonModeItems 中。commonModeItems 会被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。<br>这一步其实是系统帮我们将Timer加到了kCFRunLoopDefaultMode和UITrackingRunLoopMode中。  </p><h3 id="2-RunLoop-Source"><a href="#2-RunLoop-Source" class="headerlink" title="2.RunLoop Source"></a>2.RunLoop Source</h3><p>CFRunLoopSourceRef是事件源（输入源），比如外部的触摸，点击事件和系统内部进程间的通信等。<br>按照官方文档，Source的分类：</p><ul><li>   Port-Based Sources</li><li>   Custom Input Sources</li><li>   Cocoa Perform Selector Sources</li></ul><p>Source有两个版本：Source0 和 Source1（<em>这么风骚的名字不知道是谁想出来的</em>）。<br><strong>Source0：</strong>非基于Port的，只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。<br><strong>Source1：</strong>基于Port的，包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。后面讲到的AFNetwoeking创建常驻线程就是在线程中添加一个NSport来实现的。</p><h3 id="3-RunLoop-Timer"><a href="#3-RunLoop-Timer" class="headerlink" title="3.RunLoop Timer"></a>3.RunLoop Timer</h3><p>CFRunLoopTimerRef是基于时间的触发器，基本上说的就是NSTimer，它受RunLoop的Mode影响（GCD的定时器不受RunLoop的Mode影响），当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。如果线程阻塞或者不在这个Mode下，触发点将不会执行，一直等到下一个周期时间点触发。</p><h3 id="4-RunLoop-Observer"><a href="#4-RunLoop-Observer" class="headerlink" title="4.RunLoop Observer"></a>4.RunLoop Observer</h3><p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="built_in">CFRunLoopActivity</span> &#123;</span><br><span class="line">    kCFRunLoopEntry                     = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),    <span class="comment">// 即将进入Loop   </span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>),    <span class="comment">// 即将处理 Timer    </span></span><br><span class="line">    kCFRunLoopBeforeSources= (<span class="number">1</span> &lt;&lt; <span class="number">2</span>),    <span class="comment">// 即将处理 Source  </span></span><br><span class="line">    kCFRunLoopBeforeWaiting= (<span class="number">1</span> &lt;&lt; <span class="number">5</span>),    <span class="comment">// 即将进入休眠     </span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span> &lt;&lt; <span class="number">6</span>),    <span class="comment">// 刚从休眠中唤醒   </span></span><br><span class="line">    kCFRunLoopExit                      = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>),    <span class="comment">// 即将退出Loop  </span></span><br><span class="line">    kCFRunLoopAllActivities= <span class="number">0x0FFFFFFF</span>U  <span class="comment">// 包含上面所有状态  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="built_in">CFRunLoopActivity</span> <span class="built_in">CFRunLoopActivity</span>;</span><br></pre></td></tr></table></figure><h2 id="3-RunLoop-运行机制"><a href="#3-RunLoop-运行机制" class="headerlink" title="3.RunLoop 运行机制"></a>3.RunLoop 运行机制</h2><p>这是我从别人博客上面摘录的一张图片，详细的描述了RunLoop运行机制<br><img src="http://img.gaoshilei.com/RunLoop_1.png" loading="lazy">  </p><p>每次线程运行RunLoop都会自动处理之前未处理的消息，并且将消息发送给观察者，让事件得到执行。RunLoop运行时首先根据modeName找到对应mode，如果mode里没有source&#x2F;timer&#x2F;observer，直接返回。<br><strong>流程如下：</strong>  </p><p><strong>Step1</strong>  通知观察者 RunLoop 启动（之后调用内部函数，进入Loop，下面的流程都在Loop内部do-while函数中执行）<br><strong>Step2</strong>  通知观察者: RunLoop 即将触发 Timer 回调。（kCFRunLoopBeforeTimers）<br><strong>Step3</strong>  通知观察者: RunLoop 即将触发 Source0 回调。（kCFRunLoopBeforeSources）<br><strong>Step4</strong>  RunLoop 触发 Source0 回调。<br><strong>Step5</strong> 如果有 Source1 处于等待状态，直接处理这个 Source1 然后跳转到第9步处理消息。<br><strong>Step6</strong>通知观察者：RunLoop 的线程即将进入休眠(sleep)。（kCFRunLoopBeforeWaiting）<br><strong>Step7</strong>调用 <code>mach_msg</code> 等待接受 <code>mach_port</code> 的消息。线程将进入休眠, 直到被下面某一个事件唤醒  </p><blockquote><ol><li>   存在Source0被标记为待处理，系统调用CFRunLoopWakeUp唤醒线程处理事件  </li><li>   定时器时间到了   </li><li>   RunLoop自身的超时时间到了  </li><li>   RunLoop外部调用者唤醒</li></ol></blockquote><p><strong>Step8</strong>通知观察者线程已经被唤醒 （kCFRunLoopAfterWaiting）<br><strong>Step9</strong>   处理事件  </p><blockquote><ol><li>   如果一个 Timer 到时间了，触发这个Timer的回调    </li><li>   如果有dispatch到main_queue的block，执行block   </li><li>   如果一个 Source1 发出事件了，处理这个事件</li></ol></blockquote><p><strong>事件处理完成进行判断：</strong>  </p><blockquote><ol><li>进入loop时传入参数指明处理完事件就返回（stopAfterHandle）  </li><li>超出传入参数标记的超时时间（timeout）  </li><li>被外部调用者强制停止<code>__CFRunLoopIsStopped(runloop)</code>   </li><li>source&#x2F;timer&#x2F;observer 全都空了<code>__CFRunLoopModeIsEmpty(runloop, currentMode)</code></li></ol></blockquote><p>上面4个条件都不满足，即没超时、mode里没空、loop也没被停止，那继续loop。此时跳转到步骤2继续循环。  </p><p><strong>Step10</strong>系统通知观察者: RunLoop 即将退出。<br>满足步骤9事件处理完成判断4条中的任何一条，跳出do-while函数的内部，通知观察者Loop结束。</p><h1 id="三、RunLoop实际应用"><a href="#三、RunLoop实际应用" class="headerlink" title="三、RunLoop实际应用"></a>三、RunLoop实际应用</h1><h2 id="1-AutoreleasePool"><a href="#1-AutoreleasePool" class="headerlink" title="1. AutoreleasePool"></a>1. AutoreleasePool</h2><p>App启动之后，系统启动主线程并创建了RunLoop，在 main thread 中注册了两个 observer ，回调都是<code>_wrapRunLoopWithAutoreleasePoolHandler()</code>  </p><h3 id="1-第一个observer"><a href="#1-第一个observer" class="headerlink" title="1.第一个observer"></a>1.第一个observer</h3><p>监听了一个事件：<br>####1.即将进入Loop（kCFRunLoopEntry）<br>其回调会调用 <code>_objc_autoreleasePoolPush()</code> 创建一个栈自动释放池，这个优先级最高，保证创建释放池在其他操作之前。<br>###2.第二个observer<br>监听了两个事件：<br>####1.准备进入休眠（kCFRunLoopBeforeWaiting）<br>此时调用 <code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 来释放旧的池并创建新的池。<br>####2. 即将退出Loop（kCFRunLoopExit）<br>此时调用 <code>_objc_autoreleasePoolPop()</code>释放自动释放池。这个 observer 的优先级最低，确保池子释放在所有回调之后。  </p><p>在主线程中执行代码一般都是写在事件回调或Timer回调中的，这些回调都被加入了main thread的自动释放池中，所以在ARC模式下我们不用关心对象什么时候释放，也不用去创建和管理pool。（如果事件不在主线程中要注意创建自动释放池，否则可能会出现内存泄漏）。  </p><h2 id="2-事件响应"><a href="#2-事件响应" class="headerlink" title="2.事件响应"></a>2.事件响应</h2><p>系统注册了一个 Source1 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。当一个硬件事件(触摸&#x2F;锁屏&#x2F;摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收，</p><blockquote><p>SpringBoard 只接收按键(锁屏&#x2F;静音等)、触摸、加速，传感器等几种事件  </p></blockquote><p>随后用 mach port 转发给需要的App进程。随后系统注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code>进行应用内部的分发。<br><code>_UIApplicationHandleEventQueue()</code> 会把 IOHIDEvent 事件处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture&#x2F;处理屏幕旋转&#x2F;发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin&#x2F;Move&#x2F;End&#x2F;Cancel 事件都是在这个回调中完成的。    </p><h2 id="3-定时器"><a href="#3-定时器" class="headerlink" title="3.定时器"></a>3.定时器</h2><h3 id="1-NSTimer-的工作原理"><a href="#1-NSTimer-的工作原理" class="headerlink" title="1.NSTimer 的工作原理"></a>1.NSTimer 的工作原理</h3><p>这里说的定时器就是NSTimer，我们使用频率最高的定时器，它的原型是CFRunLoopTimerRef。一个Timer注册 RunLoop 之后，RunLoop 会为这个Timer的重复时间点注册好事件。<br>需要注意：  </p><blockquote><ol><li><p>   如果某个重复的时间点由于线程阻塞或者其他原因错过了，这个时间点会跳过去，直到下一个可以执行的时间点才会触发事件。举个栗子：假如公交车的发车间隔是10分钟，10:10的公交车我们没赶上，只能等10:20，如果由于我打电话没注意错过了10:20的车，只能等10:30的。  </p></li><li><p>   我们在哪个线程调用 NSTimer 就必须在哪个线程终止</p></li></ol></blockquote><p>NSTimer有一个 tolerance ，官方文档给它的解释是 Timer 的计时并不是准确的，有一定的误差，这个误差就是 tolerance 默认为0，我们可以手动设置这个误差。文档最后还强调了，为了防止时间点偏移，系统有权力给这个属性设置一个值无论你设置的值是多少，即使RunLoop 模式正确，当前线程并不阻塞，系统依然可能会在 NSTimer 上加上很小的的容差。    </p><h3 id="2-NSTimer-优化使用"><a href="#2-NSTimer-优化使用" class="headerlink" title="2.NSTimer 优化使用"></a>2.NSTimer 优化使用</h3><p>我们在平时开发中一个很常见的现象：</p><blockquote><p>在界面上有一个UIscrollview控件（tableview，collectionview等），如果此时还有一个定时器在执行一个事件，你会发现当你滚动scrollview的时候，定时器会失效。</p></blockquote><p>这是因为，为了更好的用户体验，在主线程中UITrackingRunLoopMode的优先级最高。在用户拖动控件时，主线程的Run Loop是运行在UITrackingRunLoopMode下，而创建的Timer是默认关联为Default Mode，因此系统不会立即执行Default Mode下接收的事件。  </p><p>解决方法1：<br>将当前 Timer 加入到 UITrackingRunLoopMode 或 kCFRunLoopCommonModes 中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> * timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(TimerFire:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];  </span><br><span class="line"><span class="comment">// 或 [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span></span><br><span class="line">[timer fire];</span><br></pre></td></tr></table></figure><p>解决方法2：<br>因为GCD创建的定时器不受RunLoop的影响，可以使用GCD创建的定时器 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dispatch_source_t必须是全局或static变量，否则timer不会触发</span></span><br><span class="line">   <span class="keyword">static</span> dispatch_source_t timer;</span><br><span class="line">   <span class="comment">//创建新的调度源（这里传入的是DISPATCH_SOURCE_TYPE_TIMER，创建的是Timer调度</span></span><br><span class="line">   timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br><span class="line">   dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">   dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//启动或继续定时器</span></span><br><span class="line">   dispatch_resume(timer);</span><br></pre></td></tr></table></figure><h3 id="3-基于mode的拓展应用"><a href="#3-基于mode的拓展应用" class="headerlink" title="3.基于mode的拓展应用"></a>3.基于mode的拓展应用</h3><p>在 Timer 使用中我们可以通过将其加入到不同的mode来解决 Timer 的跳票问题。不过有些情况下，例如：  </p><blockquote><p>用户滑动 scrollView 的过程中加载图片，由于UI的操作都是在主线程进行的，会造成滑动不流畅的问题，这个时候我们就需要在滑动的时候不加载图片，等滑动操作完成再进行加载图片的操作。  </p></blockquote><p>一般我们可以设置代理，当用户滑动结束的时候通知代理加载图片，这样比较麻烦太low，基于RunLoop的原理我们只要一行代码即可搞定  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *downloadImage = ...</span><br><span class="line">[<span class="keyword">self</span>.imageView performSelector:<span class="keyword">@selector</span>(setImage:) </span><br><span class="line">withObject: downloadImage </span><br><span class="line">afterDelay:<span class="number">3.0</span> </span><br><span class="line">inModes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];</span><br></pre></td></tr></table></figure><p>通过将图片的设置 <code>setImage:</code> 添加到 DefaultMode 里面，确保在 UITrackingRunLoopMode 下该操作不会被执行，保证了滑动的流畅性。  </p><h2 id="4-网络请求"><a href="#4-网络请求" class="headerlink" title="4.网络请求"></a>4.网络请求</h2><h3 id="1-网络请求接口"><a href="#1-网络请求接口" class="headerlink" title="1.网络请求接口"></a>1.网络请求接口</h3><p>iOS中的网络请求接口自下而上有这么几层<br><img src="http://img.gaoshilei.com/runloop-nsnetwork.png" loading="lazy">  </p><p><strong>CFSocket</strong> 是最底层的接口，只负责 socket 通信。<br><strong>CFNetwork</strong> 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作在这层。<br><strong>NSURLConnection</strong> 是基于 CFNetwork 更高层的封装，提供了面向对象的接口，AFNetworking 工作在这一层。<br><strong>NSURLSession</strong> 看似是和 NSURLConnection 并列的，实际上它也用到了 NSURLConnection 的部分功能(比如 com.apple.NSURLConnectionLoader 线程)</p><p>开始网络传输时，NSURLConnection 创建了两个新线程：<code>com.apple.NSURLConnectionLoader</code> 和 <code>com.apple.CFSocket.private</code>。<br>其中 CFSocket 线程是处理底层 socket 连接的，NSURLConnectionLoader 这个线程的RunLoop 创建了一个 Source1 事件源用来监听底层 socket 事件。当 CFSocket 处理好 socket 事件之后会通过 mach port 通知 NSURLConnectionLoader，然后 NSURLConnectionLoader 所在的线程再将消息通过 mach prot 转发给上层的 Delegate 所在的线程，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。  </p><h3 id="2-AFNetworking-的工作原理"><a href="#2-AFNetworking-的工作原理" class="headerlink" title="2.AFNetworking 的工作原理"></a>2.AFNetworking 的工作原理</h3><p>在AFNetworking2.6.3版本之前是有 AFURLConnectionOperation 这个类的，<br>AFNetworking 3.0 版本开始已经移除了这个类，AFN没有自己创建线程，而是采用的下面的这种方式  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[inputStream scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">[outputStream scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];  </span><br><span class="line"></span><br><span class="line"><span class="built_in">SCNetworkReachabilityUnscheduleFromRunLoop</span>(<span class="keyword">self</span>.networkReachability, <span class="built_in">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure><p>由于本文讨论的是RunLoop，所以这里我们还是回到2.6.3版本AFN自己创建线程并添加RunLoop的这种方式讨论，在 AFURLConnectionOperation 类中可以找到下面的代码  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)networkRequestThreadEntryPoint:(<span class="type">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@&quot;AFNetworking&quot;</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，AFN创建了一个新的线程命名为 AFNetworking ，然后在这个线程中创建了一个 RunLoop ，在上面2.3章节 RunLoop 运行机制中提到了，一个RunLoop中如果source&#x2F;timer&#x2F;observer 都为空则会退出，并不进入循环。所以，AFN在这里为 RunLoop 添加了一个 NSMachPort ，这个port开启相当于添加了一个Source1事件源，但是这个事件源并没有真正的监听什么东西，只是为了不让 RunLoop 退出。 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始请求</span></span><br><span class="line">- (<span class="type">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暂停请求</span></span><br><span class="line">- (<span class="type">void</span>)pause &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isPaused] || [<span class="keyword">self</span> isFinished] || [<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isExecuting]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidPause) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSNotificationCenter</span> *notificationCenter = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">            [notificationCenter postNotificationName:AFNetworkingOperationDidFinishNotification object:<span class="keyword">self</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.state = AFOperationPausedState;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消请求</span></span><br><span class="line">- (<span class="type">void</span>)cancel &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> isFinished] &amp;&amp; ![<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="variable language_">super</span> cancel];</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isExecuting]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，AFN每次进行的网络操作，开始、暂停、取消操作时都将相应的执行任务扔进了自己创建的线程的 RunLoop 中进行处理，从而避免造成主线程的阻塞。  </p><h2 id="5-处理崩溃让程序继续运行"><a href="#5-处理崩溃让程序继续运行" class="headerlink" title="5.处理崩溃让程序继续运行"></a>5.处理崩溃让程序继续运行</h2><p>我们都知道，如果App运行遇到 Exception 就会直接崩溃并且退出，其实真正让应用退出的并不是产生的异常，而是当产生异常时，系统会结束掉当前主线程的 RunLoop ，RunLoop 退出主线程就退出了，所以应用才会退出。明白这个道理，去完成这个“不可能的任务”就很简单了。  </p><p>接下来我们就去让应用在崩溃时依然可以正常运行，这个是非常有意义的。  </p><h3 id="1-提升用户体验"><a href="#1-提升用户体验" class="headerlink" title="1.提升用户体验"></a>1.提升用户体验</h3><p>应用遇到BUG崩溃时一般会给使用者造成非常不好的用户体验，如果当应用崩溃时我们让用户选择退出还是继续运行，那么用户会感觉我们的App跟别人的不一样，叼叼哒！</p><h3 id="2-收集崩溃日志"><a href="#2-收集崩溃日志" class="headerlink" title="2.收集崩溃日志"></a>2.收集崩溃日志</h3><p>苹果提供了产生 Exception 的处理方法，我们可以在相应的方法中处理产生的异常，但是这个时间非常的短，之后应用就会退出，具体多长时间我们也不清楚，很被动。如果我们可以在应用崩溃时，有足够的时间收集并且上传到服务器，那么给我们的分析和解决BUG会带来相当大的便利。  </p><p>下面直接上代码，非常简单：  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="built_in">CFArrayRef</span> allModes = <span class="built_in">CFRunLoopCopyAllModes</span>(runLoop);</span><br><span class="line"><span class="keyword">while</span> (!isQuit)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *mode <span class="keyword">in</span> (__bridge <span class="built_in">NSArray</span> *)allModes) &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopRunInMode</span>((<span class="built_in">CFStringRef</span>)mode, <span class="number">0.001</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CFRelease</span>(allModes);</span><br></pre></td></tr></table></figure><p>把上面的代码添加到 Exception 的handle方法中，此时创建了一个 RunLoop ，让这个 RunLoop 在所有的 Mode 下面一直不停的跑，保证主线程不会退出，我们的应用也就存活下来了。</p><p>参考：<br><a href="https://developer.apple.com/reference/corefoundation/cfrunloopref">https://developer.apple.com/reference/corefoundation/cfrunloopref</a><br><a href="http://iphil.cc/?p=279">http://iphil.cc/?p=279</a><br><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios&#x2F;</a><br><a href="http://www.itdadao.com/article/25145/">http://www.itdadao.com/article/25145/</a>  </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、RunLoop初识&quot;&gt;&lt;a href=&quot;#一、RunLoop初识&quot; class=&quot;headerlink&quot; title=&quot;一、	RunLoop初识&quot;&gt;&lt;/a&gt;一、	RunLoop初识&lt;/h1&gt;&lt;p&gt;日常的开发工作中，我们几乎很少注意RunLoop，因为我们基本上“用不到”RunLoop。包括我在内应该有很多人都不了解这个东西，只是听说过。最近有空查了不少资料终于把RunLoop运行原理搞清楚了。&lt;br&gt;本文会对RunLoop的原理进行深入探讨，但是不涉及底层的实现。&lt;br&gt;我们平时开发中的很多东西都和RunLoop相关，比如：  &lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="http://www.gaoshilei.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="RunLoop" scheme="http://www.gaoshilei.com/tags/RunLoop/"/>
    
    <category term="NSTimer" scheme="http://www.gaoshilei.com/tags/NSTimer/"/>
    
    <category term="AutoreleasePool" scheme="http://www.gaoshilei.com/tags/AutoreleasePool/"/>
    
    <category term="AFNetworking" scheme="http://www.gaoshilei.com/tags/AFNetworking/"/>
    
  </entry>
  
  <entry>
    <title>iOS静态库SDK制作（包含第三方静态库）</title>
    <link href="http://www.gaoshilei.com/Static%20Library/"/>
    <id>http://www.gaoshilei.com/Static%20Library/</id>
    <published>2016-11-17T16:00:00.000Z</published>
    <updated>2023-10-20T08:42:41.523Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>以下所涉及的框架和库只针对iOS而言，不确保在其他平台也适用。</p></blockquote><p>最近由于公司业务需要，要求封装一个支付SDK，需要用到微信支付和支付宝，之前做过的Framework没有依赖其他第三方的库所以比较好做，这次有所不同；一开始我想把支付宝和微信支付的SDK全部融合进来，折腾一天才发现我之前的想法有很多误区，这样是根本行不通的，不过最后还是封装成功了，下面把我的经验分享出来，供有需要的同学少走弯路。 制作之前最好把功课做足，看看静态库和动态库到底是什么东西。  </p><span id="more"></span><p>转载请注明出处：<a href="http://www.gaoshilei.com/">来自LeonLei的博客http://www.gaoshilei.com</a>  </p><h2 id="一-静态库和动态库的详细介绍"><a href="#一-静态库和动态库的详细介绍" class="headerlink" title="一.静态库和动态库的详细介绍"></a>一.静态库和动态库的详细介绍</h2><p>我们平时的工程中或多或少都要引入第三方的SDK，就算你没有引入第三方的，至少引用过系统的Framework吧？其实这些SDK和Framework都属于库，库又分为静态库和动态库，我们平时导入的第三方SDK有的是Framework，有的是.a，到底哪些是动态库，哪些是静态库呢？下面分别介绍静态库、动态库，Framework和.a以及.dylib&#x2F;.tbd区别  <br>###一.静态库与动态库<br>首先要解释一下什么是库，库(Library)其实就是一段编译好的二进制代码，加上头文件就可以供别人使用，一般会有两种情况要用到库：  </p><ul><li>某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件。  </li><li>对于某些不会进行大的改动的代码，比方说很多大公司常用且很少变动的模块都会编译成库，这样做的好处一是可以节省编译时间，二来对于代码的管理也非常方便。</li></ul><p>因为库是已经编译好的二进制文件了，编译的时候只需要link一下，<strong>既然提到了link那就有不同的形式了，静态和动态，与之相对应的就是静态库和动态库</strong>。   </p><h4 id="1-静态库"><a href="#1-静态库" class="headerlink" title="1. 静态库"></a>1. 静态库</h4><p>平时我们用的第三方SDK基本上都是静态库，静态库的几个特点：  </p><ul><li>   在App项目编译的时候会被拷贝一份编译到目标程序中，相当于将静态库嵌入了，所以得到的App二进制文件会变大。</li><li>在使用的时候，需要手动导入静态库所依赖的其他类库。<em>（比如说某个SDK中使用到了CoreMotion.framework，在使用的时候需要手动导入。有的SDK需要link十几个系统库，这个时候非常恶心，只能一个一个手动加，这是静态库一个很大的不便之处。）</em> </li><li>导入静态库的应用可以减少对外界的依赖，如果导入的是第三方动态库，动态库找不到的话应用就会崩掉，例如Linux上经常出现的lib not found。</li><li>静态库很大的一个优点是减少耦合性，因为静态库中是不可以包含其他静态库的，使用的时候要另外导入它的依赖库，最大限度的保证了每一个静态库都是独立的，不会重复引用。</li></ul><h4 id="2-动态库"><a href="#2-动态库" class="headerlink" title="2.动态库"></a>2.动态库</h4><p>这个是我们最常用的一类库，使用频率最高的UIKit.framework和Fundation.framework都属于动态库，所有.dylib和.tbd结尾的都属于动态库。动态库的几个特点：  </p><ul><li>   平时使用的系统库都放在iOS系统中，在你打包应用程序的时候这些库不会拷贝到你的程序中，当需要使用的时候会动态从iOS系统中加载它们，因为这个原因，动态库也被称作共享库。编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。</li><li><pre><code>这些库是所有应用公用的，换一种说法就是节省了应用安装包的体积，这是区别静态库很重要的一个特点，因为静态库使用一次就要拷贝一次，非常浪费资源。  </code></pre></li><li>动态库在制作的时候可以直接包含静态库，也能自动link所需要的依赖库。</li><li>使用动态库的时候不需要再次link依赖库，即导即用，这个就厉害了。<strong>唯一需要注意的是在导入自己制作的动态库时，需要在Embedded Binaries中导入，不然会报错：image not found。此时这个动态库会跟静态库一样被拷贝到目标程序中进行编译，苹果又把这种Framework叫做<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html">Embedded Framework</a></strong></li></ul><p><strong>关于动态库要搞清楚一点，我们自己制作的动态库与系统动态库的区别，我们自己制作的动态库引入App项目的时候需要embed进项目，也就是要拷贝到目标程序中，这就有点不像动态库的特性了，苹果这么做也是考虑安全问题吧！</strong><br>至于能不能正常上架，我也不清楚，查了大量资料都是抄来抄去没说清楚，我猜测是不能上架的，因为一般的第三方SDK也都是静态库的形式，我猜测一个重要原因是iOS的应用本来就是运行在沙盒里面的，不同应用之间不能共享代码，同时动态下载代码苹果肯定也是明令禁止的，所以动态库也就失去意义了。当然可能还有其他因素，欢迎交流学习！</p><h3 id="二-Framework、-a、-dylib-x2F-tbd"><a href="#二-Framework、-a、-dylib-x2F-tbd" class="headerlink" title="二.Framework、.a、.dylib&#x2F;.tbd"></a>二.Framework、.a、.dylib&#x2F;.tbd</h3><h4 id="1-Framework"><a href="#1-Framework" class="headerlink" title="1.Framework"></a>1.Framework</h4><p>Framework的英文释意是框架，主要由Headers、binary文件、.bundle这三部分构成，除此之外还有Info.plist和Modules，后两者主要记录Framework的版本之类的信息，一般都会删掉，不做讨论  </p><ul><li>   <strong>Headers</strong><br>包含我们在制作Framework的时候暴露的头文件，所有被暴露的.h都放在这里。</li><li>   <strong>binary文件</strong><br>整个Framework的核心，所有代码都被编译成了这样一坨二进制文件，这里要注意的是添加的依赖库不会被编译进来，用的时候还需要重新link其他依赖库。  </li><li>   <strong>.bundle</strong><br>资源文件都打包放在这里。在制作Framework的时候不可以把图片直接放在项目中，否则制作好之后图片是一张一张的出现在项目中非常乱，需要新建一个bundle将图片放进去，这里的bundle提供整个SDK的图片资源。<br><strong>注意：</strong>图片放进bundle之后不可以用<code>[UIImage ImageWithName:]</code>读取图片。要先找到bundle包再拿图片。</li></ul><p>这里要纠正一个误区</p><blockquote><p>很多人认为系统的Framework就是动态库，我们自己制作的Framework就是静态库。  </p></blockquote><p>其实Framework既可以是静态库也可以是动态库，这取决于编译成的Mach-O（就是那个二进制文件）是动态库还是静态库，Framework本质上并不是一个库，它是苹果为了方便开发者提供了一种库的打包方式，Framework会将Mach-O文件、头文件和资源包全都包含进来，不需要你再手动整理，我们也可以通过Xcode来制作framework动态库使用。<br><strong>所以总结： Framework是库的打包形式，既可以是动态库也是静态库。</strong></p><h4 id="2-a静态库"><a href="#2-a静态库" class="headerlink" title="2..a静态库"></a>2..a静态库</h4><p>这类静态库与Framework基本类似，不同的是在打包成.a文件的同时，还需要提供头文件，使用时相较于Framework比较麻烦，（例如<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419319164&token=&lang=zh_CN">微信支付SDK</a>使用的是.a，不同的是<a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.Ijm3sG&treeId=193&articleId=104509&docType=1">支付宝SDK</a>是以framework的形式打包的）。.a这样打包不够方便，而Framework编译完成暴露的头文件都已经放好了。 </p><h4 id="3-dylib-x2F-tbd-动态库"><a href="#3-dylib-x2F-tbd-动态库" class="headerlink" title="3..dylib&#x2F;.tbd 动态库"></a>3..dylib&#x2F;.tbd 动态库</h4><p>这类动态库我们也经常用，基本上都是系统提供的，一般不能自己制作，就算你通过其他方式制作使用，也肯定不能上架的，这里没什么好讲的。 </p><h2 id="二-Framework的制作"><a href="#二-Framework的制作" class="headerlink" title="二.Framework的制作"></a>二.Framework的制作</h2><p>动态库与静态库的制作流程基本一样，包括头文件的暴露等，唯一不同的是Mach-O文件的编译形式。本节将介绍Xcode制作Framework的过程，本次制作的Framework静态库依赖其他第三方静态库（Framework和.a）。</p><p>1&gt;新建工程<br><img src="http://img.gaoshilei.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B.png" alt="新建Framework工程" loading="lazy"><br>这里要选Framework，如果选择右边的Static Library制作出来的是.a静态库。</p><p>2&gt;导入所有要打包的文件和其他第三方静态库<br>正常导入要打包的文件就可以了，在导入第三方静态库的时候要注意，不要选择添加到target中，如果添加进去要去target里面把第三方静态库删掉（只需导入，不要添加进target）<br><img src="http://img.gaoshilei.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9D%99%E6%80%81%E5%BA%93.png" alt="导入第三方静态库" loading="lazy"><br>导入第三方静态库之后再link依赖的系统库，像这样<br><img src="http://img.gaoshilei.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96%E5%BA%93.png" alt="link依赖库" loading="lazy"><br>注意上面的运行目标，因为我用的是Xcode8，最低支持到iOS8。<br>要打包的文件和第三方静态库全部导入完成<br><img src="http://img.gaoshilei.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E6%83%85%E5%86%B5.png" alt="所有文件导入情况" loading="lazy">   </p><p>3&gt;项目性质修改<br>把项目的membership需改为public，否则头文件暴露将会不正常<br><img src="http://img.gaoshilei.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%B7%A5%E7%A8%8B%E6%80%A7%E8%B4%A8.png" alt="修改项目的membership" loading="lazy">  </p><p>4&gt;暴露头文件<br>将头文件暴露出去，供外界使用，所有的编译文件都在Project中，需要右击添加到public里面<br><img src="http://img.gaoshilei.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%9A%B4%E9%9C%B2%E5%A4%B4%E6%96%87%E4%BB%B6.png" alt="暴露头文件" loading="lazy">  </p><p><strong>5&gt;选择Mach-O的编译方式</strong><br>这是最重要的一步，这一步决定我们制作出来的是静态库还是动态库，默认选择的是Dynamic Library，要手动选择Static Library<br><img src="http://img.gaoshilei.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E9%80%89%E6%8B%A9%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F.png" alt="Mach-O 形式" loading="lazy"></p><p>6&gt;编译<br>如果你的依赖库里面有lib开头的dylib动态库，此时应该会报错<br><img src="http://img.gaoshilei.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E7%B3%BB%E7%BB%9F%E5%8A%A8%E6%80%81%E5%BA%93%E6%8A%A5%E9%94%99.png" alt="动态库链接报错" loading="lazy"><br>什么意思呢？大概就是没找到对应的库文件，因为tbd是苹果提供的新的动态库格式，之前都是dylib，不知道这里又抽什么风，下面解决问题。  </p><p>7&gt;tbd动态库报错修改<br>先把原来的.tbd删掉，然后再次添加，这个时候选择add other，在弹出的窗口中按快捷键shift + command + G 调出finder的前往窗口，输入&#x2F;usr&#x2F;lib，然后添加相应的dylib动态库<br><img src="http://img.gaoshilei.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E6%9B%BF%E6%8D%A2%E4%BE%9D%E8%B5%96%E5%BA%93.png" alt="修改的动态库" loading="lazy"><br>替换完成之后重新编译项目，生成Framework(可在Product文件中右击在finder中显示找到)  </p><p>8&gt;使用<br>新建一个文件夹，将制作好的静态库拷贝出来放进去，再将第三方静态库拷贝到相同的文件夹中，此时只要将这个文件夹提供给外界使用就可以了，这是我写的测试demo验证打包好的SDK是否可以正常使用<br><img src="http://img.gaoshilei.com/%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C-%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E4%BD%BF%E7%94%A8.png" alt="制作完成使用" loading="lazy"><br>至此我们已经完成了Framework中包含其他第三方静态库的制作。<br><strong>如果需要制作动态库，只需要在第5步中将Mach-O的形式改为Dynamic Library就可以了，其他步骤一样</strong>   </p><p>如果有问题请在留言区留言，或者邮件给我，互相交流学习！  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;以下所涉及的框架和库只针对iOS而言，不确保在其他平台也适用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近由于公司业务需要，要求封装一个支付SDK，需要用到微信支付和支付宝，之前做过的Framework没有依赖其他第三方的库所以比较好做，这次有所不同；一开始我想把支付宝和微信支付的SDK全部融合进来，折腾一天才发现我之前的想法有很多误区，这样是根本行不通的，不过最后还是封装成功了，下面把我的经验分享出来，供有需要的同学少走弯路。 制作之前最好把功课做足，看看静态库和动态库到底是什么东西。  &lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="http://www.gaoshilei.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="SDK" scheme="http://www.gaoshilei.com/tags/SDK/"/>
    
    <category term="静态库" scheme="http://www.gaoshilei.com/tags/%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
    <category term="动态库" scheme="http://www.gaoshilei.com/tags/%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    
    <category term="framework" scheme="http://www.gaoshilei.com/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你逆向微信之朋友圈小视频转发（下）</title>
    <link href="http://www.gaoshilei.com/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E4%B9%8B%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://www.gaoshilei.com/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E4%B9%8B%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2016-11-10T16:00:00.000Z</published>
    <updated>2023-10-20T08:42:31.211Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>接上篇<a href="http://www.gaoshilei.com/2016/11/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E4%B9%8B%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/">《手把手教你逆向微信之朋友圈小视频转发（上）》</a></p></blockquote><h2 id="代码编写及重签名打包安装-（下篇）"><a href="#代码编写及重签名打包安装-（下篇）" class="headerlink" title="代码编写及重签名打包安装 （下篇）"></a>代码编写及重签名打包安装 （下篇）</h2><p>小视频的转发支持4个功能，转发至朋友圈、转发至好友、保存到本地相册、拷贝小视频链接到粘贴板。如果小视频没有下载长按时只会出现拷贝url链接。 </p><span id="more"></span><p>转载请注明出处：<a href="http://www.gaoshilei.com/">来自LeonLei的博客http://www.gaoshilei.com</a>  </p><p><em>（非越狱机和不想利用tweak安装的越狱机<a href="#section_two">点我跳到第二节</a>）</em><br>###1.越狱机打包安装（tweak安装）<br>1&gt;新建tweak工程<br>2&gt;编写tweak文件</p><p>这里要hook两个类，分别是WCContentItemViewTemplateNewSight和SightMomentEditViewController，在WCContentItemViewTemplateNewSight中hook住onLongTouch方法然后添加menu弹出菜单，依次添加响应的方法，具体的代码如下：  </p><ul><li>   拷贝小视频的url链接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</span><br><span class="line">    UISaveVideoAtPathToSavedPhotosAlbum(localPath, nil, nil, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>   保存小视频到本地相册</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</span><br><span class="line">    UISaveVideoAtPathToSavedPhotosAlbum(localPath, nil, nil, nil);</span><br></pre></td></tr></table></figure><ul><li>   转发到朋友圈</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SightMomentEditViewController *editSightVC = [[%c(SightMomentEditViewController) alloc] init];</span><br><span class="line">   NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</span><br><span class="line">   UIImage *image = [[self valueForKey:@&quot;_sightView&quot;] getImage];</span><br><span class="line">   [editSightVC setRealMoviePath:localPath];</span><br><span class="line">   [editSightVC setMoviePath:localPath];</span><br><span class="line">   [editSightVC setRealThumbImage:image];</span><br><span class="line">   [editSightVC setThumbImage:image];</span><br><span class="line">   [WCTimelineVC presentViewController:editSightVC animated:YES completion:^&#123;</span><br><span class="line"></span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><ul><li>   转发给好友</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self sendSightToFriend];</span><br></pre></td></tr></table></figure><ul><li>   长按手势</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">UIMenuController *menuController = [UIMenuController sharedMenuController];</span><br><span class="line">if (menuController.isMenuVisible) return;//防止出现menu闪屏的情况</span><br><span class="line">[self becomeFirstResponder];</span><br><span class="line">NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</span><br><span class="line">BOOL isExist =[[NSFileManager defaultManager] fileExistsAtPath:localPath];</span><br><span class="line">UIMenuItem *retweetMenuItem = [[UIMenuItem alloc] initWithTitle:@&quot;朋友圈&quot; action:@selector(SLRetweetSight)];</span><br><span class="line">UIMenuItem *saveToDiskMenuItem = [[UIMenuItem alloc] initWithTitle:@&quot;保存到相册&quot; action:@selector(SLSightSaveToDisk)];</span><br><span class="line">UIMenuItem *sendToFriendsMenuItem = [[UIMenuItem alloc] initWithTitle:@&quot;好友&quot; action:@selector(SLSightSendToFriends)];</span><br><span class="line">UIMenuItem *copyURLMenuItem = [[UIMenuItem alloc] initWithTitle:@&quot;复制链接&quot; action:@selector(SLSightCopyUrl)];</span><br><span class="line">if(isExist)&#123;</span><br><span class="line">    [menuController setMenuItems:@[retweetMenuItem,sendToFriendsMenuItem,saveToDiskMenuItem,copyURLMenuItem]];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    [menuController setMenuItems:@[copyURLMenuItem]];</span><br><span class="line">&#125;</span><br><span class="line">[menuController setTargetRect:CGRectZero inView:self];</span><br><span class="line">[menuController setMenuVisible:YES animated:YES];</span><br></pre></td></tr></table></figure><p>具体的tweak文件我放在了github上，<a href="https://github.com/gaoshilei/WCSightRetweet">WCSightRetweet传送门</a></p><p>3&gt;编写WCTimelineRetweet.h头文件<br>编写这个头文件的目的是防止tweak在编译期间报错，我们可以在编写好tweak试着编译一下，然后根据报错信息来添加这个头文件的内容，在这个文件中要声明在tweak我们用到的微信的类和方法，具体请看代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@interface WCUrl : NSObject</span><br><span class="line">@property(retain, nonatomic) NSString *url;</span><br><span class="line">@end</span><br><span class="line">@interface WCContentItem : NSObject</span><br><span class="line">@property(retain, nonatomic) NSMutableArray *mediaList;</span><br><span class="line">@end</span><br><span class="line">@interface WCDataItem : NSObject</span><br><span class="line">@property(retain, nonatomic) WCContentItem *contentObj;</span><br><span class="line">@end</span><br><span class="line">@interface WCMediaItem : NSObject</span><br><span class="line">@property(retain, nonatomic) WCUrl *dataUrl;</span><br><span class="line">- (id)pathForSightData;</span><br><span class="line">@end</span><br><span class="line">@interface MMServiceCenter : NSObject</span><br><span class="line">+ (id)defaultCenter;</span><br><span class="line">- (id)getService:(Class)arg1;</span><br><span class="line">@end</span><br><span class="line">@interface WCFacade : NSObject</span><br><span class="line">- (id)getTimelineDataItemOfIndex:(long long)arg1;</span><br><span class="line">@end</span><br><span class="line">@interface WCSightView : UIView</span><br><span class="line">- (id)getImage;</span><br><span class="line">@end</span><br><span class="line">@interface WCContentItemViewTemplateNewSight : UIView&#123;</span><br><span class="line">    WCSightView *_sightView;</span><br><span class="line">&#125;</span><br><span class="line">- (WCMediaItem *)iOSREMediaItemFromSight;</span><br><span class="line">- (void)iOSREOnSaveToDisk;</span><br><span class="line">- (void)iOSREOnCopyURL;</span><br><span class="line">- (void)sendSightToFriend;</span><br><span class="line">@end</span><br><span class="line">@interface SightMomentEditViewController : UIViewController</span><br><span class="line">@property(retain, nonatomic) NSString *moviePath;</span><br><span class="line">@property(retain, nonatomic) NSString *realMoviePath;</span><br><span class="line">@property(retain, nonatomic) UIImage *thumbImage;</span><br><span class="line">@property(retain, nonatomic) UIImage *realThumbImage;</span><br><span class="line">- (void)makeInputController;</span><br><span class="line">@end</span><br><span class="line">@interface MMWindowController : NSObject</span><br><span class="line">- (id)initWithViewController:(id)arg1 windowLevel:(int)arg2;</span><br><span class="line">- (void)showWindowAnimated:(_Bool)arg1;</span><br><span class="line">@end</span><br><span class="line">@interface WCTimeLineViewController : UIViewController</span><br><span class="line">- (long long)calcDataItemIndex:(long long)arg1;</span><br><span class="line">@end</span><br><span class="line">@interface MMTableViewCell : UIView</span><br><span class="line">@end</span><br><span class="line">@interface MMTableView : UIView</span><br><span class="line">- (id)indexPathForCell:(id)cell;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>4&gt;Makefile文件修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">THEOS_DEVICE_IP = 192.168.0.115//手机所在的IP</span><br><span class="line">include $(THEOS)/makefiles/common.mk</span><br><span class="line">ARCHS = arm64//支持的CPU架构</span><br><span class="line">TWEAK_NAME = WCTimelineSightRetweet</span><br><span class="line">WCTimelineSightRetweet_FILES = Tweak.xm</span><br><span class="line">WCTimelineSightRetweet_FRAMEWORKS = UIKit CoreGraphics//导入系统的framework</span><br><span class="line">include $(THEOS_MAKE_PATH)/tweak.mk</span><br><span class="line"></span><br><span class="line">after-install::</span><br><span class="line">install.exec &quot;killall -9 WeChat&quot;//安装完成杀掉的进程</span><br></pre></td></tr></table></figure><p>control文件不需要做修改，然后执行命令<code>make package install</code>安装到手机，微信会被杀掉，然后再次打开微信转发小视频的功能已经加上了。  </p><h3 id="2-微信重签名打包安装"><a href="#2-微信重签名打包安装" class="headerlink" title="2.微信重签名打包安装 "></a><span id="section_two">2.微信重签名打包安装 </span></h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><h5 id="（1）安装iOSOpenDev"><a href="#（1）安装iOSOpenDev" class="headerlink" title="（1）安装iOSOpenDev"></a>（1）安装iOSOpenDev</h5><p>1&gt;安装 <a href="https://www.macports.org/install.php">macports</a> (安装过程需要连接VPN,否则无法安装成功)</p><p>2&gt;安装完MacPorts后打开终端，输入 <code>sudo port -v selfupdate</code> 更新MacPorts到最新版本，时间可能比较长。</p><p>3&gt;更新完MacPorts后安装DPKG文件，在终端输入<code>sudo port -f install dpkg</code></p><p>4&gt;下载安装 <a href="http://iosopendev.com/download">iOSOpendev</a> 如果安装失败，可以通过 <code>Command + L</code> 查看安装中出现的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PackageKit: Install Failed: Error Domain=PKInstallErrorDomain Code=112 &quot;运行软件包“iOSOpenDev-1.6-2.pkg”的脚本时出错。&quot; UserInfo=&#123;NSFilePath=./postinstall, NSURL=file://localhost/Users/ice/Downloads/iOSOpenDev-1.6-2.pkg#iodsetup.pkg, PKInstallPackageIdentifier=com.iosopendev.iosopendev162.iod-setup.pkg, NSLocalizedDescription=运行软件包“iOSOpenDev-1.6-2.pkg”的脚本时出错。&#125; &#123;</span><br><span class="line">        NSFilePath = &quot;./postinstall&quot;;</span><br><span class="line">        NSLocalizedDescription = &quot;\U8fd0\U884c\U8f6f\U4ef6\U5305\U201ciOSOpenDev-1.6-2.pkg\U201d\U7684\U811a\U672c\U65f6\U51fa\U9519\U3002&quot;;</span><br><span class="line">        NSURL = &quot;file://localhost/Users/ice/Downloads/iOSOpenDev-1.6-2.pkg#iodsetup.pkg&quot;;</span><br><span class="line">        PKInstallPackageIdentifier = &quot;com.iosopendev.iosopendev162.iod-setup.pkg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个解决方案：下载<a href="https://github.com/gaoshilei/iOSOpenDevInstallSolve">iOSOpenDevInstallSolve</a>中的Specifications文件夹  </p><p><strong>修复安装失败问题</strong><br>打开步骤4下载的Specifications文件夹，里面应该有8个文件,如果你有安装多个xcode注意放到对应的xcode里面。<br>1.iPhoneOS开头的四个文件放到&#x2F;应用程序&#x2F;Xcode&#x2F;Content&#x2F;Developer&#x2F;Platforms&#x2F;IphoneOS.platform&#x2F;Developer&#x2F;Library&#x2F;Xcode&#x2F;Specifications文件夹下（如果没有，请自己创建一个Specifications文件夹）<br>2.iPhone Simulator 开头的另外四个文件放入&#x2F;应用程序&#x2F;Xcode&#x2F;Content&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneSimulator.platform&#x2F;Developer&#x2F;Library&#x2F;Xcode&#x2F;Specifications文件夹下(如果没有，请同样创建一个)<br>3.在&#x2F;应用程序&#x2F;Xcode&#x2F;Content&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneSimulator.platform&#x2F;Developer&#x2F;文件夹下创建usr文件夹，usr文件夹下再创建一个名为bin的文件夹。<br><strong>注意：有时候会提示安装失败，打开Xcode新建工程，如果在工程的选项菜单中有iOSOpenDev就表示安装成功了，不用管那个安装提示。</strong>  </p><h5 id="（2）安装ideviceinstaller"><a href="#（2）安装ideviceinstaller" class="headerlink" title="（2）安装ideviceinstaller"></a>（2）安装ideviceinstaller</h5><blockquote><p>安装ipa包用的，也可以通过itool之类的工具，不过ideviceinstaller可以看到安装过程的过程，方便我们找到出错原因。</p></blockquote><p>执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ideviceinstaller</span><br></pre></td></tr></table></figure><p>如果提示brew命令找不到，那就是你的Mac还没有安装<a href="http://brew.sh/index_zh-cn.html">Homebrew</a><br>常见的报错信息：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Could not connect to lockdownd, error code -5</span><br></pre></td></tr></table></figure><p>这个时候只要重新安装libimobiledevice就可以了（因为ideviceinstaller依赖很多其他插件）<br>执行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$   brew uninstall libimobiledevice</span><br><span class="line">$   brew install --HEAD libimobiledevice</span><br></pre></td></tr></table></figure><p>下载<a href="https://github.com/DanTheMan827/ios-app-signer">iOS App Signer</a>重签名工具<em>（省去很多命令行操作，一键重签名！）</em>  </p><p>（3）下载砸壳的微信应用</p><blockquote><p>因为AppStore的包是被加密（有壳），无法进行重签名，所以要用砸壳的，可以用dumpdecrypted自己砸壳，也可以直接利用PP助手或者itool助手下载越狱版已经砸过壳的微信应用。  </p></blockquote><p>（4）安装yololib<br>yololib可以将dylib注入进WeChat二进制文件中，这样才能是你的Hook有作用，下载之后编译得到<a href="https://github.com/gaoshilei/yololib">yololib</a></p><h4 id="代码注入以及打包安装"><a href="#代码注入以及打包安装" class="headerlink" title="代码注入以及打包安装"></a>代码注入以及打包安装</h4><h5 id="（1）生成静态库"><a href="#（1）生成静态库" class="headerlink" title="（1）生成静态库"></a>（1）生成静态库</h5><p>在上一步中已经安装好iOSOpendev，此时打开Xcode新建项目，在选择工程界面会出现iOSOpendev的工程，这里我们要选择CaptainHook Tweak项目<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8DiOSDev.png" alt="iOSOpenDev" loading="lazy"><br>新建好的工程只有一个.mm文件，我们只需要把所有hook方法写在这个文件中即可。<br>因为非越狱机不能像越狱机一样可以安装tweak插件对原来的应用进行hook，CaptainHook使用的Runtime机制实现，利用宏命令封装类定义、方法替换等功能，简单介绍它的使用方法：  </p><ol><li>   hook某个类</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHDeclareClass(WCContentItemViewTemplateNewSight); </span><br></pre></td></tr></table></figure><p><code>CHDeclareClass(ClassName)</code>表示要hook哪个类，一般写在对这个类操作的最前面。</p><ol start="2"><li>   在hook的类种新建方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHDeclareMethod0(id, WCContentItemViewTemplateNewSight, SLSightDataItem)&#123;......&#125;</span><br></pre></td></tr></table></figure><p><code>CHDeclareMethod(count, return_type, class_type, name1, arg1, ....)</code>表示新建一个方法，count表示这个方法的参数个数，return_type表示返回类型，class_type填写这个方法所在的类名，name1表示方法名，arg1表示第一个参数，如果没有参数则不填，以此类推。  </p><ol start="3"><li>   hook原来的方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CHOptimizedMethod0(self, void, WCContentItemViewTemplateNewSight, onLongTouch)&#123;</span><br><span class="line">CHSuper(0, className, Method);//可选</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CHOptimizedMethod(count, optimization, return_type, class_type, name1, type1, arg1)</code> 表示hook原来的方法（如果不加<code>CHSuper(0, className, Method)</code>表示复写原来的方法，CHSuper表示在当前位置调用原来的方法实现），count表示hook的方法参数个数，optimization一般填self，return_type即方法返回值类型，class_type填当前类的类名，name1是方法名，arg1是参数，如果没有参数不同填写arg，以此类推。  </p><ol start="4"><li>   构造函数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CHConstructor</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool</span><br><span class="line">    &#123;</span><br><span class="line">        CHLoadLateClass(WCContentItemViewTemplateNewSight);</span><br><span class="line">        CHHook(0, WCContentItemViewTemplateNewSight, onLongTouch);    </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是CaptainHook的入口函数，所有被hook的类必须在这里声明加载，类里面的方法要在这里声明hook。<br>然后就可以往类和方法中写代码了，代码太长不贴了，请自行下载<br><strong><a href="https://github.com/gaoshilei/MMPlugin">MMPlugin传送门</a></strong><br><strong>这个项目中包含了小视频转发、自动抢红包、修改微信运动步数功能，自动抢红包和修改微信运动步数功能可以手动关闭。</strong></p><blockquote><p>注意：如果用到了系统的类记住要导入相应的类库（比方说UIKit）和头文件否则编译的时候会报错。</p></blockquote><p>编译成功之后就可以在Products文件夹中找到编译好的静态库了<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-%E7%BC%96%E8%AF%91%E5%A5%BD%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93.png" alt="编译好的静态库" loading="lazy"><br>在finder中找到它，拷贝出来待用。<br>#####(2)签名+打包+安装<br>进行到这里目前应该有的材料有：</p><ul><li>   砸壳的微信app    </li><li><pre><code>编译好的MMPlugin.dylib</code></pre></li><li>安装好的iOS App Signer</li><li>编译好的yololib文件  </li><li>ideviceinstaller</li></ul><p>从原来的微信app中找到WeChat二进制文件拷贝出来待用，<strong>删除weChat.app中的Watch文件夹、PlugIns文件夹中的WeChatShareExtensionNew.appex</strong>，这步操作必须要做，不然安装的时候会报签名错误。<br>执行下面的命令将MMPlugin.dylib注入到WeChat二进制文件中，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:WeChat gaoshilei$ ./yololib WeChat MMPlugin.dylib</span><br></pre></td></tr></table></figure><p><strong>执行这个命令时要确保yololib、WeChat、WeChat.app处于同一目录下。</strong> </p><p>完成之后将MMPlugin.dylib和WeChat拷贝到原来的WeChat.app中，覆盖掉原来的WeChat文件。<br>打开iOS App Signer按照下图选择好各项参数：<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-iOSAppSigner.png" alt="iOS App Signer" loading="lazy"><br>我这里选择的是企业级证书，个人开发者证书也是可以的，个人开发者一定要选择开发环境的并且要将需要安装的机器udid添加到prov文件里面去，选好之后点击start，稍等片刻一个经过重签名的ipa包就生成了。<br>连上你的手机执行下面的命令查看ideviceinstaller是否连接上手机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:WeChat gaoshilei$ ideviceinfo</span><br></pre></td></tr></table></figure><p>如果打印出一大堆手机的信息表示连接成功可以安装ipa包，如果不成功请根据错误提示进行调整。执行下面的命令进行安装：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:WeChat gaoshilei$ ideviceinstaller -i WeChat.ipa </span><br><span class="line">WARNING: could not locate iTunesMetadata.plist in archive!</span><br><span class="line">WARNING: could not locate Payload/WeChat.app/SC_Info/WeChat.sinf in archive!</span><br><span class="line">Copying &#x27;WeChat.ipa&#x27; to device... DONE.</span><br><span class="line">Installing &#x27;com.xxxxxxxxxxxx&#x27;</span><br><span class="line"> - CreatingStagingDirectory (5%)</span><br><span class="line"> - ExtractingPackage (15%)</span><br><span class="line"> - InspectingPackage (20%)</span><br><span class="line"> - TakingInstallLock (20%)</span><br><span class="line"> - PreflightingApplication (30%)</span><br><span class="line"> - InstallingEmbeddedProfile (30%)</span><br><span class="line"> - VerifyingApplication (40%)</span><br><span class="line"> - CreatingContainer (50%)</span><br><span class="line"> - InstallingApplication (60%)</span><br><span class="line"> - PostflightingApplication (70%)</span><br><span class="line"> - SandboxingApplication (80%)</span><br><span class="line"> - GeneratingApplicationMap (90%)</span><br><span class="line"> - Complete</span><br></pre></td></tr></table></figure><p>安装完成，在手机上打开微信试试我们添加的新功能吧！如果某个环节卡住会报错，请根据报错信息进行修改。请看效果图：<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E9%87%8D%E7%AD%BE%E5%90%8D-%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%E6%95%88%E6%9E%9C%E5%9B%BE.jpg" alt="小视频转发" loading="lazy">  </p><h4 id="有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。"><a href="#有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。" class="headerlink" title="有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。"></a>有任何问题请在文章评论区留言，或者在博客首页点击邮件联系我。</h4>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;接上篇&lt;a href=&quot;http://www.gaoshilei.com/2016/11/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E4%B9%8B%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/&quot;&gt;《手把手教你逆向微信之朋友圈小视频转发（上）》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;代码编写及重签名打包安装-（下篇）&quot;&gt;&lt;a href=&quot;#代码编写及重签名打包安装-（下篇）&quot; class=&quot;headerlink&quot; title=&quot;代码编写及重签名打包安装 （下篇）&quot;&gt;&lt;/a&gt;代码编写及重签名打包安装 （下篇）&lt;/h2&gt;&lt;p&gt;小视频的转发支持4个功能，转发至朋友圈、转发至好友、保存到本地相册、拷贝小视频链接到粘贴板。如果小视频没有下载长按时只会出现拷贝url链接。 &lt;/p&gt;</summary>
    
    
    
    <category term="iOS逆向" scheme="http://www.gaoshilei.com/categories/iOS%E9%80%86%E5%90%91/"/>
    
    
    <category term="微信" scheme="http://www.gaoshilei.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
    <category term="汇编语言" scheme="http://www.gaoshilei.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    <category term="IDA" scheme="http://www.gaoshilei.com/tags/IDA/"/>
    
    <category term="重签名" scheme="http://www.gaoshilei.com/tags/%E9%87%8D%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你逆向微信之朋友圈小视频转发（上）</title>
    <link href="http://www.gaoshilei.com/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E4%B9%8B%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://www.gaoshilei.com/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E4%B9%8B%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2016-11-09T16:00:00.000Z</published>
    <updated>2023-10-20T08:42:28.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文为逆向微信二进制文件，实现朋友圈小视频转发的教程，从最开始的汇编代码入手到最后重签名安装等操作，手把手教你玩转微信！学会之后再去逆向微信其他功能易如反掌。<br>本篇文章由于篇幅太长分成了两篇，<strong>上篇</strong>讲解的是逆向工作，也就是怎么找到相关的函数和方法实现，<strong>下篇</strong>讲解的是怎么在非越狱机重签名安装和越狱机tweak安装的详细过程。<br><strong>正文的第二部分还提供了微信自动抢红包、修改微信步数的代码，这些都可以照葫芦画瓢按照本文的套路一步步逆向找到，这里就不再赘述。</strong><br>在实践之前，需要准备好一部越狱的手机，然后将下文列出的所有工具安装好。IDA跟Reveal都是破解版，IDA的正版要2000多刀，对于这么牛逼的逆向工具确实物有所值，不过不是专门研究逆向的公司也没必要用正版的，下个Windows的破解版就好，Mac上暂时没找到。Mac上可以用hopper代替IDA，也是一款很牛逼的逆向工具。废话不多说，正式开始吧！</p><span id="more"></span><p>转载请注明出处：<a href="http://www.gaoshilei.com/">来自LeonLei的博客http://www.gaoshilei.com</a>  </p><h1 id="逆向微信朋友圈（上篇）"><a href="#逆向微信朋友圈（上篇）" class="headerlink" title="逆向微信朋友圈（上篇）"></a>逆向微信朋友圈（上篇）</h1><h2 id="一、获取朋友圈的小视频"><a href="#一、获取朋友圈的小视频" class="headerlink" title="一、获取朋友圈的小视频"></a>一、获取朋友圈的小视频</h2><blockquote><p>注意：本文逆向的微信的二进制文件为6.3.28版本，如果是不同的微信版本，二进制文件中的基地址也不相同</p></blockquote><h4 id="本文涉及到的工具"><a href="#本文涉及到的工具" class="headerlink" title="本文涉及到的工具"></a>本文涉及到的工具</h4><ol><li><a href="http://www.cycript.org/">cycript</a> </li><li>LLDB与debugserver（Xcode自带）</li><li>OpenSSH</li><li>IDA</li><li>Reveal</li><li><a href="https://github.com/theos/theos">theos</a></li><li><a href="http://www.cydiasubstrate.com/">CydiaSubstrate</a></li><li>iOSOpenDev</li><li>ideviceinstaller</li><li>tcprelay（本地端口映射，USB连接SSH，不映射可通过WiFi连接） </li><li><a href="https://github.com/stefanesser/dumpdecrypted">dumpdecrypted</a></li><li><a href="http://stevenygard.com/projects/class-dump/">class-dump</a> </li><li><a href="https://github.com/DanTheMan827/ios-app-signer">iOS App Signer</a></li><li>编译好的<a href="https://github.com/gaoshilei/yololib">yololib</a></li></ol><p><strong>逆向环境为MacOS+iPhone5S 9.1越狱机</strong><br>先用dumpdecrypted给微信砸壳（不会的请我写的看<a href="http://www.gaoshilei.com/2016/08/08/dumpdecrypted%E7%BB%99App%E7%A0%B8%E5%A3%B3/">这篇教程</a>），获得一个WeChat.decrypted文件，先把这个文件扔到IDA中分析（60MB左右的二进制文件，IDA差不多40分钟才能分析完），用class-dump导出所有头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:~ gaoshilei$ class-dump -S -s -H /Users/gaoshilei/Desktop/reverse/binary_for_class-dump/WeChat.decrypted -o /Users/gaoshilei/Desktop/reverse/binary_for_class-dump/class-Header/WeChat</span><br></pre></td></tr></table></figure><p>我滴个亲娘！一共有8000个头文件，微信果然工程量浩大！稳定一下情绪，理一理思路继续搞。要取得小视频的下载链接，找到播放视频的View，顺藤摸瓜就能找到小视频的URL。用Reveal查看小视频的播放窗口<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91Reveal.png" alt="Reveal" loading="lazy"><br>可以看出来WCContentItemViewTemplateNewSigh这个对象是小视频的播放窗口，它的subView有WCSightView，SightView、SightPlayerView，这几个类就是我们的切入点。<br>保存视频到favorite的时候是长按视频弹出选项的，那么在WCContentItemViewTemplateNewSight这个类里面可能有手势相关的方法，去刚才导出的头文件中找线索。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)onLongTouch;</span><br><span class="line">- (void)onLongPressedWCSight:(id)arg1;</span><br><span class="line">- (void)onLongPressedWCSightFullScreenWindow:(id)arg1;</span><br></pre></td></tr></table></figure><p>这几个方法跟长按手势相关，再去IDA中找到这些函数，逐个查看。onLongPressedWCSight和onLongPressedWCSightFullScreenWindow都比较简单，onLongTouch比较长，而且发现了内部调用了方法Favorites_Add，因为长按视频的时候出来一个选项就是Favorites，并且我看到这个函数调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADRP            X8, #selRef_sightVideoPath@PAGE</span><br><span class="line">LDR             X1, [X8,#selRef_sightVideoPath@PAGEOFF]</span><br></pre></td></tr></table></figure><p>这里拿到了小视频的地址，可以推测这个函数跟收藏有关，下面打断点测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) im li -o -f</span><br><span class="line">[  0] 0x000000000003c000 /var/mobile/Containers/Bundle/Application/2F1D52EC-C57E-4F95-B715-EF04351232E8/WeChat.app/WeChat(0x000000010003c000)</span><br></pre></td></tr></table></figure><p>可以看到WeChat的ASLR为0x3c000，在IDA查找到这三个函数的基地址，分别下断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0x1020D3A10+0x3c000</span><br><span class="line">Breakpoint 1: where = WeChat`___lldb_unnamed_symbol110094$$WeChat + 28, address = 0x000000010210fa10</span><br><span class="line">(lldb) br s -a 0x1020D3370+0x3c000</span><br><span class="line">Breakpoint 2: where = WeChat`___lldb_unnamed_symbol110091$$WeChat + 8, address = 0x000000010210f370</span><br><span class="line">(lldb) br s -a 0x1020D33E4+0x3c000</span><br><span class="line">Breakpoint 3: where = WeChat`___lldb_unnamed_symbol110092$$WeChat + 12, address = 0x000000010210f3e4</span><br></pre></td></tr></table></figure><p>回到微信里面长按小视频，看断点触发情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Process 3721 stopped</span><br><span class="line">* thread #1: tid = 0x658fc, 0x000000010210f370 WeChat`___lldb_unnamed_symbol110091$$WeChat + 8, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 2.1</span><br><span class="line">    frame #0: 0x000000010210f370 WeChat`___lldb_unnamed_symbol110091$$WeChat + 8</span><br><span class="line">WeChat`___lldb_unnamed_symbol110091$$WeChat:</span><br><span class="line">-&gt;  0x10210f370 &lt;+8&gt;:  add    x29, sp, #16              ; =16 </span><br><span class="line">    0x10210f374 &lt;+12&gt;: mov    x19, x0</span><br><span class="line">    0x10210f378 &lt;+16&gt;: adrp   x8, 4968</span><br><span class="line">    0x10210f37c &lt;+20&gt;: ldr    x0, [x8, #744]</span><br><span class="line">(lldb) c</span><br><span class="line">Process 3721 resuming</span><br><span class="line">Process 3721 stopped</span><br><span class="line">* thread #1: tid = 0x658fc, 0x000000010210fa10 WeChat`___lldb_unnamed_symbol110094$$WeChat + 28, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1</span><br><span class="line">    frame #0: 0x000000010210fa10 WeChat`___lldb_unnamed_symbol110094$$WeChat + 28</span><br><span class="line">WeChat`___lldb_unnamed_symbol110094$$WeChat:</span><br><span class="line">-&gt;  0x10210fa10 &lt;+28&gt;: add    x29, sp, #96              ; =96 </span><br><span class="line">    0x10210fa14 &lt;+32&gt;: sub    sp, sp, #96               ; =96 </span><br><span class="line">    0x10210fa18 &lt;+36&gt;: mov    x19, x0</span><br><span class="line">    0x10210fa1c &lt;+40&gt;: adrp   x8, 4863</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>发现断点2先被触发，接着触发断点1，后面断点2和1又各触发了1次，断点3一直很安静。可以排除onLongPressedWCSightFullScreenWindow与收藏小视频的联系。小视频的踪影就要在剩下的两个方法中寻找了。通过V找到C，顺藤摸瓜找到M屡试不爽！用cycript注入WeChat，拿到播放小视频的view所在的Controller。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0x138c18030 nextResponder]</span><br><span class="line">#&quot;&lt;WCTimeLineCellView: 0x138c34620; frame = (0 0; 319 249); tag = 1048577; layer = &lt;CALayer: 0x138362ba0&gt;&gt;&quot;</span><br><span class="line">cy# [#0x138c34620 nextResponder]</span><br><span class="line">#&quot;&lt;UITableViewCellContentView: 0x138223c70; frame = (0 0; 320 256); gestureRecognizers = &lt;NSArray: 0x1384ec480&gt;; layer = &lt;CALayer: 0x138081dc0&gt;&gt;&quot;</span><br><span class="line">cy# [#0x138223c70 nextResponder]</span><br><span class="line">#&quot;&lt;MMTableViewCell: 0x138c9f930; baseClass = UITableViewCell; frame = (0 307; 320 256); autoresize = W; layer = &lt;CALayer: 0x1382dcd10&gt;&gt;&quot;</span><br><span class="line">cy# [#0x138c9f930 nextResponder]</span><br><span class="line">#&quot;&lt;UITableViewWrapperView: 0x137b57800; frame = (0 0; 320 504); gestureRecognizers = &lt;NSArray: 0x1383db660&gt;; layer = &lt;CALayer: 0x138af20c0&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;320, 504&#125;&gt;&quot;</span><br><span class="line">cy# [#0x137b57800 nextResponder]</span><br><span class="line">#&quot;&lt;MMTableView: 0x137b8ae00; baseClass = UITableView; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x138adb590&gt;; layer = &lt;CALayer: 0x138956890&gt;; contentOffset: &#123;0, 99.5&#125;; contentSize: &#123;320, 3193&#125;&gt;&quot;</span><br><span class="line">cy# [#0x137b8ae00 nextResponder]</span><br><span class="line">#&quot;&lt;UIView: 0x138ade5c0; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x138ac9990&gt;&gt;&quot;</span><br><span class="line">cy# [#0x138ade5c0 nextResponder]</span><br><span class="line">#&quot;&lt;WCTimeLineViewController: 0x1379eb000&gt;&quot;</span><br></pre></td></tr></table></figure><p>通过响应者链条找到<br>WCContentItemViewTemplateNewSight所属的Controller为WCTimeLineViewController。在这个类的头文件中并没有发现有价值的线索，不过我们注意到小视频所在的view是属于MMTableVIewCell的（见上图Reveal分析图），这是每一个iOS最熟悉的TableView，cell的数据是通过UITableViewDataSource的代理方法<code>- tableView:cellForRowAtIndexPath:</code>赋值的，通过这个方法肯定能知道到M的影子。在IDA中找到<code>[WCTimeLineViewController tableView:cellForRowAtIndexPath:]</code>,定位到基地址0x10128B6B0位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__text:000000010128B6B0     ADRP     X8, #selRef_genNormalCell_indexPath_@PAGE</span><br></pre></td></tr></table></figure><p>这里的函数是WCTimeLineViewController中生成cell的方法，除了这个方法在这个类中还有另外三个生成cell的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)genABTestTipCell:(id)arg1 indexPath:(id)arg2;</span><br><span class="line">- (void)genRedHeartCell:(id)arg1 indexPath:(id)arg2;</span><br><span class="line">- (void)genUploadFailCell:(id)arg1 indexPath:(id)arg2;</span><br></pre></td></tr></table></figure><p>通过字面意思可以猜测出normal这个应该是生成小视频cell的方法。继续在IDA中寻找线索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__text:0000000101287CC8     ADRP     X8, #selRef_getTimelineDataItemOfIndex_@PAGE</span><br></pre></td></tr></table></figure><p>在<code>genNormalCell:IndexPath:</code>方法中发现上面这个方法，可以大胆猜想这个方法是获取TimeLine（朋友圈）数据的方法，那小视频的数据肯定也是通过这个方法获取的，并且IDA可以看到这个方法中调用一个叫做<code>selRef_getTimelineDataItemOfIndex_</code>的方法，获取DataItem貌似就是cell的数据源啊！接下来用LLDB下断点验证猜想。<br>通过IDA可以找到这个方法对应的基地址为：0x101287CE4，先打印正在运行WeChat的ASLR偏移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:~ gaoshilei$ lldb</span><br><span class="line">(lldb) process connect connect://localhost:1234</span><br><span class="line">(lldb) im li -o -f </span><br><span class="line">[0] 0x0000000000050000 /var/mobile/Containers/Bundle/Application/2DCE8F30-9B6B-4652-901C-37EB1FF2A40D/WeChat.app/WeChat(0x0000000100050000)</span><br></pre></td></tr></table></figure><p>所以我们下断点的位置是0x50000+0x101287CE4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0x50000+0x101287CE4</span><br><span class="line">Breakpoint 1: where = WeChat`___lldb_unnamed_symbol63721$$WeChat + 252, address = 0x00000001012d7ce4</span><br></pre></td></tr></table></figure><p>打印x0的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x0</span><br><span class="line">Class name: WCDataItem, addr: 0x15f5f03b0</span><br><span class="line">tid: 12393001887435993280</span><br><span class="line">username: wxid_z8twcz4o18fg12</span><br><span class="line">createtime: 1477360950</span><br><span class="line">commentUsers: (</span><br><span class="line">)</span><br><span class="line">contentObj: &lt;WCContentItem: 0x15f57d000&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到一个WCDataItem的对象，这里x0的值就是<code>selRef_getTimelineDataItemOfIndex_</code>执行完的返回值，然后把x0的值改掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register write $x0 0</span><br><span class="line">(lldb) c</span><br></pre></td></tr></table></figure><p>此时会发现我们要刷新的那条小视频内容全部为空<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91-%E8%BD%AC%E5%8F%91%E5%B0%8F%E8%A7%86%E9%A2%91%E4%B8%BA%E7%A9%BA.jpg" alt="小视频内容为空" loading="lazy"><br>到这里已经找到了小视频的源数据获取方法，问题是我们怎么拿到这个WCDataItem呢？继续看IDA分析函数的调用情况：  </p><blockquote><p>WCTimeLineViewController - (void)genNormalCell:(id) indexPath:(id)  </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">__text:0000000101287BCC                 STP             X28, X27, [SP,#var_60]!</span><br><span class="line">__text:0000000101287BD0                 STP             X26, X25, [SP,#0x60+var_50]</span><br><span class="line">__text:0000000101287BD4                 STP             X24, X23, [SP,#0x60+var_40]</span><br><span class="line">__text:0000000101287BD8                 STP             X22, X21, [SP,#0x60+var_30]</span><br><span class="line">__text:0000000101287BDC                 STP             X20, X19, [SP,#0x60+var_20]</span><br><span class="line">__text:0000000101287BE0                 STP             X29, X30, [SP,#0x60+var_10]</span><br><span class="line">__text:0000000101287BE4                 ADD             X29, SP, #0x60+var_10</span><br><span class="line">__text:0000000101287BE8                 SUB             SP, SP, #0x80</span><br><span class="line">__text:0000000101287BEC                 MOV             X19, X3</span><br><span class="line">__text:0000000101287BF0                 MOV             X22, X0</span><br><span class="line">__text:0000000101287BF4                 MOV             W25, #0x100000</span><br><span class="line">__text:0000000101287BF8                 MOVK            W25, #1</span><br><span class="line">__text:0000000101287BFC                 MOV             X0, X2</span><br><span class="line">__text:0000000101287C00                 BL              _objc_retain</span><br><span class="line">__text:0000000101287C04                 MOV             X28, X0</span><br><span class="line">__text:0000000101287C08                 MOV             X0, X19</span><br><span class="line">__text:0000000101287C0C                 BL              _objc_retain</span><br><span class="line">__text:0000000101287C10                 MOV             X20, X0</span><br><span class="line">__text:0000000101287C14                 STR             X20, [SP,#0xE0+var_98]</span><br><span class="line">__text:0000000101287C18                 ADRP            X8, #selRef_row@PAGE</span><br><span class="line">__text:0000000101287C1C                 LDR             X1, [X8,#selRef_row@PAGEOFF]</span><br><span class="line">__text:0000000101287C20                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287C24                 MOV             X26, X0</span><br><span class="line">__text:0000000101287C28                 ADRP            X8, #selRef_section@PAGE</span><br><span class="line">__text:0000000101287C2C                 LDR             X19, [X8,#selRef_section@PAGEOFF]</span><br><span class="line">__text:0000000101287C30                 MOV             X0, X20</span><br><span class="line">__text:0000000101287C34                 MOV             X1, X19</span><br><span class="line">__text:0000000101287C38                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287C3C                 STR             X0, [SP,#0xE0+var_A8]</span><br><span class="line">__text:0000000101287C40                 MOV             X0, X20</span><br><span class="line">__text:0000000101287C44                 MOV             X1, X19</span><br><span class="line">__text:0000000101287C48                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287C4C                 MOV             X2, X0</span><br><span class="line">__text:0000000101287C50                 ADRP            X8, #selRef_calcDataItemIndex_@PAGE</span><br><span class="line">__text:0000000101287C54                 LDR             X1, [X8,#selRef_calcDataItemIndex_@PAGEOFF]</span><br><span class="line">__text:0000000101287C58                 MOV             X0, X22</span><br><span class="line">__text:0000000101287C5C                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287C60                 MOV             X21, X0</span><br><span class="line">__text:0000000101287C64                 STR             X21, [SP,#0xE0+var_C0]</span><br><span class="line">__text:0000000101287C68                 ADRP            X8, #classRef_MMServiceCenter@PAGE</span><br><span class="line">__text:0000000101287C6C                 LDR             X0, [X8,#classRef_MMServiceCenter@PAGEOFF]</span><br><span class="line">__text:0000000101287C70                 ADRP            X8, #selRef_defaultCenter@PAGE</span><br><span class="line">__text:0000000101287C74                 LDR             X1, [X8,#selRef_defaultCenter@PAGEOFF]</span><br><span class="line">__text:0000000101287C78                 STR             X1, [SP,#0xE0+var_B8]</span><br><span class="line">__text:0000000101287C7C                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287C80                 MOV             X29, X29</span><br><span class="line">__text:0000000101287C84                 BL              _objc_retainAutoreleasedReturnValue</span><br><span class="line">__text:0000000101287C88                 MOV             X19, X0</span><br><span class="line">__text:0000000101287C8C                 ADRP            X8, #classRef_WCFacade@PAGE</span><br><span class="line">__text:0000000101287C90                 LDR             X0, [X8,#classRef_WCFacade@PAGEOFF]</span><br><span class="line">__text:0000000101287C94                 ADRP            X8, #selRef_class@PAGE</span><br><span class="line">__text:0000000101287C98                 LDR             X1, [X8,#selRef_class@PAGEOFF]</span><br><span class="line">__text:0000000101287C9C                 STR             X1, [SP,#0xE0+var_B0]</span><br><span class="line">__text:0000000101287CA0                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287CA4                 MOV             X2, X0</span><br><span class="line">__text:0000000101287CA8                 ADRP            X8, #selRef_getService_@PAGE</span><br><span class="line">__text:0000000101287CAC                 LDR             X1, [X8,#selRef_getService_@PAGEOFF]</span><br><span class="line">__text:0000000101287CB0                 STR             X1, [SP,#0xE0+var_A0]</span><br><span class="line">__text:0000000101287CB4                 MOV             X0, X19</span><br><span class="line">__text:0000000101287CB8                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287CBC                 MOV             X29, X29</span><br><span class="line">__text:0000000101287CC0                 BL              _objc_retainAutoreleasedReturnValue</span><br><span class="line">__text:0000000101287CC4                 MOV             X20, X0</span><br><span class="line">__text:0000000101287CC8                 ADRP            X8, #selRef_getTimelineDataItemOfIndex_@PAGE</span><br><span class="line">__text:0000000101287CCC                 LDR             X1, [X8,#selRef_getTimelineDataItemOfIndex_@PAGEOFF]</span><br><span class="line">__text:0000000101287CD0                 STR             X1, [SP,#0xE0+var_C8]</span><br><span class="line">__text:0000000101287CD4                 MOV             X2, X21</span><br><span class="line">__text:0000000101287CD8                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287CDC                 MOV             X29, X29</span><br><span class="line">__text:0000000101287CE0                 BL              _objc_retainAutoreleasedReturnValue</span><br><span class="line">__text:0000000101287CE4                 MOV             X21, X0</span><br><span class="line">__text:0000000101287CE8                 MOV             X0, X20</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><code>selRef_getTimelineDataItemOfIndex_ </code>传入的参数是x2，可以看到传值给x2的x21是函数<code>selRef_calcDataItemIndex_ </code>的返回值，是一个unsigned long数据类型。继续分析，<code>selRef_getTimelineDataItemOfIndex_ </code>函数的调用者是上一步<code>selRef_getService_ </code>的返回值，经过断点分析发现是一个<code>WCFacade</code>对象。整理一下<code>selRef_getTimelineDataItemOfIndex_ </code>的调用：<br><strong>调用者是<code>selRef_getService_ </code>的返回值；参数是<code>selRef_calcDataItemIndex_ </code>的返回值</strong><br>下面把目光转向那两个函数，用相同的原理分析它们各自怎么实现调用<br>1.先看<code>selRef_getService_</code>：<br>在0x101287CB4这个位置可以发现，这个函数的调用者是从通过x19 MOV的，打印x19发现是一个<code>MMServiceCenter</code>对象，往上找x19是在0x101287C88这个位置赋值的，结果很清晰x19是<code>[MMServiceCenter defaultCenter]</code>的返回值。<br>在0x101287CA4位置可以找到传入的参数x2，往上分析可以看出来它的参数是<code>[WCFacade class]</code>的返回值。<br>2.接着找<code>selRef_calcDataItemIndex_ </code>：<br>在0x101287C58的位置找到它的调用者x0，x0通过x22赋值，继续向上寻找，发现在最上面0x101287BF0的位置，x22是x0赋值的，一开始的x0就是<code>WCTimeLineViewController</code>自身。<br>在0x101287C4C位置发现传入的参数来自x2,x2是通过上一步<code>selRef_section</code>函数的返回值x0赋值的，在0x101287C30位置可以发现<code>selRef_section</code>函数的调用者是x20赋值的，如下图所示，最终找到<code>selRef_section</code>的调用者是x3<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-selRef_section%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%80%85.png" alt="selRef_section函数的调用者" loading="lazy"><br>x3就是函数<code> WCTimeLineViewController - (void)genNormalCell:(id) indexPath:(id)</code>的第二个参数indexPath,，所以<code>selRef_calcDataItemIndex_ </code>的参数是<code>[IndexPath section]</code>。<br>对上面的分析结果做个梳理：<br>因此<code>getTimelineDataItemOfIndex:</code>的调用者可以通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[MMServiceCenter defaultCenter] getService:[WCFacade class]]</span><br></pre></td></tr></table></figure><p>来获得,它的参数可以通过下面的函数获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[WCTimeLineViewController calcDataItemIndex:[indexPath section]]</span><br></pre></td></tr></table></figure><p>总感觉还少点什么？indexPath我们还没拿到呢！下一步就是拿到indexPath,这个就比较简单了，因为我们位于<code>[WCContentItemViewTemplateNewSight onLongTouch]</code>中，所以可以通过<code>[self nextResponder]</code>依次拿到MMTableViewCell、MMTableView和WCTimeLineViewController，再通过<code>[MMTableView indexPathForCell:MMTableViewCell]</code>拿到indexPath。<br>做完这些，已经拿到WCDataItem对象，接下来的重点要放在WCDataItem上，最终要获取我们要的小视频。到这个类的头文件中找线索，因为视频是下载完成后才能播放的，所以这里应该拿到了视频的路径，所以要注意url和path相关的属性或方法，然后找到下面这几个嫌疑对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property(retain, nonatomic) NSString *sourceUrl2; </span><br><span class="line">@property(retain, nonatomic) NSString *sourceUrl; </span><br><span class="line">- (id)descriptionForKeyPaths;</span><br><span class="line">- (id)keyPaths;</span><br></pre></td></tr></table></figure><p>回到LLDB中，用断点打印这些值，看看有什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [$x0 keyPaths]</span><br><span class="line">&lt;__NSArrayI 0x15f74e9d0&gt;(</span><br><span class="line">tid,</span><br><span class="line">username,</span><br><span class="line">createtime,</span><br><span class="line">commentUsers,</span><br><span class="line">contentObj</span><br><span class="line">)</span><br><span class="line">(lldb) po [$x0 descriptionForKeyPaths]</span><br><span class="line">Class name: WCDataItem, addr: 0x15f5f03b0</span><br><span class="line">tid: 12393001887435993280</span><br><span class="line">username: wxid_z8twcz4o18fg12</span><br><span class="line">createtime: 1477360950</span><br><span class="line">commentUsers: (</span><br><span class="line">)</span><br><span class="line">contentObj: &lt;WCContentItem: 0x15f57d000&gt;</span><br><span class="line">(lldb) po [$x0 sourceUrl]</span><br><span class="line"> nil</span><br><span class="line">(lldb) po [$x0 sourceUrl2]</span><br><span class="line"> nil</span><br></pre></td></tr></table></figure><p>并没有什么有价值的线索，不过注意到WCDataItem里面有一个WCContentItem，看来只能从这儿入手了，去看一下头文件吧！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property(retain, nonatomic) NSString *linkUrl; </span><br><span class="line">@property(retain, nonatomic) NSString *linkUrl2; </span><br><span class="line">@property(retain, nonatomic) NSMutableArray *mediaList;</span><br></pre></td></tr></table></figure><p>在LLDB打印出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [[$x0 valueForKey:@&quot;contentObj&quot;] linkUrl]</span><br><span class="line">https://support.weixin.qq.com/cgi-bin/mmsupport-bin/readtemplate?t=page/common_page__upgrade&amp;v=1</span><br><span class="line">(lldb) po [[$x0 valueForKey:@&quot;contentObj&quot;] linkUrl2]</span><br><span class="line"> nil</span><br><span class="line">(lldb) po [[$x0 valueForKey:@&quot;contentObj&quot;] mediaList]</span><br><span class="line">&lt;__NSArrayM 0x15f985e10&gt;(</span><br><span class="line">&lt;WCMediaItem: 0x15dfebdf0&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>mediaList数组里面有一个WCMediaItem对象，Media一般用来表示视频和音频，大胆猜测就是它了！赶紧找到头文件搜索一遍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@property(retain, nonatomic) WCUrl *dataUrl;</span><br><span class="line">- (id)pathForData;</span><br><span class="line">- (id)pathForSightData;</span><br><span class="line">- (id)pathForTempAttachVideoData;</span><br><span class="line">- (id)videoStreamForData;</span><br></pre></td></tr></table></figure><p>上面这些属性和方法中<code>pathForSightData</code>是最有可能拿到小视频路径的，继续验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] dataUrl]</span><br><span class="line">type[1], url[http://vweixinf.tc.qq.com/102/20202/snsvideodownload?filekey=30270201010420301e020166040253480410d14adcddf086f4e131d11a5b1cca1bdf0203039fa00400&amp;bizid=1023&amp;hy=SH&amp;fileparam=302c0201010425302302040fde55e20204580ebd3602024eea02031e8d7d02030f42400204d970370a0201000400], enckey[0], encIdx[-1], token[]</span><br><span class="line">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] pathForData]</span><br><span class="line">/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45</span><br><span class="line">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] pathForSightData]</span><br><span class="line">/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45.mp4</span><br><span class="line">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] pathForAttachVideoData]</span><br><span class="line"> nil</span><br><span class="line">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] videoStreamForData]</span><br><span class="line"> nil</span><br></pre></td></tr></table></figure><p>拿到小视频的网络url和本地路径了！这里可以用iFunBox或者scp从沙盒拷贝这个文件看看是不是这个cell应该播放的小视频。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:~ gaoshilei$ scp root@192.168.0.115:/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45.mp4 Desktop/</span><br><span class="line">8fb0cdd77208de5b56169fb3458b45.mp4                100%  232KB 231.9KB/s   00:00    </span><br></pre></td></tr></table></figure><p>用QuickTime打开发现果然是我们要寻找的小视频。再验证一下url是否正确，把上面打印的dataUrl在浏览器中打开，发现也是这个小视频。分析这个类可以得出下面的结论：  </p><ul><li><strong>dataUrl：</strong>小视频的网络url</li><li><strong>pathForData：</strong>小视频的本地路径</li><li><strong>pathForSightData：</strong>小视频的本地路径（不带后缀）</li></ul><p>至此小视频的路径和取得方式分析已经完成，要实现转发还要继续分析微信的朋友圈发布。</p><h2 id="二、实现转发功能"><a href="#二、实现转发功能" class="headerlink" title="二、实现转发功能"></a>二、实现转发功能</h2><h3 id="1-“走进死胡同”"><a href="#1-“走进死胡同”" class="headerlink" title="1.“走进死胡同”"></a>1.“走进死胡同”</h3><blockquote><p>这节是我在找小视频转发功能时走的弯路，扒到最后并没有找到实现方法，不过也提供了一些逆向中常用的思路和方法，不想看的可以跳到第二节。  </p></blockquote><h4 id="（1）找到小视频拍摄完成调用的方法名称"><a href="#（1）找到小视频拍摄完成调用的方法名称" class="headerlink" title="（1）找到小视频拍摄完成调用的方法名称"></a>（1）找到小视频拍摄完成调用的方法名称</h4><p>打开小视频的拍摄界面，用cycript注入，我们要找到发布小视频的方法是哪个，然后查看当前的窗口有哪些window（因为小视频的拍摄并不是在UIApplication的keyWindow中进行的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cy# [UIApp windows].toString()</span><br><span class="line">(</span><br><span class="line">    &quot;&lt;iConsoleWindow: 0x125f75e20; baseClass = UIWindow; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x125f77b70&gt;; layer = &lt;UIWindowLayer: 0x125df4810&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;SvrErrorTipWindow: 0x127414d40; baseClass = UIWindow; frame = (0 64; 320 45); hidden = YES; gestureRecognizers = &lt;NSArray: 0x12740d930&gt;; layer = &lt;UIWindowLayer: 0x1274030b0&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;MMUIWindow: 0x127796440; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x1278083c0&gt;; layer = &lt;UIWindowLayer: 0x127796750&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;UITextEffectsWindow: 0x1270e0d40; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = &lt;UIWindowLayer: 0x1270b4ba0&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;NewYearActionSheet: 0x127797e10; baseClass = UIWindow; frame = (0 0; 320 568); hidden = YES; userInteractionEnabled = NO; layer = &lt;UIWindowLayer: 0x1277d5490&gt;&gt;&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>发现当前页面一共有5个window，其中MMUIWindow是小视频拍摄所在的window，打印它的UI树状结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0x127796440 recursiveDescription]</span><br></pre></td></tr></table></figure><p>打印结果比较长，不贴了。找到这个按钮是拍摄小视频的按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|    |    |    |    |    | &lt;UIButton: 0x1277a9d70; frame = (89.5 368.827; 141 141); opaque = NO; gestureRecognizers = &lt;NSArray: 0x1277aaeb0&gt;; layer = &lt;CALayer: 0x1277a9600&gt;&gt;</span><br><span class="line">|    |    |    |    |    |    | &lt;UIView: 0x1277aa0a0; frame = (0 0; 141 141); userInteractionEnabled = NO; tag = 252707333; layer = &lt;CALayer: 0x1277aa210&gt;&gt;</span><br><span class="line">|    |    |    |    |    |    |    | &lt;UIImageView: 0x1277aa2e0; frame = (0 0; 141 141); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1277aa490&gt;&gt;</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0x1277a9d70 setHidden:YES]</span><br></pre></td></tr></table></figure><p>发现拍摄的按钮消失了，验证了我的猜想。寻找按钮的响应事件，可以通过target来寻找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0x1277a9d70 allTargets]</span><br><span class="line">[NSSet setWithArray:@[#&quot;&lt;MainFrameSightViewController: 0x1269a4600&gt;&quot;]]]</span><br><span class="line">cy# [#0x1277a9d70 allControlEvents]</span><br><span class="line">193</span><br><span class="line">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:193]</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>发现按钮并没有对应的action，这就奇怪了！UIButton必须要有target和action，不然这个Button不能响应事件。我们试试其他的ControlEvent</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchDown]</span><br><span class="line">@[&quot;btnPress&quot;]</span><br><span class="line">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchUpOutside]</span><br><span class="line">@[&quot;btnRelease&quot;]</span><br><span class="line">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchUpInside]</span><br><span class="line">@[&quot;btnRelease&quot;]</span><br></pre></td></tr></table></figure><p>结果发现这三个ContrlEvent有对应的action，我们再看看这三个枚举的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef enum UIControlEvents : NSUInteger &#123;</span><br><span class="line">    UIControlEventTouchDown = 1 &lt;&lt;  0,</span><br><span class="line">    UIControlEventTouchDownRepeat = 1 &lt;&lt;  1,</span><br><span class="line">    UIControlEventTouchDragInside = 1 &lt;&lt;  2,</span><br><span class="line">    UIControlEventTouchDragOutside = 1 &lt;&lt;  3,</span><br><span class="line">    UIControlEventTouchDragEnter = 1 &lt;&lt;  4,</span><br><span class="line">    UIControlEventTouchDragExit = 1 &lt;&lt;  5,</span><br><span class="line">    UIControlEventTouchUpInside = 1 &lt;&lt;  6,</span><br><span class="line">    UIControlEventTouchUpOutside = 1 &lt;&lt;  7,</span><br><span class="line">    UIControlEventTouchCancel = 1 &lt;&lt;  8,</span><br><span class="line">......</span><br><span class="line">&#125; UIControlEvents;</span><br></pre></td></tr></table></figure><p>可以看出来UIControlEventTouchDown对应1，UIControlEventTouchUpInside对应128，UIControlEventTouchUpOutside对应64，三者相加正好193！原来调用<code>[#0x1277a9d70 allControlEvents]</code>的时候返回的应该是枚举，有多个枚举则把它们的值相加，是不是略坑？我也是这样觉得的！刚才我们把三种ControlEvent对应的action都打印出来了，继续LLDB+IDA进行动态分析。<br>####（2）找到小视频拍摄完成跳转到发布界面的方法<br>因为要找到小视频发布的方法，所以对应的<code>btnPress</code>函数我们并不关心，把重点放在<code>btnRelease</code>上面，拍摄按钮松开后就会调用的方法。在IDA中找到这个方法<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-btnRelease.png" alt="MainFrameSightViewController - (void)btnRelease" loading="lazy"><br>找到之后下个断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0xac000+0x10209369C</span><br><span class="line">Breakpoint 4: where = WeChat`___lldb_unnamed_symbol108894$$WeChat + 32, address = 0x000000010213f69c</span><br><span class="line">Process 3813 stopped</span><br><span class="line">* thread #1: tid = 0xf1ef0, 0x000000010213f69c WeChat`___lldb_unnamed_symbol108894$$WeChat + 32, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 4.1</span><br><span class="line">    frame #0: 0x000000010213f69c WeChat`___lldb_unnamed_symbol108894$$WeChat + 32</span><br><span class="line">WeChat`___lldb_unnamed_symbol108894$$WeChat:</span><br><span class="line">-&gt;  0x10213f69c &lt;+32&gt;: bl     0x1028d0b60               ; symbol stub for: objc_msgSend</span><br><span class="line">    0x10213f6a0 &lt;+36&gt;: cmp    w0, #2                    ; =2 </span><br><span class="line">    0x10213f6a4 &lt;+40&gt;: b.ne   0x10213f6dc               ; &lt;+96&gt;</span><br><span class="line">    0x10213f6a8 &lt;+44&gt;: adrp   x8, 5489</span><br></pre></td></tr></table></figure><p>用手机拍摄小视频然后松开，触发了断点，说明我们的猜想是正确的。继续分析发现代码是从上图的右边走的，看了一下没有什么方法是跳转到发布视频的，不过仔细看一下有一个block，是系统的延时block，位置在0x102093760。然后我们跟着断点进去，在0x1028255A0跳转到x16所存的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(lldb) si</span><br><span class="line">Process 3873 stopped</span><br><span class="line">* thread #1: tid = 0xf62c4, 0x00000001028d9598 WeChat`dispatch_after, queue = &#x27;com.apple.main-thread&#x27;, stop reason = instruction step into</span><br><span class="line">    frame #0: 0x00000001028d9598 WeChat`dispatch_after</span><br><span class="line">WeChat`dispatch_after:</span><br><span class="line">-&gt;  0x1028d9598 &lt;+0&gt;: adrp   x16, 1655</span><br><span class="line">    0x1028d959c &lt;+4&gt;: ldr    x16, [x16, #1056]</span><br><span class="line">    0x1028d95a0 &lt;+8&gt;: br     x16</span><br><span class="line"></span><br><span class="line">WeChat`dispatch_apply:</span><br><span class="line">    0x1028d95a4 &lt;+0&gt;: adrp   x16, 1655</span><br><span class="line">(lldb) po $x2</span><br><span class="line">&lt;__NSStackBlock__: 0x16fd49f88&gt;</span><br></pre></td></tr></table></figure><p>发现传入的参数x2是一个block，我们再回顾一下dispatch_after函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure><p>这个函数有三个参数，分别是dispatch_time_t、dispatch_queue_t、dispatch_block_t，那这里打印的x2就是要传入的block，所以我们猜测拍摄完小视频会有一个延时，然后执行刚才传入的block，所以x2中肯定有其他方法调用，下一步就是要知道这个block的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read --size 8 --format x 0x16fd49f88</span><br><span class="line">0x16fd49f88: 0x000000019f8fd218 0x00000000c2000000</span><br><span class="line">0x16fd49f98: 0x000000010214777c 0x0000000102fb0e60</span><br><span class="line">0x16fd49fa8: 0x000000015da32600 0x000000015ea1a430</span><br><span class="line">0x16fd49fb8: 0x000000015cf5fee0 0x000000016fd49ff0</span><br></pre></td></tr></table></figure><p>0x000000010214777c就是block所在的位置，当然要减掉当前WeChat的ASLR偏移，最终在IDA中的地址为0x10209377C，突然发现这就是<code>btnRelease</code>的子程序sub_10209377C。这个子程序非常简单，只有一个方法<code>selRef_logicCheckState_</code>有可能是我们的目标。先看看这个方法是谁调用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0xb4000+0x1020937BC</span><br><span class="line">......</span><br><span class="line">Process 3873 stopped</span><br><span class="line">* thread #1: tid = 0xf62c4, 0x00000001021477bc WeChat`___lldb_unnamed_symbol108895$$WeChat + 64, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 3.1</span><br><span class="line">    frame #0: 0x00000001021477bc WeChat`___lldb_unnamed_symbol108895$$WeChat + 64</span><br><span class="line">WeChat`___lldb_unnamed_symbol108895$$WeChat:</span><br><span class="line">-&gt;  0x1021477bc &lt;+64&gt;: adrp   x8, 5489</span><br><span class="line">    0x1021477c0 &lt;+68&gt;: ldr    x1, [x8, #1552]</span><br><span class="line">    0x1021477c4 &lt;+72&gt;: orr    w2, wzr, #0x1</span><br><span class="line">    0x1021477c8 &lt;+76&gt;: ldp    x29, x30, [sp, #16]</span><br><span class="line">(lldb) po $x0</span><br><span class="line">&lt;MainFrameSightViewController: 0x15d1f0c00&gt;</span><br></pre></td></tr></table></figure><p>发现还是MainFrameSightViewController这个对象调用的，那<code>selRef_logicCheckState_ </code>肯定也在这个类的头文件中，寻找一下果然发现了  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)logicCheckState:(int)arg1;</span><br></pre></td></tr></table></figure><p>在IDA左侧窗口中寻找[MainFrameSightViewController logicCheckState:]，发现这个方法超级复杂，逻辑太多了，不着急慢慢捋。<br>在0x102094D6C位置我们发现一个switch jump，思路就很清晰了，我们只要找到小视频拍摄完成的这条线往下看就行了，LLDB来帮忙看看走的那条线。在0x102094D6C位置下个断点，这个断点在拍摄小视频的时候会多次触发，可以在拍摄之前把断点dis掉，拍摄松手之前再启用断点，打印此时的x8值  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x $x8</span><br><span class="line">(unsigned long) $38 = 0x0000000102174e10</span><br></pre></td></tr></table></figure><p>x8是一个指针，它指向的地址是0x102174e10，用这个地址减去当前ASLR的偏移就可以找到在IDA中的基地址，发现是0x102094E10，拍摄完成的逻辑处理这条线找到了，一直走到0x102094E24位置之后跳转0x1020951C4，这个分支的内容较少，里面有三个函数  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">loc_1020951C4</span><br><span class="line">ADRP            X8, #selRef_hideTips@PAGE</span><br><span class="line">LDR             X1, [X8,#selRef_hideTips@PAGEOFF]</span><br><span class="line">MOV             X0, X19</span><br><span class="line">BL              _objc_msgSend</span><br><span class="line">ADRP            X8, #selRef_finishWriter@PAGE</span><br><span class="line">LDR             X1, [X8,#selRef_finishWriter@PAGEOFF]</span><br><span class="line">MOV             X0, X19</span><br><span class="line">BL              _objc_msgSend</span><br><span class="line">ADRP            X8, #selRef_turnCancelBtnForFinishRecording@PAGE</span><br><span class="line">LDR             X1, [X8,#selRef_turnCancelBtnForFinishRecording@PAGEOFF]</span><br><span class="line">MOV             X0, X19</span><br><span class="line">BL              _objc_msgSend</span><br><span class="line">B               loc_102095288</span><br></pre></td></tr></table></figure><p>其中<code>selRef_finishWriter</code>和<code>selRef_turnCancelBtnForFinishRecording</code>需要重点关注，这两个方法看上去都是小视频录制结束的意思，线索极有可能就在这两个函数中。通过查看调用者发现这两个方法都属于MainFrameSightViewController，继续在IDA中查看这两个方法。在<code>selRef_finishWriter </code>中靠近末尾0x102094248的位置发现一个方法名叫做<code>f_switchToSendingPanel</code>，下个断点，然后拍摄视频，发现这个方法并没有被触发。应该不是通过这个方法调用发布界面的，继续回到<code>selRef_finishWriter </code>方法中；在0x1020941DC的位置调用方法<code>selRef_stopRecording</code>，打印它的调用者发现这个方法属于<code>SightFacade</code>，继续在IDA中寻找这个方法的实现。在这个方法的0x101F9BED4位置又调用了<code>selRef_stopRecord</code>，同样打印调用者发现这个方法属于SightCaptureLogicF4，有点像剥洋葱，继续在寻找这个方法的实现。在这个方法内部0x101A98778位置又调用了<code>selRef_finishWriting</code>，同样的原理找到这个方法是属于SightMovieWriter。已经剥了3层了，继续往下：<br>在<code>SightMovieWriter - (void)finishWriting</code>中的0x10261D004位置分了两条线，这个位置下个断点，然后拍摄完小视频触发断点，打印x19的值  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x19</span><br><span class="line">&lt;OS_dispatch_queue: CAPTURE.CALLBACK[0x13610bcd0] = &#123; xrefcnt = 0x4, refcnt = 0x4, suspend_cnt = 0x0, locked = 1, target = com.apple.root.default-qos.overcommit[0x1a0aa3700], width = 0x0, running = 0x0, barrier = 1 &#125;&gt;</span><br></pre></td></tr></table></figure><p>所以代码不会跳转到loc_10261D054而是走的左侧，在左侧的代码中发现启用了一个block，这个block是子程序sub_10261D0AC，地址为0x10261D0AC，找到这个地址，结构如下图所示：<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91sub_10261D0AC.png" alt="sub_10261D0AC" loading="lazy"><br>可以看出来主要分两条线，我们在第一个方框的末尾也就是0x10261D108位置下个断点，等拍摄完毕触发断点之后打印x0的值为1，这里的汇编代码为  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__text:000000010261D104                 CMP             X0, #2</span><br><span class="line">__text:000000010261D108                 B.EQ            loc_10261D234</span><br></pre></td></tr></table></figure><p>B.EQ是在上一步的结果为0才会跳转到loc_10261D234，但是这里的结果是不为0的，将x0的值改为2让上一步的结果为0  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x0</span><br><span class="line">1</span><br><span class="line">(lldb) register write $x0 2</span><br><span class="line">(lldb) po $x0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>此时放开断点，等待跳转到小视频发布界面，结果是一直卡在这个界面没有任何反应，所以猜测实现跳转的逻辑应该在右边的那条线，继续顺着右边的线寻找：<br>在右侧0x10261D3AC位置发现调用了下面的这个方法  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)finishWritingWithCompletionHandler:(void (^)(void))handler;</span><br></pre></td></tr></table></figure><p>这个方法是系统提供的AVAssetWriter里面的方法，在视频写入完成之后要做的操作，这个里是要传入一个block的，因为只有一个参数所以对应的变量是x2，打印x2的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x2</span><br><span class="line">&lt;__NSStackBlock__: 0x16e086c78&gt;</span><br><span class="line">(lldb) memory read --size 8 --format x 0x16e086c78</span><br><span class="line">0x16e086c78: 0x00000001a0aa5218 0x00000000c2000000</span><br><span class="line">0x16e086c88: 0x00000001026d94b0 0x0000000102fc98c0</span><br><span class="line">0x16e086c98: 0x0000000136229fd0 0x000000016e086d00</span><br><span class="line">0x16e086ca8: 0x00000001997f5318 0xfffffffec9e882ff</span><br></pre></td></tr></table></figure><p>并且通过栈内存找到block位置为0x10261D4B0（需要减去ASLR的偏移）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sub_10261D4B0</span><br><span class="line">var_20= -0x20</span><br><span class="line">var_10= -0x10</span><br><span class="line">STP             X20, X19, [SP,#var_20]!</span><br><span class="line">STP             X29, X30, [SP,#0x20+var_10]</span><br><span class="line">ADD             X29, SP, #0x20+var_10</span><br><span class="line">MOV             X19, X0</span><br><span class="line">LDR             X0, [X19,#0x20]</span><br><span class="line">ADRP            X8, #selRef_stopAmr@PAGE</span><br><span class="line">LDR             X1, [X8,#selRef_stopAmr@PAGEOFF]</span><br><span class="line">BL              _objc_msgSend</span><br><span class="line">LDR             X0, [X19,#0x20]</span><br><span class="line">ADRP            X8, #selRef_compressAudio@PAGE</span><br><span class="line">LDR             X1, [X8,#selRef_compressAudio@PAGEOFF]</span><br><span class="line">LDP             X29, X30, [SP,#0x20+var_10]</span><br><span class="line">LDP             X20, X19, [SP+0x20+var_20],#0x20</span><br><span class="line">B               _objc_msgSend</span><br><span class="line">; End of function sub_10261D4B0</span><br></pre></td></tr></table></figure><p>只调用了两个方法，一个是<code>selRef_stopAmr</code>停止amr（一种音频格式），另一个是<code>selRef_compressAudio</code>压缩音频，拍摄完成的下一步操作应该不会放在这两个方法里面，找了这么久也没有头绪，这个路看来走不通了，不要钻牛角尖，战略性撤退寻找其他入口。<br><strong>逆向的乐趣就是一直寻找真相的路上，能体会到成功的乐趣，也有可能方向错了离真相反而越来越远，不要气馁调整方向继续前进！</strong></p><h3 id="2-“另辟蹊径”"><a href="#2-“另辟蹊径”" class="headerlink" title="2.“另辟蹊径”"></a>2.“另辟蹊径”</h3><blockquote><p>（由于微信在后台偷偷升级了，下面的内容都是微信6.3.30版本的ASLR，上面的分析基于6.3.28版本）</p></blockquote><p>注意到在点击朋友圈右上角的相机按钮底部会弹出一个Sheet，第一个就是Sight小视频，从这里入手，用cycript查看Sight按钮对应的事件是哪个  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iPhone-5S:~ root# cycript -p &quot;WeChat&quot;</span><br><span class="line">cy# [UIApp windows].toString()</span><br><span class="line">`(</span><br><span class="line">    &quot;&lt;iConsoleWindow: 0x14d6ccc00; baseClass = UIWindow; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x14d7df110&gt;; layer = &lt;UIWindowLayer: 0x14d7d6f60&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;SvrErrorTipWindow: 0x14eaa5800; baseClass = UIWindow; frame = (0 0; 320 45); hidden = YES; gestureRecognizers = &lt;NSArray: 0x14e9e8950&gt;; layer = &lt;UIWindowLayer: 0x14e9e6510&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;UITextEffectsWindow: 0x14ec38ba0; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = &lt;UIWindowLayer: 0x14ec39360&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;UITextEffectsWindow: 0x14e9c67a0; frame = (0 0; 320 568); layer = &lt;UIWindowLayer: 0x14d683ff0&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;UIRemoteKeyboardWindow: 0x14f226e40; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = &lt;UIWindowLayer: 0x14d6f4de0&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;NewYearActionSheet: 0x14f1704a0; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x14ef9bf90&gt;; layer = &lt;UIWindowLayer: 0x14ef61a20&gt;&gt;&quot;</span><br><span class="line">)`</span><br><span class="line">cy# [#0x14f1704a0 recursiveDescription].toString()</span><br></pre></td></tr></table></figure><p>底部的Sheet是NewYearActionSheet，然后打印NewYearActionSheet的UI树状结构图（比较长不贴了）。然后找到Sight对应的UIButton是0x14f36d470   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0x14f36d470 allTargets]</span><br><span class="line">[NSSet setWithArray:@[#&quot;&lt;NewYearActionSheet: 0x14f1704a0; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x14ef9bf90&gt;; layer = &lt;UIWindowLayer: 0x14ef61a20&gt;&gt;&quot;]]]</span><br><span class="line">cy# [#0x14f36d470 allControlEvents]</span><br><span class="line">64</span><br><span class="line">cy# [#0x14f36d470 actionsForTarget:#0x14f1704a0 forControlEvent:64]</span><br><span class="line">@[&quot;OnDefaultButtonTapped:&quot;]</span><br></pre></td></tr></table></figure><p>通过UIControl的<code>actionsForTarget:forControlEvent:</code>方法可以找到按钮绑定的事件，Sight按钮的触发方法为<code>OnDefaultButtonTapped:</code>，回到IDA中在NewYearActionSheet中找到这个方法们继续往下分析只有这个方法<code>selRef_dismissWithClickedButtonIndex_animated</code>，通过打印它的调用者发现还是NewYearActionSheet，继续点进去找到<code>newYearActionSheet_clickedButtonAtIndex</code>方法，看样子不是NewYearActionSheet自己的，打印调用者x0发现它属于类WCTimeLineViewController。跟着断点走下去在0x1012B78CC位置调用了方法<code>#selRef_showSightWindowForMomentWithMask_byViewController_scene</code><br>通过观察发现这个方法的调用者是0x1012B78AC这个位置的返回值x0，这是一个类SightFacade，猜测这个方法在SightFacade里面，去头文件里找一下果然发现这个方法  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)showSightWindowForMomentWithMask:(id)arg1 byViewController:(id)arg2 scene:(int)arg3;</span><br></pre></td></tr></table></figure><p>这个方法应该就是跳转到小视频界面的方法了。下面分别打印它的参数  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x2</span><br><span class="line">&lt;UIImage: 0x14f046660&gt;, &#123;320, 568&#125;</span><br><span class="line">(lldb) po $x3</span><br><span class="line">&lt;WCTimeLineViewController: 0x14e214800&gt;</span><br><span class="line">(lldb) po $x4</span><br><span class="line">2</span><br><span class="line">(lldb) po $x0</span><br><span class="line">&lt;SightFacade: 0x14f124b40&gt;</span><br></pre></td></tr></table></figure><p>其中x2、x3、x4分别对应三个参数，x0是调用者，跳到这个方法内部查看怎么实现的。发现在这个方法中进行了小视频拍摄界面的初始化工作，首先初始化一个MainFrameSightViewController，再创建一个UINavigationController将MainFrameSightViewController放进去，接下来初始化一个MMWindowController调用  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithViewController:(id)arg1 windowLevel:(int)arg2;</span><br></pre></td></tr></table></figure><p>方法将UINavigationController放了进去，完成小视频拍摄界面的所有UI创建工作。<br>拍摄完成之后进入发布界面，此时用cycript找到当前的Controller是SightMomentEditViewController，由此萌生一个想法，跳过前面的拍摄界面直接进入发布界面不就可以了吗？我们自己创建一个SightMomentEditViewController然后放到UINavigationController里面，然后再将这个导航控制器放到MMWindowController里面。<strong>（这里我已经写好tweak进行了验证，具体的tweak思路编写在后文有）</strong>结果是的确可以弹出发布的界面，但是导航栏的NavgationBar遮住了原来的，整个界面是透明的，很难看，而且发布完成之后无法销毁整个MMWindowController，还是停留在发布界面。我们要的结果不是这个，不过确实有很大的收获，最起码可以直接调用发布界面了，小视频也能正常转发。我个人猜测，当前界面不能被销毁的原因是因为MMWindowController新建了一个window,它跟TimeLine所在的keyWindow不是同一个，SightMomentEditViewController的按钮触发的方法是没有办法销毁这个window的，所以有一个大胆的猜想，我直接在当前的WCTimeLineViewController上把SightMomentEditViewController展示出来不就可以了吗？  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[WCTimelineVC presentViewController:editSightVC animated:YES completion:^&#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>像这样展示岂不妙哉？不过通过观察SightMomentEditViewController的头文件，结合小视频发布时界面上的元素，推测创建这个控制器至少需要两个属性，一个是小视频的路径，另一个是小视频的缩略图，将这两个关键属性给了SightMomentEditViewController那么应该就可以正常展示了   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SightMomentEditViewController *editSightVC = [[%c(SightMomentEditViewController) alloc] init];</span><br><span class="line">NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</span><br><span class="line">UIImage *image = [[self valueForKey:@&quot;_sightView&quot;] getImage];</span><br><span class="line">[editSightVC setRealMoviePath:localPath];</span><br><span class="line">[editSightVC setMoviePath:localPath];</span><br><span class="line">[editSightVC setRealThumbImage:image];</span><br><span class="line">[editSightVC setThumbImage:image];</span><br><span class="line">[WCTimelineVC presentViewController:editSightVC animated:YES completion:^&#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>小视频的发布界面可以正常显示并且所有功能都可以正常使用，唯一的问题是返回按钮没有效果，并不能销毁SightMomentEditViewController。用cycript查看左侧按钮的actionEvent找到它的响应函数是<code>- (void)popSelf;</code>，点击左侧返回触发的是pop方法，但是这个控制器并不在navgationController里面，所以无效，我们要对这个方法进行重写  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)popSelf</span><br><span class="line">&#123;</span><br><span class="line">    [self dismissViewControllerAnimated:YES completion:^&#123;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再点击返回按钮就可以正常退出了，此外，在WCContentItemViewTemplateNewSight中发现了一个方法叫做<code>- (void)sendSightToFriend;</code>，可以直接将小视频转发给好友，至此小视频转发的功能已经找到了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;此文为逆向微信二进制文件，实现朋友圈小视频转发的教程，从最开始的汇编代码入手到最后重签名安装等操作，手把手教你玩转微信！学会之后再去逆向微信其他功能易如反掌。&lt;br&gt;本篇文章由于篇幅太长分成了两篇，&lt;strong&gt;上篇&lt;/strong&gt;讲解的是逆向工作，也就是怎么找到相关的函数和方法实现，&lt;strong&gt;下篇&lt;/strong&gt;讲解的是怎么在非越狱机重签名安装和越狱机tweak安装的详细过程。&lt;br&gt;&lt;strong&gt;正文的第二部分还提供了微信自动抢红包、修改微信步数的代码，这些都可以照葫芦画瓢按照本文的套路一步步逆向找到，这里就不再赘述。&lt;/strong&gt;&lt;br&gt;在实践之前，需要准备好一部越狱的手机，然后将下文列出的所有工具安装好。IDA跟Reveal都是破解版，IDA的正版要2000多刀，对于这么牛逼的逆向工具确实物有所值，不过不是专门研究逆向的公司也没必要用正版的，下个Windows的破解版就好，Mac上暂时没找到。Mac上可以用hopper代替IDA，也是一款很牛逼的逆向工具。废话不多说，正式开始吧！&lt;/p&gt;</summary>
    
    
    
    <category term="iOS逆向" scheme="http://www.gaoshilei.com/categories/iOS%E9%80%86%E5%90%91/"/>
    
    
    <category term="微信" scheme="http://www.gaoshilei.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
    <category term="汇编语言" scheme="http://www.gaoshilei.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    <category term="IDA" scheme="http://www.gaoshilei.com/tags/IDA/"/>
    
    <category term="重签名" scheme="http://www.gaoshilei.com/tags/%E9%87%8D%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>【转载】黑科技：把第三方iOS应用转成动态库</title>
    <link href="http://www.gaoshilei.com/iOSAppToLibrary/"/>
    <id>http://www.gaoshilei.com/iOSAppToLibrary/</id>
    <published>2016-10-15T16:00:00.000Z</published>
    <updated>2023-10-20T12:32:48.013Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文章转载自<a href="http://blog.imjun.net/">杨君的小黑屋</a>，对排版进行了一些调整</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文会介绍一个自己写的工具，能够把第三方iOS应用转成动态库，并加载到自己的App中，文章最后会以支付宝为例，展示如何调用其中的C函数和OC方法。<br>工具开源地址：<br><a href="https://github.com/tobefuturer/app2dylib">https://github.com/tobefuturer/app2dylib</a>  </p><span id="more"></span><h2 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h2><p>为什么要把第三方应用转成动态库呢？与一般的注入动态库+重签名打包的手段有什么不一样呢？</p><p>好处主要有下面几点：<br>1.可以直接调用别人的算法<br>    逆向分析别人的应用时，可能会遇到一些私有算法，如果搞不定的话，直接拿来用就好。<br>2.掌控程序的控制权<br>    程序的主体是自己的App，第三方应用的代码只是以动态库的形式加载，主要的控制权还是在我们自己手里，所以可以直接绕过应用的检测代码（文章最后有关于这部分攻防的讨论）。<br>3.同个进程内加载多个应用<br>    重签名打包毕竟只能是原来的应用，但是如果是动态库的话，可以同时加载多个应用到进程内了，比如你想同时把美图秀秀和饿了么加载进来也是可以的（秀秀不饿，想想去年大众点评那个APPmixer的软广 - -! ）。  </p><h2 id="应用和动态库的异同"><a href="#应用和动态库的异同" class="headerlink" title="应用和动态库的异同"></a>应用和动态库的异同</h2><p>我们要把应用转成动态库，首先要知道这两者之前有什么相同与不同，有相同的才存在转换的可能，而不同之处就是我们要重点关注的了。  </p><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><p><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%BA%94%E7%94%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="应用和动态库的异同" loading="lazy"><br>可执行文件和动态库都是标准的 Mach-O 文件格式，两者的文件头部结构非常类似，特别是其中的代码段（TEXT）,和数据段（DATA）结构完全一致，这也是后面转换工作的基础。  </p><h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><p>不同点就是我们转换工作的重点了，主要有：<br>1.头部的文件类型<br>    一个是 MH_EXECUTE 可执行文件， 一个是 MH_DYLIB 动态库， 还有各种头部的Flags，要特别留意下可执行文件中Flags部分的 MH_PIE 标志，后面再详细说。<br><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%B4%E9%83%A8%E6%96%87%E4%BB%B6%E4%B8%8D%E5%90%8C.jpg" alt="头部的文件类型不同" loading="lazy"><br>2.动态库文件中多一个类型为 LC_ID_DYLIB 的 Load Command, 作用是动态库的标识符，一般为文件路径。路径可以随便填，但是这部分必须要有，是codesign的要求。<br><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B.jpg" alt="LC_ID_DYLIB 的 Load Command" loading="lazy"><br>3.可执行文件会多出一个 PAGEZERO段，动态库中没有。这个段开始地址为0（NULL指针指向的位置），是一个不可读、不可写、不可执行的空间，能够在空指针访问时抛出异常。这个段的大小，32位上是0x4000，64位上是4G。这个段的处理也是转换工作的重点之一，之前有人尝试转换，不成功就是因为没有处理好 PAGEZERO.<br><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%E5%A4%9A%E5%87%BA%E4%B8%80%E4%B8%AA%20PAGEZERO%E6%AE%B5.jpg" alt="多出的PAGEZERO段" loading="lazy">  </p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="修改文件类型"><a href="#修改文件类型" class="headerlink" title="修改文件类型"></a>修改文件类型</h3><p>第一步是修改文件的头部信息，把文件类型从可执行文件修改成动态库，同时把一些Flags修改好。</p><p>这里一个比较关键的Flag是可执行文件中的 MH_PIE 标志位，（position-independent executable）。</p><p>这个标志位，表明可执行文件能够在内存中任意位置正确地运行，而不受其绝对地址影响的特性，这一特性是动态库所必须的一个特性。没有这个标志位的可执行文件是没有办法转换成动态库的。iOS系统中，arm64架构下，目前这个标志位是必须的，不然程序无法运行（系统的安全性要求），但是armv7架构下，可以没有这个标志位，所以支付宝armv7版本的可执行文件是不能转成动态库的，就是这个原因。不过所有的arm64的应用都是可以转换的，后面演示时用的支付宝是arm64架构的。<br>###头部中添加 LC_ID_DYLIB<br>直接在文件头部中按照文档格式插入一个Load Command，并填入合适的数据。这里要注意下插入内容的字节数必须是8字节对齐的。<br>###修改PAGEZERO段<br>这部分是最重要的一部分，因为arm64上这个段的大小有4G，直接往内存中加载，会提示没有足够的连续的地址空间，所以必须要调整这个段的大小，而要调整 PAGEZERO 这个段的大小, 又会引起一连串的地址空间的变化，所以不能盲目的直接改，必须结合dyld的源码来对应修改。（注意这里不能直接把 PAGEZERO 这个段给去掉，也不能直接把大小调成0，因为涉及到dyld的rebase操作，详细看后面）  </p><h4 id="1-所有段的地址都要重新计算"><a href="#1-所有段的地址都要重新计算" class="headerlink" title="1.所有段的地址都要重新计算"></a>1.所有段的地址都要重新计算</h4><p>单纯减少 PAGEZERO 段的占用空间，作用不大，因为dyld加载动态库的时候，要求是所有的段一起进行mmap（详细可以查看dyld源码的ImageLoaderMachO::assignSegmentAddresses函数），所以必须把接下来所有的段的地址都重新计算一次。</p><p>同时要保证，前后两个段没有地址空间重叠，并且每个段都是按0x4000对齐。因为 PAGEZERO 是所有段中的第一个，所以可以直接把 PAGEZERO 的大小调整到0x4000，然后后面每一个段都按顺序依次减少同样大小(0xFFFFC000 &#x3D; 0x100000000 - 0x4000)，同时能保证每个段在文件内的偏移量不变。</p><p><strong>修改前：</strong><br><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-PAGEZERO%E6%AE%B5%E4%BF%AE%E6%94%B9%E5%89%8D.jpg" alt="PAGEZERO段修改前" loading="lazy">  </p><p><strong>修改后：</strong><br><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-PAGEZERO%E6%AE%B5%E4%BF%AE%E6%94%B9%E5%90%8E.jpg" alt="PAGEZERO段修改后" loading="lazy">  </p><h4 id="2-对动态库进行rebase操作"><a href="#2-对动态库进行rebase操作" class="headerlink" title="2.对动态库进行rebase操作"></a>2.对动态库进行rebase操作</h4><p>这里的rebase是系统为了解决动态库虚拟内存地址冲突，在加载动态库时进行的基地址重定位操作。</p><p>这一步操作是整个流程里最重要的，因为按照前面的操作，整个文件地址空间已经发生了变化，如果dyld依然按照原来的地址进行rebase，必然会失败。</p><p>那么rebase操作需要做哪些工作呢？</p><p>相关的信息储存在 Mach-O 文件的 LINKEDIT 段中, 并由 LC_DYLD_INFO_ONLY 指定 rebase info 在文件中的偏移量<br><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E5%81%8F%E7%A7%BB%E9%87%8F.jpg" alt="rebase在文件中的偏移量" loading="lazy">  </p><p>详细的rebase信息:<br><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.jpg" alt="详细的rebase信息" loading="lazy">  </p><p>红框里那些Pointer的意思是说，在内存地址为 0x367C698 的地方有一个指针，这个指针需要进行rebase操作, 操作的内容就是和前面调整地址空间一样，每个指针减去 0xFFFFC000。<br><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20%E4%B8%AD%E6%8C%87%E9%92%88%E5%87%8F0xFFFFC000.jpg" loading="lazy">  </p><h4 id="3-为什么不能直接去掉PAGEZERO这个段"><a href="#3-为什么不能直接去掉PAGEZERO这个段" class="headerlink" title="3.为什么不能直接去掉PAGEZERO这个段"></a>3.为什么不能直接去掉PAGEZERO这个段</h4><p>这个原因要涉及到文件中rebase信息的储存格式，上面的图中，可以看出rebase要处理的是一个个指针，但是实际上这些信息在文件中并不是以指针数组的形式存在，而是以一连串rebase opcode的形式存在，上面看到的一个个指针其实是 Mach O View 这个软件帮我们将opcode整理得到的。<br><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20rebase%20opcode.jpg" loading="lazy">  </p><p>这些opcode中有一种操作比较关键，REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB。<br><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB.jpg" loading="lazy">  </p><p>这个opcode的意思是, 接下去需要调整文件的中的第2个段，就是图中segment(2)所表示的含义。</p><p>所以说，如果把PAGEZERO这个段给去掉了，文件中各个段的序号也就都错位了，与rebase中的信息就对应不上了。<br>而且把这个段大小改为0，也是不行的，因为dyld在加载的过程中，会重新自动过滤掉大小为0的段，也会导致同样的段序号错位的问题。（有兴趣的同学可以看下dyld的源码，在ImageLoaderMachO类的构造函数里）<br>这就是为什么必须要保留PAGEZERO这个段，同时大小不能为0。  </p><h3 id="修改符号表"><a href="#修改符号表" class="headerlink" title="修改符号表"></a>修改符号表</h3><p>正常的线上应用是不存在符号表的，但是如果你之前用了我的另一个工具 <a href="https://github.com/tobefuturer/restore-symbol">restore-symbol</a>来恢复符号表的话，这个地方自然也需要做一些处理，处理方法同rebase类似，减去0xFFFFC000.</p><p>不过有一些符号需要单独过滤，比如这个：<br><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E4%BF%AE%E6%94%B9%E7%AC%A6%E5%8F%B7%E8%A1%A8.jpg" loading="lazy">  </p><p>这个radr:&#x2F;&#x2F;5614542是个什么神奇的符号呢，google就能发现，念茜的twitter上提过这个奇葩的符号。(女神果然是女神, 棒~ 😂)<br><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E5%BF%B5%E8%8C%9Ctwitter.jpg" loading="lazy">  </p><h2 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h2><p>工具开源在<a href="https://github.com/tobefuturer/app2dylib">github</a>上，用法：<br>###1.下载源码编译：</p><pre class="language-git" data-language="git"><code class="language-git">git clone --recursive https://github.com/tobefuturer/app2dylib.gitcd app2dylib &amp;&amp; make./app2dylib</code></pre><h3 id="2-把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库"><a href="#2-把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库" class="headerlink" title="2.把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库"></a>2.把支付宝arm64砸壳，然后提取可执行文件，用上面的工具把支付宝的可执行文件转成动态库</h3><pre class="language-linux" data-language="linux"><code class="language-linux">.&#x2F;app2dylib &#x2F;tmp&#x2F;AlipayWallet -o &#x2F;tmp&#x2F;libAlipayApp.dylib   </code></pre><h3 id="3-用-Xcode-新建工程，并把新生成的dylib拖进去，调整好各项设置"><a href="#3-用-Xcode-新建工程，并把新生成的dylib拖进去，调整好各项设置" class="headerlink" title="3.用 Xcode 新建工程，并把新生成的dylib拖进去，调整好各项设置."></a>3.用 Xcode 新建工程，并把新生成的dylib拖进去，调整好各项设置.</h3><p><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20Xcode%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B.jpg" loading="lazy">  </p><p>Run Script里的代码(目的是为了对dylib进行签名)  </p><pre><code class="linux">cd $&#123;BUILT_PRODUCTS_DIR&#125;cd $&#123;FULL_PRODUCT_NAME&#125;/usr/bin/codesign --force --sign $&#123;EXPANDED_CODE_SIGN_IDENTITY&#125; --timestamp=none libAlipayApp.dylib</code></pre><h3 id="4-怎么调用动态库里的方法呢？"><a href="#4-怎么调用动态库里的方法呢？" class="headerlink" title="4.怎么调用动态库里的方法呢？"></a>4.怎么调用动态库里的方法呢？</h3><p>为方便大家尝试，这里选两个分析起来比较简单的函数调用演示给大家。</p><p>一个是OC的方法 <code>+[aluSecurity rsaEncryptText:pubKey:]</code>, 可以直接用oc运行时调用。</p><p>另一个是C的函数 <code>int base64_encode(char * output, int * output_length, char * input, int input_length)</code><br>这个需要先确定 base64_encode 这个C函数的函数签名和在dylib中的偏移地址（我这边的9.9.3版本是0xa798e4），可以用ida分析得到。</p><p>运行结果：<br><img src="http://img.gaoshilei.com/App%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93-%20%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" loading="lazy">  </p><pre><code class="C">#import &lt;UIKit/UIKit.h&gt;#import &lt;dlfcn.h&gt;#import &lt;mach/mach.h&gt;#import &lt;mach-o/loader.h&gt;#import &lt;mach-o/dyld.h&gt;#import &lt;objc/runtime.h&gt;int main(int argc, char * argv[]) &#123;    NSLog(@&quot;\n===Start===\n&quot;);    NSString * dylibName = @&quot;libAlipayApp&quot;;    NSString * path = [[NSBundle mainBundle] pathForResource:dylibName ofType:@&quot;dylib&quot;];    if (dlopen(path.UTF8String, RTLD_NOW) == NULL)&#123;        NSLog(@&quot;dlopen failed ，error %s&quot;, dlerror());        return 0;    &#125;;        //运行时 直接调用oc方法    NSString * plain = @&quot;alipay&quot;;    NSString * pubkey = @&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDZ6i9VNEGEaZaYE7XffA9XRj15cp/ZKhHYY43EEva8LIhCWi29EREaF4JjZVMwFpUAfrL+9gpA7NMQmaMRHbrz1KHe2Ho4HpUhEac8M9zUbNvaDKSlhx0lq/15TQP+57oQbfJ9oKKd+he4Yd6jpBI3UtGmwJyN/T1S0DQ0aXR8OQIDAQAB&quot;;    NSString * cipher = [NSClassFromString(@&quot;aluSecurity&quot;) performSelector:NSSelectorFromString(@&quot;rsaEncryptText:pubKey:&quot;) withObject:plain withObject:pubkey];    NSLog(@&quot;\n-----------call oc method---------\n明文：%@\n密文： %@\n-----------------------------------&quot;, plain,cipher);        //确认dylib加载在内存中的地址    uint64_t slide = 0;    for (int i = 0; i &lt;  _dyld_image_count(); i ++)        if ([[NSString stringWithUTF8String:_dyld_get_image_name(i)] isEqualToString:path])            slide = _dyld_get_image_vmaddr_slide(i);    assert(slide != 0);            typedef int (*BASE64_ENCODE_FUNC_TYPE) (char * output, int * output_size , char * input, int input_length);    /** 根据偏移算出函数地址， 然后调用*/    long long base64_encode_offset_in_dylib = 0xa798e4;    BASE64_ENCODE_FUNC_TYPE base64_encode = (BASE64_ENCODE_FUNC_TYPE)(slide + base64_encode_offset_in_dylib);    char output[1000] = &#123;0&#125;;    int length = 1000;    char * input = &quot;alipay&quot;;    base64_encode(output, &amp; length,  input, (int)strlen(input));    NSLog(@&quot;\n-----------call c function---------\nbase64: %s -&gt; %s\n-----------------------------------&quot;, input,  output);&#125;</code></pre><p>ps：示例代码中，我刻意除掉了界面部分的代码，因为支付宝的+load函数里swizzle了UI层的一些方法，会导致crash，如果想干掉那些+load方法的话，看下面。  </p><h2 id="关于绕过检测代码"><a href="#关于绕过检测代码" class="headerlink" title="关于绕过检测代码"></a>关于绕过检测代码</h2><p>文章开头的简介中有提到，以动态库的形式加载，能够绕过应用的检测代码，这说法不完全，因为如果把检测代码写在类的+load方法里或者mod_init_func函数（ 全局静态变量的构造函数和__attribute__((constructor))指定的函数 ）里，在dylib加载的时候也是可以得到调用的。</p><p>那么也就衍生出两种配搭的对抗方案：<br><strong>i）越狱机</strong><br>+load方法的调用是在libobjc.dylib中的call_load_methods函数， mod_init_func函数的调用是在dyld中的doModInitFunctions函数，可以直接用CydiaSubstrate inline hook掉这两个函数，而且动态库是由我们自己加载的，所以可以控制hook和加载dylib的时序。</p><p><strong>ii) 非越狱机</strong><br>非越狱机上，没有办法inline hook，但是可以利用_dyld_register_func_for_add_image 这个函数注册回调，这个回调是发生在动态库加载到内存后，+load方法和mod_init_func函数调用前，所以可以在这个回调里把+load方法改名，把mod_init_func段改名等等，也就可以使得各种检测函数没法调用了。</p><p>总之，主要的控制权还是在我们手中。<br>测试环境：<br>iPhone 6Plus 、iOS 9.3.1 、arm64<br>支付宝9.9.3</p><p>参考链接&amp;致谢<br>1.dyld的源码：<a href="https://opensource.apple.com/source/dyld/">https://opensource.apple.com/source/dyld/</a><br>2.iOS逆向的论坛 <a href="http://iosre.com/">http://iosre.com/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;文章转载自&lt;a href=&quot;http://blog.imjun.net/&quot;&gt;杨君的小黑屋&lt;/a&gt;，对排版进行了一些调整&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文会介绍一个自己写的工具，能够把第三方iOS应用转成动态库，并加载到自己的App中，文章最后会以支付宝为例，展示如何调用其中的C函数和OC方法。&lt;br&gt;工具开源地址：&lt;br&gt;&lt;a href=&quot;https://github.com/tobefuturer/app2dylib&quot;&gt;https://github.com/tobefuturer/app2dylib&lt;/a&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="他山之石" scheme="http://www.gaoshilei.com/categories/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/"/>
    
    
    <category term="动态库" scheme="http://www.gaoshilei.com/tags/%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    
    <category term="黑科技" scheme="http://www.gaoshilei.com/tags/%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>iPhone查找序列号生成函数</title>
    <link href="http://www.gaoshilei.com/iphone-serial-number/"/>
    <id>http://www.gaoshilei.com/iphone-serial-number/</id>
    <published>2016-09-07T16:00:00.000Z</published>
    <updated>2023-10-20T08:45:15.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在iOS7之前我们可以通过<code>- (NSString *)uniqueIdentifier</code>这个方法获取iPhone的唯一标识符，也叫作UDID。不过自从iOS7苹果就把这个方法给禁了，此时我们想要获取iPhone的唯一标识符就很困难。<br>不过苹果提供一个叫做IDFA的标识符，这个IDFA是广告标识符用来追踪广告投放的，不过用户可以在设置中手动重置IDFA，可靠性很低，目前常见的两种标记iPhone的方式为  </p><ul><li>openUDID  </li><li>IDFA或UUID+keychain</li></ul><p>这两种模式都有个弊端，用户重置手机或者刷机唯一标识符会发生变化，不过对于大多数情况是够用了。看来苹果是把路给封死了，有没有办法拿到之前的UDID呢？我们注意到iPhone的设置通用关于里面有手机的硬件信息，其中有一个serialNumber，这个serialnumber就是我们查询手机是否过保的依据，那么它肯定是唯一的，所以下文是围绕这个进行的探索。最终是可以拿到这个serialNumber的， 不过由于苹果的沙盒限制，所以只能在越狱机中拿到，如果想在非越狱机中拿到必须添加entitlements文件来获取权限，可想而知这个应用是无法上架的。<strong>下文仅作为逆向工程的一种思路和探索</strong> </p><span id="more"></span><p>转载请注明出处：<a href="http://www.gaoshilei.com/">来自LeonLei的博客http://www.gaoshilei.com</a>  </p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一、SSH连接手机（USB模式）"><a href="#一、SSH连接手机（USB模式）" class="headerlink" title="一、SSH连接手机（USB模式）"></a>一、SSH连接手机（USB模式）</h3><h4 id="1-映射端口"><a href="#1-映射端口" class="headerlink" title="1.映射端口"></a>1.映射端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:~ gaoshilei$ /Users/gaoshilei/Desktop/reverse/USBSSH/tcprelay.py -t 22:6666</span><br><span class="line">Forwarding local port 6666 to remote port 22</span><br></pre></td></tr></table></figure><h4 id="2-连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试"><a href="#2-连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试" class="headerlink" title="2.连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试"></a>2.连接手机，并且用grep命令快速筛选当前我们要调试的应用Preferences，附加debugserver开始1234端口等待lldb调试</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:~ gaoshilei$ ssh root@localhost -p 6666</span><br><span class="line">iPhone-5S:~ root# ps -e | grep Pre</span><br><span class="line">  270 ??         0:00.29 /System/Library/PrivateFrameworks/MobileSoftwareUpdate.framework/XPCServices/com.apple.MobileSoftwareUpdate.CleanupPreparePathService.xpc/com.apple.MobileSoftwareUpdate.CleanupPreparePathService</span><br><span class="line"> 1192 ??         0:14.26 /var/db/stash/_.fP74Fg/Applications/Preferences.app/Preferences</span><br><span class="line"> 1289 ttys000    0:00.01 grep Pre</span><br><span class="line">iPhone-5S:~ root# debugserver *:1234 -a &quot;Preferences&quot;</span><br><span class="line">debugserver-@(#)PROGRAM:debugserver  PROJECT:debugserver-340.3.51.1</span><br><span class="line"> for arm64.</span><br><span class="line">Attaching to process Preferences...</span><br><span class="line">Listening to port 1234 for a connection from *...</span><br></pre></td></tr></table></figure><h4 id="3-完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样"><a href="#3-完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样" class="headerlink" title="3.完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样"></a>3.完成以上两步接下来就可以进行lldb调试了，首先要把远端（手机）的1234端口映射到本地，跟前面提到的SSH端口映射一样</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:~ gaoshilei$ /Users/gaoshilei/Desktop/reverse/USBSSH/tcprelay.py -t 1234:1234</span><br><span class="line">Forwarding local port 1234 to remote port 1234</span><br></pre></td></tr></table></figure><h3 id="二、通过LLDB、IDA寻找线索"><a href="#二、通过LLDB、IDA寻找线索" class="headerlink" title="二、通过LLDB、IDA寻找线索"></a>二、通过LLDB、IDA寻找线索</h3><p>lldb的调试端口已经打开，此时我们可以进入调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:~ gaoshilei$ lldb</span><br><span class="line">(lldb) process connect connect://localhost:1234</span><br><span class="line">Process 1192 stopped  </span><br><span class="line">* thread #1: tid = 0x523a6, 0x000000019a3c8a40 libsystem_kernel.dylib`mach_msg_trap + 8, queue = &#x27;com.apple.main-thread&#x27;, stop reason = signal SIGSTOP  </span><br><span class="line">    frame #0: 0x000000019a3c8a40 libsystem_kernel.dylib`mach_msg_trap + 8</span><br><span class="line">libsystem_kernel.dylib`mach_msg_trap:</span><br><span class="line">-&gt;  0x19a3c8a40 &lt;+8&gt;: ret    </span><br><span class="line">libsystem_kernel.dylib`mach_msg_overwrite_trap:</span><br><span class="line">    0x19a3c8a44 &lt;+0&gt;: movn   x16, #0x1f</span><br><span class="line">    0x19a3c8a48 &lt;+4&gt;: svc    #0x80</span><br><span class="line">    0x19a3c8a4c &lt;+8&gt;: ret    </span><br></pre></td></tr></table></figure><p>此时我们已经成功进入Preferences的调试阶段，先c一下，让程序继续运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) c</span><br><span class="line">Process 1192 resuming</span><br></pre></td></tr></table></figure><p>这么做的原因是我们待会要打印image的基地址偏移，有可能在我们打印的image list中没有我们想要的image。<br>此时我们已经找到到Preference.framework的基地址偏移，见下图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) im li -o -f</span><br><span class="line">[  0] 0x00000000000dc000 /var/db/stash/_.fP74Fg/Applications/Preferences.app/Preferences(0x00000001000dc000)</span><br><span class="line">[  1] 0x0000000100100000 /Library/MobileSubstrate/MobileSubstrate.dylib(0x0000000100100000)</span><br><span class="line">[  2] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/PrivateFrameworks/BulletinBoard.framework/BulletinBoard</span><br><span class="line">[  3] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation</span><br><span class="line">[  4] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit</span><br><span class="line">…</span><br><span class="line">[ 44] 0x0000000002e50000 /Users/gaoshilei/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/System/Library/PrivateFrameworks/Preferences.framework/Preferences</span><br><span class="line">…  </span><br></pre></td></tr></table></figure><p>我们要找的image的序号在这里是44，它的基地址偏移为0x2e50000，我们把从iPhone中导出的PrivateFrameworks中的Preferences.framework丢到IDA中进行分析，这个二进制文件比较小，很快就分析完成，在前面我们已经知道iPhone的唯一序列号serial number是通过PSListController生成的，并且我们知道这是一个cell，我们要去调试<code>[PSListController tableView:cellForRowAtIndexPath:]</code>这个方法，从中找到cell值的来源，从而找到获取序列号的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">__text:<span class="number">00000001908040</span>C8 ; -[PSListController tableView:cellForRowAtIndexPath:]</span><br><span class="line">__text:<span class="number">00000001908040</span>C8 __PSListController_tableView_cellForRowAtIndexPath__</span><br><span class="line">__text:<span class="number">00000001908040</span>C8                                         ; DATA XREF: __objc_const:<span class="number">000000019</span>C069B88o</span><br><span class="line">__text:<span class="number">00000001908040</span>C8</span><br><span class="line">__text:<span class="number">00000001908040</span>C8 var_80          = <span class="number">-0x80</span></span><br><span class="line">__text:<span class="number">00000001908040</span>C8 var_78          = <span class="number">-0x78</span></span><br><span class="line">__text:<span class="number">00000001908040</span>C8 var_70          = <span class="number">-0x70</span></span><br><span class="line">__text:<span class="number">00000001908040</span>C8 var_68          = <span class="number">-0x68</span></span><br><span class="line">__text:<span class="number">00000001908040</span>C8 var_60          = <span class="number">-0x60</span></span><br><span class="line">__text:<span class="number">00000001908040</span>C8 var_50          = <span class="number">-0x50</span></span><br><span class="line">__text:<span class="number">00000001908040</span>C8 var_40          = <span class="number">-0x40</span></span><br><span class="line">__text:<span class="number">00000001908040</span>C8 var_30          = <span class="number">-0x30</span></span><br><span class="line">__text:<span class="number">00000001908040</span>C8 var_20          = <span class="number">-0x20</span></span><br><span class="line">__text:<span class="number">00000001908040</span>C8 var_10          = <span class="number">-0x10</span></span><br><span class="line">__text:<span class="number">00000001908040</span>C8</span><br><span class="line">__text:<span class="number">00000001908040</span>C8                 STP             X28, X27, [SP,#var_60]!</span><br><span class="line">__text:<span class="number">00000001908040</span>CC                 STP             X26, X25, [SP,#<span class="number">0x60</span>+var_50]</span><br><span class="line">__text:<span class="number">00000001908040</span>D0                 STP             X24, X23, [SP,#<span class="number">0x60</span>+var_40]</span><br><span class="line">__text:<span class="number">00000001908040</span>D4                 STP             X22, X21, [SP,#<span class="number">0x60</span>+var_30]</span><br><span class="line">__text:<span class="number">00000001908040</span>D8                 STP             X20, X19, [SP,#<span class="number">0x60</span>+var_20]</span><br><span class="line">__text:<span class="number">00000001908040</span>DC                 STP             X29, X30, [SP,#<span class="number">0x60</span>+var_10]</span><br><span class="line">__text:<span class="number">00000001908040E0</span>                 ADD             X29, SP, #<span class="number">0x60</span>+var_10</span><br><span class="line">__text:<span class="number">00000001908040E4</span>                 SUB             SP, SP, #<span class="number">0x20</span></span><br><span class="line">__text:<span class="number">00000001908040E8</span>                 MOV             X21, X3</span><br><span class="line">__text:<span class="number">00000001908040</span>EC                 MOV             X20, X0</span><br><span class="line">__text:<span class="number">00000001908040</span>F0                 MOV             X0, X2</span><br><span class="line">__text:<span class="number">00000001908040</span>F4                 BL              <span class="number">0x96C400A0</span></span><br><span class="line">__text:<span class="number">00000001908040</span>F8                 MOV             X26, X0</span><br><span class="line">__text:<span class="number">00000001908040</span>FC                 ADRP            X8, #off_19DACC568@PAGE</span><br><span class="line">__text:<span class="number">0000000190804100</span>                 LDR             X1, [X8,#off_19DACC568@PAGEOFF]</span><br><span class="line">__text:<span class="number">0000000190804104</span>                 MOV             X0, X20</span><br><span class="line">__text:<span class="number">0000000190804108</span>                 MOV             X2, X21</span><br><span class="line">__text:<span class="number">000000019080410</span>C                 BL              <span class="number">0x96C39BC0</span></span><br><span class="line">__text:<span class="number">0000000190804110</span>                 MOV             X2, X0</span><br><span class="line">__text:<span class="number">0000000190804114</span>                 ADRP            X8, #_OBJC_IVAR_$_PSListController._specifiers@PAGE ; <span class="built_in">NSArray</span> *_specifiers;</span><br><span class="line">__text:<span class="number">0000000190804118</span>                 LDRSW           X27, [X8,#_OBJC_IVAR_$_PSListController._specifiers@PAGEOFF] ; <span class="built_in">NSArray</span> *_specifiers;</span><br><span class="line">__text:<span class="number">000000019080411</span>C                 LDR             X0, [X20,X27]</span><br><span class="line">__text:<span class="number">0000000190804120</span>                 ADRP            X8, #off_19DACC558@PAGE</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>我们在Preference.framework中基地址为0x190804114的位置打个断点，具体的做法是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a <span class="number">0x190804114</span>+<span class="number">0x2e50000</span></span><br><span class="line">Breakpoint <span class="number">1</span>: where = Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + <span class="number">76</span>, address = <span class="number">0x0000000193654114</span></span><br><span class="line">Process <span class="number">1192</span> stopped</span><br><span class="line">* thread #<span class="number">1</span>: tid = <span class="number">0x523a6</span>, <span class="number">0x0000000193654114</span> Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + <span class="number">76</span>, queue = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = breakpoint <span class="number">1.1</span></span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000193654114</span> Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + <span class="number">76</span></span><br><span class="line">Preferences`-[PSListController tableView:cellForRowAtIndexPath:]:</span><br><span class="line">-&gt;  <span class="number">0x193654114</span> &lt;+<span class="number">76</span>&gt;: adrp   x8, <span class="number">53965</span></span><br><span class="line">    <span class="number">0x193654118</span> &lt;+<span class="number">80</span>&gt;: ldrsw  x27, [x8, #<span class="number">516</span>]</span><br><span class="line">    <span class="number">0x19365411c</span> &lt;+<span class="number">84</span>&gt;: ldr    x0, [x20, x27]</span><br><span class="line">    <span class="number">0x193654120</span> &lt;+<span class="number">88</span>&gt;: adrp   x8, <span class="number">53960</span></span><br></pre></td></tr></table></figure><p>这里断点这样打是因为系统加载可执行文件和各种framework的时候会有一个地址偏移，我们在打断点的时候要把这个偏移量加上，这样我们打的断点才是准确的。<br>可以看到我们已经成功打了一个断点，断点的address &#x3D; 0x193654114。此时我们打印变量x0和x27的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x0</span><br><span class="line">13</span><br><span class="line">(lldb) po $x27</span><br><span class="line">1104</span><br></pre></td></tr></table></figure><p>我们执行ni让程序继续（这里的<code>ni</code>命令相当于Xcode的那个下箭头命令，也就是下一行）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) ni</span><br><span class="line">Process <span class="number">1192</span> stopped</span><br><span class="line">* thread #<span class="number">1</span>: tid = <span class="number">0x523a6</span>, <span class="number">0x0000000193654118</span> Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + <span class="number">80</span>, queue = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = instruction step over</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000193654118</span> Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + <span class="number">80</span></span><br><span class="line">Preferences`-[PSListController tableView:cellForRowAtIndexPath:]:</span><br><span class="line">-&gt;  <span class="number">0x193654118</span> &lt;+<span class="number">80</span>&gt;: ldrsw  x27, [x8, #<span class="number">516</span>]</span><br><span class="line">    <span class="number">0x19365411c</span> &lt;+<span class="number">84</span>&gt;: ldr    x0, [x20, x27]</span><br><span class="line">    <span class="number">0x193654120</span> &lt;+<span class="number">88</span>&gt;: adrp   x8, <span class="number">53960</span></span><br><span class="line">    <span class="number">0x193654124</span> &lt;+<span class="number">92</span>&gt;: ldr    x22, [x8, #<span class="number">1368</span>]</span><br><span class="line">(lldb) ni</span><br><span class="line">Process <span class="number">1192</span> stopped</span><br><span class="line">* thread #<span class="number">1</span>: tid = <span class="number">0x523a6</span>, <span class="number">0x000000019365411c</span> Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + <span class="number">84</span>, queue = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = instruction step over</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x000000019365411c</span> Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + <span class="number">84</span></span><br><span class="line">Preferences`-[PSListController tableView:cellForRowAtIndexPath:]:</span><br><span class="line">-&gt;  <span class="number">0x19365411c</span> &lt;+<span class="number">84</span>&gt;: ldr    x0, [x20, x27]</span><br><span class="line">    <span class="number">0x193654120</span> &lt;+<span class="number">88</span>&gt;: adrp   x8, <span class="number">53960</span></span><br><span class="line">    <span class="number">0x193654124</span> &lt;+<span class="number">92</span>&gt;: ldr    x22, [x8, #<span class="number">1368</span>]</span><br><span class="line">    <span class="number">0x193654128</span> &lt;+<span class="number">96</span>&gt;: mov    x1, x22</span><br><span class="line">(lldb) po $x27</span><br><span class="line"><span class="number">848</span></span><br><span class="line"></span><br><span class="line">(lldb) po $x0</span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><p>我们ni的两次，程序已经走到0x19080411C的位置，然后我们继续打印变量x0和x27的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x0</span><br><span class="line">13</span><br><span class="line">(lldb) po $x27</span><br><span class="line">1104</span><br></pre></td></tr></table></figure><p>打印出来的x0和x27都是随机数，还是没有什么收获，我们继续</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(lldb) ni</span><br><span class="line">Process <span class="number">1192</span> stopped</span><br><span class="line">* thread #<span class="number">1</span>: tid = <span class="number">0x523a6</span>, <span class="number">0x0000000193654120</span> Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + <span class="number">88</span>, queue = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = instruction step over</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000193654120</span> Preferences`-[PSListController tableView:cellForRowAtIndexPath:] + <span class="number">88</span></span><br><span class="line">Preferences`-[PSListController tableView:cellForRowAtIndexPath:]:</span><br><span class="line">-&gt;  <span class="number">0x193654120</span> &lt;+<span class="number">88</span>&gt;:  adrp   x8, <span class="number">53960</span></span><br><span class="line">    <span class="number">0x193654124</span> &lt;+<span class="number">92</span>&gt;:  ldr    x22, [x8, #<span class="number">1368</span>]</span><br><span class="line">    <span class="number">0x193654128</span> &lt;+<span class="number">96</span>&gt;:  mov    x1, x22</span><br><span class="line">    <span class="number">0x19365412c</span> &lt;+<span class="number">100</span>&gt;: bl     <span class="number">0x199a89bc0</span>               ; objc_msgSend</span><br><span class="line">(lldb) po $x0</span><br><span class="line">&lt;__NSArrayI <span class="number">0x13105a780</span>&gt;(</span><br><span class="line">G: &lt;PSSpecifier <span class="number">0x12ff50cf0</span>: ID <span class="number">0</span>, Name <span class="string">&#x27;&#x27;</span> target &lt;(null): <span class="number">0x0</span>&gt;&gt; <span class="number">0x12ff50cf0</span>,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff50f50</span>: ID NAME_CELL_ID, Name <span class="string">&#x27;Name&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">G: &lt;PSSpecifier <span class="number">0x12ff51680</span>: ID <span class="number">2</span>, Name <span class="string">&#x27;&#x27;</span> target &lt;(null): <span class="number">0x0</span>&gt;&gt; <span class="number">0x12ff51680</span>,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff52360</span>: ID NETWORK, Name <span class="string">&#x27;Network&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff52420</span>: ID SONGS, Name <span class="string">&#x27;Songs&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff519f0</span>: ID VIDEOS, Name <span class="string">&#x27;Videos&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff51ab0</span>: ID PHOTOS, Name <span class="string">&#x27;Photos&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff51b70</span>: ID APPLICATIONS, Name <span class="string">&#x27;Applications&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff524e0</span>: ID User Data Capacity, Name <span class="string">&#x27;Capacity&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff525a0</span>: ID User Data Available, Name <span class="string">&#x27;Available&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff526a0</span>: ID ProductVersion, Name <span class="string">&#x27;Version&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff52850</span>: ID <span class="built_in">CARRIER_VERSION</span>, Name <span class="string">&#x27;Carrier&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff52980</span>: ID ProductModel, Name <span class="string">&#x27;Model&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff52a60</span>: ID SerialNumber, Name <span class="string">&#x27;Serial Number&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff52b90</span>: ID MACAddress, Name <span class="string">&#x27;Wi-Fi Address&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12ff51050</span>: ID BTMACAddress, Name <span class="string">&#x27;Bluetooth&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12fde95d0</span>: ID ModemVersion, Name <span class="string">&#x27;Modem Firmware&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;,</span><br><span class="line">G: &lt;PSSpecifier <span class="number">0x131031e90</span>: ID <span class="number">17</span>, Name <span class="string">&#x27;&#x27;</span> target &lt;(null): <span class="number">0x0</span>&gt;&gt; <span class="number">0x131031e90</span>,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x12fde9c40</span>: ID LEGAL_AND_REGULATORY, Name <span class="string">&#x27;Legal&#x27;</span> target &lt;(null): <span class="number">0x0</span>&gt;&gt;,</span><br><span class="line">G: &lt;PSSpecifier <span class="number">0x131029dc0</span>: ID TRUST_STORE_GROUP, Name <span class="string">&#x27;&#x27;</span> target &lt;(null): <span class="number">0x0</span>&gt;&gt; <span class="number">0x131029dc0</span>,</span><br><span class="line">&lt;PSSpecifier <span class="number">0x131033520</span>: ID TRUST_STORE, Name <span class="string">&#x27;Trust Store&#x27;</span> target &lt;AboutDataSource: <span class="number">0x131028390</span>&gt;&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们让程序执行下一步，发现此时x0已经有值了，可以明显的看出，x0的值是在0x190804114~0x19080411C这段代码生成的，下面我们的工作重点就是寻找这段代码干了什么，胜利就在眼前！下面我们验证一下这里面到底有没有我们要的序列号：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [[$x0 objectAtIndex:<span class="number">13</span>] <span class="keyword">class</span>]</span><br><span class="line">PSSpecifier</span><br><span class="line">(lldb) po [[$x0 objectAtIndex:<span class="number">13</span>] properties]</span><br><span class="line">&#123;</span><br><span class="line">    cellObject = <span class="string">&quot;&lt;PSTableCell: 0x130800000; baseClass = UITableViewCell; frame = (0 565; 320 45); text = &#x27;Serial Number&#x27;; hidden = YES; autoresize = W; tag = 4; gestureRecognizers = &lt;NSArray: 0x12ff821c0&gt;; layer = &lt;CALayer: 0x12fd7d340&gt;&gt;&quot;</span>;</span><br><span class="line">    <span class="type">id</span> = SerialNumber;</span><br><span class="line">    isCopyable = <span class="number">1</span>;</span><br><span class="line">    value = DNPMVG0EFF9V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们打印数组中存放cell数据的object属于哪个类，发现是<code>PSSpecifier</code>，我们找到之前导出的类的头文件，发现这个类有一个叫做<code>properties</code>的实例方法，我们调用一下发现我们要的序列号就在里面<code>value = DNPMVG0EFF9V</code>，这跟iPhone设置中看到的序列号是一致的。猜测这个数组里面存放着系统设置中<code>PSUIAboutController</code>中所有cel的数据，这个数组下一个肯定要传递到cell生成的方法中，这个就不做验证了，大事重要，我们继续找序列号的生成方法。<br>这个<code>PSSpecifier</code>中有一个<code>AboutDataSource</code>对象，这个非常可疑，从名称上可以判断，这个类是专门用于数据处理的，不过在这之前我们还是先验证一下，在0x190804114~0x19080411C这段地址中，执行了<code>_PSListController._specifiers</code>，我们从<code>PSListController</code>的头文件（下文有讲怎么获取）中可以看到有一个specifiers属性，我们在IDA分析的文件中找到<code>[PSListController specifiers]</code>，我们先定位到方法在二进制文件中的位置：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">__text:<span class="number">00000001907</span>FE4A8 ; -[PSListController specifiers]</span><br><span class="line">__text:<span class="number">00000001907</span>FE4A8 __PSListController_specifiers_          ; DATA XREF: __objc_const:<span class="number">000000019</span>C069A08o</span><br><span class="line">__text:<span class="number">00000001907</span>FE4A8</span><br><span class="line">__text:<span class="number">00000001907</span>FE4A8 var_40          = <span class="number">-0x40</span></span><br><span class="line">__text:<span class="number">00000001907</span>FE4A8 var_30          = <span class="number">-0x30</span></span><br><span class="line">__text:<span class="number">00000001907</span>FE4A8 var_20          = <span class="number">-0x20</span></span><br><span class="line">__text:<span class="number">00000001907</span>FE4A8 var_10          = <span class="number">-0x10</span></span><br><span class="line">__text:<span class="number">00000001907</span>FE4A8</span><br><span class="line">__text:<span class="number">00000001907</span>FE4A8                 STP             X24, X23, [SP,#var_40]!</span><br><span class="line">__text:<span class="number">00000001907</span>FE4AC                 STP             X22, X21, [SP,#<span class="number">0x40</span>+var_30]</span><br><span class="line">__text:<span class="number">00000001907</span>FE4B0                 STP             X20, X19, [SP,#<span class="number">0x40</span>+var_20]</span><br><span class="line">__text:<span class="number">00000001907</span>FE4B4                 STP             X29, X30, [SP,#<span class="number">0x40</span>+var_10]</span><br><span class="line">__text:<span class="number">00000001907</span>FE4B8                 ADD             X29, SP, #<span class="number">0x40</span>+var_10</span><br><span class="line">__text:<span class="number">00000001907</span>FE4BC                 MOV             X19, X0</span><br><span class="line">__text:<span class="number">00000001907</span>FE4C0                 ADRP            X8, #_OBJC_IVAR_$_PSListController._specifiers@PAGE ; <span class="built_in">NSArray</span> *_specifiers;</span><br><span class="line">__text:<span class="number">00000001907</span>FE4C4                 LDRSW           X22, [X8,#_OBJC_IVAR_$_PSListController._specifiers@PAGEOFF] ; <span class="built_in">NSArray</span> *_specifiers;</span><br><span class="line">__text:<span class="number">00000001907</span>FE4C8                 LDR             X8, [X19,X22]</span><br><span class="line">__text:<span class="number">00000001907</span>FE4CC                 CBNZ            X8, loc_1907FE5E0</span><br><span class="line">__text:<span class="number">00000001907</span>FE4D0                 ADRP            X8, #_OBJC_IVAR_$_PSListController._dataSource@PAGE ; <span class="type">id</span> &lt;PSSpecifierDataSource&gt; _dataSource;</span><br><span class="line">__text:<span class="number">00000001907</span>FE4D4                 LDRSW           X8, [X8,#_OBJC_IVAR_$_PSListController._dataSource@PAGEOFF] ; <span class="type">id</span> &lt;PSSpecifierDataSource&gt; _dataSource;</span><br><span class="line">__text:<span class="number">00000001907</span>FE4D8                 LDR             X9, [X19,X8]</span><br><span class="line">__text:<span class="number">00000001907</span>FE4DC                 CBZ             X9, loc_1907FE550</span><br><span class="line">__text:<span class="number">00000001907</span>FE4E0                 ADRP            X9, #_OBJC_IVAR_$_PSListController._requestingSpecifiersFromDataSource@PAGE ; <span class="type">bool</span> _requestingSpecifiersFromDataSource;</span><br><span class="line">__text:<span class="number">00000001907</span>FE4E4                 LDRSW           X23, [X9,#_OBJC_IVAR_$_PSListController._requestingSpecifiersFromDataSource@PAGEOFF] ; <span class="type">bool</span> _requestingSpecifiersFromDataSource;</span><br><span class="line">__text:<span class="number">00000001907</span>FE4E8                 MOV             W9, #<span class="number">1</span></span><br><span class="line">__text:<span class="number">00000001907</span>FE4EC                 STRB            W9, [X19,X23]</span><br><span class="line">__text:<span class="number">00000001907</span>FE4F0                 LDR             X20, [X19,X8]</span><br><span class="line">__text:<span class="number">00000001907</span>FE4F4                 ADRP            X8, #selRef_specifier@PAGE</span><br><span class="line">__text:<span class="number">00000001907</span>FE4F8                 LDR             X1, [X8,#selRef_specifier@PAGEOFF]</span><br><span class="line">__text:<span class="number">00000001907</span>FE4FC                 MOV             X0, X19</span><br><span class="line">__text:<span class="number">00000001907</span>FE500                 BL              <span class="number">0x96C39BC0</span></span><br><span class="line">__text:<span class="number">00000001907</span>FE504                 MOV             X29, X29</span><br><span class="line">__text:<span class="number">00000001907</span>FE508                 BL              <span class="number">0x96C41EF0</span></span><br><span class="line">__text:<span class="number">00000001907</span>FE50C                 MOV             X21, X0</span><br><span class="line">__text:<span class="number">00000001907</span>FE510                 ADRP            X8, #selRef_specifiersForSpecifier_observer_@PAGE</span><br><span class="line">__text:<span class="number">00000001907</span>FE514                 LDR             X1, </span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>然后在这里面下个断点看看会发生什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0x1907FE4D0+0x198e58640</span><br><span class="line">Breakpoint 9: where = Preferences`-[PSListController specifiers] + 40, address = 0x000000019364e4d0</span><br></pre></td></tr></table></figure><p>我们从设置中进入通用&gt;关于，发现一开始就走到了这个断点，我们猜测，一进入关于页面，系统会首先把所有cell的数据都准备好，然后加载UI</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Process <span class="number">1192</span> stopped</span><br><span class="line">* thread #<span class="number">1</span>: tid = <span class="number">0x523a6</span>, <span class="number">0x000000019364e4d0</span> Preferences`-[PSListController specifiers] + <span class="number">40</span>, queue = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = breakpoint <span class="number">9.1</span></span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x000000019364e4d0</span> Preferences`-[PSListController specifiers] + <span class="number">40</span></span><br><span class="line">Preferences`-[PSListController specifiers]:</span><br><span class="line">-&gt;  <span class="number">0x19364e4d0</span> &lt;+<span class="number">40</span>&gt;: adrp   x8, <span class="number">53971</span></span><br><span class="line">    <span class="number">0x19364e4d4</span> &lt;+<span class="number">44</span>&gt;: ldrsw  x8, [x8, #<span class="number">536</span>]</span><br><span class="line">    <span class="number">0x19364e4d8</span> &lt;+<span class="number">48</span>&gt;: ldr    x9, [x19, x8]</span><br><span class="line">    <span class="number">0x19364e4dc</span> &lt;+<span class="number">52</span>&gt;: cbz    x9, <span class="number">0x19364e550</span>           ; &lt;+<span class="number">168</span>&gt;</span><br></pre></td></tr></table></figure><p>我们打印变量x8和x9的值，看一下系统做了什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x8</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">(lldb) po $x9</span><br><span class="line">PSUIAboutController</span><br></pre></td></tr></table></figure><p>并没有数据之类的东西值得我们关注，让断点继续往下走，走到0x19364e4dc的位置，我们再次打印变量x8和x9的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(lldb) n</span><br><span class="line">Process 1192 stopped</span><br><span class="line">* thread #1: tid = 0x523a6, 0x000000019364e4dc Preferences`-[PSListController specifiers] + 52, queue = &#x27;com.apple.main-thread&#x27;, stop reason = instruction step over</span><br><span class="line">    frame #0: 0x000000019364e4dc Preferences`-[PSListController specifiers] + 52</span><br><span class="line">Preferences`-[PSListController specifiers]:</span><br><span class="line">-&gt;  0x19364e4dc &lt;+52&gt;: cbz    x9, 0x19364e550           ; &lt;+168&gt;</span><br><span class="line">    0x19364e4e0 &lt;+56&gt;: adrp   x9, 53971</span><br><span class="line">    0x19364e4e4 &lt;+60&gt;: ldrsw  x23, [x9, #540]</span><br><span class="line">    0x19364e4e8 &lt;+64&gt;: orr    w9, wzr, #0x1</span><br><span class="line">(lldb) po $x8</span><br><span class="line">952</span><br><span class="line">(lldb) po $x9</span><br><span class="line">&lt;AboutDataSource: 0x131130730&gt;</span><br></pre></td></tr></table></figure><p>此时的变量x9已经变成了<code>AboutDataSource</code>，这里验证了我们上一步的猜想，所以我们重点来研究它，我们先找到这个类在哪个framework中，这里使用的是grep命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:~ gaoshilei$ grep AboutDataSource -r /Users/gaoshilei/Desktop/reverse/iOS-Runtime-Headers-9.1 </span><br><span class="line">/Users/gaoshilei/Desktop/reverse/iOS-Runtime-Headers-9.1/PrivateFrameworks/PreferencesUI.framework/AboutDataSource.h:@interface AboutDataSource : PSSpecifierDataSource &#123;</span><br></pre></td></tr></table></figure><p>这里要说明一下iOS-Runtime-Headers-9.1这个文件夹是iOS9.1系统的所有头文件（共有+私有），这个你可以自己导（iOS9之后只能用runtime导，class-dump已经不行了），你也可以拿现成的用，github上面已经有雷锋把所有系统的头文件都导出来了，直接下载就可以了。我们发现<code>AboutDataSource</code>这个类在<code>PrivateFrameworks/PreferencesUI.framework</code>中，先看一下这个类里面有什么方法和属性，有一个方法<code>- (void)_loadValues;</code> 我们对它进行分析。这里又要借助IDA分析，把PreferencesUI这个二进制文件丢到IDA里面，在0x19091EBB8这个位置打个断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0x19091EBB8+0x2e50000</span><br><span class="line">Breakpoint 3: where = PreferencesUI`-[AboutDataSource _loadValues] + 1956, address = 0x000000019376ebb8</span><br></pre></td></tr></table></figure><p>接下来我们进入关于来触发断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (char *) $x28</span><br><span class="line">&quot;_setValue:forSpecifierWithKey:&quot;</span><br></pre></td></tr></table></figure><p>在这里打印变量x28的值，发现它是一个方法名，从名称来看是给<code>specifier</code>赋值的，看来我们要寻找的真相已经很近了，让代码走到下面的位置0x19376ebd8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Process 2107 stopped</span><br><span class="line">* thread #1: tid = 0xe8e23, 0x000000019376ebd8 PreferencesUI`-[AboutDataSource _loadValues] + 1988, queue = &#x27;com.apple.main-thread&#x27;, stop reason = instruction step over</span><br><span class="line">    frame #0: 0x000000019376ebd8 PreferencesUI`-[AboutDataSource _loadValues] + 1988</span><br><span class="line">PreferencesUI`-[AboutDataSource _loadValues]:</span><br><span class="line">-&gt;  0x19376ebd8 &lt;+1988&gt;: bl     0x198e58640               ; MGCopyAnswer</span><br><span class="line">    0x19376ebdc &lt;+1992&gt;: mov    x22, x0</span><br><span class="line">    0x19376ebe0 &lt;+1996&gt;: mov    x1, x19</span><br><span class="line">    0x19376ebe4 &lt;+2000&gt;: bl     0x199a89bc0               ; objc_msgSend</span><br><span class="line">(lldb) po $x0</span><br><span class="line">SerialNumber</span><br></pre></td></tr></table></figure><p>此时我们打印的x0是一个<code>NSCFConstantString</code>，本质就是一个<code>NSString</code>，继续<code>ni</code>让程序运行到0x19376ebdc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Process 2107 stopped</span><br><span class="line">* thread #1: tid = 0xe8e23, 0x000000019376ebdc PreferencesUI`-[AboutDataSource _loadValues] + 1992, queue = &#x27;com.apple.main-thread&#x27;, stop reason = instruction step over</span><br><span class="line">    frame #0: 0x000000019376ebdc PreferencesUI`-[AboutDataSource _loadValues] + 1992</span><br><span class="line">PreferencesUI`-[AboutDataSource _loadValues]:</span><br><span class="line">-&gt;  0x19376ebdc &lt;+1992&gt;: mov    x22, x0</span><br><span class="line">    0x19376ebe0 &lt;+1996&gt;: mov    x1, x19</span><br><span class="line">    0x19376ebe4 &lt;+2000&gt;: bl     0x199a89bc0               ; objc_msgSend</span><br><span class="line">    0x19376ebe8 &lt;+2004&gt;: cbnz   x0, 0x19376ec4c           ; &lt;+2104&gt;</span><br><span class="line">(lldb) po $x0</span><br><span class="line">DNPMVG0EFF9V</span><br></pre></td></tr></table></figure><p>在这里我们打印了变量x0的值为<strong>DNPMVG0EFF9V</strong>，这就是我们苦苦寻找的序列号。不难看出，序列号就是在0x19376ebd8这行拿到的，范围越来越小，敌人无路可逃！下面我们就要对这行进行分析，我们按照之前的步骤，再次走到0x19376ebd8这个位置，这不过这次我们不要<code>step-over</code>，我们用<code>si</code>跳入看看</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(lldb) si</span><br><span class="line">Process <span class="number">2107</span> stopped</span><br><span class="line">* thread #<span class="number">1</span>: tid = <span class="number">0xe8e23</span>, <span class="number">0x0000000198e58640</span> libMobileGestalt.dylib`MGCopyAnswer, queue = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = instruction step into</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000198e58640</span> libMobileGestalt.dylib`MGCopyAnswer</span><br><span class="line">libMobileGestalt.dylib`MGCopyAnswer:</span><br><span class="line">-&gt;  <span class="number">0x198e58640</span> &lt;+<span class="number">0</span>&gt;: movz   x1, #<span class="number">0</span></span><br><span class="line">    <span class="number">0x198e58644</span> &lt;+<span class="number">4</span>&gt;: b      <span class="number">0x198e58648</span>               ; ___lldb_unnamed_symbol64$$libMobileGestalt.dylib</span><br><span class="line"></span><br><span class="line">libMobileGestalt.dylib`___lldb_unnamed_symbol64$$libMobileGestalt.dylib:</span><br><span class="line">    <span class="number">0x198e58648</span> &lt;+<span class="number">0</span>&gt;: stp    x24, x23, [sp, #<span class="number">-64</span>]!</span><br><span class="line">    <span class="number">0x198e5864c</span> &lt;+<span class="number">4</span>&gt;: stp    x22, x21, [sp, #<span class="number">16</span>]</span><br><span class="line">此时跳入了一个静态库libMobileGestalt.dylib，我们可以在usr/lib/ibMobileGestalt.dylib找到它，我们将它扔进IDA，用当前的addr减去libMobileGestalt.dylib的基地址偏移得到它的静态地址<span class="number">0x196008640</span>，对应的是一个函数MGCopyAnswer</span><br><span class="line">__text:<span class="number">0000000196008640</span></span><br><span class="line">__text:<span class="number">0000000196008640</span> ; =============== S U B R O U T I N E =======================================</span><br><span class="line">__text:<span class="number">0000000196008640</span></span><br><span class="line">__text:<span class="number">0000000196008640</span></span><br><span class="line">__text:<span class="number">0000000196008640</span>                 EXPORT _MGCopyAnswer</span><br><span class="line">__text:<span class="number">0000000196008640</span> _MGCopyAnswer                           ; CODE XREF: sub_196005958+<span class="number">30</span>p</span><br><span class="line">__text:<span class="number">0000000196008640</span>                                         ; sub_196006258+<span class="number">28</span>p ...</span><br><span class="line">__text:<span class="number">0000000196008640</span>                 MOV             X1, #<span class="number">0</span></span><br><span class="line">__text:<span class="number">0000000196008644</span>                 B               sub_196008648</span><br><span class="line">__text:<span class="number">0000000196008644</span> ; End of function _MGCopyAnswer</span><br></pre></td></tr></table></figure><p>这个函数最外层只有两行代码，将立即数0赋给x1，然后跳进了子程序sub_196008648，跳进去之后进行了一些很复杂的运算，这里就不做介绍了，里面的实现大概是这样的：<br>x0是作为一个参数传入的，并且这里x0的值为<code>SerialNumber</code>，在地址为0x196008678的地方，这个函数中x1变成了一串随机数，有点像MD5加密之后的东西，应该是“钥匙”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (char*) $x1</span><br><span class="line">&quot;l92SaBpqIvQs+KBljuwGA&quot;</span><br></pre></td></tr></table></figure><p>在0x196008690这里，我们<code>setp-into</code>这个函数，在函数的末尾返回值的地方0x196007474打个断点，打印返回值x0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x0</span><br><span class="line">DNPMVG0EFF9V</span><br></pre></td></tr></table></figure><p>这里的x0由<code>SerialNumber</code>变成了真正的序列号，并且就是在0x196008690对应的子程序sub_19600738C里面拿到的，所以我们就这样一个猜测，在<code>MGCopyAnswer</code>函数中，x0作为一个参数传入，并且在内部进行了一系列复杂的运算，拿到了获取序列号的“钥匙”x1，然后在sub_19600738C中拿到了最终的序列号。这里笔者也没有对序列号的拿到在进行进一步的深究，这里苹果做了很大的限制，再继续研究恐怕也是收获不大，而且我们在这里已经能拿到序列号了。<br>###三、验证结果<br>接下来就是验证的过程了，我们写一个tweak来验证，当然也可以用其他方式来验证：<br>tweak的创建这里就不赘述了，我把我的tweak和makefile文件内容贴一下：</p><blockquote><p>tweak文件：</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tweak.xm:</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="built_in">NSString</span> *MGCopyAnswer(<span class="built_in">NSString</span>*);</span><br><span class="line">%hook SpringBoard</span><br><span class="line">- (<span class="type">void</span>)applicationDidFinishLaunching:(<span class="type">id</span>)application &#123;</span><br><span class="line">%orig;</span><br><span class="line"><span class="built_in">NSString</span> *serialNumber = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>,[MGCopyAnswer(<span class="string">@&quot;SerialNumber&quot;</span>) autorelease]];</span><br><span class="line"><span class="built_in">UIAlertView</span> *alert = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:serialNumber message:<span class="literal">nil</span> delegate:<span class="keyword">self</span> cancelButtonTitle:<span class="string">@&quot;OK&quot;</span> otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">[alert show];</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>这里注入系统的SpringBoard，在SB启动的时候hook住applicationDidFinishLaunching：函数，并且在这个函数里面添加获取序列号的代码，并且以弹框的形式展现出来。  </p><blockquote><p>makefile文件:</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">THEOS_DEVICE_IP = <span class="number">192.168</span><span class="number">.0</span><span class="number">.115</span></span><br><span class="line">include $(THEOS)/makefiles/common.mk</span><br><span class="line">TWEAK_NAME = SerialNumber</span><br><span class="line">SerialNumber_FILES = Tweak.xm</span><br><span class="line">include $(THEOS_MAKE_PATH)/tweak.mk</span><br><span class="line">SerialNumber_LDFLAGS = -lMobileGestalt</span><br><span class="line">after-install::</span><br><span class="line">install.exec <span class="string">&quot;killall -9 SpringBoard&quot;</span></span><br></pre></td></tr></table></figure><p>其中有一行<code>SerialNumber_LDFLAGS = -lMobileGestalt</code>千万要注意，使用的时候要加载这个静态库，因为SpringBoard加载的时候我也不确定是否有加载这个库，然后我们验证一下吧！<br><img src="http://img.gaoshilei.com/%E6%9F%A5%E6%89%BE%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B01.jpg" alt="序列号验证-获取" loading="lazy"><img src="http://img.gaoshilei.com/%E6%9F%A5%E6%89%BE%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B02.jpg" alt="序列号验证-系统" loading="lazy">  </p><p> <a href="https://www.amazon.cn/iOS%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B-%E6%B2%99%E6%A2%93%E7%A4%BE/dp/B00VFDVY7E/ref=sr_1_1?ie=UTF8&qid=1477453672&sr=8-1&keywords=iOS%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B">此文参考了《iOS逆向工程（第二版）》</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在iOS7之前我们可以通过&lt;code&gt;- (NSString *)uniqueIdentifier&lt;/code&gt;这个方法获取iPhone的唯一标识符，也叫作UDID。不过自从iOS7苹果就把这个方法给禁了，此时我们想要获取iPhone的唯一标识符就很困难。&lt;br&gt;不过苹果提供一个叫做IDFA的标识符，这个IDFA是广告标识符用来追踪广告投放的，不过用户可以在设置中手动重置IDFA，可靠性很低，目前常见的两种标记iPhone的方式为  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;openUDID  &lt;/li&gt;
&lt;li&gt;IDFA或UUID+keychain&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种模式都有个弊端，用户重置手机或者刷机唯一标识符会发生变化，不过对于大多数情况是够用了。看来苹果是把路给封死了，有没有办法拿到之前的UDID呢？我们注意到iPhone的设置通用关于里面有手机的硬件信息，其中有一个serialNumber，这个serialnumber就是我们查询手机是否过保的依据，那么它肯定是唯一的，所以下文是围绕这个进行的探索。最终是可以拿到这个serialNumber的， 不过由于苹果的沙盒限制，所以只能在越狱机中拿到，如果想在非越狱机中拿到必须添加entitlements文件来获取权限，可想而知这个应用是无法上架的。&lt;strong&gt;下文仅作为逆向工程的一种思路和探索&lt;/strong&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="iOS逆向" scheme="http://www.gaoshilei.com/categories/iOS%E9%80%86%E5%90%91/"/>
    
    
    <category term="serial Number" scheme="http://www.gaoshilei.com/tags/serial-Number/"/>
    
    <category term="UDID" scheme="http://www.gaoshilei.com/tags/UDID/"/>
    
  </entry>
  
  <entry>
    <title>dumpdecrypted给App砸壳</title>
    <link href="http://www.gaoshilei.com/dumpdecrypted%E7%BB%99App%E7%A0%B8%E5%A3%B3/"/>
    <id>http://www.gaoshilei.com/dumpdecrypted%E7%BB%99App%E7%A0%B8%E5%A3%B3/</id>
    <published>2016-08-08T16:00:00.000Z</published>
    <updated>2023-10-20T08:42:38.862Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h4><blockquote><p>我们都知道从AppStore下载的应用二进制文件被苹果进行了加密处理，也就是我们俗称的<em>壳</em>，我们要想对目标App进行逆向分析，必须解密目标二进制文件，俗称<em>砸壳</em>。<br>long long ago有一种傻瓜式的砸壳方式，利用iPhoneCake源的AppCrackr进行一键砸壳，这种方式简单粗暴，省时省力，但正是因为它过于方便，导致几乎所有用户都可轻松上手，随便亵玩，所以不少用户都拿它来破解程序，这也导致了iOS越狱开发社区普遍认为这个软件助长了盗版的气焰，对iPhoneCake源进行了强烈谴责。迫于压力，iPhoneCake将AppCrackr下架。从此利用纯UI方式砸壳的行为已经走入绝路，只能利用更加geek更加niubility的方式来砸壳，这也是这篇文章介绍的主角<strong>dumpdecrypted</strong>  </p></blockquote><span id="more"></span> <p>转载请注明出处：<a href="http://www.gaoshilei.com/">来自LeonLei的博客http://www.gaoshilei.com</a>  </p><h4 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h4><ol><li>一部已经越狱的手机 <code>我这里用的是iPhone 5S; iOS 9.1</code></li><li>已经安装了OpenSSH</li><li>已经安装了<a href="http://www.cycript.org/">Cycript</a></li><li><a href="https://github.com/stefanesser/dumpdecrypted/archive/master.zip">dumpdecrypted源码</a></li></ol><h4 id="3-编译dumpdecrypted"><a href="#3-编译dumpdecrypted" class="headerlink" title="3.编译dumpdecrypted"></a>3.编译dumpdecrypted</h4><p>下载好之后将文件放到你自己的文件夹中，下面开始编译：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:~ gaoshilei$ cd /Users/gaoshilei/Desktop/reverse/dumpdecrypted  </span><br><span class="line">LeonLei-MBP:dumpdecrypted gaoshilei$ make</span><br><span class="line">`xcrun --sdk iphoneos --find gcc` -Os  -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -dynamiclib -o dumpdecrypted.dylib dumpdecrypted.o</span><br></pre></td></tr></table></figure><p>进入dumpdecrypted目录下之后，执行make命令，此时目录下会生成一个<code>dumpdecrypted.dylib</code>，这个文件生成一次即可，下次砸壳可以直接使用。</p><h4 id="4-开始砸壳"><a href="#4-开始砸壳" class="headerlink" title="4.开始砸壳"></a>4.开始砸壳</h4><h5 id="定位目标App可执行文件的位置"><a href="#定位目标App可执行文件的位置" class="headerlink" title="定位目标App可执行文件的位置"></a>定位目标App可执行文件的位置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:~ gaoshilei$ ssh root@192.168.0.115</span><br><span class="line">iPhone-5S:~ root# ps -e</span><br><span class="line">  PID TTY           TIME CMD</span><br><span class="line">    1 ??         5:23.51 /sbin/launchd</span><br><span class="line">   23 ??         0:00.81 /usr/libexec/amfid</span><br><span class="line">   34 ??         1:28.92 /usr/sbin/mediaserverd</span><br><span class="line">   36 ??         4:23.49 /usr/libexec/fseventsd</span><br><span class="line">   38 ??         1:21.05 /System/Library/PrivateFrameworks/AssistantServices.framework/assistantd</span><br><span class="line">   40 ??         0:01.13 /System/Library/PrivateFrameworks/FileProvider.framework/Support/fileproviderd</span><br><span class="line">   42 ??         1:56.46 /usr/libexec/routined</span><br><span class="line">   46 ??         0:03.34 /System/Library/PrivateFrameworks/MediaRemote.framework/Support/mediaremoted</span><br><span class="line">   48 ??         0:00.86 /usr/libexec/misd</span><br><span class="line">   50 ??         0:18.48 /System/Library/Frameworks/HealthKit.framework/healthd</span><br><span class="line">   52 ??        19:18.39 /usr/libexec/configd</span><br><span class="line">   54 ??         3:30.26 /System/Library/CoreServices/powerd.bundle/powerd</span><br><span class="line">   58 ??         0:50.73 /usr/libexec/atc</span><br><span class="line">   60 ??        13:47.50 /usr/sbin/wifid</span><br><span class="line">   ···              ···</span><br><span class="line"> 5673 ??         0:04.41 /var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat</span><br><span class="line"> 5732 ??         0:00.32 /usr/libexec/ptpd -t usb</span><br><span class="line"> 5735 ??         0:00.07 /usr/libexec/webinspectord</span><br><span class="line"> 5741 ??         0:00.18 sshd: root@ttys000 </span><br><span class="line"> 5770 ??         0:00.16 /System/Library/PrivateFrameworks/SyncedDefaults.framework/Support/syncdefaultsd</span><br><span class="line"> 5785 ??         0:00.05 /System/Library/CoreServices/CFNetworkAgent</span><br></pre></td></tr></table></figure><p>可以看到目前手机运行的进程中有微信的影子<code>/var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat</code> 我们已经找到微信可执行文件的位置</p><h5 id="目标锁定，定位到目标App的Documents位置"><a href="#目标锁定，定位到目标App的Documents位置" class="headerlink" title="目标锁定，定位到目标App的Documents位置"></a>目标锁定，定位到目标App的Documents位置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iPhone-5S:~ root# cycript -p WeChat  </span><br><span class="line">cy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]</span><br><span class="line">#file:///var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents/  </span><br></pre></td></tr></table></figure><p>执行到这里我们已经找到了微信的Documents位置，正式开始砸壳！</p><blockquote><p>这里有两种方式，一种是scp命令行拷贝<br>另一种是iFunBox工具操作  </p></blockquote><p>我这里采用的是第一种scp命令行  </p><pre><code>LeonLei-MBP:~ gaoshilei$ scp /Users/gaoshilei/Desktop/reverse/dumpdecrypted/dumpdecrypted.dylib   root@192.168.0.115:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents  dumpdecrypted.dylib                                                              100%  193KB 192.9KB/s   00:00   </code></pre><p>我们已经将dumpdecrypted.dylib拷贝到了微信沙盒的Document目录中，可以砸壳了：  </p><pre><code>iPhone-5S:~ root# cd /var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents/iPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChatmach-o decryption dumperDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.[+] detected 64bit ARM binary in memory.[+] offset to cryptid found: @0x100024ca8(from 0x100024000) = ca8[+] Found encrypted data at address 00004000 of length 45678592 bytes - type 1.[+] Opening /private/var/mobile/Containers/Bundle/Application/2A4313C7-6B36-40AF-9BEC-2C77FF1AC484/WeChat.app/WeChat for reading.[+] Reading header[+] Detecting header type[+] Executable is a plain MACH-O image[+] Opening WeChat.decrypted for writing.[+] Copying the not encrypted start of the file[+] Dumping the decrypted data into the file[+] Copying the not encrypted remainder of the file[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset ca8[+] Closing original file[+] Closing dump fileiPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root#  </code></pre><p>等待命令执行完，此时已经完成砸壳，我们看一下当前目录都有啥：  </p><pre><code>iPhone-5S:/var/mobile/Containers/Data/Application/B591D3D1-5B75-4F55-923B-C9FBF339EFE5/Documents root# ls -ototal 55272drwxr-xr-x  6 mobile      272 Aug 26 13:48 00000000000000000000000000000000drwxr-xr-x 20 mobile     1122 Oct 10 15:28 6f696a1b596ce2499419d844f90418aadrwxr-xr-x  3 mobile      136 Oct  9 10:56 CrashReport-rw-r--r--  1 mobile      310 Aug 26 13:49 Ksid-rw-r--r--  1 mobile     1036 Oct 10 13:40 LocalInfo.lstdrwxr-xr-x  5 mobile      272 Aug 26 13:49 MMResourceMgrdrwxr-xr-x  2 mobile      748 Aug 26 13:51 MMappedKV-rw-r--r--  1 mobile       15 Oct 10 13:40 SafeMode.dat-rw-r--r--  1 root   56380816 Oct 10 15:37 WeChat.decrypted-rwxr-xr-x  1 root     197528 Oct 10 15:34 dumpdecrypted.dylib-rw-r--r--  1 mobile      448 Aug 26 13:49 mmupdateinfo.archive</code></pre><p>砸好壳的微信可执行文件<code>WeChat.decrypted</code>已经生成，现在就可以把文件拷到Mac上利用IDA或者Hopper的分析了。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;我们都知道从AppStore下载的应用二进制文件被苹果进行了加密处理，也就是我们俗称的&lt;em&gt;壳&lt;/em&gt;，我们要想对目标App进行逆向分析，必须解密目标二进制文件，俗称&lt;em&gt;砸壳&lt;/em&gt;。&lt;br&gt;long long ago有一种傻瓜式的砸壳方式，利用iPhoneCake源的AppCrackr进行一键砸壳，这种方式简单粗暴，省时省力，但正是因为它过于方便，导致几乎所有用户都可轻松上手，随便亵玩，所以不少用户都拿它来破解程序，这也导致了iOS越狱开发社区普遍认为这个软件助长了盗版的气焰，对iPhoneCake源进行了强烈谴责。迫于压力，iPhoneCake将AppCrackr下架。从此利用纯UI方式砸壳的行为已经走入绝路，只能利用更加geek更加niubility的方式来砸壳，这也是这篇文章介绍的主角&lt;strong&gt;dumpdecrypted&lt;/strong&gt;  &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="iOS逆向" scheme="http://www.gaoshilei.com/categories/iOS%E9%80%86%E5%90%91/"/>
    
    
    <category term="dumpdecrypted" scheme="http://www.gaoshilei.com/tags/dumpdecrypted/"/>
    
    <category term="砸壳" scheme="http://www.gaoshilei.com/tags/%E7%A0%B8%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>Xcode编译报错Undefined symbols解决方案</title>
    <link href="http://www.gaoshilei.com/Xcode%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99Undefined%20symbols%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://www.gaoshilei.com/Xcode%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99Undefined%20symbols%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2016-03-15T16:00:00.000Z</published>
    <updated>2023-10-20T08:44:20.947Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="当我们用cocopods管理第三方类库时，经常遇到编译报错的问题："><a href="#当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：" class="headerlink" title="当我们用cocopods管理第三方类库时，经常遇到编译报错的问题："></a>当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">`Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;_OBJC_CLASS_$_AFHTTPRequestOperation&quot;, referenced from:</span><br><span class="line">      objc-class-ref in ZRAPIClient.o</span><br><span class="line">  &quot;_OBJC_CLASS_$_AFHTTPRequestSerializer&quot;, referenced from:</span><br><span class="line">      objc-class-ref in ZRAPIClient.o</span><br><span class="line">  &quot;_OBJC_CLASS_$_AFJSONResponseSerializer&quot;, referenced from:</span><br><span class="line">      objc-class-ref in ZRAPIClient.o</span><br><span class="line">  &quot;_OBJC_CLASS_$_BITHockeyManager&quot;, referenced from:</span><br><span class="line">      objc-class-ref in ZRAppDelegate.o`</span><br></pre></td></tr></table></figure><span id="more"></span><p>转载请注明出处：<a href="http://www.gaoshilei.com/">来自LeonLei的博客http://www.gaoshilei.com</a><br>网上各种说法都有，不过每个人遇到的情况可能不一样，个人总结了3个方案供参考：</p><h5 id="所连接的静态库不支持-x86-64，解决方案："><a href="#所连接的静态库不支持-x86-64，解决方案：" class="headerlink" title="所连接的静态库不支持 x86_64，解决方案："></a>所连接的静态库不支持 x86_64，解决方案：</h5><ol><li>打开Pods的<code>Build Setting</code> ，添加<code>X86_64</code>architecture</li><li>设置<code>Build Active Architectures Only</code>为<code>NO</code></li><li>Clean Pods</li><li>Build 项目</li></ol><h5 id="OtherLink-Flags问题，解决方案："><a href="#OtherLink-Flags问题，解决方案：" class="headerlink" title="OtherLink Flags问题，解决方案："></a>OtherLink Flags问题，解决方案：</h5><p>打开项目的<code>TARGETS</code> &gt; <code>Build Settings</code> &gt;<code>OTHER_LDFLAGS </code><br>添加<code> $(inherited)</code></p><h5 id="编译文件出错，解决方案："><a href="#编译文件出错，解决方案：" class="headerlink" title="编译文件出错，解决方案："></a>编译文件出错，解决方案：</h5><ol><li>找到<br><code>/Users/***YourName***/Library/Developer/Xcode/DerivedData/***YourProject***/Build/Products/Debug-iphoneos</code></li><li>这里可以使用terminal命令行打开，打开终端输入 <code>open &quot;上面的路径&quot;</code>可以直接打开目录</li><li>删除当前报错项目的编译文件，回到项目里面重新Build就不会报错了</li></ol>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：&quot;&gt;&lt;a href=&quot;#当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：&quot; class=&quot;headerlink&quot; title=&quot;当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：&quot;&gt;&lt;/a&gt;当我们用cocopods管理第三方类库时，经常遇到编译报错的问题：&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;`Undefined symbols for architecture x86_64:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;_OBJC_CLASS_$_AFHTTPRequestOperation&amp;quot;, referenced from:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      objc-class-ref in ZRAPIClient.o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;_OBJC_CLASS_$_AFHTTPRequestSerializer&amp;quot;, referenced from:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      objc-class-ref in ZRAPIClient.o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;_OBJC_CLASS_$_AFJSONResponseSerializer&amp;quot;, referenced from:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      objc-class-ref in ZRAPIClient.o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;_OBJC_CLASS_$_BITHockeyManager&amp;quot;, referenced from:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      objc-class-ref in ZRAppDelegate.o`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="跳坑指南" scheme="http://www.gaoshilei.com/categories/%E8%B7%B3%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="Xcode" scheme="http://www.gaoshilei.com/tags/Xcode/"/>
    
    <category term="Cocopods" scheme="http://www.gaoshilei.com/tags/Cocopods/"/>
    
  </entry>
  
</feed>
