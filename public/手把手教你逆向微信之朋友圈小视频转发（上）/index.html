<!DOCTYPE html><html lang="zh-CN"><head><!-- hexo injector head_begin start --><link href="/css/hexo-tag-common.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="LeonLei"><meta name="copyright" content="LeonLei"><meta name="generator" content="Hexo 6.3.0"><meta name="theme" content="hexo-theme-yun"><title>手把手教你逆向微信之朋友圈小视频转发（上） | 路是月的痕</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"www.gaoshilei.com","root":"/","title":"大石头的小站","version":"1.10.7","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="路是月的痕" type="application/atom+xml"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-1LL0D86CY9"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1LL0D86CY9');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><meta name="description" content="前言此文为逆向微信二进制文件，实现朋友圈小视频转发的教程，从最开始的汇编代码入手到最后重签名安装等操作，手把手教你玩转微信！学会之后再去逆向微信其他功能易如反掌。本篇文章由于篇幅太长分成了两篇，上篇讲解的是逆向工作，也就是怎么找到相关的函数和方法实现，下篇讲解的是怎么在非越狱机重签名安装和越狱机tweak安装的详细过程。正文的第二部分还提供了微信自动抢红包、修改微信步数的代码，这些都可以照葫芦画瓢">
<meta property="og:type" content="article">
<meta property="og:title" content="手把手教你逆向微信之朋友圈小视频转发（上）">
<meta property="og:url" content="http://www.gaoshilei.com/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E4%B9%8B%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/index.html">
<meta property="og:site_name" content="路是月的痕">
<meta property="og:description" content="前言此文为逆向微信二进制文件，实现朋友圈小视频转发的教程，从最开始的汇编代码入手到最后重签名安装等操作，手把手教你玩转微信！学会之后再去逆向微信其他功能易如反掌。本篇文章由于篇幅太长分成了两篇，上篇讲解的是逆向工作，也就是怎么找到相关的函数和方法实现，下篇讲解的是怎么在非越狱机重签名安装和越狱机tweak安装的详细过程。正文的第二部分还提供了微信自动抢红包、修改微信步数的代码，这些都可以照葫芦画瓢">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91Reveal.png">
<meta property="og:image" content="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91-%E8%BD%AC%E5%8F%91%E5%B0%8F%E8%A7%86%E9%A2%91%E4%B8%BA%E7%A9%BA.jpg">
<meta property="og:image" content="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-selRef_section%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%80%85.png">
<meta property="og:image" content="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-btnRelease.png">
<meta property="og:image" content="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91sub_10261D0AC.png">
<meta property="article:published_time" content="2016-11-09T16:00:00.000Z">
<meta property="article:modified_time" content="2023-10-20T08:42:28.416Z">
<meta property="article:author" content="LeonLei">
<meta property="article:tag" content="微信">
<meta property="article:tag" content="汇编语言">
<meta property="article:tag" content="IDA">
<meta property="article:tag" content="重签名">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91Reveal.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="LeonLei"><img width="96" loading="lazy" src="/images/avatar.png" alt="LeonLei"></a><div class="site-author-name"><a href="/about/">LeonLei</a></div><span class="site-name">路是月的痕</span><sub class="site-subtitle">代码略懂，精通LOL</sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">15</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">6</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">29</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:clipboard-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">逆向微信朋友圈（上篇）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%8E%B7%E5%8F%96%E6%9C%8B%E5%8F%8B%E5%9C%88%E7%9A%84%E5%B0%8F%E8%A7%86%E9%A2%91"><span class="toc-number">2.1.</span> <span class="toc-text">一、获取朋友圈的小视频</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">本文涉及到的工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E8%BD%AC%E5%8F%91%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">二、实现转发功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E2%80%9C%E8%B5%B0%E8%BF%9B%E6%AD%BB%E8%83%A1%E5%90%8C%E2%80%9D"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.“走进死胡同”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%89%BE%E5%88%B0%E5%B0%8F%E8%A7%86%E9%A2%91%E6%8B%8D%E6%91%84%E5%AE%8C%E6%88%90%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">（1）找到小视频拍摄完成调用的方法名称</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E2%80%9C%E5%8F%A6%E8%BE%9F%E8%B9%8A%E5%BE%84%E2%80%9D"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.“另辟蹊径”</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://www.gaoshilei.com/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E4%B9%8B%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="LeonLei"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="路是月的痕"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">手把手教你逆向微信之朋友圈小视频转发（上）<a class="post-edit-link" href="https://github.com/YunYouJun/yunyoujun.github.io/tree/hexo/source/_posts/posts/手把手教你逆向微信之朋友圈小视频转发（上）.md" target="_blank" title="编辑" rel="noopener"><span class="icon iconify" data-icon="ri:edit-line"></span></a></h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2016-11-10 00:00:00" itemprop="dateCreated datePublished" datetime="2016-11-10T00:00:00+08:00">2016-11-10</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2023-10-20 16:42:28" itemprop="dateModified" datetime="2023-10-20T16:42:28+08:00">2023-10-20</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/iOS%E9%80%86%E5%90%91/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">iOS逆向</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E5%BE%AE%E4%BF%A1/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">微信</span></a><a class="tag-item" href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">汇编语言</span></a><a class="tag-item" href="/tags/IDA/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">IDA</span></a><a class="tag-item" href="/tags/%E9%87%8D%E7%AD%BE%E5%90%8D/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">重签名</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文为逆向微信二进制文件，实现朋友圈小视频转发的教程，从最开始的汇编代码入手到最后重签名安装等操作，手把手教你玩转微信！学会之后再去逆向微信其他功能易如反掌。<br>本篇文章由于篇幅太长分成了两篇，<strong>上篇</strong>讲解的是逆向工作，也就是怎么找到相关的函数和方法实现，<strong>下篇</strong>讲解的是怎么在非越狱机重签名安装和越狱机tweak安装的详细过程。<br><strong>正文的第二部分还提供了微信自动抢红包、修改微信步数的代码，这些都可以照葫芦画瓢按照本文的套路一步步逆向找到，这里就不再赘述。</strong><br>在实践之前，需要准备好一部越狱的手机，然后将下文列出的所有工具安装好。IDA跟Reveal都是破解版，IDA的正版要2000多刀，对于这么牛逼的逆向工具确实物有所值，不过不是专门研究逆向的公司也没必要用正版的，下个Windows的破解版就好，Mac上暂时没找到。Mac上可以用hopper代替IDA，也是一款很牛逼的逆向工具。废话不多说，正式开始吧！</p>
<span id="more"></span>
<p>转载请注明出处：<a href="http://www.gaoshilei.com/">来自LeonLei的博客http://www.gaoshilei.com</a>  </p>
<h1 id="逆向微信朋友圈（上篇）"><a href="#逆向微信朋友圈（上篇）" class="headerlink" title="逆向微信朋友圈（上篇）"></a>逆向微信朋友圈（上篇）</h1><h2 id="一、获取朋友圈的小视频"><a href="#一、获取朋友圈的小视频" class="headerlink" title="一、获取朋友圈的小视频"></a>一、获取朋友圈的小视频</h2><blockquote>
<p>注意：本文逆向的微信的二进制文件为6.3.28版本，如果是不同的微信版本，二进制文件中的基地址也不相同</p>
</blockquote>
<h4 id="本文涉及到的工具"><a href="#本文涉及到的工具" class="headerlink" title="本文涉及到的工具"></a>本文涉及到的工具</h4><ol>
<li><a target="_blank" rel="noopener" href="http://www.cycript.org/">cycript</a> </li>
<li>LLDB与debugserver（Xcode自带）</li>
<li>OpenSSH</li>
<li>IDA</li>
<li>Reveal</li>
<li><a target="_blank" rel="noopener" href="https://github.com/theos/theos">theos</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cydiasubstrate.com/">CydiaSubstrate</a></li>
<li>iOSOpenDev</li>
<li>ideviceinstaller</li>
<li>tcprelay（本地端口映射，USB连接SSH，不映射可通过WiFi连接） </li>
<li><a target="_blank" rel="noopener" href="https://github.com/stefanesser/dumpdecrypted">dumpdecrypted</a></li>
<li><a target="_blank" rel="noopener" href="http://stevenygard.com/projects/class-dump/">class-dump</a> </li>
<li><a target="_blank" rel="noopener" href="https://github.com/DanTheMan827/ios-app-signer">iOS App Signer</a></li>
<li>编译好的<a target="_blank" rel="noopener" href="https://github.com/gaoshilei/yololib">yololib</a></li>
</ol>
<p><strong>逆向环境为MacOS	+	iPhone5S 9.1越狱机</strong><br>先用dumpdecrypted给微信砸壳（不会的请我写的看<a href="http://www.gaoshilei.com/2016/08/08/dumpdecrypted%E7%BB%99App%E7%A0%B8%E5%A3%B3/">这篇教程</a>），获得一个WeChat.decrypted文件，先把这个文件扔到IDA中分析（60MB左右的二进制文件，IDA差不多40分钟才能分析完），用class-dump导出所有头文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:~ gaoshilei$ class-dump -S -s -H /Users/gaoshilei/Desktop/reverse/binary_for_class-dump/WeChat.decrypted -o /Users/gaoshilei/Desktop/reverse/binary_for_class-dump/class-Header/WeChat</span><br></pre></td></tr></table></figure>

<p>我滴个亲娘！一共有8000个头文件，微信果然工程量浩大！稳定一下情绪，理一理思路继续搞。要取得小视频的下载链接，找到播放视频的View，顺藤摸瓜就能找到小视频的URL。用Reveal查看小视频的播放窗口<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91Reveal.png" alt="Reveal" loading="lazy"><br>可以看出来WCContentItemViewTemplateNewSigh这个对象是小视频的播放窗口，它的subView有WCSightView，SightView、SightPlayerView，这几个类就是我们的切入点。<br>保存视频到favorite的时候是长按视频弹出选项的，那么在WCContentItemViewTemplateNewSight这个类里面可能有手势相关的方法，去刚才导出的头文件中找线索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)onLongTouch;</span><br><span class="line">- (void)onLongPressedWCSight:(id)arg1;</span><br><span class="line">- (void)onLongPressedWCSightFullScreenWindow:(id)arg1;</span><br></pre></td></tr></table></figure>

<p>这几个方法跟长按手势相关，再去IDA中找到这些函数，逐个查看。onLongPressedWCSight和onLongPressedWCSightFullScreenWindow都比较简单，onLongTouch比较长，而且发现了内部调用了方法Favorites_Add，因为长按视频的时候出来一个选项就是Favorites，并且我看到这个函数调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADRP            X8, #selRef_sightVideoPath@PAGE</span><br><span class="line">LDR             X1, [X8,#selRef_sightVideoPath@PAGEOFF]</span><br></pre></td></tr></table></figure>

<p>这里拿到了小视频的地址，可以推测这个函数跟收藏有关，下面打断点测试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) im li -o -f</span><br><span class="line">[  0] 0x000000000003c000 /var/mobile/Containers/Bundle/Application/2F1D52EC-C57E-4F95-B715-EF04351232E8/WeChat.app/WeChat(0x000000010003c000)</span><br></pre></td></tr></table></figure>

<p>可以看到WeChat的ASLR为0x3c000，在IDA查找到这三个函数的基地址，分别下断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0x1020D3A10+0x3c000</span><br><span class="line">Breakpoint 1: where = WeChat`___lldb_unnamed_symbol110094$$WeChat + 28, address = 0x000000010210fa10</span><br><span class="line">(lldb) br s -a 0x1020D3370+0x3c000</span><br><span class="line">Breakpoint 2: where = WeChat`___lldb_unnamed_symbol110091$$WeChat + 8, address = 0x000000010210f370</span><br><span class="line">(lldb) br s -a 0x1020D33E4+0x3c000</span><br><span class="line">Breakpoint 3: where = WeChat`___lldb_unnamed_symbol110092$$WeChat + 12, address = 0x000000010210f3e4</span><br></pre></td></tr></table></figure>

<p>回到微信里面长按小视频，看断点触发情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Process 3721 stopped</span><br><span class="line">* thread #1: tid = 0x658fc, 0x000000010210f370 WeChat`___lldb_unnamed_symbol110091$$WeChat + 8, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 2.1</span><br><span class="line">    frame #0: 0x000000010210f370 WeChat`___lldb_unnamed_symbol110091$$WeChat + 8</span><br><span class="line">WeChat`___lldb_unnamed_symbol110091$$WeChat:</span><br><span class="line">-&gt;  0x10210f370 &lt;+8&gt;:  add    x29, sp, #16              ; =16 </span><br><span class="line">    0x10210f374 &lt;+12&gt;: mov    x19, x0</span><br><span class="line">    0x10210f378 &lt;+16&gt;: adrp   x8, 4968</span><br><span class="line">    0x10210f37c &lt;+20&gt;: ldr    x0, [x8, #744]</span><br><span class="line">(lldb) c</span><br><span class="line">Process 3721 resuming</span><br><span class="line">Process 3721 stopped</span><br><span class="line">* thread #1: tid = 0x658fc, 0x000000010210fa10 WeChat`___lldb_unnamed_symbol110094$$WeChat + 28, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1</span><br><span class="line">    frame #0: 0x000000010210fa10 WeChat`___lldb_unnamed_symbol110094$$WeChat + 28</span><br><span class="line">WeChat`___lldb_unnamed_symbol110094$$WeChat:</span><br><span class="line">-&gt;  0x10210fa10 &lt;+28&gt;: add    x29, sp, #96              ; =96 </span><br><span class="line">    0x10210fa14 &lt;+32&gt;: sub    sp, sp, #96               ; =96 </span><br><span class="line">    0x10210fa18 &lt;+36&gt;: mov    x19, x0</span><br><span class="line">    0x10210fa1c &lt;+40&gt;: adrp   x8, 4863</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>发现断点2先被触发，接着触发断点1，后面断点2和1又各触发了1次，断点3一直很安静。可以排除onLongPressedWCSightFullScreenWindow与收藏小视频的联系。小视频的踪影就要在剩下的两个方法中寻找了。通过V找到C，顺藤摸瓜找到M屡试不爽！用cycript注入WeChat，拿到播放小视频的view所在的Controller。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0x138c18030 nextResponder]</span><br><span class="line">#&quot;&lt;WCTimeLineCellView: 0x138c34620; frame = (0 0; 319 249); tag = 1048577; layer = &lt;CALayer: 0x138362ba0&gt;&gt;&quot;</span><br><span class="line">cy# [#0x138c34620 nextResponder]</span><br><span class="line">#&quot;&lt;UITableViewCellContentView: 0x138223c70; frame = (0 0; 320 256); gestureRecognizers = &lt;NSArray: 0x1384ec480&gt;; layer = &lt;CALayer: 0x138081dc0&gt;&gt;&quot;</span><br><span class="line">cy# [#0x138223c70 nextResponder]</span><br><span class="line">#&quot;&lt;MMTableViewCell: 0x138c9f930; baseClass = UITableViewCell; frame = (0 307; 320 256); autoresize = W; layer = &lt;CALayer: 0x1382dcd10&gt;&gt;&quot;</span><br><span class="line">cy# [#0x138c9f930 nextResponder]</span><br><span class="line">#&quot;&lt;UITableViewWrapperView: 0x137b57800; frame = (0 0; 320 504); gestureRecognizers = &lt;NSArray: 0x1383db660&gt;; layer = &lt;CALayer: 0x138af20c0&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;320, 504&#125;&gt;&quot;</span><br><span class="line">cy# [#0x137b57800 nextResponder]</span><br><span class="line">#&quot;&lt;MMTableView: 0x137b8ae00; baseClass = UITableView; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x138adb590&gt;; layer = &lt;CALayer: 0x138956890&gt;; contentOffset: &#123;0, 99.5&#125;; contentSize: &#123;320, 3193&#125;&gt;&quot;</span><br><span class="line">cy# [#0x137b8ae00 nextResponder]</span><br><span class="line">#&quot;&lt;UIView: 0x138ade5c0; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x138ac9990&gt;&gt;&quot;</span><br><span class="line">cy# [#0x138ade5c0 nextResponder]</span><br><span class="line">#&quot;&lt;WCTimeLineViewController: 0x1379eb000&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>通过响应者链条找到<br>WCContentItemViewTemplateNewSight所属的Controller为WCTimeLineViewController。在这个类的头文件中并没有发现有价值的线索，不过我们注意到小视频所在的view是属于MMTableVIewCell的（见上图Reveal分析图），这是每一个iOS最熟悉的TableView，cell的数据是通过UITableViewDataSource的代理方法<code>- tableView:cellForRowAtIndexPath:</code>赋值的，通过这个方法肯定能知道到M的影子。在IDA中找到<code>[WCTimeLineViewController tableView:cellForRowAtIndexPath:]</code>,定位到基地址0x10128B6B0位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__text:000000010128B6B0     ADRP     X8, #selRef_genNormalCell_indexPath_@PAGE</span><br></pre></td></tr></table></figure>

<p>这里的函数是WCTimeLineViewController中生成cell的方法，除了这个方法在这个类中还有另外三个生成cell的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)genABTestTipCell:(id)arg1 indexPath:(id)arg2;</span><br><span class="line">- (void)genRedHeartCell:(id)arg1 indexPath:(id)arg2;</span><br><span class="line">- (void)genUploadFailCell:(id)arg1 indexPath:(id)arg2;</span><br></pre></td></tr></table></figure>

<p>通过字面意思可以猜测出normal这个应该是生成小视频cell的方法。继续在IDA中寻找线索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__text:0000000101287CC8     ADRP     X8, #selRef_getTimelineDataItemOfIndex_@PAGE</span><br></pre></td></tr></table></figure>

<p>在<code>genNormalCell:IndexPath:</code>方法中发现上面这个方法，可以大胆猜想这个方法是获取TimeLine（朋友圈）数据的方法，那小视频的数据肯定也是通过这个方法获取的，并且IDA可以看到这个方法中调用一个叫做<code>selRef_getTimelineDataItemOfIndex_</code>的方法，获取DataItem貌似就是cell的数据源啊！接下来用LLDB下断点验证猜想。<br>通过IDA可以找到这个方法对应的基地址为：0x101287CE4，先打印正在运行WeChat的ASLR偏移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:~ gaoshilei$ lldb</span><br><span class="line">(lldb) process connect connect://localhost:1234</span><br><span class="line">(lldb) im li -o -f </span><br><span class="line">[0] 0x0000000000050000 /var/mobile/Containers/Bundle/Application/2DCE8F30-9B6B-4652-901C-37EB1FF2A40D/WeChat.app/WeChat(0x0000000100050000)</span><br></pre></td></tr></table></figure>

<p>所以我们下断点的位置是0x50000+0x101287CE4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0x50000+0x101287CE4</span><br><span class="line">Breakpoint 1: where = WeChat`___lldb_unnamed_symbol63721$$WeChat + 252, address = 0x00000001012d7ce4</span><br></pre></td></tr></table></figure>

<p>打印x0的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x0</span><br><span class="line">Class name: WCDataItem, addr: 0x15f5f03b0</span><br><span class="line">tid: 12393001887435993280</span><br><span class="line">username: wxid_z8twcz4o18fg12</span><br><span class="line">createtime: 1477360950</span><br><span class="line">commentUsers: (</span><br><span class="line">)</span><br><span class="line">contentObj: &lt;WCContentItem: 0x15f57d000&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>得到一个WCDataItem的对象，这里x0的值就是<code>selRef_getTimelineDataItemOfIndex_</code>执行完的返回值，然后把x0的值改掉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register write $x0 0</span><br><span class="line">(lldb) c</span><br></pre></td></tr></table></figure>

<p>此时会发现我们要刷新的那条小视频内容全部为空<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91-%E8%BD%AC%E5%8F%91%E5%B0%8F%E8%A7%86%E9%A2%91%E4%B8%BA%E7%A9%BA.jpg" alt="小视频内容为空" loading="lazy"><br>到这里已经找到了小视频的源数据获取方法，问题是我们怎么拿到这个WCDataItem呢？继续看IDA分析函数的调用情况：  </p>
<blockquote>
<p>WCTimeLineViewController - (void)genNormalCell:(id) indexPath:(id)  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">__text:0000000101287BCC                 STP             X28, X27, [SP,#var_60]!</span><br><span class="line">__text:0000000101287BD0                 STP             X26, X25, [SP,#0x60+var_50]</span><br><span class="line">__text:0000000101287BD4                 STP             X24, X23, [SP,#0x60+var_40]</span><br><span class="line">__text:0000000101287BD8                 STP             X22, X21, [SP,#0x60+var_30]</span><br><span class="line">__text:0000000101287BDC                 STP             X20, X19, [SP,#0x60+var_20]</span><br><span class="line">__text:0000000101287BE0                 STP             X29, X30, [SP,#0x60+var_10]</span><br><span class="line">__text:0000000101287BE4                 ADD             X29, SP, #0x60+var_10</span><br><span class="line">__text:0000000101287BE8                 SUB             SP, SP, #0x80</span><br><span class="line">__text:0000000101287BEC                 MOV             X19, X3</span><br><span class="line">__text:0000000101287BF0                 MOV             X22, X0</span><br><span class="line">__text:0000000101287BF4                 MOV             W25, #0x100000</span><br><span class="line">__text:0000000101287BF8                 MOVK            W25, #1</span><br><span class="line">__text:0000000101287BFC                 MOV             X0, X2</span><br><span class="line">__text:0000000101287C00                 BL              _objc_retain</span><br><span class="line">__text:0000000101287C04                 MOV             X28, X0</span><br><span class="line">__text:0000000101287C08                 MOV             X0, X19</span><br><span class="line">__text:0000000101287C0C                 BL              _objc_retain</span><br><span class="line">__text:0000000101287C10                 MOV             X20, X0</span><br><span class="line">__text:0000000101287C14                 STR             X20, [SP,#0xE0+var_98]</span><br><span class="line">__text:0000000101287C18                 ADRP            X8, #selRef_row@PAGE</span><br><span class="line">__text:0000000101287C1C                 LDR             X1, [X8,#selRef_row@PAGEOFF]</span><br><span class="line">__text:0000000101287C20                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287C24                 MOV             X26, X0</span><br><span class="line">__text:0000000101287C28                 ADRP            X8, #selRef_section@PAGE</span><br><span class="line">__text:0000000101287C2C                 LDR             X19, [X8,#selRef_section@PAGEOFF]</span><br><span class="line">__text:0000000101287C30                 MOV             X0, X20</span><br><span class="line">__text:0000000101287C34                 MOV             X1, X19</span><br><span class="line">__text:0000000101287C38                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287C3C                 STR             X0, [SP,#0xE0+var_A8]</span><br><span class="line">__text:0000000101287C40                 MOV             X0, X20</span><br><span class="line">__text:0000000101287C44                 MOV             X1, X19</span><br><span class="line">__text:0000000101287C48                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287C4C                 MOV             X2, X0</span><br><span class="line">__text:0000000101287C50                 ADRP            X8, #selRef_calcDataItemIndex_@PAGE</span><br><span class="line">__text:0000000101287C54                 LDR             X1, [X8,#selRef_calcDataItemIndex_@PAGEOFF]</span><br><span class="line">__text:0000000101287C58                 MOV             X0, X22</span><br><span class="line">__text:0000000101287C5C                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287C60                 MOV             X21, X0</span><br><span class="line">__text:0000000101287C64                 STR             X21, [SP,#0xE0+var_C0]</span><br><span class="line">__text:0000000101287C68                 ADRP            X8, #classRef_MMServiceCenter@PAGE</span><br><span class="line">__text:0000000101287C6C                 LDR             X0, [X8,#classRef_MMServiceCenter@PAGEOFF]</span><br><span class="line">__text:0000000101287C70                 ADRP            X8, #selRef_defaultCenter@PAGE</span><br><span class="line">__text:0000000101287C74                 LDR             X1, [X8,#selRef_defaultCenter@PAGEOFF]</span><br><span class="line">__text:0000000101287C78                 STR             X1, [SP,#0xE0+var_B8]</span><br><span class="line">__text:0000000101287C7C                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287C80                 MOV             X29, X29</span><br><span class="line">__text:0000000101287C84                 BL              _objc_retainAutoreleasedReturnValue</span><br><span class="line">__text:0000000101287C88                 MOV             X19, X0</span><br><span class="line">__text:0000000101287C8C                 ADRP            X8, #classRef_WCFacade@PAGE</span><br><span class="line">__text:0000000101287C90                 LDR             X0, [X8,#classRef_WCFacade@PAGEOFF]</span><br><span class="line">__text:0000000101287C94                 ADRP            X8, #selRef_class@PAGE</span><br><span class="line">__text:0000000101287C98                 LDR             X1, [X8,#selRef_class@PAGEOFF]</span><br><span class="line">__text:0000000101287C9C                 STR             X1, [SP,#0xE0+var_B0]</span><br><span class="line">__text:0000000101287CA0                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287CA4                 MOV             X2, X0</span><br><span class="line">__text:0000000101287CA8                 ADRP            X8, #selRef_getService_@PAGE</span><br><span class="line">__text:0000000101287CAC                 LDR             X1, [X8,#selRef_getService_@PAGEOFF]</span><br><span class="line">__text:0000000101287CB0                 STR             X1, [SP,#0xE0+var_A0]</span><br><span class="line">__text:0000000101287CB4                 MOV             X0, X19</span><br><span class="line">__text:0000000101287CB8                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287CBC                 MOV             X29, X29</span><br><span class="line">__text:0000000101287CC0                 BL              _objc_retainAutoreleasedReturnValue</span><br><span class="line">__text:0000000101287CC4                 MOV             X20, X0</span><br><span class="line">__text:0000000101287CC8                 ADRP            X8, #selRef_getTimelineDataItemOfIndex_@PAGE</span><br><span class="line">__text:0000000101287CCC                 LDR             X1, [X8,#selRef_getTimelineDataItemOfIndex_@PAGEOFF]</span><br><span class="line">__text:0000000101287CD0                 STR             X1, [SP,#0xE0+var_C8]</span><br><span class="line">__text:0000000101287CD4                 MOV             X2, X21</span><br><span class="line">__text:0000000101287CD8                 BL              _objc_msgSend</span><br><span class="line">__text:0000000101287CDC                 MOV             X29, X29</span><br><span class="line">__text:0000000101287CE0                 BL              _objc_retainAutoreleasedReturnValue</span><br><span class="line">__text:0000000101287CE4                 MOV             X21, X0</span><br><span class="line">__text:0000000101287CE8                 MOV             X0, X20</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><code>selRef_getTimelineDataItemOfIndex_ </code>传入的参数是x2，可以看到传值给x2的x21是函数<code>selRef_calcDataItemIndex_ </code>的返回值，是一个unsigned long数据类型。继续分析，<code>selRef_getTimelineDataItemOfIndex_ </code>函数的调用者是上一步<code>selRef_getService_ </code>的返回值，经过断点分析发现是一个<code>WCFacade</code>对象。整理一下<code>selRef_getTimelineDataItemOfIndex_ </code>的调用：<br><strong>调用者是<code>selRef_getService_ </code>的返回值；参数是<code>selRef_calcDataItemIndex_ </code>的返回值</strong><br>下面把目光转向那两个函数，用相同的原理分析它们各自怎么实现调用<br>1.	先看<code>selRef_getService_</code>：<br>在0x101287CB4这个位置可以发现，这个函数的调用者是从通过x19 MOV的，打印x19发现是一个<code>MMServiceCenter</code>对象，往上找x19是在0x101287C88这个位置赋值的，结果很清晰x19是<code>[MMServiceCenter defaultCenter]</code>的返回值。<br>在0x101287CA4位置可以找到传入的参数x2，往上分析可以看出来它的参数是<code>[WCFacade class]</code>的返回值。<br>2.	接着找<code>selRef_calcDataItemIndex_ </code>：<br>在0x101287C58的位置找到它的调用者x0，x0通过x22赋值，继续向上寻找，发现在最上面0x101287BF0的位置，x22是x0赋值的，一开始的x0就是<code>WCTimeLineViewController</code>自身。<br>在0x101287C4C位置发现传入的参数来自x2,x2是通过上一步<code>selRef_section</code>函数的返回值x0赋值的，在0x101287C30位置可以发现<code>selRef_section</code>函数的调用者是x20赋值的，如下图所示，最终找到<code>selRef_section</code>的调用者是x3<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-selRef_section%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%80%85.png" alt="selRef_section函数的调用者" loading="lazy"><br>x3就是函数<code> WCTimeLineViewController - (void)genNormalCell:(id) indexPath:(id)</code>的第二个参数indexPath,，所以<code>selRef_calcDataItemIndex_ </code>的参数是<code>[IndexPath section]</code>。<br>对上面的分析结果做个梳理：<br>因此<code>getTimelineDataItemOfIndex:</code>的调用者可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[MMServiceCenter defaultCenter] getService:[WCFacade class]]</span><br></pre></td></tr></table></figure>

<p>来获得,它的参数可以通过下面的函数获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[WCTimeLineViewController calcDataItemIndex:[indexPath section]]</span><br></pre></td></tr></table></figure>

<p>总感觉还少点什么？indexPath我们还没拿到呢！下一步就是拿到indexPath,这个就比较简单了，因为我们位于<code>[WCContentItemViewTemplateNewSight onLongTouch]</code>中，所以可以通过<code>[self nextResponder]</code>依次拿到MMTableViewCell、MMTableView和WCTimeLineViewController，再通过<code>[MMTableView indexPathForCell:MMTableViewCell]</code>拿到indexPath。<br>做完这些，已经拿到WCDataItem对象，接下来的重点要放在WCDataItem上，最终要获取我们要的小视频。到这个类的头文件中找线索，因为视频是下载完成后才能播放的，所以这里应该拿到了视频的路径，所以要注意url和path相关的属性或方法，然后找到下面这几个嫌疑对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property(retain, nonatomic) NSString *sourceUrl2; </span><br><span class="line">@property(retain, nonatomic) NSString *sourceUrl; </span><br><span class="line">- (id)descriptionForKeyPaths;</span><br><span class="line">- (id)keyPaths;</span><br></pre></td></tr></table></figure>

<p>回到LLDB中，用断点打印这些值，看看有什么。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [$x0 keyPaths]</span><br><span class="line">&lt;__NSArrayI 0x15f74e9d0&gt;(</span><br><span class="line">	tid,</span><br><span class="line">	username,</span><br><span class="line">	createtime,</span><br><span class="line">	commentUsers,</span><br><span class="line">	contentObj</span><br><span class="line">)</span><br><span class="line">(lldb) po [$x0 descriptionForKeyPaths]</span><br><span class="line">Class name: WCDataItem, addr: 0x15f5f03b0</span><br><span class="line">tid: 12393001887435993280</span><br><span class="line">username: wxid_z8twcz4o18fg12</span><br><span class="line">createtime: 1477360950</span><br><span class="line">commentUsers: (</span><br><span class="line">)</span><br><span class="line">contentObj: &lt;WCContentItem: 0x15f57d000&gt;</span><br><span class="line">(lldb) po [$x0 sourceUrl]</span><br><span class="line"> nil</span><br><span class="line">(lldb) po [$x0 sourceUrl2]</span><br><span class="line"> nil</span><br></pre></td></tr></table></figure>

<p>并没有什么有价值的线索，不过注意到WCDataItem里面有一个WCContentItem，看来只能从这儿入手了，去看一下头文件吧！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property(retain, nonatomic) NSString *linkUrl; </span><br><span class="line">@property(retain, nonatomic) NSString *linkUrl2; </span><br><span class="line">@property(retain, nonatomic) NSMutableArray *mediaList;</span><br></pre></td></tr></table></figure>

<p>在LLDB打印出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [[$x0 valueForKey:@&quot;contentObj&quot;] linkUrl]</span><br><span class="line">https://support.weixin.qq.com/cgi-bin/mmsupport-bin/readtemplate?t=page/common_page__upgrade&amp;v=1</span><br><span class="line">(lldb) po [[$x0 valueForKey:@&quot;contentObj&quot;] linkUrl2]</span><br><span class="line"> nil</span><br><span class="line">(lldb) po [[$x0 valueForKey:@&quot;contentObj&quot;] mediaList]</span><br><span class="line">&lt;__NSArrayM 0x15f985e10&gt;(</span><br><span class="line">&lt;WCMediaItem: 0x15dfebdf0&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>mediaList数组里面有一个WCMediaItem对象，Media一般用来表示视频和音频，大胆猜测就是它了！赶紧找到头文件搜索一遍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@property(retain, nonatomic) WCUrl *dataUrl;</span><br><span class="line">- (id)pathForData;</span><br><span class="line">- (id)pathForSightData;</span><br><span class="line">- (id)pathForTempAttachVideoData;</span><br><span class="line">- (id)videoStreamForData;</span><br></pre></td></tr></table></figure>
<p>上面这些属性和方法中<code>pathForSightData</code>是最有可能拿到小视频路径的，继续验证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] dataUrl]</span><br><span class="line">type[1], url[http://vweixinf.tc.qq.com/102/20202/snsvideodownload?filekey=30270201010420301e020166040253480410d14adcddf086f4e131d11a5b1cca1bdf0203039fa00400&amp;bizid=1023&amp;hy=SH&amp;fileparam=302c0201010425302302040fde55e20204580ebd3602024eea02031e8d7d02030f42400204d970370a0201000400], enckey[0], encIdx[-1], token[]</span><br><span class="line">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] pathForData]</span><br><span class="line">/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45</span><br><span class="line">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] pathForSightData]</span><br><span class="line">/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45.mp4</span><br><span class="line">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] pathForAttachVideoData]</span><br><span class="line"> nil</span><br><span class="line">(lldb) po [[[[$x0 valueForKey:@&quot;contentObj&quot;] mediaList] lastObject] videoStreamForData]</span><br><span class="line"> nil</span><br></pre></td></tr></table></figure>

<p>拿到小视频的网络url和本地路径了！这里可以用iFunBox或者scp从沙盒拷贝这个文件看看是不是这个cell应该播放的小视频。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LeonLei-MBP:~ gaoshilei$ scp root@192.168.0.115:/var/mobile/Containers/Data/Application/7C3A6322-1F57-49A0-ACDE-6EF0ED74D137/Library/WechatPrivate/6f696a1b596ce2499419d844f90418aa/wc/media/5/53/8fb0cdd77208de5b56169fb3458b45.mp4 Desktop/</span><br><span class="line">8fb0cdd77208de5b56169fb3458b45.mp4                100%  232KB 231.9KB/s   00:00    </span><br></pre></td></tr></table></figure>

<p>用QuickTime打开发现果然是我们要寻找的小视频。再验证一下url是否正确，把上面打印的dataUrl在浏览器中打开，发现也是这个小视频。分析这个类可以得出下面的结论：  </p>
<ul>
<li><strong>dataUrl：</strong>小视频的网络url</li>
<li><strong>pathForData：</strong>小视频的本地路径</li>
<li><strong>pathForSightData：</strong>小视频的本地路径（不带后缀）</li>
</ul>
<p>至此小视频的路径和取得方式分析已经完成，要实现转发还要继续分析微信的朋友圈发布。</p>
<h2 id="二、实现转发功能"><a href="#二、实现转发功能" class="headerlink" title="二、实现转发功能"></a>二、实现转发功能</h2><h3 id="1-“走进死胡同”"><a href="#1-“走进死胡同”" class="headerlink" title="1.“走进死胡同”"></a>1.“走进死胡同”</h3><blockquote>
<p>这节是我在找小视频转发功能时走的弯路，扒到最后并没有找到实现方法，不过也提供了一些逆向中常用的思路和方法，不想看的可以跳到第二节。  </p>
</blockquote>
<h4 id="（1）找到小视频拍摄完成调用的方法名称"><a href="#（1）找到小视频拍摄完成调用的方法名称" class="headerlink" title="（1）找到小视频拍摄完成调用的方法名称"></a>（1）找到小视频拍摄完成调用的方法名称</h4><p>打开小视频的拍摄界面，用cycript注入，我们要找到发布小视频的方法是哪个，然后查看当前的窗口有哪些window（因为小视频的拍摄并不是在UIApplication的keyWindow中进行的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cy# [UIApp windows].toString()</span><br><span class="line">(</span><br><span class="line">    &quot;&lt;iConsoleWindow: 0x125f75e20; baseClass = UIWindow; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x125f77b70&gt;; layer = &lt;UIWindowLayer: 0x125df4810&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;SvrErrorTipWindow: 0x127414d40; baseClass = UIWindow; frame = (0 64; 320 45); hidden = YES; gestureRecognizers = &lt;NSArray: 0x12740d930&gt;; layer = &lt;UIWindowLayer: 0x1274030b0&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;MMUIWindow: 0x127796440; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x1278083c0&gt;; layer = &lt;UIWindowLayer: 0x127796750&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;UITextEffectsWindow: 0x1270e0d40; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = &lt;UIWindowLayer: 0x1270b4ba0&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;NewYearActionSheet: 0x127797e10; baseClass = UIWindow; frame = (0 0; 320 568); hidden = YES; userInteractionEnabled = NO; layer = &lt;UIWindowLayer: 0x1277d5490&gt;&gt;&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>发现当前页面一共有5个window，其中MMUIWindow是小视频拍摄所在的window，打印它的UI树状结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0x127796440 recursiveDescription]</span><br></pre></td></tr></table></figure>

<p>打印结果比较长，不贴了。找到这个按钮是拍摄小视频的按钮</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|    |    |    |    |    | &lt;UIButton: 0x1277a9d70; frame = (89.5 368.827; 141 141); opaque = NO; gestureRecognizers = &lt;NSArray: 0x1277aaeb0&gt;; layer = &lt;CALayer: 0x1277a9600&gt;&gt;</span><br><span class="line">|    |    |    |    |    |    | &lt;UIView: 0x1277aa0a0; frame = (0 0; 141 141); userInteractionEnabled = NO; tag = 252707333; layer = &lt;CALayer: 0x1277aa210&gt;&gt;</span><br><span class="line">|    |    |    |    |    |    |    | &lt;UIImageView: 0x1277aa2e0; frame = (0 0; 141 141); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1277aa490&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>然后执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0x1277a9d70 setHidden:YES]</span><br></pre></td></tr></table></figure>

<p>发现拍摄的按钮消失了，验证了我的猜想。寻找按钮的响应事件，可以通过target来寻找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0x1277a9d70 allTargets]</span><br><span class="line">[NSSet setWithArray:@[#&quot;&lt;MainFrameSightViewController: 0x1269a4600&gt;&quot;]]]</span><br><span class="line">cy# [#0x1277a9d70 allControlEvents]</span><br><span class="line">193</span><br><span class="line">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:193]</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>发现按钮并没有对应的action，这就奇怪了！UIButton必须要有target和action，不然这个Button不能响应事件。我们试试其他的ControlEvent</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchDown]</span><br><span class="line">@[&quot;btnPress&quot;]</span><br><span class="line">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchUpOutside]</span><br><span class="line">@[&quot;btnRelease&quot;]</span><br><span class="line">cy# [#0x1277a9d70 actionsForTarget:#0x1269a4600 forControlEvent:UIControlEventTouchUpInside]</span><br><span class="line">@[&quot;btnRelease&quot;]</span><br></pre></td></tr></table></figure>

<p>结果发现这三个ContrlEvent有对应的action，我们再看看这三个枚举的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef enum UIControlEvents : NSUInteger &#123;</span><br><span class="line">    UIControlEventTouchDown = 1 &lt;&lt;  0,</span><br><span class="line">    UIControlEventTouchDownRepeat = 1 &lt;&lt;  1,</span><br><span class="line">    UIControlEventTouchDragInside = 1 &lt;&lt;  2,</span><br><span class="line">    UIControlEventTouchDragOutside = 1 &lt;&lt;  3,</span><br><span class="line">    UIControlEventTouchDragEnter = 1 &lt;&lt;  4,</span><br><span class="line">    UIControlEventTouchDragExit = 1 &lt;&lt;  5,</span><br><span class="line">    UIControlEventTouchUpInside = 1 &lt;&lt;  6,</span><br><span class="line">    UIControlEventTouchUpOutside = 1 &lt;&lt;  7,</span><br><span class="line">    UIControlEventTouchCancel = 1 &lt;&lt;  8,</span><br><span class="line">	......</span><br><span class="line">&#125; UIControlEvents;</span><br></pre></td></tr></table></figure>

<p>可以看出来UIControlEventTouchDown对应1，UIControlEventTouchUpInside对应128，UIControlEventTouchUpOutside对应64，三者相加正好193！原来调用<code>[#0x1277a9d70 allControlEvents]</code>的时候返回的应该是枚举，有多个枚举则把它们的值相加，是不是略坑？我也是这样觉得的！刚才我们把三种ControlEvent对应的action都打印出来了，继续LLDB+IDA进行动态分析。<br>####	（2）找到小视频拍摄完成跳转到发布界面的方法<br>因为要找到小视频发布的方法，所以对应的<code>btnPress</code>函数我们并不关心，把重点放在<code>btnRelease</code>上面，拍摄按钮松开后就会调用的方法。在IDA中找到这个方法<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91-btnRelease.png" alt="MainFrameSightViewController - (void)btnRelease" loading="lazy"><br>找到之后下个断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0xac000+0x10209369C</span><br><span class="line">Breakpoint 4: where = WeChat`___lldb_unnamed_symbol108894$$WeChat + 32, address = 0x000000010213f69c</span><br><span class="line">Process 3813 stopped</span><br><span class="line">* thread #1: tid = 0xf1ef0, 0x000000010213f69c WeChat`___lldb_unnamed_symbol108894$$WeChat + 32, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 4.1</span><br><span class="line">    frame #0: 0x000000010213f69c WeChat`___lldb_unnamed_symbol108894$$WeChat + 32</span><br><span class="line">WeChat`___lldb_unnamed_symbol108894$$WeChat:</span><br><span class="line">-&gt;  0x10213f69c &lt;+32&gt;: bl     0x1028d0b60               ; symbol stub for: objc_msgSend</span><br><span class="line">    0x10213f6a0 &lt;+36&gt;: cmp    w0, #2                    ; =2 </span><br><span class="line">    0x10213f6a4 &lt;+40&gt;: b.ne   0x10213f6dc               ; &lt;+96&gt;</span><br><span class="line">    0x10213f6a8 &lt;+44&gt;: adrp   x8, 5489</span><br></pre></td></tr></table></figure>

<p>用手机拍摄小视频然后松开，触发了断点，说明我们的猜想是正确的。继续分析发现代码是从上图的右边走的，看了一下没有什么方法是跳转到发布视频的，不过仔细看一下有一个block，是系统的延时block，位置在0x102093760。然后我们跟着断点进去，在0x1028255A0跳转到x16所存的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(lldb) si</span><br><span class="line">Process 3873 stopped</span><br><span class="line">* thread #1: tid = 0xf62c4, 0x00000001028d9598 WeChat`dispatch_after, queue = &#x27;com.apple.main-thread&#x27;, stop reason = instruction step into</span><br><span class="line">    frame #0: 0x00000001028d9598 WeChat`dispatch_after</span><br><span class="line">WeChat`dispatch_after:</span><br><span class="line">-&gt;  0x1028d9598 &lt;+0&gt;: adrp   x16, 1655</span><br><span class="line">    0x1028d959c &lt;+4&gt;: ldr    x16, [x16, #1056]</span><br><span class="line">    0x1028d95a0 &lt;+8&gt;: br     x16</span><br><span class="line"></span><br><span class="line">WeChat`dispatch_apply:</span><br><span class="line">    0x1028d95a4 &lt;+0&gt;: adrp   x16, 1655</span><br><span class="line">(lldb) po $x2</span><br><span class="line">&lt;__NSStackBlock__: 0x16fd49f88&gt;</span><br></pre></td></tr></table></figure>

<p>发现传入的参数x2是一个block，我们再回顾一下dispatch_after函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>

<p>这个函数有三个参数，分别是dispatch_time_t、dispatch_queue_t、dispatch_block_t，那这里打印的x2就是要传入的block，所以我们猜测拍摄完小视频会有一个延时，然后执行刚才传入的block，所以x2中肯定有其他方法调用，下一步就是要知道这个block的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read --size 8 --format x 0x16fd49f88</span><br><span class="line">0x16fd49f88: 0x000000019f8fd218 0x00000000c2000000</span><br><span class="line">0x16fd49f98: 0x000000010214777c 0x0000000102fb0e60</span><br><span class="line">0x16fd49fa8: 0x000000015da32600 0x000000015ea1a430</span><br><span class="line">0x16fd49fb8: 0x000000015cf5fee0 0x000000016fd49ff0</span><br></pre></td></tr></table></figure>

<p>0x000000010214777c就是block所在的位置，当然要减掉当前WeChat的ASLR偏移，最终在IDA中的地址为0x10209377C，突然发现这就是<code>btnRelease</code>的子程序sub_10209377C。这个子程序非常简单，只有一个方法<code>selRef_logicCheckState_</code>有可能是我们的目标。先看看这个方法是谁调用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0xb4000+0x1020937BC</span><br><span class="line">......</span><br><span class="line">Process 3873 stopped</span><br><span class="line">* thread #1: tid = 0xf62c4, 0x00000001021477bc WeChat`___lldb_unnamed_symbol108895$$WeChat + 64, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 3.1</span><br><span class="line">    frame #0: 0x00000001021477bc WeChat`___lldb_unnamed_symbol108895$$WeChat + 64</span><br><span class="line">WeChat`___lldb_unnamed_symbol108895$$WeChat:</span><br><span class="line">-&gt;  0x1021477bc &lt;+64&gt;: adrp   x8, 5489</span><br><span class="line">    0x1021477c0 &lt;+68&gt;: ldr    x1, [x8, #1552]</span><br><span class="line">    0x1021477c4 &lt;+72&gt;: orr    w2, wzr, #0x1</span><br><span class="line">    0x1021477c8 &lt;+76&gt;: ldp    x29, x30, [sp, #16]</span><br><span class="line">(lldb) po $x0</span><br><span class="line">&lt;MainFrameSightViewController: 0x15d1f0c00&gt;</span><br></pre></td></tr></table></figure>
<p>发现还是MainFrameSightViewController这个对象调用的，那<code>selRef_logicCheckState_ </code>肯定也在这个类的头文件中，寻找一下果然发现了  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)logicCheckState:(int)arg1;</span><br></pre></td></tr></table></figure>

<p>在IDA左侧窗口中寻找[MainFrameSightViewController logicCheckState:]，发现这个方法超级复杂，逻辑太多了，不着急慢慢捋。<br>在0x102094D6C位置我们发现一个switch jump，思路就很清晰了，我们只要找到小视频拍摄完成的这条线往下看就行了，LLDB来帮忙看看走的那条线。在0x102094D6C位置下个断点，这个断点在拍摄小视频的时候会多次触发，可以在拍摄之前把断点dis掉，拍摄松手之前再启用断点，打印此时的x8值  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x $x8</span><br><span class="line">(unsigned long) $38 = 0x0000000102174e10</span><br></pre></td></tr></table></figure>

<p>x8是一个指针，它指向的地址是0x102174e10，用这个地址减去当前ASLR的偏移就可以找到在IDA中的基地址，发现是0x102094E10，拍摄完成的逻辑处理这条线找到了，一直走到0x102094E24位置之后跳转0x1020951C4，这个分支的内容较少，里面有三个函数  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">loc_1020951C4</span><br><span class="line">ADRP            X8, #selRef_hideTips@PAGE</span><br><span class="line">LDR             X1, [X8,#selRef_hideTips@PAGEOFF]</span><br><span class="line">MOV             X0, X19</span><br><span class="line">BL              _objc_msgSend</span><br><span class="line">ADRP            X8, #selRef_finishWriter@PAGE</span><br><span class="line">LDR             X1, [X8,#selRef_finishWriter@PAGEOFF]</span><br><span class="line">MOV             X0, X19</span><br><span class="line">BL              _objc_msgSend</span><br><span class="line">ADRP            X8, #selRef_turnCancelBtnForFinishRecording@PAGE</span><br><span class="line">LDR             X1, [X8,#selRef_turnCancelBtnForFinishRecording@PAGEOFF]</span><br><span class="line">MOV             X0, X19</span><br><span class="line">BL              _objc_msgSend</span><br><span class="line">B               loc_102095288</span><br></pre></td></tr></table></figure>

<p>其中<code>selRef_finishWriter</code>和<code>selRef_turnCancelBtnForFinishRecording</code>需要重点关注，这两个方法看上去都是小视频录制结束的意思，线索极有可能就在这两个函数中。通过查看调用者发现这两个方法都属于MainFrameSightViewController，继续在IDA中查看这两个方法。在<code>selRef_finishWriter </code>中靠近末尾0x102094248的位置发现一个方法名叫做<code>f_switchToSendingPanel</code>，下个断点，然后拍摄视频，发现这个方法并没有被触发。应该不是通过这个方法调用发布界面的，继续回到<code>selRef_finishWriter </code>方法中；在0x1020941DC的位置调用方法<code>selRef_stopRecording</code>，打印它的调用者发现这个方法属于<code>SightFacade</code>，继续在IDA中寻找这个方法的实现。在这个方法的0x101F9BED4位置又调用了<code>selRef_stopRecord</code>，同样打印调用者发现这个方法属于SightCaptureLogicF4，有点像剥洋葱，继续在寻找这个方法的实现。在这个方法内部0x101A98778位置又调用了<code>selRef_finishWriting</code>，同样的原理找到这个方法是属于SightMovieWriter。已经剥了3层了，继续往下：<br>在<code>SightMovieWriter - (void)finishWriting</code>中的0x10261D004位置分了两条线，这个位置下个断点，然后拍摄完小视频触发断点，打印x19的值  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x19</span><br><span class="line">&lt;OS_dispatch_queue: CAPTURE.CALLBACK[0x13610bcd0] = &#123; xrefcnt = 0x4, refcnt = 0x4, suspend_cnt = 0x0, locked = 1, target = com.apple.root.default-qos.overcommit[0x1a0aa3700], width = 0x0, running = 0x0, barrier = 1 &#125;&gt;</span><br></pre></td></tr></table></figure>

<p>所以代码不会跳转到loc_10261D054而是走的左侧，在左侧的代码中发现启用了一个block，这个block是子程序sub_10261D0AC，地址为0x10261D0AC，找到这个地址，结构如下图所示：<br><img src="http://img.gaoshilei.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91sub_10261D0AC.png" alt="sub_10261D0AC" loading="lazy"><br>可以看出来主要分两条线，我们在第一个方框的末尾也就是0x10261D108位置下个断点，等拍摄完毕触发断点之后打印x0的值为1，这里的汇编代码为  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__text:000000010261D104                 CMP             X0, #2</span><br><span class="line">__text:000000010261D108                 B.EQ            loc_10261D234</span><br></pre></td></tr></table></figure>

<p>B.EQ是在上一步的结果为0才会跳转到loc_10261D234，但是这里的结果是不为0的，将x0的值改为2让上一步的结果为0  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x0</span><br><span class="line">1</span><br><span class="line">(lldb) register write $x0 2</span><br><span class="line">(lldb) po $x0</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>此时放开断点，等待跳转到小视频发布界面，结果是一直卡在这个界面没有任何反应，所以猜测实现跳转的逻辑应该在右边的那条线，继续顺着右边的线寻找：<br>在右侧0x10261D3AC位置发现调用了下面的这个方法  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)finishWritingWithCompletionHandler:(void (^)(void))handler;</span><br></pre></td></tr></table></figure>

<p>这个方法是系统提供的AVAssetWriter里面的方法，在视频写入完成之后要做的操作，这个里是要传入一个block的，因为只有一个参数所以对应的变量是x2，打印x2的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x2</span><br><span class="line">&lt;__NSStackBlock__: 0x16e086c78&gt;</span><br><span class="line">(lldb) memory read --size 8 --format x 0x16e086c78</span><br><span class="line">0x16e086c78: 0x00000001a0aa5218 0x00000000c2000000</span><br><span class="line">0x16e086c88: 0x00000001026d94b0 0x0000000102fc98c0</span><br><span class="line">0x16e086c98: 0x0000000136229fd0 0x000000016e086d00</span><br><span class="line">0x16e086ca8: 0x00000001997f5318 0xfffffffec9e882ff</span><br></pre></td></tr></table></figure>

<p>并且通过栈内存找到block位置为0x10261D4B0（需要减去ASLR的偏移）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sub_10261D4B0</span><br><span class="line">var_20= -0x20</span><br><span class="line">var_10= -0x10</span><br><span class="line">STP             X20, X19, [SP,#var_20]!</span><br><span class="line">STP             X29, X30, [SP,#0x20+var_10]</span><br><span class="line">ADD             X29, SP, #0x20+var_10</span><br><span class="line">MOV             X19, X0</span><br><span class="line">LDR             X0, [X19,#0x20]</span><br><span class="line">ADRP            X8, #selRef_stopAmr@PAGE</span><br><span class="line">LDR             X1, [X8,#selRef_stopAmr@PAGEOFF]</span><br><span class="line">BL              _objc_msgSend</span><br><span class="line">LDR             X0, [X19,#0x20]</span><br><span class="line">ADRP            X8, #selRef_compressAudio@PAGE</span><br><span class="line">LDR             X1, [X8,#selRef_compressAudio@PAGEOFF]</span><br><span class="line">LDP             X29, X30, [SP,#0x20+var_10]</span><br><span class="line">LDP             X20, X19, [SP+0x20+var_20],#0x20</span><br><span class="line">B               _objc_msgSend</span><br><span class="line">; End of function sub_10261D4B0</span><br></pre></td></tr></table></figure>

<p>只调用了两个方法，一个是<code>selRef_stopAmr</code>停止amr（一种音频格式），另一个是<code>selRef_compressAudio</code>压缩音频，拍摄完成的下一步操作应该不会放在这两个方法里面，找了这么久也没有头绪，这个路看来走不通了，不要钻牛角尖，战略性撤退寻找其他入口。<br><strong>逆向的乐趣就是一直寻找真相的路上，能体会到成功的乐趣，也有可能方向错了离真相反而越来越远，不要气馁调整方向继续前进！</strong></p>
<h3 id="2-“另辟蹊径”"><a href="#2-“另辟蹊径”" class="headerlink" title="2.“另辟蹊径”"></a>2.“另辟蹊径”</h3><blockquote>
<p>（由于微信在后台偷偷升级了，下面的内容都是微信6.3.30版本的ASLR，上面的分析基于6.3.28版本）</p>
</blockquote>
<p>注意到在点击朋友圈右上角的相机按钮底部会弹出一个Sheet，第一个就是Sight小视频，从这里入手，用cycript查看Sight按钮对应的事件是哪个  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iPhone-5S:~ root# cycript -p &quot;WeChat&quot;</span><br><span class="line">cy# [UIApp windows].toString()</span><br><span class="line">`(</span><br><span class="line">    &quot;&lt;iConsoleWindow: 0x14d6ccc00; baseClass = UIWindow; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x14d7df110&gt;; layer = &lt;UIWindowLayer: 0x14d7d6f60&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;SvrErrorTipWindow: 0x14eaa5800; baseClass = UIWindow; frame = (0 0; 320 45); hidden = YES; gestureRecognizers = &lt;NSArray: 0x14e9e8950&gt;; layer = &lt;UIWindowLayer: 0x14e9e6510&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;UITextEffectsWindow: 0x14ec38ba0; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = &lt;UIWindowLayer: 0x14ec39360&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;UITextEffectsWindow: 0x14e9c67a0; frame = (0 0; 320 568); layer = &lt;UIWindowLayer: 0x14d683ff0&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;UIRemoteKeyboardWindow: 0x14f226e40; frame = (0 0; 320 568); opaque = NO; autoresize = W+H; layer = &lt;UIWindowLayer: 0x14d6f4de0&gt;&gt;&quot;,</span><br><span class="line">    &quot;&lt;NewYearActionSheet: 0x14f1704a0; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x14ef9bf90&gt;; layer = &lt;UIWindowLayer: 0x14ef61a20&gt;&gt;&quot;</span><br><span class="line">)`</span><br><span class="line">cy# [#0x14f1704a0 recursiveDescription].toString()</span><br></pre></td></tr></table></figure>

<p>底部的Sheet是NewYearActionSheet，然后打印NewYearActionSheet的UI树状结构图（比较长不贴了）。然后找到Sight对应的UIButton是0x14f36d470   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0x14f36d470 allTargets]</span><br><span class="line">[NSSet setWithArray:@[#&quot;&lt;NewYearActionSheet: 0x14f1704a0; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x14ef9bf90&gt;; layer = &lt;UIWindowLayer: 0x14ef61a20&gt;&gt;&quot;]]]</span><br><span class="line">cy# [#0x14f36d470 allControlEvents]</span><br><span class="line">64</span><br><span class="line">cy# [#0x14f36d470 actionsForTarget:#0x14f1704a0 forControlEvent:64]</span><br><span class="line">@[&quot;OnDefaultButtonTapped:&quot;]</span><br></pre></td></tr></table></figure>

<p>通过UIControl的<code>actionsForTarget:forControlEvent:</code>方法可以找到按钮绑定的事件，Sight按钮的触发方法为<code>OnDefaultButtonTapped:</code>，回到IDA中在NewYearActionSheet中找到这个方法们继续往下分析只有这个方法<code>selRef_dismissWithClickedButtonIndex_animated</code>，通过打印它的调用者发现还是NewYearActionSheet，继续点进去找到<code>newYearActionSheet_clickedButtonAtIndex</code>方法，看样子不是NewYearActionSheet自己的，打印调用者x0发现它属于类WCTimeLineViewController。跟着断点走下去在0x1012B78CC位置调用了方法<code>#selRef_showSightWindowForMomentWithMask_byViewController_scene</code><br>通过观察发现这个方法的调用者是0x1012B78AC这个位置的返回值x0，这是一个类SightFacade，猜测这个方法在SightFacade里面，去头文件里找一下果然发现这个方法  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)showSightWindowForMomentWithMask:(id)arg1 byViewController:(id)arg2 scene:(int)arg3;</span><br></pre></td></tr></table></figure>

<p>这个方法应该就是跳转到小视频界面的方法了。下面分别打印它的参数  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $x2</span><br><span class="line">&lt;UIImage: 0x14f046660&gt;, &#123;320, 568&#125;</span><br><span class="line">(lldb) po $x3</span><br><span class="line">&lt;WCTimeLineViewController: 0x14e214800&gt;</span><br><span class="line">(lldb) po $x4</span><br><span class="line">2</span><br><span class="line">(lldb) po $x0</span><br><span class="line">&lt;SightFacade: 0x14f124b40&gt;</span><br></pre></td></tr></table></figure>

<p>其中x2、x3、x4分别对应三个参数，x0是调用者，跳到这个方法内部查看怎么实现的。发现在这个方法中进行了小视频拍摄界面的初始化工作，首先初始化一个MainFrameSightViewController，再创建一个UINavigationController将MainFrameSightViewController放进去，接下来初始化一个MMWindowController调用  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithViewController:(id)arg1 windowLevel:(int)arg2;</span><br></pre></td></tr></table></figure>

<p>方法将UINavigationController放了进去，完成小视频拍摄界面的所有UI创建工作。<br>拍摄完成之后进入发布界面，此时用cycript找到当前的Controller是SightMomentEditViewController，由此萌生一个想法，跳过前面的拍摄界面直接进入发布界面不就可以了吗？我们自己创建一个SightMomentEditViewController然后放到UINavigationController里面，然后再将这个导航控制器放到MMWindowController里面。<strong>（这里我已经写好tweak进行了验证，具体的tweak思路编写在后文有）</strong>结果是的确可以弹出发布的界面，但是导航栏的NavgationBar遮住了原来的，整个界面是透明的，很难看，而且发布完成之后无法销毁整个MMWindowController，还是停留在发布界面。我们要的结果不是这个，不过确实有很大的收获，最起码可以直接调用发布界面了，小视频也能正常转发。我个人猜测，当前界面不能被销毁的原因是因为MMWindowController新建了一个window,它跟TimeLine所在的keyWindow不是同一个，SightMomentEditViewController的按钮触发的方法是没有办法销毁这个window的，所以有一个大胆的猜想，我直接在当前的WCTimeLineViewController上把SightMomentEditViewController展示出来不就可以了吗？  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[WCTimelineVC presentViewController:editSightVC animated:YES completion:^&#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>像这样展示岂不妙哉？不过通过观察SightMomentEditViewController的头文件，结合小视频发布时界面上的元素，推测创建这个控制器至少需要两个属性，一个是小视频的路径，另一个是小视频的缩略图，将这两个关键属性给了SightMomentEditViewController那么应该就可以正常展示了   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SightMomentEditViewController *editSightVC = [[%c(SightMomentEditViewController) alloc] init];</span><br><span class="line">NSString *localPath = [[self iOSREMediaItemFromSight] pathForSightData];</span><br><span class="line">UIImage *image = [[self valueForKey:@&quot;_sightView&quot;] getImage];</span><br><span class="line">[editSightVC setRealMoviePath:localPath];</span><br><span class="line">[editSightVC setMoviePath:localPath];</span><br><span class="line">[editSightVC setRealThumbImage:image];</span><br><span class="line">[editSightVC setThumbImage:image];</span><br><span class="line">[WCTimelineVC presentViewController:editSightVC animated:YES completion:^&#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>小视频的发布界面可以正常显示并且所有功能都可以正常使用，唯一的问题是返回按钮没有效果，并不能销毁SightMomentEditViewController。用cycript查看左侧按钮的actionEvent找到它的响应函数是<code>- (void)popSelf;</code>，点击左侧返回触发的是pop方法，但是这个控制器并不在navgationController里面，所以无效，我们要对这个方法进行重写  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)popSelf</span><br><span class="line">&#123;</span><br><span class="line">    [self dismissViewControllerAnimated:YES completion:^&#123;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时再点击返回按钮就可以正常退出了，此外，在WCContentItemViewTemplateNewSight中发现了一个方法叫做<code>- (void)sendSightToFriend;</code>，可以直接将小视频转发给好友，至此小视频转发的功能已经找到了。</p>
</div></section><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>LeonLei</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://www.gaoshilei.com/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E4%B9%8B%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/" title="手把手教你逆向微信之朋友圈小视频转发（上）">http://www.gaoshilei.com/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E4%B9%8B%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E4%B9%8B%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%B0%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%8F%91%EF%BC%88%E4%B8%8B%EF%BC%89/" rel="prev" title="手把手教你逆向微信之朋友圈小视频转发（下）"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">手把手教你逆向微信之朋友圈小视频转发（下）</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/iOSAppToLibrary/" rel="next" title="【转载】黑科技：把第三方iOS应用转成动态库"><span class="post-nav-text">【转载】黑科技：把第三方iOS应用转成动态库</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>如果您有任何内容想要讨论，欢迎前往 <a href="https://github.com/gaoshilei" target="_blank">GitHub</a> 与我交流。</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备19073416号</a></div><div class="copyright"><span>&copy; 2016 – 2023 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> LeonLei</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.7</span></div><div class="footer-support"><span>本网站由</span><a class="footer-support-logo" href="https://s.qiniu.com/IVvymu" target="blank" title="七牛云"><img height="30" src="https://img.gaoshilei.com/qiniuyun-logo.png" alt="七牛云"></a><span>提供储存和 CDN 加速</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><!-- hexo injector body_end start --><script src="/js/hexo-tag-common.js"></script><!-- hexo injector body_end end --></body></html>